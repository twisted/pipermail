From exarkun at divmod.com  Fri Jun  4 13:27:19 2004
From: exarkun at divmod.com (Jp Calderone)
Date: Fri Jun  4 13:27:23 2004
Subject: [Reality] Is collect() broken?
Message-ID: <40C0CD17.7000502@divmod.com>


   This is based on radix's example.

   Consider a battery shed.  It has an open window and a closed window. 
  Inside are heaps and heaps of batteries.  An actor outside the shed 
attempts to take one of the batteries.

   collect() will reach the actor's location from the actor, and then do 
both of the following two things in some order:

     reach the open window from the actor's location, reach the interior 
of the shed from the open window, reach a battery from the shed, yield a 
battery to the caller (because things can be taken through open windows).

     reach the closed window from the actor's location, reach the 
interior of the shed from the closed window, reach a battery from the 
shed, yield a refusal around the battery (because things can't be taken 
through open windows).

   Or will it!  In fact, it will not.  Whichever runs first will cause 
the shed to be added to the seen dictionary, which will in turn cause 
the subsequent portion of the traversal, upon reaching the shed, to skip 
it.  If the open window is traversed first, the battery will be 
takeable.  If the closed window is traversed first, the battery will not 
be takeable.

   How can we solve this?  Off the top of my head, and with no filters 
for putrification factor:

   * yield an "unsee" callable with each implementor.  Calling this 
would allow an implementor to be yielded again.

   * Don't put implementors in the seen dict, or put use a path segment 
leading up to the implementor in the seen dict with it, so that an 
object reached via multiple paths can be yielded multiple times.  Fix 
code using collect() to be aware of this possibility.

   * ... ?

   Jp


From radix at twistedmatrix.com  Fri Jun  4 13:43:04 2004
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Fri Jun  4 13:43:03 2004
Subject: [Reality] Is collect() broken?
In-Reply-To: <40C0CD17.7000502@divmod.com>
References: <40C0CD17.7000502@divmod.com>
Message-ID: <40C0D0C8.3060005@twistedmatrix.com>

Jp Calderone wrote:

>   * Don't put implementors in the seen dict, or put use a path segment 
> leading up to the implementor in the seen dict with it, so that an 
> object reached via multiple paths can be yielded multiple times.  Fix 
> code using collect() to be aware of this possibility.

I had this idea before, too, when thinking of a way to make a box that 
can be seen (differently) from both inside and outside. I *think* it 
would solve that problem too, but I decided to try out proxies instead, 
so that I wouldn't have to modify the collection system. However, I'm 
not sure proxies would solve *this* problem. So maybe we should try this.

-- 
  Twisted | Christopher Armstrong: International Man of Twistery
   Radix  |          Release Manager,  Twisted Project
---------+           http://radix.twistedmatrix.com/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 256 bytes
Desc: OpenPGP digital signature
Url : http://pyramid.twistedmatrix.com/pipermail/reality/attachments/20040604/9786bdb9/signature.bin
From glyph at divmod.com  Mon Jun  7 23:53:43 2004
From: glyph at divmod.com (Glyph Lefkowitz)
Date: Mon Jun  7 23:50:12 2004
Subject: [Reality] collectionary
Message-ID: <1086674023.30297.43.camel@kazekage>

Notes from IRC.

Since certain systems may want to involve themselves in the collect()
process but not do anything with containment or physical relationships,
we need a way to hook into that WITHOUT implying physical relationships.

For example, a "frotz" spell may want to cause things to give off a
"glow", and the "glow" is actually an object, but not physically
contained or an exit from the object, but logically associated with it
in an abstract way.

This means that ICollector needs some extra methods to provide these
hooks, e.g. the link and unlink methods currently on container.  In
order to distinguish between these "external" uses, where only the
system that places the link should remove it, and "normal" uses, where
there is a defined API for adding and removing objects in some
conceptual, usually physical relationship, we should have several
different implementations of find and more, but only one implementation
of link and unlink.  A Collector base-class which implements link and
unlink in the canonical way that Container currently does should move
into simulacrum.  Container should subclass that to provide a
location-aware containment graph.  Room should subclass Container to
provide an exit-aware containment graph.

We should also eliminate distance from the collection process as much as
possible.  Distance should be part of a criterion, which will be managed
by Room's exit machinery to propogate and add distance through exits. 
Distance should be added, I think, by using proxies.  The proxy returned
by a room would return "too far away" proxies or Refusals for
_contained_ objects from .find() and .more(), but _exits_ would not be
returned at all.  The "too many hops" limit is really to prevent
griefing the containment system, and should not be mixed up with the
"too far away" limit.


