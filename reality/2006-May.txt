From radix at twistedmatrix.com  Mon May  1 07:25:15 2006
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Mon May  1 07:25:19 2006
Subject: [Reality] Guess What
Message-ID: <60ed19d40605010525y810bf00s4826b3456ffc2b95@mail.gmail.com>

Yeah, we're active again. Stop by #imagination in case you want to chat in
real time.

http://jcalderone.livejournal.com/23667.html


--
Christopher Armstrong
International Man of Twistery
http://radix.twistedmatrix.com/
http://twistedmatrix.com/
http://canonical.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://twistedmatrix.com/pipermail/reality/attachments/20060501/dbe9613a/attachment.htm
From duncan.mcgreggor at gmail.com  Mon May  1 13:24:20 2006
From: duncan.mcgreggor at gmail.com (Duncan McGreggor)
Date: Mon May  1 13:24:47 2006
Subject: [Reality] Guess What
In-Reply-To: <60ed19d40605010525y810bf00s4826b3456ffc2b95@mail.gmail.com>
References: <60ed19d40605010525y810bf00s4826b3456ffc2b95@mail.gmail.com>
Message-ID: <509117bc88d3dbcfc368abf6c1c5d905@gmail.com>


On May 1, 2006, at 6:25 AM, Christopher Armstrong wrote:

> Yeah, we're active again. Stop by #imagination in case you want to 
> chat in real time.
>
> http://jcalderone.livejournal.com/23667.html

Sweet! I haven't seen a post on this list in *ages* :-)


From radix at twistedmatrix.com  Mon May  1 19:55:40 2006
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Mon May  1 19:55:45 2006
Subject: [Reality] Current Task: OBJECT PROXIES.
Message-ID: <60ed19d40605011755m20da19feo991ccb9c3af21964@mail.gmail.com>

Jp and I will be working on "OBJECT PROXIES" starting tonight. These are
meant to solve the problem of dynamically changing the behavior based on
intermediary game objects. FOR EXAMPLE: A sound-proof glass window should
let light through but not sound. This would be implemented by capturing
events which traverse the glass window, and removing aurial concepts from
that event. MAYBE. We don't actually know how we're going to do this, but
we'll write some unit tests and see where that takes us.

--
Christopher Armstrong
International Man of Twistery
http://radix.twistedmatrix.com/
http://twistedmatrix.com/
http://canonical.com/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://twistedmatrix.com/pipermail/reality/attachments/20060501/01236527/attachment.htm
From exarkun at divmod.com  Tue May  2 07:00:13 2006
From: exarkun at divmod.com (Jean-Paul Calderone)
Date: Tue May  2 07:00:17 2006
Subject: [Reality] Current Task: OBJECT PROXIES.
In-Reply-To: <60ed19d40605011755m20da19feo991ccb9c3af21964@mail.gmail.com>
Message-ID: <20060502120013.22481.620992647.divmod.quotient.20533@ohm>

On Mon, 1 May 2006 20:55:40 -0400, Christopher Armstrong <radix@twistedmatrix.com> wrote:
>Jp and I will be working on "OBJECT PROXIES" starting tonight. These are
>meant to solve the problem of dynamically changing the behavior based on
>intermediary game objects. FOR EXAMPLE: A sound-proof glass window should
>let light through but not sound. This would be implemented by capturing
>events which traverse the glass window, and removing aurial concepts from
>that event. MAYBE. We don't actually know how we're going to do this, but
>we'll write some unit tests and see where that takes us.
>

We made a little progress on this.  A new findProviders method has been added which returns a generator of all objects that provide a particular interface within a certain distance from a particular object.  We didn't get much further than that because we noticed several tests in the suite had started failing due to my upgrader to dapper: pyparsing is smashing unicode down into byte strings sometimes, which breaks when it hits axiom.

Anyone know how to force pyparsing to always emit unicode?

Jean-Paul

From duncan.mcgreggor at gmail.com  Tue May  2 08:53:21 2006
From: duncan.mcgreggor at gmail.com (Duncan McGreggor)
Date: Tue May  2 08:53:49 2006
Subject: [Reality] Current Task: OBJECT PROXIES.
In-Reply-To: <20060502120013.22481.620992647.divmod.quotient.20533@ohm>
References: <20060502120013.22481.620992647.divmod.quotient.20533@ohm>
Message-ID: <be28cdd838f5360e9a3067b0fcf15f14@gmail.com>


On May 2, 2006, at 6:00 AM, Jean-Paul Calderone wrote:

> On Mon, 1 May 2006 20:55:40 -0400, Christopher Armstrong 
> <radix@twistedmatrix.com> wrote:
>> Jp and I will be working on "OBJECT PROXIES" starting tonight. These 
>> are
>> meant to solve the problem of dynamically changing the behavior based 
>> on
>> intermediary game objects. FOR EXAMPLE: A sound-proof glass window 
>> should
>> let light through but not sound. This would be implemented by 
>> capturing
>> events which traverse the glass window, and removing aurial concepts 
>> from
>> that event. MAYBE. We don't actually know how we're going to do this, 
>> but
>> we'll write some unit tests and see where that takes us.
>>
>
> We made a little progress on this.  A new findProviders method has 
> been added which returns a generator of all objects that provide a 
> particular interface within a certain distance from a particular 
> object.  We didn't get much further than that because we noticed 
> several tests in the suite had started failing due to my upgrader to 
> dapper: pyparsing is smashing unicode down into byte strings 
> sometimes, which breaks when it hits axiom.
>
> Anyone know how to force pyparsing to always emit unicode?

I don't know how to force it to *always* emit unicode, but you can 
redefine your alphas:

   alphas = u''.join(unichr(x) for x in xrange(startUnicodeRange, 
endUnicodeRange))


From radix at twistedmatrix.com  Thu May  4 09:09:37 2006
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Thu May  4 09:09:39 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <60ed19d40605011755m20da19feo991ccb9c3af21964@mail.gmail.com>
References: <60ed19d40605011755m20da19feo991ccb9c3af21964@mail.gmail.com>
Message-ID: <60ed19d40605040709v2c7d4582n47e9321eec256e2d@mail.gmail.com>

On 5/1/06, Christopher Armstrong <radix@twistedmatrix.com> wrote:
> Jp and I will be working on "OBJECT PROXIES" starting tonight. These are
> meant to solve the problem of dynamically changing the behavior based on
> intermediary game objects. FOR EXAMPLE: A sound-proof glass window should
> let light through but not sound. This would be implemented by capturing
> events which traverse the glass window, and removing aurial concepts from
> that event. MAYBE. We don't actually know how we're going to do this, but
> we'll write some unit tests and see where that takes us.

We did it.  Rooms can now be dark (a LocationLighting powerup on a
room, with candelas set to 0), and they'll make everything inside of
them invisible[1]. It does this by powering up the room for
ILocationProxy, which will get a chance to proxy all of its contents
found during a findProviders traversal (as opposed to an IProxy, which
gets a chance to proxy all objects found *through* it, like the
objects on the other side of a red glass window).

Then we implemented a torch. The torch is a Thing with a LightSource
powerup; the LightSource powers up its thing for ILightSource, and
provides a candelas attribute. The LightingLocation proxy searches for
(calls findProviders with) ILightSource, accumulates all the light
sources, and adds it to the ambient light of the room, to decide
whether it is bright enough to see anything.

None of this stuff is yet available to builders in the game world, but
hopefully we'll try to do something about that before we merge.

I think this is the first lighting system in a looong time. Reality? TR/J?


1: Perhaps the LocationLighting proxy should, when it gets a chance to
proxy the actual location, return an IVisible whose name is "dark
place"? That would let the player know whether they're standing in
complete blackness or floating in a pure white abyss,  for example.

--
Christopher Armstrong
International Man of Twistery
http://radix.twistedmatrix.com/
http://twistedmatrix.com/
http://canonical.com/

From mike at mkp.ca  Thu May  4 09:21:03 2006
From: mike at mkp.ca (Mike Pelletier)
Date: Thu May  4 09:21:07 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <60ed19d40605040709v2c7d4582n47e9321eec256e2d@mail.gmail.com>
References: <60ed19d40605011755m20da19feo991ccb9c3af21964@mail.gmail.com>
	<60ed19d40605040709v2c7d4582n47e9321eec256e2d@mail.gmail.com>
Message-ID: <200605041021.03794.mike@mkp.ca>

On Thursday 04 May 2006 10:09, Christopher Armstrong wrote:
> We did it. ?Rooms can now be dark (a LocationLighting powerup on a
> room, with candelas set to 0), and they'll make everything inside of
> them invisible[1]. It does this by powering up the room for
> ILocationProxy, which will get a chance to proxy all of its contents
> found during a findProviders traversal (as opposed to an IProxy, which
> gets a chance to proxy all objects found *through* it, like the
> objects on the other side of a red glass window).
>
> Then we implemented a torch. The torch is a Thing with a LightSource
> powerup; the LightSource powers up its thing for ILightSource, and
> provides a candelas attribute. The LightingLocation proxy searches for
> (calls findProviders with) ILightSource, accumulates all the light
> sources, and adds it to the ambient light of the room, to decide
> whether it is bright enough to see anything.

Does an ILocationProxy get to know who's asking?  Seems as though properties 
of the actor would be important to deciding whether it's bright enough/too 
bright.

It sounds like (ha ha) this could be extended to support aural events, and 
perhaps even smision.  I reckon an ILocationProxy could, hypothetically with 
more work, ask its neighbours about noisy things (or in the case of smision, 
swaggy thing) and attenuate the decibel level?

Is there a place we can follow progress?  None of this seems to be in the SVN 
repository, or I'm just too stupid to use it properly.  Don't see changes 
more recent than "3 weeks".

Mike.

From glyph at divmod.com  Thu May  4 09:28:52 2006
From: glyph at divmod.com (glyph@divmod.com)
Date: Thu May  4 09:28:56 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <60ed19d40605040709v2c7d4582n47e9321eec256e2d@mail.gmail.com>
Message-ID: <20060504142852.22481.1079067463.divmod.quotient.21331@ohm>

On Thu, 4 May 2006 10:09:37 -0400, Christopher Armstrong <radix@twistedmatrix.com> wrote:

>We did it.  Rooms can now be dark 

ALL HAIL THE BRINGERS OF DARKNESS!!!!!!

This is awesome, I can't wait to have a look at the implementation.

From radix at twistedmatrix.com  Thu May  4 09:47:45 2006
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Thu May  4 09:47:48 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <200605041021.03794.mike@mkp.ca>
References: <60ed19d40605011755m20da19feo991ccb9c3af21964@mail.gmail.com>
	<60ed19d40605040709v2c7d4582n47e9321eec256e2d@mail.gmail.com>
	<200605041021.03794.mike@mkp.ca>
Message-ID: <60ed19d40605040747o3f862d7cye845db234a684a1d@mail.gmail.com>

On 5/4/06, Mike Pelletier <mike@mkp.ca> wrote:
> On Thursday 04 May 2006 10:09, Christopher Armstrong wrote:
> > We did it. Rooms can now be dark (a LocationLighting powerup on a
> > room, with candelas set to 0), and they'll make everything inside of
> > them invisible[1]. It does this by powering up the room for
> > ILocationProxy, which will get a chance to proxy all of its contents
> > found during a findProviders traversal (as opposed to an IProxy, which
> > gets a chance to proxy all objects found *through* it, like the
> > objects on the other side of a red glass window).
> >
> > Then we implemented a torch. The torch is a Thing with a LightSource
> > powerup; the LightSource powers up its thing for ILightSource, and
> > provides a candelas attribute. The LightingLocation proxy searches for
> > (calls findProviders with) ILightSource, accumulates all the light
> > sources, and adds it to the ambient light of the room, to decide
> > whether it is bright enough to see anything.
>
> Does an ILocationProxy get to know who's asking?  Seems as though properties
> of the actor would be important to deciding whether it's bright enough/too
> bright.

Not yet, but it's a good possibility. We've been careful to not do too
much that doesn't directly solve use cases we want to implement, so as
to avoid the abstraction-insanity that Imagination had. Getting
information about the observer doing the requesting sounds like
something that would really be necessary for a bunch of use cases,
though.

> Is there a place we can follow progress?  None of this seems to be in the SVN
> repository, or I'm just too stupid to use it properly.  Don't see changes
> more recent than "3 weeks".

See /branches/torch-931. We're doing branch-based development (or
Ultimate Quality Based Development, or whatever). Every branch has a
ticket, and the Imaginary tickets are here:

http://divmod.org/trac/query?status=new&status=assigned&status=reopened&component=Imaginary&order=priority

Have fun, and help out ;-)

--
Christopher Armstrong
International Man of Twistery
http://radix.twistedmatrix.com/
http://twistedmatrix.com/
http://canonical.com/

From exarkun at divmod.com  Thu May  4 10:09:56 2006
From: exarkun at divmod.com (Jean-Paul Calderone)
Date: Thu May  4 10:09:57 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <60ed19d40605040747o3f862d7cye845db234a684a1d@mail.gmail.com>
Message-ID: <20060504150956.22481.1998942811.divmod.quotient.21342@ohm>

On Thu, 4 May 2006 10:47:45 -0400, Christopher Armstrong <radix@twistedmatrix.com> wrote:
>On 5/4/06, Mike Pelletier <mike@mkp.ca> wrote:
>>On Thursday 04 May 2006 10:09, Christopher Armstrong wrote:
>> > We did it. Rooms can now be dark (a LocationLighting powerup on a
>> > room, with candelas set to 0), and they'll make everything inside of
>> > them invisible[1]. It does this by powering up the room for
>> > ILocationProxy, which will get a chance to proxy all of its contents
>> > found during a findProviders traversal (as opposed to an IProxy, which
>> > gets a chance to proxy all objects found *through* it, like the
>> > objects on the other side of a red glass window).
>> >
>> > Then we implemented a torch. The torch is a Thing with a LightSource
>> > powerup; the LightSource powers up its thing for ILightSource, and
>> > provides a candelas attribute. The LightingLocation proxy searches for
>> > (calls findProviders with) ILightSource, accumulates all the light
>> > sources, and adds it to the ambient light of the room, to decide
>> > whether it is bright enough to see anything.
>>
>>Does an ILocationProxy get to know who's asking?  Seems as though 
>>properties
>>of the actor would be important to deciding whether it's bright enough/too
>>bright.
>
>Not yet, but it's a good possibility. We've been careful to not do too
>much that doesn't directly solve use cases we want to implement, so as
>to avoid the abstraction-insanity that Imagination had. Getting
>information about the observer doing the requesting sounds like
>something that would really be necessary for a bunch of use cases,
>though.


I don't think IProxy.proxy needs to know who's asking.  The point
is that the proxy objects it returns have logic in them.  Currently
the illumination game system is extremely stupid: if a location is
lit, everyone can see things in it; otherwise no one can.  A more
advanced illumination game system would wrap objects and then provide
an alternate IConcept implementation.  If the light level is low but
non-zero, it can replace the thing's description with text like "a
dark oblong blob"; since conceptualization does take the observer
into account already, if it is dark but the observer has infravision,
a custom description that takes both of these facts into account can
be given to just that observer.

Jean-Paul

From ironfroggy at gmail.com  Thu May  4 16:38:52 2006
From: ironfroggy at gmail.com (Calvin Spealman)
Date: Thu May  4 16:38:58 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <20060504150956.22481.1998942811.divmod.quotient.21342@ohm>
References: <60ed19d40605040747o3f862d7cye845db234a684a1d@mail.gmail.com>
	<20060504150956.22481.1998942811.divmod.quotient.21342@ohm>
Message-ID: <76fd5acf0605041438n1d06037bv1eb6d927729b1c5@mail.gmail.com>

On 5/4/06, Jean-Paul Calderone <exarkun@divmod.com> wrote:
>
> On Thu, 4 May 2006 10:47:45 -0400, Christopher Armstrong <
> radix@twistedmatrix.com> wrote:
> >On 5/4/06, Mike Pelletier <mike@mkp.ca> wrote:
> >>On Thursday 04 May 2006 10:09, Christopher Armstrong wrote:
> >> > We did it. Rooms can now be dark (a LocationLighting powerup on a
> >> > room, with candelas set to 0), and they'll make everything inside of
> >> > them invisible[1]. It does this by powering up the room for
> >> > ILocationProxy, which will get a chance to proxy all of its contents
> >> > found during a findProviders traversal (as opposed to an IProxy,
> which
> >> > gets a chance to proxy all objects found *through* it, like the
> >> > objects on the other side of a red glass window).
> >> >
> >> > Then we implemented a torch. The torch is a Thing with a LightSource
> >> > powerup; the LightSource powers up its thing for ILightSource, and
> >> > provides a candelas attribute. The LightingLocation proxy searches
> for
> >> > (calls findProviders with) ILightSource, accumulates all the light
> >> > sources, and adds it to the ambient light of the room, to decide
> >> > whether it is bright enough to see anything.
> >>
> >>Does an ILocationProxy get to know who's asking?  Seems as though
> >>properties
> >>of the actor would be important to deciding whether it's bright
> enough/too
> >>bright.
> >
> >Not yet, but it's a good possibility. We've been careful to not do too
> >much that doesn't directly solve use cases we want to implement, so as
> >to avoid the abstraction-insanity that Imagination had. Getting
> >information about the observer doing the requesting sounds like
> >something that would really be necessary for a bunch of use cases,
> >though.
>
>
> I don't think IProxy.proxy needs to know who's asking.  The point
> is that the proxy objects it returns have logic in them.  Currently
> the illumination game system is extremely stupid: if a location is
> lit, everyone can see things in it; otherwise no one can.  A more
> advanced illumination game system would wrap objects and then provide
> an alternate IConcept implementation.  If the light level is low but
> non-zero, it can replace the thing's description with text like "a
> dark oblong blob"; since conceptualization does take the observer
> into account already, if it is dark but the observer has infravision,
> a custom description that takes both of these facts into account can
> be given to just that observer.
>
> Jean-Paul


As things progress and more combinations of conditions, objects, and actors
exist,
how will you manage all these descriptions of the objects in so many
environments
or what kind of automation will come to describing them under the different
conditions
and to differently abled actors? That is, will you need to define that for
some range of
light in a normally-visioned person that "a dark oblong blob" is the
description, or is
that somehow deducable by the system?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://twistedmatrix.com/pipermail/reality/attachments/20060504/b76d0387/attachment.htm
From exarkun at divmod.com  Mon May  8 08:32:30 2006
From: exarkun at divmod.com (Jean-Paul Calderone)
Date: Mon May  8 08:32:33 2006
Subject: [Reality] Re: Current Task: OBJECT PROXIES.
In-Reply-To: <76fd5acf0605041438n1d06037bv1eb6d927729b1c5@mail.gmail.com>
Message-ID: <20060508133230.22481.2057774510.divmod.quotient.22316@ohm>

On Thu, 4 May 2006 17:38:52 -0400, Calvin Spealman <ironfroggy@gmail.com> wrote:
>On 5/4/06, Jean-Paul Calderone <exarkun@divmod.com> wrote:
>>
>>I don't think IProxy.proxy needs to know who's asking.  The point
>>is that the proxy objects it returns have logic in them.  Currently
>>the illumination game system is extremely stupid: if a location is
>>lit, everyone can see things in it; otherwise no one can.  A more
>>advanced illumination game system would wrap objects and then provide
>>an alternate IConcept implementation.  If the light level is low but
>>non-zero, it can replace the thing's description with text like "a
>>dark oblong blob"; since conceptualization does take the observer
>>into account already, if it is dark but the observer has infravision,
>>a custom description that takes both of these facts into account can
>>be given to just that observer.
>>
>>Jean-Paul
>
>
>As things progress and more combinations of conditions, objects, and actors
>exist,
>how will you manage all these descriptions of the objects in so many
>environments
>or what kind of automation will come to describing them under the different
>conditions
>and to differently abled actors? That is, will you need to define that for
>some range of
>light in a normally-visioned person that "a dark oblong blob" is the
>description, or is
>that somehow deducable by the system?
>

It should be deducable by the system.  In all areas, Imaginary strives to avoid the combinatorial explosion of development/creative effort that often comes with even slightly complex systems.  This particular feature might be implemented by having the visibility system extract information from an interface which describes the size and shape of a Thing.  It can combine that information with the acuity of the observer and the particular conditions of the environment when deciding how far to degrade the description of the thing being observed.

Of course, that's still a complicated task, but it's one which can be improved independently of the rest of the system.  It's an example of what we call a "game system" - something between the core simulation engine and any application-level code.

Jean-Paul

From glyph at divmod.com  Thu May 18 23:45:37 2006
From: glyph at divmod.com (glyph@divmod.com)
Date: Thu May 18 23:45:38 2006
Subject: [Reality] we're the most frontingest
In-Reply-To: 0
Message-ID: <20060519044537.28682.1098839844.divmod.quotient.2671@ohm>


=== Name Resolution, findProviders(), and the search() for intelligence ===

search() is currently pending deprecation.  In order to make puzzles that are
properly secure, we need to eliminate it and its attendant unnecessary
complexity.

The first thing we need to do is create a "perception" data structure, which
will be stored in the 'intelligence' for a player.

In the case of "purely server-side" UI, like the text server, this is simply a
dictionary mapping names to lists of perceived objects with that name.  Parsing
to actions can then happen entirely in text server UI code; no interaction with
the world object graph is required to identify the user's *intent*, and
formulate an Action instance which represents that intent.  There is already an
API for making sure that users can securely access the objects they are
referring to, 'proxiedThing'.  Since the values in this list are Things
already, they can be passed directly to this existing API.

(Although we'd like to suggest a name change: proxiedThing implies that the
return value is also a Thing, it could be something else, so maybe
'proxyForThing' or 'facetForThing'?)

This parsing separation should then also provide a foothold for disambiguation;
it can reorder and discard from the ambiguous list of potential targets,
eventually presenting the user with a list of long descriptions for the objects
which they might have been referring to, which actually make sense.  Initially
this will simply be reordering based on proximity; eventually, we can add
information to the "perception" object about whether objects are apparently
reachable, actual physical objects or simply concepts (like "the air" or "that
sound") which don't make sense to use as targets for a particular action.  The
menu of available targets for a particular action can be presented also without
interacting with the world's object graph: all information required is present
in UI data structures.

It's important to keep in mind that GUI clients later (the faucet will flow
again!) will use names only *client*-side, which will be represented as
selectable lists of objects, also potentially with names, to provide the user
with a diverse set of input mechanisms.  These names will be mapped on the
client to identifiers which are unique to the session (to make cheating harder
- no reason to allow players to persistently to refer to objects they can't
access from their client).  Ambiguity will therefore be handled *almost*
entirely on the client; for special-case parsing it would be nice to also send
along a string to the server, but in general this will not be used; a
structured expression representing the action will be sent to the server.

    (As an aside about GUI clients, imagine this experience.  You type "get
    qui" and an intellisense-style menu pops down which lists all of the
    objects whose names contain "qui" at a word boundary that are currently
    visible to you.  You select "the quiche I am holding" from a list that says
    "the quiche I am holding" and "the quiche that the baker will immediately
    kill me if I attempt to pick up".  The text field then fills in with the
    full name of the selected quiche, along with an icon and a color indicating
    that it is an *object* with *identity*, not just some crappy string.  No
    menu needs to be presented saying "which quiche?" from the server.)

=== proxy() design patterns, and quantum fronting in Imaginary ===

We are thinking about implementing wearable sunglasses and night-vision
goggles.  We want to implement it by having a IProxy powered up on the player
when it puts on the glasses and powered down when it takes them off.  The
current proxy() system is basically designed right for this with respect to
visibility events, but seems to be missing one necessary feature for it to be
complete.  (I'll get to explaining what that is in a moment...)

As a first step, the implementation of LocationLighting.proxy needs to be
changed to _always_ wrap its contents with an IlluminatedThing wrapper, which
will provide IVisible and have an API for mutating the luminous intensity
associated with it.  (I think that somebody needs to really understand the
difference between luminous intensity and luminous flux in order to determine
what we're actually talking about as our virtual photon makes its way outward
from its source to its observer, but I digress.)

In the case of [un]illuminated environments -- and more generally, in any
implementation of proxy() that might want to interfere with a player's ability
to see or interact with objects -- there are a few general types of
interaction:

    - see an object (.isOrExtends(IVisible))
    - designate an object as a target of some kind (.isOrExtends(IDesignatable))
      two other parent interfaces extend this one:
        - physically interact with an object (.isOrExtends(IReachable))
        - remotely indicate an object (.isOrExtends(IAimedTarget))

I note "isOrExtends" here because in the visibility case as currently
implemented, it is slightly misleading to think there is only one interface we
need to worry about for security reasons; even if a player can't see an object
at a particular time, they might indicate it later in some other way, and the
illumination system needs to deal with their ability to (for example) pick up
an object off the floor when it's dark, that they previously saw when it was
light.  The design for this system, as relayed to me by Chris, is that a roll
will be made vs. a player's perception and orientation stats with the final
perceived illumination level as a modifier.  In the "well-lit" case this check
will always pass, but there is a chance you will or will not be able to pick up
stuff that you have previously seen if a room goes dark or you are blinded.

Note that in the visibility case "IVisible" generally suffices (at least for
now) but in the "pick stuff up" case, you have to be able to substitute "pick
stuff up", "eat", "shoot with a laser beam", or any number of I<X>Target
interface arguments to proxy().

There are some systems (light being the most obvious and one of the more
complex ones) which will need to mutate an object at various points in its
discovery path through findProviders, but not be able to return an object that
actually provides (or rejects) the requested interface until they have actually
reached the end of the path and know who the observer / actor will be.

The proposed solution here is to allow proxy() to return both providers of the
requested interface and providers of a new interface, IWaveform.  IWaveform has
one method: collapse(observer), which returns a provider of the originally
requested interface passed to proxy().  collapse(player) will be called at the
end of the resolve() phase of Action, if the given things do not implement the
interface they are supposed to implement at that point (and, obviously, do
provide IWaveform; otherwise this is simply an error.)

For example, the IlluminatedThing wrapper will implement IVisible and
IWaveform, since it knows what to do in the case of visibility, but it provides
a general "can I reach this" implementation for _all_ tool and target
interfaces, not merely those it can explicitly single out.  i.e., for any
interface LocationLighting.proxy is passed that isOrExtends(IDesignatable), an
IlluminatedThing will be returned, whose collapse() method will make the
appropriate rolls: can I see this?  can I interact with it?  what's the chance
I will hit it if it's an IAimedTarget?  how long will it take to rummage for
it?  (the last only once we implement some kind of actions-taking-time system).



From radix at twistedmatrix.com  Fri May 19 13:11:21 2006
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Fri May 19 13:11:25 2006
Subject: [Reality] we're the most frontingest
In-Reply-To: <20060519044537.28682.1098839844.divmod.quotient.2671@ohm>
References: <20060519044537.28682.1098839844.divmod.quotient.2671@ohm>
Message-ID: <60ed19d40605191111h3fcec42ex780b936c5f9b068a@mail.gmail.com>

On 5/19/06, glyph@divmod.com <glyph@divmod.com> wrote:

> === proxy() design patterns, and quantum fronting in Imaginary ===
...
> In the case of [un]illuminated environments -- and more generally, in any
> implementation of proxy() that might want to interfere with a player's ability
> to see or interact with objects -- there are a few general types of
> interaction:
>
>     - see an object (.isOrExtends(IVisible))
>     - designate an object as a target of some kind (.isOrExtends(IDesignatable))
>       two other parent interfaces extend this one:
>         - physically interact with an object (.isOrExtends(IReachable))
>         - remotely indicate an object (.isOrExtends(IAimedTarget))
>
...
> The proposed solution here is to allow proxy() to return both providers of the
> requested interface and providers of a new interface, IWaveform.  IWaveform has
> one method: collapse(observer), which returns a provider of the originally
> requested interface passed to proxy().  collapse(player) will be called at the
> end of the resolve() phase of Action, if the given things do not implement the
> interface they are supposed to implement at that point (and, obviously, do
> provide IWaveform; otherwise this is simply an error.)
>
> For example, the IlluminatedThing wrapper will implement IVisible and
> IWaveform, since it knows what to do in the case of visibility, but it provides
> a general "can I reach this" implementation for _all_ tool and target
> interfaces, not merely those it can explicitly single out.  i.e., for any
> interface LocationLighting.proxy is passed that isOrExtends(IDesignatable), an
> IlluminatedThing will be returned, whose collapse() method will make the
> appropriate rolls: can I see this?  can I interact with it?  what's the chance
> I will hit it if it's an IAimedTarget?  how long will it take to rummage for
> it?  (the last only once we implement some kind of actions-taking-time system).


So, I'm still vaguely uncomfortable with IWaveform (for one, since its
specification is still pretty vague; I don't think IlluminatedThing
has been thought through to the point where we *really* know how its
IWaveform implementation will work).

Let me state a (perceived) problem, concentrated down from glyph's
huge and twisty maze of logic:

Currently, modification of object behavior that needs to take into
consideration the state of the actor/observer can use only one
strategy: do the observer-dependent logic in the Concept, where the
observer is available.

Unfortunately, there are (probably) use cases where conceptualization
of objects and/or events is too late in the process: those cases where
we want to change more than how how an observer perceives something,
but make the outcome of the action dependent on the actor.

Shoot a gun in the dark at a noisy enemy (while an innocent bystander
is standing next to him). Is your "Listen" check (based on Wis) high
enough to beat the enemy's "Move Silently" check? Asking this question
in ShotFiredConcept makes no sense, because the concept can't decide
who the bullet actually hits.  As a perhaps simpler example, consider
finding the exit out of a dark room: you need to "grope my way out of
here", which means feel along the wall until you've found an exit and
walk through it. Conceptualization-time, again, is too late to decide
whether you find an exit, or how long it takes to find the exit (which
should be based on the actor's knowledge of the layout of the room,
for example).

How do we solve this? I know glyph's answer already, but I want to see
what other's immediate impressions are. Perhaps this shouldn't even be
a function of the proxy system, or we need to modify some logic
elsewhere.

Of course, my current suggestion is the same as glyph's: Don't
implement IWaveform (or any solution to this problem) yet, but wait
until we've thought harder and actually get to the point where we want
to implement combat in dark rooms :-)

(also, non-dark-room use cases would be appreciated)

-- 
Christopher Armstrong
International Man of Twistery
http://radix.twistedmatrix.com/
http://twistedmatrix.com/
http://canonical.com/

