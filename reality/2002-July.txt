From reality@twistedmatrix.com  Thu Jul  4 23:49:15 2002
From: reality@twistedmatrix.com (Jp Calderone)
Date: Thu, 4 Jul 2002 18:49:15 -0400
Subject: [Reality] A few thoughts on Action related matters
Message-ID: <20020704224915.GA26790@meson.dyndns.org>

--SUOF0GtieIMvvwua
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

  Almost there, I think.  So far things are looking good, there're just a
few things I've run into...

  Thing.locate() - This could probably use an extra parameter, 'interface'
(defaulting to None).  First thought was just to pass it through to
=2ElookAroundFor() which now also takes a parameter of the same name.  This
work, but gives what I think is an incorrect error message to the user
(Keeping in mind that .locate() raises CantFind() or Ambiguity() in error
conditions, which are reported to the player).  IMHO, the CantFind() case
needs to be broken into a case where truly nothing matches the given name
and the case where something(s) match, but none implement the given
interface; something that ends up yielding something to the effect of
"%(name) can't be used in that way."  I'm not sure if the .find() method
should do something like this as well, because I'm not entirely sure what
the intended uses of these two fairly similar methods are.

  DispatchingAction - (Note: I acknowledge in advance that this point is
extremely trivial) The three classes beyondspike derives from this are for
targetless actions ("say", "yodel", "clap"), targetted actions ("get",
"sit", "nibble"), and tool actions, which are basically two-target actions
("hit X with Y", etc).  The minor nit I have is with the default argument
ordering of ToolAction's getDispatchList().  The ordering (modulo an offset)
is "actor, target, tool" for two methods but "actor, tool, target" for the
third.  Since changing the order now will break at most two projects (and
only one - mine - if glyph hasn't written any code that uses this yet)
changing it now isn't a problem.

  As a learning exercise, I've implemented one of each of the existing types
of DispatchingActions.  Basic speech, whispering to a target, and a vending
machine.  So far the third has given me the only problems.  My vending
machines implement the IInsertTarget interface and my coins implement the
IInsertTool interface.  The vending machine, however, needs to know more
about the coin than what its interface provides, specifically its value.=20

Option the first: Add a value method to the insert interface (rejected,
stupid). =20

Option the second: Create a new interface, ICoin, and only allow
implementors of it into the vending machine.  Put the value method on this
interface.  This appears to work, but costs generality and, I think, leads
down the path to hordes of special cases and damages the chances of
initially unrelated things to interact in interesting ways.

Option the third: Remove the vending machine's ability to "cheat" and make
it identify what was inserted into it through general methods/attributes
that all Things implement.  Size, mass, spectral properties, Dingleforpen
index, etc.

I kind of prefer #3.  Deciding what properties are appropriate here is
important.  Some of them might be useful to add directly onto Reality's
Thing class, others might be game-specific enough that a subclass is
appropriate.  Alternatively, a simple interface for asking about an
arbitrary property might be preferable over adding accessors along the lines
of those that already exist.  =20

I can see the merits of the second option, but I doubt my ability to
properly design and implement a set of interfaces that both provides is
complex enough to be interesting but clean enough to be extensible and
understandable.  Option #3 appears to make this easier.

Thoughts?

--=20
 2:00am up 44 days, 2:44, 7 users, load average: 0.00, 0.01, 0.00

--SUOF0GtieIMvvwua
Content-Type: application/pgp-signature
Content-Disposition: inline

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.0.7 (GNU/Linux)

iD8DBQE9JNDpedcO2BJA+4YRAs3lAJ90V/Jf09CYpqGvfFRAfJg9wLxinACfQrzd
p2XVT8g8nX6jcBpp7Bajh+c=
=TTdU
-----END PGP SIGNATURE-----

--SUOF0GtieIMvvwua--


From reality@twistedmatrix.com  Wed Jul 24 10:54:48 2002
From: reality@twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 24 Jul 2002 04:54:48 -0500 (CDT)
Subject: [Reality] Re: [Twisted-Python] Reality?
In-Reply-To: <20020724004642.31EB.JCARLSON@isd.net>
References: <20020724004642.31EB.JCARLSON@isd.net>
Message-ID: <20020724.045448.59648656.glyph@twistedmatrix.com>

----Security_Multipart(Wed_Jul_24_04:54:48_2002_636)--
Content-Type: Text/Plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

On Wed, 24 Jul 2002 01:09:57 -0700, Josiah Carlson <jcarlson@isd.net> wrote:

> To get to the point; if you want people to use reality, get a distribution of
> any stable version, a world file with help about what is currently available
> in the mini-world, and a little how-to for getting the thing to run.  It also
> wouldn't hurt to get a link to this distribution on some download page at
> twisted.

Yes, that would all help.

I'm sure it would also help for us to have a killer game that was totally
addictive and thousands of people were playing based on the infrastructure.
We're working on that too.

At one point, we did have such a distribution, but we only have so much
manpower -- we're currently maintaining twisted.reality along with, a
webserver, a database interface, an asynchronous networking infrastructure, an
application server platform, two (although at least I hope to phase one out)
web templating systems, a remote object protocol, a multi-protocol chat server,
a multi-protocol chat client, a user authentication system, and still trying to
write code that we can all get paid for somehow.

All in all I think we're doing a pretty good job, but some things will
inevitably fall through the cracks.

I have to say I understand your confusion and your problems with Twisted
Reality.  Reality itself is in a state of flux.  We're currently in the process
of exploring a new command-processing system and replacing the old, grotty one
that we were using before.  There isn't even a demonstration world, or game, to
load up in TR and poke around at what it can do.

Nevertheless, in many cases, I would still recommend using it.  The primary
reason is social, not technical; in using Reality you are using something that
I am dedicated to maintaining into the future; virtual world creation,
especially as it relates to text-based games, is my passion.  It's the whole
point of all the nuts and bolts in the Twisted framework.  This commitment,
combined their experience with my other efforts, has lead several other
energetic, intelligent people to use the Reality framework, even in spite of
the current technical state of disarray.

That's not to say it's for everybody.  If your project is only going to last
for a month or two, and you don't plan to maintain it beyond that, the future
maintenance and evolution of Reality as a framework probably is not really an
issue for you.  If you plan to have a game that lives for a long time, though,
that could be crucial to its survival, as it would reduce the size of the team
*you* need to gain the interest of by a lot.

> I'm telling you this because I have just embarked on a project that quite
> possibly could last until I start my phd in september - possibly longer.
> Building a mud server and a mud using the server.

Well; those are two separate projects :-).  Are you planning to use Twisted at
all for this?

> I'm doing this because I don't believe any mud servers currently available
> are workable solutions to the problem of 'how do I make my mud do X', where X
> is anything.

It sounds like you're saying you're unaware of any programmable MUD servers.
Have you looked at any of MOO ancestry? NightmareMUD, or anything that uses
LPC?  ColdMUD?

> At 37k lines of code for circlemud, and nearly 140k lines for SMAUG, either
> is too huge.

> Reality is a nice change, but it still feels bulky (in terms of source code
> size) and I wouldn't want to muck around in the source for anything.

Your comparison seems a little weird:

glyph@zelda:~/Projects/Reality% find . -name "*.py" | xargs wc -l | tail -1 
   6273 total

That's including all those docstrings you mentioned earlier, and unit tests,
too.  Now, I understand the functionality isn't really comparable to circlemud,
but it *is* 1/6 the size.  How rediculously small would you consider a
non-bulky game to be?


-- 
 |    <`'>    |  Glyph Lefkowitz: Traveling Sorcerer   |
 |   < _/ >   |  Lead Developer,  the Twisted project  |
 |  < ___/ >  |      http://www.twistedmatrix.com      |

----Security_Multipart(Wed_Jul_24_04:54:48_2002_636)--
Content-Type: application/pgp-signature
Content-Transfer-Encoding: 7bit

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.0.7 (GNU/Linux)

iD8DBQA9PnlovVGR4uSOE2wRAiC9AJ0ed2HoCtLbPg7L/tHmryvytR5klQCfSFWg
hZT+oYomPSJ5bRYGNsFhB2U=
=wmYc
-----END PGP SIGNATURE-----

----Security_Multipart(Wed_Jul_24_04:54:48_2002_636)----


