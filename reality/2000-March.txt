From glyph@twistedmatrix.com Sat, 4 Mar 2000 00:45:00 -0500 (EST)
Date: Sat, 4 Mar 2000 00:45:00 -0500 (EST)
From: glyph@twistedmatrix.com glyph@twistedmatrix.com
Subject: [Reality] python TR II 0.0.0

Okay, this is the first release I feel comfortable with announcing in
any form.

Take a look at www.twistedmatrix.com; it says it all.  Well, actually,
there are a lot of things it DOESN'T say, but if you come up with one
of those, I'd love to see it discussed here! :-)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/






From mad96@hampshire.edu Mon, 13 Mar 2000 07:36:40 -0500 (EST)
Date: Mon, 13 Mar 2000 07:36:40 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Python TR in CVS?

Is it there?  If so, how do we get at it?



--Mike







From glyph@twistedmatrix.com Mon, 13 Mar 2000 12:30:55 -0500 (EST)
Date: Mon, 13 Mar 2000 12:30:55 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] Python TR in CVS?

On Mon, 13 Mar 2000, Michael Dartt wrote:

> Is it there?  If so, how do we get at it?

> --Mike

Yeah, same CVSROOT as before, module 'reality'...

I also checked the newest iteration of the C faucet sources in to CVS,
mostly because I'm not planning to work on them at all, so if somebody
else wants to ... that's module 'cfaucet'.

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/







From mad96@hampshire.edu Tue, 14 Mar 2000 03:28:10 -0500 (EST)
Date: Tue, 14 Mar 2000 03:28:10 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] PyGTK Faucet

Have you guys thought of using Glade?  Last I checked, it could output
Python code.


--Mike







From glyph@twistedmatrix.com Tue, 14 Mar 2000 13:13:24 -0500 (EST)
Date: Tue, 14 Mar 2000 13:13:24 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] PyGTK Faucet

On Tue, 14 Mar 2000, Michael Dartt wrote:

> Have you guys thought of using Glade?  Last I checked, it could output
> Python code.
> 
> --Mike

Minor correction: python parses glade's XML save format.

Yes, I considered using it -- after all, we had the interface defined
already in the C version using glade... I even read in the interface file
and instantiated some stuff (pyglade is cool...).  However, it's not
really worth it for an interface as small as the faucet (look at
gtkfaucet.py; it would probably be MORE work to do that interface
graphically again) and secondly, I thought it would be good if Dave and I
got more familiar with the GTK API for actually building GUIs, as it
would be nice to send little 'applets' over the wire to the client ... and
we would probably need to design a small GUI API (which would likely have
to overlay Tk, Gtk, and maybe even something else) to allow the python
scripts that get sent to the client to be relatively cross-platform.

If only the damned dynamic-theme stuff worked right, I'd be really gung-ho
to just scrap that idea and use glade and use gtk on both win32 and linux,
even if it meant I had to help develop glade for win32 =)

Which reminds me, I have to write that nasty C preamble that will allow
the gtk faucet in python to use themes...

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/







From mad96@hampshire.edu Thu, 16 Mar 2000 04:21:51 -0500 (EST)
Date: Thu, 16 Mar 2000 04:21:51 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Faucet API & class, round 1

I'm working on writing:

Faucet class (faucet.py): contains structures, functions, etc. common to
all Faucets, regardless of front-end, excepting networking/protocol stuff,
which will go in protocol.py

Faucet GUI API: function and variable names and construction, so that
it'll be easier to write, read, and debug Faucet front-ends (assuming
programmers follow this :-j)

The inheritance structure would go: FaucetProtocol -> Faucet -> GUIFaucet
(e.g. GtkFaucet, TkFaucet, NcursesFaucet, etc.)

Below are my lists for what I think should go into the two things I've
mentioned above.  Let me know what needs changing.  (Or if there are any
suggestions....)

Functions are denoted with a dollar sign ($).  The other symbols have no
significance.  (It's all indentation.  :-)


--Mike

------

* Common stuff (Faucet.py)
	- history
	  $ history up
	  $ history down
	  $ save history
	- keys
	  - shortcuts (keypad #s for moving, other user-defined, etc) dict
	  - expansions ("u" for "go up", etc.) dict
	  - etc. (Return, Up, Down, et al) dict
	  $ load shortcuts, etc.
	  $ change shortcuts
	  $ key functions (what Return, et al do)
	- items dictionary
	  $ refresh
	  $ add items
	  $ remove items
	  $ clear	  
	- description dictionary
	  $ refresh
	  $ add key
	  $ remove key
	  $ clear
	- exits list
	  $ add exits to desc
* UI pieces (API)
	- Login window
	  @ window title
	  @ character name text entry field (drop-down)
	    - label
	  @ password text entry field
	    - label
	  @ server text entry field (drop-down?)
	    - label
	  @ progress bar
	  @ login button
	    - label
	  @ program name and version label
	  @ cancel/quit button
	    - label
	  @ "save password" check box
	    - label
	  @ "auto-login" check box
	    - label
	  $ save fields & prefs
	- Game window
	  @ window title
	  @ description box
	    - description scrollbar
	    $ refresh
	  @ item box
	    $ refresh
	  @ item tree
	  @ message box
	    - msg box scrollbar
	    $ display message
	  @ command line
	    $ clear
	    $ focus
	    $ get/send text
	- Authoring window
	  @ window title
	  @ OK button
	    - button label
	  @ Cancel button
	    - button label
	  @ Clear button
	    - button label
	  @ text field 
	  $ get text from box
	$ Quit
	$ change theme

* Save following in Faucet dir (one file, XML?):
	- keyboard macros
	- command history (save on quit)
	- login info







From glyph@twistedmatrix.com Thu, 16 Mar 2000 11:26:30 -0500 (EST)
Date: Thu, 16 Mar 2000 11:26:30 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] Faucet API & class, round 1

Good idea, but I don't think as many parts of this are generalizable as
you think; but let me address each one specifically.

On Thu, 16 Mar 2000, Michael Dartt wrote:

> Faucet class (faucet.py): contains structures, functions, etc. common to
> all Faucets, regardless of front-end, excepting networking/protocol stuff,
> which will go in protocol.py

Well, it might be better to just put the 'common' stuff in protocol.py,
since the protocol should ideally not only define the bytes being sent
over the wire, but the higher-level *meaning* of those bytes... however...

> Faucet GUI API: function and variable names and construction, so that
> it'll be easier to write, read, and debug Faucet front-ends (assuming
> programmers follow this :-j)

Well, this exists to some extent already.  I mean, the name, hears,
et. al. methods are there... there are things to implement to do all of
the major functions, and as it gets complete, more of those will
appear.  FaucetProtocol defines this.

> The inheritance structure would go: FaucetProtocol -> Faucet -> GUIFaucet
> (e.g. GtkFaucet, TkFaucet, NcursesFaucet, etc.)

You might want to eliminate the first or second link in this chain
(depending on how you want to do naming) , for the reasons I gave above...

> Below are my lists for what I think should go into the two things I've
> mentioned above.  Let me know what needs changing.  (Or if there are any
> suggestions....)

Will do :-)

> Functions are denoted with a dollar sign ($).  The other symbols have no
> significance.  (It's all indentation.  :-)

"It's all about the whitespace, baby..."

> --Mike
> ------
> 
> * Common stuff (Faucet.py)
> 	- history
> 	  $ history up
> 	  $ history down
> 	  $ save history

All good stuff.  This can definitely be generalized.

> 	- keys
> 	  - shortcuts (keypad #s for moving, other user-defined, etc) dict
> 	  - expansions ("u" for "go up", etc.) dict
> 	  - etc. (Return, Up, Down, et al) dict
> 	  $ load shortcuts, etc.
> 	  $ change shortcuts
> 	  $ key functions (what Return, et al do)

Also not bad.

> 	- items dictionary
> 	  $ refresh
> 	  $ add items
> 	  $ remove items
> 	  $ clear	  

Aah, here we get into a problem.

The GUI frontend is going to need to know about add/removes, especially if
we're going to put the items display into a tree (GtkCTree) or list
(GtkCList).  Not to mention the hariness of doing this in
ncurses.  I don't know if keeping the dictionary around will always be
useful... or if it is, to what degree... different formats of storage may
prove useful here.

> 	- description dictionary
> 	  $ refresh
> 	  $ add key
> 	  $ remove key
> 	  $ clear

OK, this could quite possibly be generic, since there's no need for
elements of the description to be distinct to the player...

> 	- exits list
> 	  $ add exits to desc

This not so much.  I'd ideally like to have a graphical compass of some
kind at some point... the exits in the room desc was always supposed to be
temporary (but it's been around so long it's grown into a kind of de facto
standard)

> * UI pieces (API)
> 	- Login window
<snip>

Why do we need an API to access login-windows?  I can't see a reason that
that would be helpful in-game...

> 	  @ "save password" check box
> 	    - label

Uh... I dunno... the little security demon in my head is screaming about
that one ;)

> 	  @ "auto-login" check box
> 	    - label

This too ... but I guess AIM does it... hm.

> 	  $ save fields & prefs

OK...

> 	- Game window

<snip>

When you say "API", what do you mean here?  What I was thinking you meant
was entry points for the "gui plugins" that Dave and I suggested, but it
looks like you're talking about something different... what programmers
would be using this API?

> 	- Authoring window
> 	  @ window title
> 	  @ OK button
> 	    - button label
> 	  @ Cancel button
> 	    - button label
> 	  @ Clear button
> 	    - button label
> 	  @ text field 
> 	  $ get text from box

well, this would be useful in any case...

> * Save following in Faucet dir (one file, XML?):

Ooh yes, let's use XML!  It will be dynamic and efficient and
multithreaded and enterprise wide!  Not to mention scalable and
multi-architectured and hluaghlaughlauglhagluahg (ad infinitum).

No, I think that a nice, simple tab-delimited text file will be fine
:-) those were a standard long before XML got its claws into the lives and
sanity of programmers everywhere.  And, as in most places where XML is
suggested, we need none of its features and it would probably just serve
to make things slow and stupid.

On a more positive XML-type note, it might be a nice thing to use for the
map format, if pickle doesn't scale well ... and it would be nice to have
something slightly more human-readable... I know you're probably looking
at all those wonderfully easy-to-use XML APIs in python and wondering what
to do with them.  So am I :)

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/










From mad96@hampshire.edu Thu, 16 Mar 2000 12:38:53 -0500 (EST)
Date: Thu, 16 Mar 2000 12:38:53 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Faucet API & class, round 1

Clarification: the GUI API is basically us saying, "If you write a
front-end, could you please name your functions and variables/widgets/etc.
according to these guidelines?"  So it's really just an interface--no
official code to go with it.

The criteria I used for splitting stuff up was that the GUI stuff only
deals with toolkit-specific issues--widgets, displaying info, etc.  The
Faucet module will handle the manipulation and storage of the information,
since that's common to all clients, no matter what toolkit is being used.
Finally, the front-end won't be ignorant of the stuff in Faucet.py, b/c
it'll inherit from it.

The point of this is to make it easier to develop Faucets--the only thing
one has to do is write the GUI code.

As far as merging Faucet.py with FaucetProtocol, I'm a bit leery of that
b/c the protocol implies the means by which the Faucet interacts with the
Pump, rather than how the Faucet operates internally.

Does this clear things up?


--Mike


On Thu, 16 Mar 2000, Glyph Lefkowitz wrote:

> 
> Good idea, but I don't think as many parts of this are generalizable as
> you think; but let me address each one specifically.
> 
> On Thu, 16 Mar 2000, Michael Dartt wrote:
> 
> > Faucet class (faucet.py): contains structures, functions, etc. common to
> > all Faucets, regardless of front-end, excepting networking/protocol stuff,
> > which will go in protocol.py
> 
> Well, it might be better to just put the 'common' stuff in protocol.py,
> since the protocol should ideally not only define the bytes being sent
> over the wire, but the higher-level *meaning* of those bytes... however...
> 
> > Faucet GUI API: function and variable names and construction, so that
> > it'll be easier to write, read, and debug Faucet front-ends (assuming
> > programmers follow this :-j)
> 
> Well, this exists to some extent already.  I mean, the name, hears,
> et. al. methods are there... there are things to implement to do all of
> the major functions, and as it gets complete, more of those will
> appear.  FaucetProtocol defines this.
> 
> > The inheritance structure would go: FaucetProtocol -> Faucet -> GUIFaucet
> > (e.g. GtkFaucet, TkFaucet, NcursesFaucet, etc.)
> 
> You might want to eliminate the first or second link in this chain
> (depending on how you want to do naming) , for the reasons I gave above...
> 
> > Below are my lists for what I think should go into the two things I've
> > mentioned above.  Let me know what needs changing.  (Or if there are any
> > suggestions....)
> 
> Will do :-)
> 
> > Functions are denoted with a dollar sign ($).  The other symbols have no
> > significance.  (It's all indentation.  :-)
> 
> "It's all about the whitespace, baby..."
> 
> > --Mike
> > ------
> > 
> > * Common stuff (Faucet.py)
> > 	- history
> > 	  $ history up
> > 	  $ history down
> > 	  $ save history
> 
> All good stuff.  This can definitely be generalized.
> 
> > 	- keys
> > 	  - shortcuts (keypad #s for moving, other user-defined, etc) dict
> > 	  - expansions ("u" for "go up", etc.) dict
> > 	  - etc. (Return, Up, Down, et al) dict
> > 	  $ load shortcuts, etc.
> > 	  $ change shortcuts
> > 	  $ key functions (what Return, et al do)
> 
> Also not bad.
> 
> > 	- items dictionary
> > 	  $ refresh
> > 	  $ add items
> > 	  $ remove items
> > 	  $ clear	  
> 
> Aah, here we get into a problem.
> 
> The GUI frontend is going to need to know about add/removes, especially if
> we're going to put the items display into a tree (GtkCTree) or list
> (GtkCList).  Not to mention the hariness of doing this in
> ncurses.  I don't know if keeping the dictionary around will always be
> useful... or if it is, to what degree... different formats of storage may
> prove useful here.
> 
> > 	- description dictionary
> > 	  $ refresh
> > 	  $ add key
> > 	  $ remove key
> > 	  $ clear
> 
> OK, this could quite possibly be generic, since there's no need for
> elements of the description to be distinct to the player...
> 
> > 	- exits list
> > 	  $ add exits to desc
> 
> This not so much.  I'd ideally like to have a graphical compass of some
> kind at some point... the exits in the room desc was always supposed to be
> temporary (but it's been around so long it's grown into a kind of de facto
> standard)
> 
> > * UI pieces (API)
> > 	- Login window
> <snip>
> 
> Why do we need an API to access login-windows?  I can't see a reason that
> that would be helpful in-game...
> 
> > 	  @ "save password" check box
> > 	    - label
> 
> Uh... I dunno... the little security demon in my head is screaming about
> that one ;)
> 
> > 	  @ "auto-login" check box
> > 	    - label
> 
> This too ... but I guess AIM does it... hm.
> 
> > 	  $ save fields & prefs
> 
> OK...
> 
> > 	- Game window
> 
> <snip>
> 
> When you say "API", what do you mean here?  What I was thinking you meant
> was entry points for the "gui plugins" that Dave and I suggested, but it
> looks like you're talking about something different... what programmers
> would be using this API?
> 
> > 	- Authoring window
> > 	  @ window title
> > 	  @ OK button
> > 	    - button label
> > 	  @ Cancel button
> > 	    - button label
> > 	  @ Clear button
> > 	    - button label
> > 	  @ text field 
> > 	  $ get text from box
> 
> well, this would be useful in any case...
> 
> > * Save following in Faucet dir (one file, XML?):
> 
> Ooh yes, let's use XML!  It will be dynamic and efficient and
> multithreaded and enterprise wide!  Not to mention scalable and
> multi-architectured and hluaghlaughlauglhagluahg (ad infinitum).
> 
> No, I think that a nice, simple tab-delimited text file will be fine
> :-) those were a standard long before XML got its claws into the lives and
> sanity of programmers everywhere.  And, as in most places where XML is
> suggested, we need none of its features and it would probably just serve
> to make things slow and stupid.
> 
> On a more positive XML-type note, it might be a nice thing to use for the
> map format, if pickle doesn't scale well ... and it would be nice to have
> something slightly more human-readable... I know you're probably looking
> at all those wonderfully easy-to-use XML APIs in python and wondering what
> to do with them.  So am I :)
> 
>                       ______      __   __  _____  _     _
>                      |  ____ |      \_/   |_____] |_____|
>                      |_____| |_____  |    |       |     |
>                      @ t w i s t e d m a t r i x  . c o m
>                      http://www.twistedmatrix.com/~glyph/
> 
> 
> 
> 
> 
> 
> 
> _______________________________________________
> Reality mailing list
> Reality@twistedmatrix.com
> http://twistedmatrix.com/cgi-bin/mailman/listinfo/reality
> 






From glyph@twistedmatrix.com Thu, 16 Mar 2000 14:41:37 -0500 (EST)
Date: Thu, 16 Mar 2000 14:41:37 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] Faucet API & class, round 1

On Thu, 16 Mar 2000, Michael Dartt wrote:

> Clarification: the GUI API is basically us saying, "If you write a
> front-end, could you please name your functions and variables/widgets/etc.
> according to these guidelines?"  So it's really just an interface--no
> official code to go with it.

Okay.  I draw your attention to lines 280-290 of protocol.py:


	def __init__(self):
		self.commands={CMD_Hears: self.hear,
				CMD_SetName: self.name,
				CMD_DescAppend: self.describe,
				CMD_SetTheme: self.theme,
				CMD_DescClear: self.desc_clear,
				CMD_ListClear: self.list_clear,
				CMD_Exits: self.exits,
				CMD_ListAdd: self.list_add,
				CMD_ListRemove: self.list_remove,
				CMD_CompletedAction: self.reactivate}

I'd say that that little snippit fairly clearly defines an interface,
wouldn't you? ;-)

> The criteria I used for splitting stuff up was that the GUI stuff only
> deals with toolkit-specific issues--widgets, displaying info, etc.  The
> Faucet module will handle the manipulation and storage of the information,
> since that's common to all clients, no matter what toolkit is being used.
> Finally, the front-end won't be ignorant of the stuff in Faucet.py, b/c
> it'll inherit from it.

I don't think that the data would be useful; as I said in my last email,
each GUI is going to have to store the data in a different format,
especially if there's going to be tree or other list-type widget being
used for the item display stuff.  The only thing that might be useful is
the description handling.

> The point of this is to make it easier to develop Faucets--the only thing
> one has to do is write the GUI code.

It's pretty close to that right now, looking at what we've got... maybe it
could be better documented...

> As far as merging Faucet.py with FaucetProtocol, I'm a bit leery of that
> b/c the protocol implies the means by which the Faucet interacts with the
> Pump, rather than how the Faucet operates internally.

I guess, but the distinction seems academic to me.  Is there ever
somewhere you'd want to use a Faucet protocol without using a Faucet?

> Does this clear things up?

a bit.

> --Mike


                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/








From mad96@hampshire.edu Sat, 18 Mar 2000 08:30:04 -0500 (EST)
Date: Sat, 18 Mar 2000 08:30:04 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Python question--parsing

I'd really like to be able to use parse.py's Tokenizer to parse a given
text string.  The problem, of course, is that it calls tokenize(), which
wants a readline()-type argument.  Is there any function I can use that
will allow me to do this?

Right now, this is the code I have for __init__() in parse.py:

	def __init__(self, string):
		self.tokens=[]
		self._neg=None
		#self.fn=string #not sure why this is here...
		try: fd=open(string) # if it's a file, this will work 
		except IOError: # must just be a string
			import time
			x=time.time()
###Problem line--->	tokenize(string, self.eat)
			x=time.time()-x
			print 'Tokenization took %d seconds.' % x
			self.reset()
		else: # is a file
			import time
			x=time.time()
			tokenize(fd.readline,self.eat)
			x=time.time()-x
			print 'Tokenization took %d seconds.' % x	
			fd.close()
			self.reset()


I suppose I could use re for this, but I'd really rather not: this is much
more convenient for my purposes.

Thanks in advance for your help.  :-)


--Mike/Jedin







From glyph@twistedmatrix.com Sat, 18 Mar 2000 13:02:47 -0500 (EST)
Date: Sat, 18 Mar 2000 13:02:47 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] Python question--parsing

On Sat, 18 Mar 2000, Michael Dartt wrote:

> I'd really like to be able to use parse.py's Tokenizer to parse a given
> text string.  The problem, of course, is that it calls tokenize(), which
> wants a readline()-type argument.  Is there any function I can use that
> will allow me to do this?

twisted/words/sentence.py:16/17 should answer this question

(Try to ignore the nasty hack there that makes strings that end with an
EOF be valid...)

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/








From mad96@hampshire.edu Sat, 18 Mar 2000 11:22:47 -0500 (EST)
Date: Sat, 18 Mar 2000 11:22:47 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Re: Python question--parsing

'S cool--I'm using StringIO to create a buffer, which I can then call
readline() on.  I love comp.lang.python...:-)  (Esp. since EFnet hates
me....)


--Mike


On Sat, 18 Mar 2000, Michael Dartt wrote:

> I'd really like to be able to use parse.py's Tokenizer to parse a given
> text string.  The problem, of course, is that it calls tokenize(), which
> wants a readline()-type argument.  Is there any function I can use that
> will allow me to do this?
> 
> Right now, this is the code I have for __init__() in parse.py:
> 
> 	def __init__(self, string):
> 		self.tokens=[]
> 		self._neg=None
> 		#self.fn=string #not sure why this is here...
> 		try: fd=open(string) # if it's a file, this will work 
> 		except IOError: # must just be a string
> 			import time
> 			x=time.time()
> ###Problem line--->	tokenize(string, self.eat)
> 			x=time.time()-x
> 			print 'Tokenization took %d seconds.' % x
> 			self.reset()
> 		else: # is a file
> 			import time
> 			x=time.time()
> 			tokenize(fd.readline,self.eat)
> 			x=time.time()-x
> 			print 'Tokenization took %d seconds.' % x	
> 			fd.close()
> 			self.reset()
> 
> 
> I suppose I could use re for this, but I'd really rather not: this is much
> more convenient for my purposes.
> 
> Thanks in advance for your help.  :-)
> 
> 
> --Mike/Jedin
> 
> 
> 






From mad96@hampshire.edu Sat, 18 Mar 2000 15:44:24 -0500 (EST)
Date: Sat, 18 Mar 2000 15:44:24 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Where is stuff?

Maybe it's b/c I'm tired, but I'm having trouble finding out what,
exactly, I can do with a player, esp. the following functions: hears(),
he(), him(), etc.  Where can I find this out?  I didn't see them in the
User class.  Also, where should I put the code for determining whether or
not the social exists?  I assume it should go in core.Sentence, along with
the verb stuff, but I'm not exactly sure what to have it check.  And,
shall I add the creation of the socials in the initialization of the
reality?

On another note, are we trying to win an obfuscated Python contest?  I
popped open PlayerSayHandler.py, and all I saw was:

def event(ev,th):
	th.hears(ev.origin,' says, "',ev.data,'".')

"th"?  What kind of thing is that?  Looks like a player, but I haven't
seen any comments, or any documented references....



--Mike







From glyph@twistedmatrix.com Sat, 18 Mar 2000 19:00:51 -0500 (EST)
Date: Sat, 18 Mar 2000 19:00:51 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] Where is stuff?

On Sat, 18 Mar 2000, Michael Dartt wrote:

> Maybe it's b/c I'm tired, but I'm having trouble finding out what,
> exactly, I can do with a player, esp. the following functions: hears(),
> he(), him(), etc.  Where can I find this out?  I didn't see them in the
> User class.  Also, where should I put the code for determining whether or
> not the social exists?  I assume it should go in core.Sentence, along with
> the verb stuff, but I'm not exactly sure what to have it check.  And,
> shall I add the creation of the socials in the initialization of the
> reality?

Perhaps the source of your confusion is that there is no such thing as a
"player".  A player is just a Thing that happens to be connected to a User
(a User being an authentication object, not something that has to do with
the game directly, except for controlling and recieving input...)

> On another note, are we trying to win an obfuscated Python contest?  I
> popped open PlayerSayHandler.py, and all I saw was:

Mike, just read core.py; the documentation isn't great, but the python
certainly isn't obfuscated.  A cursory glance through the event handling
code (even just searching or grepping for "event" in core.py) would have
revealed the following;

> def event(ev,th):
> 	th.hears(ev.origin,' says, "',ev.data,'".')
> 
> "th"?  What kind of thing is that?  Looks like a player, but I haven't
> seen any comments, or any documented references....

core.py:597

	def handleEvent(self,event,data=None,origin=None,delay=0):
		"Handle an event on this object, if a proper handler exists."
		if delay:
			dl = DelayedEvent(event,data,origin,self,delay)
			self.getReality().insertEvent(dl)
		else:
			x=self.getHandler(event)
			if not x is None:
				e=Event(event,data,origin)
				x.event(e,self)
				^^^^^^^^^^^^^^^

I will give you one guess as to what type the object 'self' is in that
context.

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/








From mad96@hampshire.edu Wed, 22 Mar 2000 13:28:31 -0500 (EST)
Date: Wed, 22 Mar 2000 13:28:31 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Socials questions

I'm parsing in the socials from a text file and storing them in a
dictionary (Socials.socials, indexed by name, of course).  IIUnderstandC,
I need to put an action() function in socials.py, which will be executed
as if it were a verb.  Here's what I'm wondering:

1) Since the socials are being held in their own dictionary, how will the
game know to call the socials "verb" when someone calls, say, "bite"?  Or
will "socials" be called whenever the given verb can't be found?

2) Should I throw an InappropriateVerb exception or a NoVerb exception if
the requested social doesn't exist?

3) Should the action() method be inside the Socials class, or outside it?
Is this true for all verbs?

I was thinking originally that the socials dictionary would be part of the
given reality, e.g. self.socials = Socials("socials.txt"), and it could
then be referenced by whatever does the verb checking, so that the socials
stuff isn't run unless the requested one actually exists.

I hope I haven't been too confusing.  Thanks in advance for your help.



--Mike







From glyph@twistedmatrix.com Wed, 22 Mar 2000 15:15:27 -0500 (EST)
Date: Wed, 22 Mar 2000 15:15:27 -0500 (EST)
From: Glyph Lefkowitz glyph@twistedmatrix.com
Subject: [Reality] Socials questions

On Wed, 22 Mar 2000, Michael Dartt wrote:

> I'm parsing in the socials from a text file and storing them in a
> dictionary (Socials.socials, indexed by name, of course).  IIUnderstandC,
> I need to put an action() function in socials.py, which will be executed
> as if it were a verb.  Here's what I'm wondering:
> 
> 1) Since the socials are being held in their own dictionary, how will the
> game know to call the socials "verb" when someone calls, say, "bite"?  Or
> will "socials" be called whenever the given verb can't be found?

Socials is a regular verb; as such, its action method will be invoked when
it is found on an object.

I assume you're using a class for some of this stuff, so somewhere in
socials you'll have a line that looks like

socials=Socials("socials.txt")

You should, at least, have a module-global representation of whatever
object you're using to keep track of the socials you read in.

Then after that,

names=socials.getNamesTuple()

This will tell the core that your verb has the names listed in 'names'
(again, this has to be module-global).

> 2) Should I throw an InappropriateVerb exception or a NoVerb exception if
> the requested social doesn't exist?

InappropriateVerb; you really shouldn't ever raise NoVerb yourself.  
Think of InappropriateVerb as a NoVerb but giving the game an extra chance
to correct itself, if it somehow found your verb in error.

> 3) Should the action() method be inside the Socials class, or outside it?
> Is this true for all verbs?

It should be outside it.  The 'verb' is basically a module; you don't
*need* to define a socials class at all (although I can see how it might
be convenient).  The only things that the game will look for are a
module-global variable called 'names' and one called 'action'.  'names',
as I said before, should be a tuple containing the names that your verb
can be referred to as; 'action' should be a method which takes on
argument.

> I was thinking originally that the socials dictionary would be part of the
> given reality, e.g. self.socials = Socials("socials.txt"), and it could
> then be referenced by whatever does the verb checking, so that the socials
> stuff isn't run unless the requested one actually exists.

I don't think this would be a good idea, since it would negate the
benefits of being able to reload the socials module to reload the socials
file.

Also, socials shouldn't really have to be a 'special' verb... seems like
it would just add more crap to debug, without adding any functionality.

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://www.twistedmatrix.com/~glyph/







From mad96@hampshire.edu Wed, 22 Mar 2000 14:40:14 -0500 (EST)
Date: Wed, 22 Mar 2000 14:40:14 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Socials questions

Should I then put the "socials.py" file in twisted/reality/plugins?  (Why
is it called "plugins" instead of "verbs"?  If there are other "plugins"
planned, why not have a plugins/verbs folder?)  


--Mike








From mad96@hampshire.edu Wed, 22 Mar 2000 14:46:06 -0500 (EST)
Date: Wed, 22 Mar 2000 14:46:06 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Socials questions

Whoop--one more: since I've got a "names" list, I don't have to worry
about throwing an exception, right?  The verb executor (or whatever it's
called) will do that for me, just as with a normal verb, yes?


--Mike








From mad96@hampshire.edu Wed, 22 Mar 2000 15:26:19 -0500 (EST)
Date: Wed, 22 Mar 2000 15:26:19 -0500 (EST)
From: Michael Dartt mad96@hampshire.edu
Subject: [Reality] Socials questions

And another....Do I need to check for whether or not the (direct |
indirect) object(s) are actually there?  The engine takes care of that for
me and doesn't execute the verb if stuff isn't present, right?


--Mike


On Wed, 22 Mar 2000, Michael Dartt wrote:

> Whoop--one more: since I've got a "names" list, I don't have to worry
> about throwing an exception, right?  The verb executor (or whatever it's
> called) will do that for me, just as with a normal verb, yes?
> 
> 
> --Mike
> 
> 
> 
> 
> 
> _______________________________________________
> Reality mailing list
> Reality@twistedmatrix.com
> http://twistedmatrix.com/cgi-bin/mailman/listinfo/reality
> 






