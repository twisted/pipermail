From exarkun at divmod.com  Sat Apr  3 23:33:06 2004
From: exarkun at divmod.com (exarkun@divmod.com)
Date: Sat Apr  3 23:40:24 2004
Subject: [Reality] Containment - barriers to implementation
Message-ID: <20040404063306.24283.904559571.divmod.quotient.14@ohm>


  Summary of conversation on IRC tonight:

    We want to start a containment implementation.  Some things it should support include simple room/exit structures, cardboard boxes, lead boxes, glass boxes, and brass cockroaches.  It should also support an observation [sub]system of some sort, including both vision in the normal spectrum and in the x-ray spectrum ("See through lots of stuff, but not lead").

    The major point of discussion was over who should be responsible for knowing that x-rays pass through cardboard and glass, but not lead, and that human-visible spectrum light passes through glass, but not cardboard or lead.

    A good answer seems to be that a materials system should be responsible for knowing this.  This appears to require a change to imagination.simulacrum.collect().  The current Look action is implemented only in terms of the IDescribable interface (possibly a mistake, but probably unrelated to the real issue).  With the current imagination.simulacrum.Container implementation of ICollector, there is no way to have Look bypass all barriers in the object graph (such as a closed cardboard box) and filter the result based on some containment system.

    The main idea discussed to make this possible was the addition of a second criterion, for use with ICollector.more() (whereas the current criterion is used with both, though the current implementation uses it only in find()).  As an alternative to adding a second criterion, it also seems possible to change the current criterion to an introspectable object (*not* a Componentized, as radix suggested in an attempt to fry my brain) which would provide enough information to filter both collectors/more and implements/find in semantically different ways.  This preserves the existing interfaces, more or less, and forces us to fix criterion sooner rather than later, so maybe is a better solution.

    So!  What does all this mean?  Perhaps something like this:

    class Look(TargetAction):
        ....

        def doAction(self):
            ....
            if usingXRayVision:
                c = collect(self.target, IDescribable,
                            # Only implementors that are lead can actually be seen
                            lambda o: IMaterial(o).type == 'lead',
                            # Only collectors that are lead cannot be seen through
                            lambda o: IMaterial(o).type != 'lead',
                            2)
            else:
                c = collect(self.target, IDescribable,
                            # All implementors are visible
                            lambda o: True,
                            # Open and transparent containers can be seen through
                            lambda o: not ICloseable(o).closed or IMaterial(o).type == 'glass'
                            2)
            ....

    Does this seem to be at all on the right track?

  Jp

From radix at twistedmatrix.com  Sat Apr  3 23:56:58 2004
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Sat Apr  3 23:57:18 2004
Subject: [Reality] Containment - barriers to implementation
In-Reply-To: <20040404063306.24283.904559571.divmod.quotient.14@ohm>
References: <20040404063306.24283.904559571.divmod.quotient.14@ohm>
Message-ID: <406FB1BA.80502@twistedmatrix.com>

exarkun@divmod.com wrote:
>     class Look(TargetAction):
>         def doAction(self):
>             ....
>             if usingXRayVision:
>                 c = collect(self.target, IDescribable,
>                             # Only implementors that are lead can actually be seen
>                             lambda o: IMaterial(o).type == 'lead',
>                             # Only collectors that are lead cannot be seen through
>                             lambda o: IMaterial(o).type != 'lead',
>                             2)
>             else:
>                 c = collect(self.target, IDescribable,
>                             # All implementors are visible
>                             lambda o: True,
>                             # Open and transparent containers can be seen through
>                             lambda o: not ICloseable(o).closed or IMaterial(o).type == 'glass'
>                             2)

Hmm, the last bit kinda annoys me. Maybe we should allow the collectors 
to implement some of those 'blocking' semantics themselves ("Am I 
closed? If so, don't let things through") with the option for the 
criterion to override them?

-- 
  Twisted | Christopher Armstrong: International Man of Twistery
   Radix  |          Release Manager,  Twisted Project
---------+           http://radix.twistedmatrix.com/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 256 bytes
Desc: OpenPGP digital signature
Url : http://pyramid.twistedmatrix.com/pipermail/reality/attachments/20040404/20d7dce1/signature.bin
From glyph at twistedmatrix.com  Sun Apr  4 00:01:23 2004
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun Apr  4 00:01:58 2004
Subject: [Reality] Containment - barriers to implementation
In-Reply-To: <20040404063306.24283.904559571.divmod.quotient.14@ohm>
References: <20040404063306.24283.904559571.divmod.quotient.14@ohm>
Message-ID: <E21E1B24-8605-11D8-9D8B-000393C9700E@twistedmatrix.com>


On Apr 4, 2004, at 1:33 AM, <exarkun@divmod.com> wrote:

> As an alternative to adding a second criterion, it also seems possible 
> to change the current criterion to an introspectable object ... which 
> would provide enough information to filter both collectors/more and 
> implements/find in semantically different ways.  This preserves the 
> existing interfaces, more or less, and forces us to fix criterion 
> sooner rather than later, so maybe is a better solution.

IMHO this is the correct solution, because I have a feeling we will 
want the criterion to do more sophisticated things as time goes on, and 
I don't want to go from 2 to 3 to 4 kinds of criterion in doing so.

A good example of "more stuff" might be a 'refine' method on criterion 
to aggregate them, whereby one might (somehow) indicate that one is 
requesting an object *both* whose name is "sword" *and* whose owner is 
me.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PGP.sig
Type: application/pgp-signature
Size: 186 bytes
Desc: This is a digitally signed message part
Url : http://pyramid.twistedmatrix.com/pipermail/reality/attachments/20040404/f33fb119/PGP.bin
From glyph at twistedmatrix.com  Sun Apr  4 12:56:10 2004
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun Apr  4 20:23:27 2004
Subject: [Reality] Containment - barriers to implementation
In-Reply-To: <20040404063306.24283.904559571.divmod.quotient.14@ohm>
References: <20040404063306.24283.904559571.divmod.quotient.14@ohm>
Message-ID: <BCB88024-8669-11D8-9D8B-000393C9700E@twistedmatrix.com>


On Apr 4, 2004, at 1:33 AM, <exarkun@divmod.com> wrote:

>     We want to start a containment implementation.  Some things it 
> should support include simple room/exit structures, cardboard boxes, 
> lead boxes, glass boxes, and brass cockroaches.  It should also 
> support an observation [sub]system of some sort, including both vision 
> in the normal spectrum and in the x-ray spectrum ("See through lots of 
> stuff, but not lead").


Containment (and carrying) should also take into account some simple 
statistics related to weight and size.  In Divunal mk 1, we also had 
"weildiness", which was an abstract number indicating how comfortable a 
given thing is to carry barehanded.  I suppose it represented how 
complex and/or oblong a thing was.

This might also involve some form of timed event.  For example, you can 
pick up a certain amount of weight for 10 minutes, but then it gets too 
heavy and you need to put stuff down.  Or, a particular pile of junk is 
stable for a given number of minutes and then collapses.

This also implies some base stats such as strength on the 
ITakeActor/IDropActor/IPushActor/etc implementor, which will hopefully 
all be the same object...
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PGP.sig
Type: application/pgp-signature
Size: 186 bytes
Desc: This is a digitally signed message part
Url : http://pyramid.twistedmatrix.com/pipermail/reality/attachments/20040404/7a66bf17/PGP.bin
From exarkun at divmod.com  Sun Apr  4 21:57:54 2004
From: exarkun at divmod.com (exarkun@divmod.com)
Date: Sun Apr  4 21:57:55 2004
Subject: [Reality] Containment - barriers to implementation
Message-ID: <20040405035754.26225.1979519620.divmod.quotient.1@ohm>

On Sun, 04 Apr 2004 01:56:58 -0500, Christopher Armstrong <radix@twistedmatrix.com> wrote:
>
> [snip]
> 
> Hmm, the last bit kinda annoys me. Maybe we should allow the collectors 
> to implement some of those 'blocking' semantics themselves ("Am I 
> closed? If so, don't let things through") with the option for the 
> criterion to override them?

  Override the default behavior?  But then you need a default behavior... which should be... what?

  Jp

From exarkun at divmod.com  Sun Apr  4 22:27:20 2004
From: exarkun at divmod.com (exarkun@divmod.com)
Date: Sun Apr  4 22:27:22 2004
Subject: [Reality] Containment - barriers to implementation
Message-ID: <20040405042720.26225.1672980630.divmod.quotient.2@ohm>

On Sun, 4 Apr 2004 03:01:23 -0400, Glyph Lefkowitz <glyph@twistedmatrix.com> wrote:
>
> On Apr 4, 2004, at 1:33 AM, <exarkun@divmod.com> wrote:
> 
> > As an alternative to adding a second criterion, it also seems possible 
> > to change the current criterion to an introspectable object ... which 
> > would provide enough information to filter both collectors/more and 
> > implements/find in semantically different ways.  This preserves the 
> > existing interfaces, more or less, and forces us to fix criterion 
> > sooner rather than later, so maybe is a better solution.
> 
> IMHO this is the correct solution, because I have a feeling we will 
> want the criterion to do more sophisticated things as time goes on, and 
> I don't want to go from 2 to 3 to 4 kinds of criterion in doing so.

  I suspected this was the case.  I am trying to come up with concrete examples of how one of these criterion objects would be implemented and having a fairly difficult time of it.

  Briefly, I thought different types of criterion objects could be used when collecting different interfaces,  Unfortunately it seems that radix and I demolished that possiblity at PyCon by calling the criterion object in _collect():

def _collect(asker, start, interface, criterion, radius=2):
    seen = {}
    selfish = interface(start, default=None)
    if selfish is not None and criterion(selfish):
        yield (0, selfish)
        seen[id(selfish)] = True
    for distance, collector in _evermore(start, asker, interface, criterion, radius):
        for implementor in collector.find(asker, interface, criterion):
            if id(implementor) not in seen:
                yield distance, implementor
                seen[id(implementor)] = True

  The change fixed a bug where too many objects were being collected.  Maybe there is another way to accomplish the same thing without using the criterion object.

> 
> A good example of "more stuff" might be a 'refine' method on criterion 
> to aggregate them, whereby one might (somehow) indicate that one is 
> requesting an object *both* whose name is "sword" *and* whose owner is 
> me.
> 

  So, here's a random thought for the structure of the criterion object:

    criterion = [
        (common.INoun, 'name', lambda o: o == 'sword'),
        (something.IPosession, 'owner', lambda o: o is glyph),
    ]

  Of course, this only allows for one kind of logical boolean connector.  A possible fix would be to build up a tree representing the criteria, e.g.:

    criterion = AND(
        (common.INoun, 'name', lambda o: o == 'sword'),
        (something.IPosession, 'owner', lambda o: o is glyph)
    )

  with all the other obvious callables such as OR, NOT etc.  This adds a pretty hefty burden to the implementors of find() and more() though.

  Better ideas (please)?

  Jp

From exarkun at divmod.com  Sun Apr  4 22:41:09 2004
From: exarkun at divmod.com (exarkun@divmod.com)
Date: Sun Apr  4 22:41:11 2004
Subject: [Reality] Containment - barriers to implementation
Message-ID: <20040405044109.26225.288540762.divmod.quotient.3@ohm>

On Sun, 4 Apr 2004 14:56:10 -0400, Glyph Lefkowitz <glyph@twistedmatrix.com> wrote:
>
> On Apr 4, 2004, at 1:33 AM, <exarkun@divmod.com> wrote:
> 
> >     We want to start a containment implementation.  Some things it 
> > should support include simple room/exit structures, cardboard boxes, 
> > lead boxes, glass boxes, and brass cockroaches.  It should also 
> > support an observation [sub]system of some sort, including both vision 
> > in the normal spectrum and in the x-ray spectrum ("See through lots of 
> > stuff, but not lead").
> 
> 
> Containment (and carrying) should also take into account some simple 
> statistics related to weight and size.  In Divunal mk 1, we also had 
> "weildiness", which was an abstract number indicating how comfortable a 
> given thing is to carry barehanded.  I suppose it represented how 
> complex and/or oblong a thing was.
> 

  I was thinking of dealing with such things in a manner something like the following:

    class BoringEuclideanObject(Adapter):
        __implements__ = IPhysical

        mass = None


    class BoringEuclideanContainer(Adapter):
        __implements__ = ICollecter

        capacity = 50
        contained = 0

        # ... find and more implementations ...

        def get(self, obj):
            """Try and make obj become inside self.
            """
            mass = IPhysical(obj).mass
            if mass > self.capacity:
                raise SomeKindOfException("Tooooo biiig")
            self.capacity -= mass
            self.contained += mass
            # Equivalent of .link()/.grab()

  The important bit being the adaption to IPhysical and the use of its attribute to determine whether containment can be achieved.  Weieldiness could be achieved the same way, by having the actor's wield method check whatever attributes of whatever component are appropriate.

> This might also involve some form of timed event.  For example, you can 
> pick up a certain amount of weight for 10 minutes, but then it gets too 
> heavy and you need to put stuff down.  Or, a particular pile of junk is 
> stable for a given number of minutes and then collapses.
> 
> This also implies some base stats such as strength on the 
> ITakeActor/IDropActor/IPushActor/etc implementor, which will hopefully 
> all be the same object...
> 

  Assuming everything I've written so far is approximately correct, I think this is a vastly simpler problem (at least for me) than the one regarding criteria discussed elsewhere in this thread.

  Jp

From radix at twistedmatrix.com  Sun Apr  4 23:14:51 2004
From: radix at twistedmatrix.com (Christopher Armstrong)
Date: Sun Apr  4 23:14:54 2004
Subject: [Reality] Containment - barriers to implementation
In-Reply-To: <20040405035754.26225.1979519620.divmod.quotient.1@ohm>
References: <20040405035754.26225.1979519620.divmod.quotient.1@ohm>
Message-ID: <4070EB4B.2040104@twistedmatrix.com>

exarkun@divmod.com wrote:
> On Sun, 04 Apr 2004 01:56:58 -0500, Christopher Armstrong <radix@twistedmatrix.com> wrote:
> 
>>[snip]
>>
>>Hmm, the last bit kinda annoys me. Maybe we should allow the collectors 
>>to implement some of those 'blocking' semantics themselves ("Am I 
>>closed? If so, don't let things through") with the option for the 
>>criterion to override them?
> 
> 
>   Override the default behavior?  But then you need a default behavior... which should be... what?

No, I didn't mention anything about defaults. I meant for the criterion 
to override the container's blocking-semantics; the container's blocking 
semantics are defined on a per-ICollector basis...

Anyway, I don't know enough about how an implementation of these 
semantics would go; I just frowned at the fact that the 
IClosable(o).closed check was in the criterion, and not the box, which 
is where we said it would be before. I'm probably wrong, and I have no 
basis on which to make an argument. So ignore this. :-)

-- 
  Twisted | Christopher Armstrong: International Man of Twistery
   Radix  |          Release Manager,  Twisted Project
---------+           http://radix.twistedmatrix.com/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 256 bytes
Desc: OpenPGP digital signature
Url : http://pyramid.twistedmatrix.com/pipermail/reality/attachments/20040405/893f36f9/signature.bin
