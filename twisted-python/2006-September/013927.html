<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Data management in a Twisted application
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Data%20management%20in%20a%20Twisted%20application&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013924.html">
   <LINK REL="Next"  HREF="013928.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Data management in a Twisted application</H1>
    <B>Robert Gravina</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Data%20management%20in%20a%20Twisted%20application&In-Reply-To="
       TITLE="[Twisted-Python] Data management in a Twisted application">robert at gravina.com
       </A><BR>
    <I>Sat Sep  2 05:20:19 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="013924.html">[Twisted-Python] strports.service, ssl and forcing client certs
</A></li>
        <LI>Next message: <A HREF="013928.html">[Twisted-Python] Re: twisted rpm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13927">[ date ]</a>
              <a href="thread.html#13927">[ thread ]</a>
              <a href="subject.html#13927">[ subject ]</a>
              <a href="author.html#13927">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Twisted and Divmod lists,

Sorry about the cross posting here - this is mainly a Twisted  
question but it involves Divmod Axiom a little too.

I'm looking for some advice about the best way to implement data  
management in my application. The way I see it, there is a &quot;client  
does almost everything&quot; approach, and &quot;server does almost everything&quot;  
approach. I'd currently using the former, but I'd like to hear some  
opinions about switching to the latter, or if there is a better  
approach you can think of.

Here are the approaches as I see them:

---

1) Client does almost everything approach

When the user logs on they get a Cacheable, which contains a list of  
Copyable objects that they will be able to add/edit/delete. These  
objects are quite complex (have list of other objects etc.). There is  
a main screen which lists the objects details.

The user can select a row, and they get a form where that can edit  
all the various attributes (obviously much more than is displayed on  
the list on the main screen), and save it to the server. The server  
calls an update method which essentially copies across all the  
attributes to the server-side Axiom Item instance which it  
represents . Using the Cacheable previously mentioned, it notifies  
all clients that an object has been updated and sends them this  
updated object. Adding new objects works in a similar way.

Problems arise with things like delete - I'd really need to set a  
flag on the server-side object when someone has it open, so that I  
can inform other users they can't delete it.

At some point I'd like to implement searching on the main interface,  
so the users can filter their list of objects. This would require me  
to build up boolean search criteria and roll my own search using the  
lists of objects.

2) Sever does almost everything

When the user logs on they get a Cacheable again, but this time the  
list is just a summary of the objects attributes, enough to populate  
the main screen list. When the user edits a row, the client requests  
the Cacheable from the server it represents (not a Copyable anymore).  
When they save, they sent the Cacheable back to the server (is this  
possible I wonder?) and copy accross all the data like before, and  
update the clients by sending them new summary data for that object  
(but not the object itself). I hope, it's possible to stop observing  
the object too.  That way, on the server I could maintain a list of  
who has the object open at the moment.

For searching, now that all the objects live on the server I could  
send my boolean search criteria and use Axiom's search facilities to  
so a proper database search. This saves my rolling me own.

Also, another bonus of this approach is if Axiom one day supports  
Live Queries (maybe I can help implement this when I get the bulk of  
this app done) I can update the clients when their query results  
changes!

---

However, it's expected the users will be searching often, so there's  
something to be said about having all the data close at hand on the  
client. Obviously, this has drawbacks too. Aside from having to  
implement my own search, I'm worried this might mean having thousands  
of objects locally might be a memory hog (but premature optimisation  
is the root of all evil, so I'll worry about this later). The search  
might by faster since there's no need to ask the server to do it, but  
since server-side search is probably going to be much faster than my  
client side search, it's hard to estimate which will be faster.

Anyway, I hope the issues here and my implementation makes sense. I'm  
torn between which approach to take, and I'd really appreciate some  
advice.

Robert




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013924.html">[Twisted-Python] strports.service, ssl and forcing client certs
</A></li>
	<LI>Next message: <A HREF="013928.html">[Twisted-Python] Re: twisted rpm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13927">[ date ]</a>
              <a href="thread.html#13927">[ thread ]</a>
              <a href="subject.html#13927">[ subject ]</a>
              <a href="author.html#13927">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
