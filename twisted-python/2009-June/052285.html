<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] inlineCallbacksDecorator
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20inlineCallbacksDecorator&In-Reply-To=%3C18989.28745.400512.674702%40jon.es%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="052284.html">
   <LINK REL="Next"  HREF="052276.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] inlineCallbacksDecorator</H1>
    <B>Terry Jones</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20inlineCallbacksDecorator&In-Reply-To=%3C18989.28745.400512.674702%40jon.es%3E"
       TITLE="[Twisted-Python] inlineCallbacksDecorator">terry at jon.es
       </A><BR>
    <I>Mon Jun  8 14:10:49 MDT 2009</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="052284.html">[Twisted-Python] inlineCallbacksDecorator
</A></li>
        <LI>Next message (by thread): <A HREF="052276.html">[Twisted-Python] Weekly Bug Summary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#52285">[ date ]</a>
              <a href="thread.html#52285">[ thread ]</a>
              <a href="subject.html#52285">[ subject ]</a>
              <a href="author.html#52285">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;&gt;&gt;&gt;<i> &quot;Drew&quot; == Drew Smathers &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">drew.smathers at gmail.com</A>&gt; writes:
</I>Drew&gt; On Sat, Jun 6, 2009 at 9:41 PM, Terry Jones&lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">terry at jon.es</A>&gt; wrote:
&gt;&gt;<i> One inconvenience with inlineCallbacks is that you might have some kind
</I>&gt;&gt;<i> of processing you want done no matter how the function returns, or
</I>&gt;&gt;<i> wherever an error occurs. Two solutions here are 1) to put try/except
</I>&gt;&gt;<i> calls around your various yields, and/or to perhaps do something else
</I>&gt;&gt;<i> with various callbacks that might call defer.returnValue, or 2) expect
</I>&gt;&gt;<i> each caller of your method to deal with the result. I don't like the
</I>&gt;&gt;<i> first of those much (depending on the code), and don't like the second
</I>&gt;&gt;<i> at all.
</I>
Drew&gt; How does inlineCallbacks preclude you from adding &quot;processing you
Drew&gt; want done no matter how the function returns&quot; or currying callbacks?
Drew&gt; From my understanding of the problem, this is already solved by
Drew&gt; attaching callbacks/errbacks in the regular way:

Drew&gt; @inlineCallbacks
Drew&gt; def foo(a, b, c):
Drew&gt; ...
Drew&gt; foo(a, b, c).addBoth(cb, a, b, c)

Right, that's what I meant by the (2) in my paragraph. The reason that's
not always what you want is that there may be things foo needs to get done
before it returns, things that are best or can only be computed inside
foo. In that case you don't really want to make all your callers have to
add a callback to add functionality/logic that belongs inside foo.

Under normal circumstances you'd have code like this:

  def foo():
    d = someOtherFunc()
    d.addCallbacks(...)
    return d

or

  def foo():
    d = defer.Callback()
    # Set up some stuff that will fire d
    return d

so the deferred that comes back from foo is under control of foo and if
there's any logical last steps to be done to it, foo can easily add them.

But with inlineCallbacks, foo never has its hands on the deferred that will
be returned.  Yes, you could do:

  @inlineCallbacks
  def foo():
    try:
      #
      # All sorts of stuff, yielding deferreds
      #
    except ...:
      # yield somethingElse or raise something

But that's not so attractive, and it only deals with errbacks. To deal with
all returns, you could catch the undocumented _DefGen_Return, do your
processing and then re-raise it but that's even more ugly.  So I'm just
trying to offer a clean way to always get hold of the deferred and be able
to consistently process it using code in the same file (or class, given a
self) as foo.

Terry


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="052284.html">[Twisted-Python] inlineCallbacksDecorator
</A></li>
	<LI>Next message (by thread): <A HREF="052276.html">[Twisted-Python] Weekly Bug Summary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#52285">[ date ]</a>
              <a href="thread.html#52285">[ thread ]</a>
              <a href="subject.html#52285">[ subject ]</a>
              <a href="author.html#52285">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
