<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Advice on porting Python application to Twisted
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Advice%20on%20porting%20Python%20application%20to%20Twisted&In-Reply-To=%3CCAMYwhV%3D7UzcV2yJLBBRSyxgHJWCPRqdeo7gbtRMtLDCYj9LwMg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   
   <LINK REL="Next"  HREF="027393.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Advice on porting Python application to Twisted</H1>
    <B>Matthew Humphrey</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Advice%20on%20porting%20Python%20application%20to%20Twisted&In-Reply-To=%3CCAMYwhV%3D7UzcV2yJLBBRSyxgHJWCPRqdeo7gbtRMtLDCYj9LwMg%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Advice on porting Python application to Twisted">mhumphrey at gmail.com
       </A><BR>
    <I>Sun Sep  1 14:04:35 MDT 2013</I>
    <P><UL>
        
        <LI>Next message (by thread): <A HREF="027393.html">[Twisted-Python] Passing additional arguments to errback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27392">[ date ]</a>
              <a href="thread.html#27392">[ thread ]</a>
              <a href="subject.html#27392">[ subject ]</a>
              <a href="author.html#27392">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Tom -

Just wanted to thank you for your help. I got everything ported over to
Twisted on Friday, and the responsiveness of the web site is 10 times
better. Also the number of lines of (my) code declined, which is great.

Thanks much.



On Wed, Aug 28, 2013 at 6:40 AM, Tom Sheffler &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">tom.sheffler at gmail.com</A>&gt;wrote:

&gt;<i>
</I>&gt;<i> Hi Matthew -
</I>&gt;<i>
</I>&gt;<i> I have a couple of idioms I use for #2 and #3 in your message.  Here they
</I>&gt;<i> are.
</I>&gt;<i>
</I>&gt;<i> #2)
</I>&gt;<i>
</I>&gt;<i> For timer events, I create a function that when called, continuously
</I>&gt;<i> schedules itself again in the reactor, does some work for the current
</I>&gt;<i> tick, and then exits.  I've used this down to 1-second intervals.  If
</I>&gt;<i> you're looking for sub-millisecond level timing, this may not be
</I>&gt;<i> appropriate for your application.
</I>&gt;<i>
</I>&gt;<i> def timerFunction(reactor):
</I>&gt;<i>
</I>&gt;<i>     reactor.callLater(1.0, timerFunction, reactor)
</I>&gt;<i>
</I>&gt;<i>     # do the work for this time tick
</I>&gt;<i>     # etc etc
</I>&gt;<i>
</I>&gt;<i>     return
</I>&gt;<i>
</I>&gt;<i> # Somewhere in main do this to kick it off
</I>&gt;<i> from twisted.internet import reactor
</I>&gt;<i> timerFunction(reactor)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> #3)
</I>&gt;<i>
</I>&gt;<i> For subprocesses, I like to create a custom protocol for each type of
</I>&gt;<i> sub-command I am calling.  I also like to create an object to manage
</I>&gt;<i> the process, its arguments, its results and its temp files.  The idiom
</I>&gt;<i> below is suitable for calling a subprocess that accepts a small amount
</I>&gt;<i> of buffered data on stdin, produces some output on stdout, and logs its
</I>&gt;<i> stderr.
</I>&gt;<i>
</I>&gt;<i> Be careful examining the value of reason.value.exitCode in
</I>&gt;<i> processExited.  The twisted docs show printing the exitCode as a &quot;%d&quot;,
</I>&gt;<i> but sometimes the value is None --- if the process was terminated by a
</I>&gt;<i> signal.  The mere printing of the value with &quot;%d&quot; will then trigger an
</I>&gt;<i> exception!
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Here's my idiom:
</I>&gt;<i>
</I>&gt;<i> class FooprocProtocol(protocol.ProcessProtocol):
</I>&gt;<i>
</I>&gt;<i>     def __init__(self, foomgr):
</I>&gt;<i>         # the object managing my subprocess
</I>&gt;<i>         self.foomgr = foomgr
</I>&gt;<i>
</I>&gt;<i>         # my stdout data
</I>&gt;<i>         self.data = &quot;&quot;
</I>&gt;<i>
</I>&gt;<i>     def connectionMade(self):
</I>&gt;<i>         # Pump input data in using this, and then close stdin
</I>&gt;<i>         log.msg(&quot;connectionMade!&quot;)
</I>&gt;<i>         # self.transport.write(&quot;...&quot;)  # if there is any data to shove
</I>&gt;<i> into stdin
</I>&gt;<i>         self.transport.closeStdin()
</I>&gt;<i>
</I>&gt;<i>     def outReceived(self, data):
</I>&gt;<i>         # collect up our stdout
</I>&gt;<i>         log.msg(&quot;outReceived! with %d bytes!&quot; % len(data))
</I>&gt;<i>         self.data = self.data + data
</I>&gt;<i>
</I>&gt;<i>     def errReceived(self, data):
</I>&gt;<i>         # echo stderr messages to log with a marker
</I>&gt;<i>         log.msg(&quot;&gt;%s&quot; % data)
</I>&gt;<i>
</I>&gt;<i>     def inConnectionLost(self):
</I>&gt;<i>         print &quot;inConnectionLost! stdin is closed! (we probably did it)&quot;
</I>&gt;<i>
</I>&gt;<i>     def outConnectionLost(self):
</I>&gt;<i>         log.msg(&quot;outConnectionLost! The child closed their stdout!&quot;)
</I>&gt;<i>
</I>&gt;<i>     def errConnectionLost(self):
</I>&gt;<i>         log.msg(&quot;errConnectionLost! The child closed their stderr.&quot;)
</I>&gt;<i>
</I>&gt;<i>     def processExited(self, reason):
</I>&gt;<i>         log.msg(&quot;processExited:%s:&quot; % reason)
</I>&gt;<i>         exitcode = reason.value.exitCode         # an integer or None
</I>&gt;<i>
</I>&gt;<i>         # do some work upon processExit potentially make a decision on
</I>&gt;<i> exitcode ...
</I>&gt;<i>
</I>&gt;<i>         log.msg(&quot;processExited:%s&quot; % exitcode)
</I>&gt;<i>
</I>&gt;<i>     def processEnded(self, reason):
</I>&gt;<i>         print &quot;processEnded, status %s&quot; % (reason.value.exitCode,)
</I>&gt;<i>
</I>&gt;<i>         # process the data in the process manager
</I>&gt;<i>         exitcode = reason.value.exitCode         # might be non-numeric
</I>&gt;<i>         result = self.foomgr.processData(exitcode)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> # The main job of the Process Manager is to build the command list and
</I>&gt;<i> # process the results.  It gives us a handy place to encapsulate this
</I>&gt;<i> # logic.
</I>&gt;<i>
</I>&gt;<i> class FooprocManager(object):
</I>&gt;<i>
</I>&gt;<i>     CMD = &quot;/usr/local/foocmd&quot;
</I>&gt;<i>
</I>&gt;<i>     def __init__(self, arg1, arg2, arg3)
</I>&gt;<i>
</I>&gt;<i>         # create a Deferred to fire when we succeed or fail
</I>&gt;<i>         self.d = Deferred()
</I>&gt;<i>
</I>&gt;<i>         # build our command argument list as appropriate for our command
</I>&gt;<i>         self.cmdargs = self.build_cmd_args(arg1, arg2, arg3)
</I>&gt;<i>
</I>&gt;<i>         # define places to store the transport, pid and other things
</I>&gt;<i>         self.ptransport = None
</I>&gt;<i>         self.pid = None
</I>&gt;<i>
</I>&gt;<i>     def build_cmd_args(self, arg1, arg2, arg3):
</I>&gt;<i>
</I>&gt;<i>         # in my projects, this method has become fairly involved as it
</I>&gt;<i> creates
</I>&gt;<i>         # tmp files and builds potentially complicated argument lists.
</I>&gt;<i>
</I>&gt;<i>         arglist = [self.CMD, arg1, arg2, arg3]
</I>&gt;<i>         return arglist
</I>&gt;<i>
</I>&gt;<i>     def run(self):
</I>&gt;<i>
</I>&gt;<i>         # instantiate a protocol connected to this manager
</I>&gt;<i>         pp = FooprocProtocol(self)
</I>&gt;<i>
</I>&gt;<i>         # spawn the process, save the PID
</I>&gt;<i>         self.ptransport = reactor.spawnProcess(pp, self.CMD, self.cmdargs,
</I>&gt;<i> { })
</I>&gt;<i>         self.pid = self.ptransport.pid
</I>&gt;<i>
</I>&gt;<i>     def processData(exitcode):
</I>&gt;<i>
</I>&gt;<i>         # in my projects, this method opens up result files, parses
</I>&gt;<i> results,
</I>&gt;<i>         # moves things around, deletes tmp files, etc.
</I>&gt;<i>
</I>&gt;<i>         # return the result that we ran this subprocess for
</I>&gt;<i>         return result
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> # Instantiate a new process manager and run it this way.
</I>&gt;<i>
</I>&gt;<i> mgr = FooprocManager(args ...)
</I>&gt;<i> d = mgr.run(args ...)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> =================
</I>&gt;<i> T
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20130901/a5611387/attachment.html">http://twistedmatrix.com/pipermail/twisted-python/attachments/20130901/a5611387/attachment.html</A>&gt;
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message (by thread): <A HREF="027393.html">[Twisted-Python] Passing additional arguments to errback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27392">[ date ]</a>
              <a href="thread.html#27392">[ thread ]</a>
              <a href="subject.html#27392">[ subject ]</a>
              <a href="author.html#27392">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
