<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Configuration, Final Spec
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Configuration%2C%20Final%20Spec&In-Reply-To=%3C0105130254560I.17572%40helix%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="032588.html">
   <LINK REL="Next"  HREF="032590.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Configuration, Final Spec</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Configuration%2C%20Final%20Spec&In-Reply-To=%3C0105130254560I.17572%40helix%3E"
       TITLE="[Twisted-Python] Configuration, Final Spec">glyph at twistedmatrix.com
       </A><BR>
    <I>Sun May 13 01:54:56 MDT 2001</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="032588.html">[Twisted-Python] Configuration, Final Spec
</A></li>
        <LI>Next message (by thread): <A HREF="032590.html">[Twisted-Python] configuration usecases
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32589">[ date ]</a>
              <a href="thread.html#32589">[ thread ]</a>
              <a href="subject.html#32589">[ subject ]</a>
              <a href="author.html#32589">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sunday 13 May 2001 00:31, you wrote:
&gt;<i> On Sat, 12 May 2001, Glyph Lefkowitz &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at twistedmatrix.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; In my humble (but correct) opinion, it is *always* bad API design to
</I>&gt;<i> &gt; force the caller to &quot;promise&quot; something.  (Sometimes, other design
</I>&gt;<i> &gt; concerns mitigate this decision, but I don't see one here.  However, I
</I>&gt;<i> &gt; have frequently joked about having a neon sign in my office, for design
</I>&gt;<i> &gt; discussions, that says &quot;IT IS NOT THE CALLER'S RESPONSIBILITY&quot; in
</I>&gt;<i> &gt; 10-foot-tall letters)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I would much rather see a .getParameters() -&gt; dict /
</I>&gt;<i> &gt; .setParameters(dict). It seems more symmetrical, and if you can &quot;promise&quot;
</I>&gt;<i> &gt; that (A) setParameters may be called some number of times and (B)
</I>&gt;<i> &gt; endParameters() will *always* be called afterwards, we can put that loop
</I>&gt;<i> &gt; into the config side of the code.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Any reasons why it can't be done this way?
</I>&gt;<i>
</I>&gt;<i> Yes. In the usual case, where you don't need a .endParameters(), then the
</I>&gt;<i> code will be *much* clearer. You also missed the place where I say
</I>&gt;<i> &quot;.endParameters() will not be called if it doesn't exist&quot;.
</I>&gt;<i> See axiom 4 -- certainly
</I>[snipped examples]

But if you declare setParameters as a member of the Configurable class, then 
you don't have to write every UI to deal with the possible existance or 
non-existance of endParameters.

I am strongly opposed to any API which requires validation on the caller's 
behalf, for several reasons.  A practical concern is that using an RPC like 
gloop (e.g. an asynchronous one) it is impossible to tell if the object you 
are calling &quot;has the attribute&quot; endParameters or not.  You just have to call 
it and hope for the best.

If setParameters is defined in Configurable (the default implementation being 
a 2-line loop which does setParameter and then endParameter) then the extra 
work you're talking about for the configurable author can be avoided.

Having an API which requires a garuantee on the caller's behalf (the &quot;caller&quot; 
in this case being the UI) in a language where exceptions are as common as in 
Python makes handling of errors somewhat tricky.  After all, if setting a 
bunch of parameters is a non-atomic operation, then what do you do when one 
of your parameters is invalid, and raises an exception?  Does endParameters 
still have to get called?

It seems to me that setParameters is an atomic operation, which should 
validate, then test.  validateParameters could be a method as well, to do 
extra validation if parameters are dependant upon each other.  However, you 
can then clearly say that setParameter may never raise an exception: if the 
call to validateParameters succeeds, but setParameter fails, then you are in 
a known-to-be-inconsistent state and can display an appropriate error 
message.  However, if some of your setParameter calls raise exceptions and 
others do not, should endParameters be called anyway?  Does every UI need to 
handle exceptions itself?

&gt;<i> &gt; Another interesting open question (although not one I'm sure this code
</I>&gt;<i> &gt; has to address) is how to get the respective configuration interfaces to
</I>&gt;<i> &gt; represent object identity.  (e.g. I want to mount the *same* web resource
</I>&gt;<i> &gt; on /foo, on /bar)
</I>&gt;<i>
</I>&gt;<i> This code isn't the one that should address it -- this is UI's
</I>&gt;<i> responsibility. Take *another* look at the way Zope does it.
</I>
Zope confuses the hell out of me, both in the UI and the code :)... but I 
agree that this code probably shouldn't have to deal with that.

&gt;<i> &gt; However, I prefer the register(klass) way, both for clarity and
</I>&gt;<i> &gt; efficiency. Explicit is better than implicit.
</I>&gt;<i>
</I>&gt;<i> Indeed, I've decided I agree, for a different reason -- we do not want
</I>&gt;<i> spurious options for the user.
</I>
Yay, agreement! :)

&gt;<i> I've thought about it, and decided against it -- since the UI needs to know
</I>&gt;<i> so much about the validation anyway, I prefer to putting the knowledge in
</I>&gt;<i> the UI. Sure, when we realized what is convinient for two UIs, we can have
</I>&gt;<i> some nice functions to help UIs -- but *outside* the Parameter class.
</I>&gt;<i> The classical example is that the UI might need to write the validation
</I>&gt;<i> code in JavaScript, for DHTML forms. Surely, a method written in Python
</I>&gt;<i> won't help...
</I>
It's not to help out the UIs, it's to prevent setParameter from being called 
incorrectly.  There are several points of failure here --

 * the user typed something incorrect (presumably, your JavaScript example)
 * something bad came from the transport (WebUI.validate)
 * there is a bug in/bad data from the UI (Parameter.validate)
 * there is a bug in the configurable (exceptions caught by Configurable on 
setParameter)

and I think each one has to be treated differently.

&gt;<i> &gt; On the whole this looks like a good proposal, although I'm still not
</I>&gt;<i> &gt; entirely sure what the final end-user experience of configuration will
</I>&gt;<i> &gt; look like.
</I>&gt;<i>
</I>&gt;<i> Well, I've already gave an example of what it would look like with the
</I>&gt;<i> command line. Mutatis-mutandis, we can pretty much imagine how to translate
</I>&gt;<i> it into web-based. Of course, many options still remain, but I don't think
</I>&gt;<i> I care about UIs: I've specified enough information for the UI -- now
</I>&gt;<i> the UIs can compete. (We can have 10 different web-based UIs, and choose
</I>&gt;<i> among them)
</I>
It's for this reason that I'd like as much thought to be given to making UIs 
easy to write as to making Configurable objects easy to write.  I think I've 
changed my mind about Configurable not providing much functionality;  The 
Configurable and Parameter classes should encapsulate as much common behavior 
as possible.  (Although, I admit that there is probably not *much* common 
functionality.)  If they don't for some reason (and I am still not convinced 
any such reasons exist), the &quot;config&quot; module should at least contain it all, 
and as a core part of the interface, not as an additional utility library for 
GUIs.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     <A HREF="http://twistedmatrix.com/users/glyph">http://twistedmatrix.com/users/glyph</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="032588.html">[Twisted-Python] Configuration, Final Spec
</A></li>
	<LI>Next message (by thread): <A HREF="032590.html">[Twisted-Python] configuration usecases
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32589">[ date ]</a>
              <a href="thread.html#32589">[ thread ]</a>
              <a href="subject.html#32589">[ subject ]</a>
              <a href="author.html#32589">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
