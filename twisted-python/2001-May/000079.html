<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Configuration, Final Spec
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Configuration%2C%20Final%20Spec&In-Reply-To=E14yTt3-00078c-00%40darjeeling">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000078.html">
   <LINK REL="Next"  HREF="000080.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Configuration, Final Spec</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Configuration%2C%20Final%20Spec&In-Reply-To=E14yTt3-00078c-00%40darjeeling"
       TITLE="[Twisted-Python] Configuration, Final Spec">glyph at twistedmatrix.com
       </A><BR>
    <I>Sat May 12 19:03:15 EDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000078.html">[Twisted-Python] Configuration, Final Spec
</A></li>
        <LI>Next message: <A HREF="000080.html">[Twisted-Python] Configuration, Final Spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#79">[ date ]</a>
              <a href="thread.html#79">[ thread ]</a>
              <a href="subject.html#79">[ subject ]</a>
              <a href="author.html#79">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Saturday 12 May 2001 02:32, you wrote:
&gt;<i> Rewritten, standalone, spec
</I>
[ agreement with axioms ]

&gt;<i> OK, so what do we need to do about it?
</I>&gt;<i> Here's a rough proposition:
</I>&gt;<i>
</I>&gt;<i> the configurable *interface*, which will be a class, but not a class
</I>&gt;<i> people should inherit from, will contain the following methods:
</I>
IMHO, people *should* inherit from it, so that we can have some visibility on 
what implements it.  I agree that it should provide as little functionality 
as possible, however.

&gt;<i> .getParameters() --&gt; return a dictionary: name of parameter, Parameter
</I>&gt;<i> object .setParameter(name, answer) --&gt; notify the application that an
</I>&gt;<i> answer has been given to a particular question
</I>&gt;<i>                              It can throw an InvalidParameter exception
</I>&gt;<i> with a string for a reason. This is for
</I>&gt;<i>                              application-level verification. Note that
</I>&gt;<i>                              application-level verification is discouraged.
</I>&gt;<i> .endParameters() --&gt; the &quot;application&quot; promises that no methods of the
</I>&gt;<i> object will be called between a series of .setParameter()s and
</I>&gt;<i> .endParameters(). So, this means that if the UI got a bunch of answers, it
</I>&gt;<i> will call .setParameter() several times, and then .endParameters(). The UI
</I>&gt;<i> will *check* for this method's existance, and will not call it if it
</I>&gt;<i> doesn't exist. .setParent(parent) --&gt; if the object is created inside an
</I>&gt;<i> InterfaceProperty of some other object, module nested ArrayParameters and
</I>&gt;<i> DictParameters, .setParent will be called with that object, *if it exists*.
</I>
I don't understand this part of the design.

In my humble (but correct) opinion, it is *always* bad API design to force 
the caller to &quot;promise&quot; something.  (Sometimes, other design concerns 
mitigate this decision, but I don't see one here.  However, I have frequently 
joked about having a neon sign in my office, for design discussions, that 
says &quot;IT IS NOT THE CALLER'S RESPONSIBILITY&quot; in 10-foot-tall letters)

I would much rather see a .getParameters() -&gt; dict / .setParameters(dict).  
It seems more symmetrical, and if you can &quot;promise&quot; that (A) setParameters 
may be called some number of times and (B) endParameters() will *always* be 
called afterwards, we can put that loop into the config side of the code.

Any reasons why it can't be done this way?

&gt;<i> Parameter objects are meant to be open ended.
</I>&gt;<i> They can contain a default.
</I>&gt;<i>
</I>&gt;<i> Here is the general interface of the Question, that all objects conform
</I>&gt;<i> too:
</I>
Of the &quot;Parameter&quot;, I take it you mean? :)

&gt;<i> .hasValue() --&gt; boolean, whether the Parameter already contains an
</I>&gt;<i>                 value
</I>&gt;<i> .getValue() --&gt; will only work if .hasValue() is true, returns the answer
</I>&gt;<i> .setValue(val) --&gt; make .hasValue() true
</I>&gt;<i> .title --&gt; A string, the human-readable description of the property.
</I>&gt;<i>
</I>&gt;<i> Objects which can be created by the UI should have an initParameters
</I>&gt;<i> attribute which should be a sequence of Parameters, which correspond
</I>&gt;<i> to the mandatory arguments of the __init__ method.
</I>
Another interesting open question (although not one I'm sure this code has to 
address) is how to get the respective configuration interfaces to represent 
object identity.  (e.g. I want to mount the *same* web resource on /foo, on 
/bar)

&gt;<i> This leaves open the question of how classes register with the UI at all.
</I>&gt;<i> A possibly radical solution will be to have the UI scan through
</I>&gt;<i> sys.modules, and each class will be checked for the __implements__
</I>&gt;<i> attribute. A less radical option is to have a register(klass) function
</I>&gt;<i> which registers it with the UI. register() can be used from within the
</I>&gt;<i> module, if it is an active participant, or from within an importing module.
</I>
There is a third option -- make Configurable a metaclass :)

However, I prefer the register(klass) way, both for clarity and efficiency.  
Explicit is better than implicit.

&gt;<i> example:
</I>&gt;<i>
</I>&gt;<i> class Server: # note -- not inheriting from anything
</I>&gt;<i>
</I>&gt;<i>     initParameters = (StringParameter(&quot;Server Name&quot;), IntParameter(&quot;Port&quot;))
</I>&gt;<i>     def __init__(self, name, port):
</I>&gt;<i>         self.name, self.port = name, port
</I>&gt;<i>
</I>&gt;<i>     def getParameters(self):
</I>&gt;<i>         name = StringQuestion(&quot;Server Name&quot;)
</I>&gt;<i>         name.setValue(self.name)
</I>&gt;<i>         port = IntQuestion(&quot;Port&quot;)
</I>&gt;<i>         port.setValue(self.port)
</I>&gt;<i>         return {'port': port, 'name': name}
</I>&gt;<i>
</I>&gt;<i>     def setParameter(self, name, answer):
</I>&gt;<i>         # note: no need to use int(answer)
</I>&gt;<i>         # for port: an IntQuestion has an integer as a .getValue()
</I>&gt;<i>         setattr(self, name, answer)
</I>
Your code has a bug in it, which is a good example of why I like to actually 
inherit from interfaces :).  You don't define &quot;endParameters&quot;.

One more question -- why doesn't the Configurable interface class actually do 
some things, like data validation? It sounds like it'd be possible 
(isCorrectInput method on the Parameter classes, or somesuch...)

On the whole this looks like a good proposal, although I'm still not entirely 
sure what the final end-user experience of configuration will look like.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     <A HREF="http://twistedmatrix.com/users/glyph">http://twistedmatrix.com/users/glyph</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000078.html">[Twisted-Python] Configuration, Final Spec
</A></li>
	<LI>Next message: <A HREF="000080.html">[Twisted-Python] Configuration, Final Spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#79">[ date ]</a>
              <a href="thread.html#79">[ thread ]</a>
              <a href="subject.html#79">[ subject ]</a>
              <a href="author.html#79">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
