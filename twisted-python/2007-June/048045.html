<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] What is the best way to implement &quot;need more data&quot;	semantics?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20What%20is%20the%20best%20way%20to%20implement%20%22need%20more%20data%22%0A%09semantics%3F&In-Reply-To=%3Ccdb837ea0706140203g1c8a5995h7256d376746e3c7%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="048061.html">
   <LINK REL="Next"  HREF="048047.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] What is the best way to implement &quot;need more data&quot;	semantics?</H1>
    <B>甜瓜</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20What%20is%20the%20best%20way%20to%20implement%20%22need%20more%20data%22%0A%09semantics%3F&In-Reply-To=%3Ccdb837ea0706140203g1c8a5995h7256d376746e3c7%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] What is the best way to implement &quot;need more data&quot;	semantics?">littlesweetmelon at gmail.com
       </A><BR>
    <I>Thu Jun 14 03:03:32 MDT 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="048061.html">[Twisted-Python] twisted and performance
</A></li>
        <LI>Next message (by thread): <A HREF="048047.html">[Twisted-Python] SSL: wrong version number
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#48045">[ date ]</a>
              <a href="thread.html#48045">[ thread ]</a>
              <a href="subject.html#48045">[ subject ]</a>
              <a href="author.html#48045">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>My goal is writing a specific protocol. The data transfered between
client and server are mixed with text and binary. I override the
method dataReceived. When it get some new data, it will call a certain
parseFunc according to the current state of the protocol, such as:
Step 1: dataReceived will call parseGreetingMessage(), and then call
ReplyGreetingMessage()
Step 2: dataReceived will call parseHandShaking(), and then call
ReplyHandShaking()
Step 3: dataReceived will call parseSecurity(), and then call ReplySecurity()
....

However, in some cases, the data received from the server is not
completely fetched by the client, so the data passed to parseFunc will
be treated as incomplete, and parseFunc will try to return and wait
for more data. Currently, my code for doing this seems very ulgy ^_^.
Could you please give me some suggestions to make the implementation
of the &quot;need more data&quot; semantics more clearly and more easily?

The problem is that the message boundary in my protocol is not as
simple as LineReceiver. Each step, I should use different parse to
determine whether I get the whole data. For example:
parseErrorString: The data compose an leading 4byte integer size plus
following string characters. If the length of collected data is
shorter than (4 + size of string), it will be treated as incomplete.
parseBitmap: The data compose a bitmap header and following bitmap
data. If the length of collected data is shorter than (sizeof(header)
+ headerwidth*header.height*bits_per_pixel), it will be treated as
incomplete.

My method is:
parseFunc parses the data while testing the completeness. If
incomplete occrred, parseFunct return. When new data arrived, the
dataReceived method will call parseFunc again, and &quot;re-parse&quot; the
previous data as well as new data. However, sometimes, re-parse is
time consuming. I want to find a way to hold the result for
already-parsed data. Maybe it will be similar to &quot;generator&quot;:

# In class MyProtocol(protocol.Protocol):  pseudo-code
def parseFunc(...):
    # parse header ...
    if not completeness:
        yield   # need more data, go into data waiting state.
    # If new data arrived, dataReceived will be called, and then
    # call parseFunc again to continue parsing.
    # parse following data...
    if not completeness:
        yield   # need more data
    ....

def dataReceived(s):
    self.data += s
    self.parseFunc()

---
ShenLei


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="048061.html">[Twisted-Python] twisted and performance
</A></li>
	<LI>Next message (by thread): <A HREF="048047.html">[Twisted-Python] SSL: wrong version number
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#48045">[ date ]</a>
              <a href="thread.html#48045">[ thread ]</a>
              <a href="subject.html#48045">[ subject ]</a>
              <a href="author.html#48045">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
