<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Is a Viewable Cacheable a good idea?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Is%20a%20Viewable%20Cacheable%20a%20good%20idea%3F&In-Reply-To=%3CCALpq1pYg_nY8B5sW3Jv5HDS4vSzYqpFUAWjLKHpoQ0AvGviLeA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027711.html">
   <LINK REL="Next"  HREF="027729.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Is a Viewable Cacheable a good idea?</H1>
    <B>Flint</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Is%20a%20Viewable%20Cacheable%20a%20good%20idea%3F&In-Reply-To=%3CCALpq1pYg_nY8B5sW3Jv5HDS4vSzYqpFUAWjLKHpoQ0AvGviLeA%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Is a Viewable Cacheable a good idea?">grindizer at gmail.com
       </A><BR>
    <I>Wed Nov 13 04:32:11 MST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="027711.html">[Twisted-Python] Is a Viewable Cacheable a good idea?
</A></li>
        <LI>Next message: <A HREF="027729.html">[Twisted-Python] Is a Viewable Cacheable a good idea?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27714">[ date ]</a>
              <a href="thread.html#27714">[ thread ]</a>
              <a href="subject.html#27714">[ subject ]</a>
              <a href="author.html#27714">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

&gt;&gt;<i> Is simultaneously sub-classing Viewable and Cacheable a good idea?
</I>I am not sure it would work, at least not as you expect.
Viewable and Cacheable both implement a different version of jellyFor
(which will decides how object is seen on the other side of the connection).
If you sub-class both of them your resulting class will act either as a
cacheable or as a viewable depending on how you sub-class them -- at least
for the serialization part.

For your problem, It seems to me that you're trying to do 2 things:
1 - manage a server side object of stockroom(s)
2 - keep a copy of that object(s) synchronized in clients.

So may be (IMHO) you could have one viewable object acting like a
stockroom-manager that clients will (remote)call to make changes on the
server side stockroom-object,
And a cacheable stockroom-object, that you will sync with client.

That said, note that, there is no magic in the sync process when using
cacheable, you will have to propagate the change made to the cacheable
object yourself, by implementing the observe_ methods.
And when you make any changes to the server copy you will have to call
those observe_ methods on all clients, just as you said you would do in
your example.

Another option would be to stockroom object with copyable items and
implement getter method in the stockroom-manager, so clients would be able
to query only data that they need, when they need it, and then do not fire
all the sync stuff each time your stockroom is updates.
Besides cacheable object are said to be used for big object that do not
change frequently, which is not the case of your stockroom I guess.

Hope this help.
--
Nacim.






2013/11/12 Daniel Sank &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">sank.daniel at gmail.com</A>&gt;

&gt;<i> Suppose I want to make a networked stockroom program with perspective
</I>&gt;<i> broker. We have a user side client object,
</I>&gt;<i>
</I>&gt;<i> class Client(pb.Referenceable):
</I>&gt;<i>     def connect(self):
</I>&gt;<i>         # host, port, factory, and credentials come from elsewhere
</I>&gt;<i>         reactor.connectTCP(host, port, factory)
</I>&gt;<i>         d = self.factory.login(credentials, self)
</I>&gt;<i>         d.addCallback(self.connected)
</I>&gt;<i>
</I>&gt;<i>     def connected(self, perspective):
</I>&gt;<i>         if perspective:
</I>&gt;<i>             self.perspective = perspective
</I>&gt;<i>
</I>&gt;<i> and a &quot;corresponding&quot; server side User,
</I>&gt;<i>
</I>&gt;<i> class User(pb.Avatar):
</I>&gt;<i>     def __init__(self, name, server, mind):
</I>&gt;<i>         self.name = name
</I>&gt;<i>         self.server = server
</I>&gt;<i>         self.client = mind #This is a remote reference to a Client
</I>&gt;<i>
</I>&gt;<i>     def logout(self):
</I>&gt;<i>         ...logic...
</I>&gt;<i>
</I>&gt;<i> We have the IRealm implementer,
</I>&gt;<i>
</I>&gt;<i> @implementer(portal.IRealm)
</I>&gt;<i> class Server(object):
</I>&gt;<i>     &quot;&quot;&quot;I manage games and produce Avatars&quot;&quot;&quot;
</I>&gt;<i>     def __init__(self, loggingPath):
</I>&gt;<i>         self.users = {}
</I>&gt;<i>         self.stockrooms = set()
</I>&gt;<i>
</I>&gt;<i>     def requestAvatar(self, avatarId, mind, *interfaces):
</I>&gt;<i>         assert pb.IPerspective in interfaces
</I>&gt;<i>         user = self.users.setdefault(avatarId, User(avatarId, self, mind))
</I>&gt;<i>         return pb.IPerspective, user, user.logout
</I>&gt;<i>
</I>&gt;<i> and finally we have the Stockroom
</I>&gt;<i>
</I>&gt;<i> class Stockroom(object):
</I>&gt;<i>     ...logic...
</I>&gt;<i>
</I>&gt;<i> Now I'd like for my Clients to be able to remove/add items to the
</I>&gt;<i> stockroom. Using only the code above I'd have to add perspective_*
</I>&gt;<i> methods to the User. These methods would direct the Client's intent to
</I>&gt;<i> the appropriate Stockroom. Changes made to the Stockroom would then
</I>&gt;<i> have to be announced to any interested Clients by invoking the
</I>&gt;<i> appropriate Users' mind property.
</I>&gt;<i>
</I>&gt;<i> This seems very awkward. I'd rather just have the Stockrooms be
</I>&gt;<i> Viewable so that Clients can invoke methods on them directly. If the
</I>&gt;<i> Stockroom were _also_ Cacheable then changes on a Stockroom would
</I>&gt;<i> automatically propagate to the client process.
</I>&gt;<i>
</I>&gt;<i> Is simultaneously sub-classing Viewable and Cacheable a good idea?
</I>&gt;<i>
</I>&gt;<i> Am I thinking about this properly?
</I>&gt;<i>
</I>&gt;<i> Regards and thanks in advance,
</I>&gt;<i> Daniel Sank
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Department of Physics
</I>&gt;<i> Broida Hall
</I>&gt;<i> University of California
</I>&gt;<i> Santa Barbara, CA 93117
</I>&gt;<i> (805)893-3899
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20131113/cceb234c/attachment.html">http://twistedmatrix.com/pipermail/twisted-python/attachments/20131113/cceb234c/attachment.html</A>&gt;
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027711.html">[Twisted-Python] Is a Viewable Cacheable a good idea?
</A></li>
	<LI>Next message: <A HREF="027729.html">[Twisted-Python] Is a Viewable Cacheable a good idea?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27714">[ date ]</a>
              <a href="thread.html#27714">[ thread ]</a>
              <a href="subject.html#27714">[ subject ]</a>
              <a href="author.html#27714">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
