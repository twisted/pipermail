<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Could Service.startService return a Deferred?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Could%20Service.startService%20return%20a%20Deferred%3F&In-Reply-To=%3C20131127192018.6892.1747918954.divmod.xquotient.22%40top%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="060246.html">
   <LINK REL="Next"  HREF="060253.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Could Service.startService return a Deferred?</H1>
    <B>exarkun at twistedmatrix.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Could%20Service.startService%20return%20a%20Deferred%3F&In-Reply-To=%3C20131127192018.6892.1747918954.divmod.xquotient.22%40top%3E"
       TITLE="[Twisted-Python] Could Service.startService return a Deferred?">exarkun at twistedmatrix.com
       </A><BR>
    <I>Wed Nov 27 12:20:18 MST 2013</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="060246.html">[Twisted-Python] Could Service.startService return a Deferred?
</A></li>
        <LI>Next message (by thread): <A HREF="060253.html">[Twisted-Python] Could Service.startService return a Deferred?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#60247">[ date ]</a>
              <a href="thread.html#60247">[ thread ]</a>
              <a href="subject.html#60247">[ subject ]</a>
              <a href="author.html#60247">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 06:00 pm, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">peter.westlake at pobox.com</A> wrote:
&gt;<i>On Wed, Nov 27, 2013, at 17:13, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">exarkun at twistedmatrix.com</A> wrote:
</I>&gt;&gt;<i>On 02:58 pm, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">peter.westlake at pobox.com</A> wrote:
</I>&gt;&gt;<i>... So would it be possible for
</I>&gt;&gt;<i> &gt;t.a.s.Service.startService
</I>&gt;&gt;<i> &gt;to be allowed to return a Deferred? Then the next service would only 
</I>&gt;&gt;<i>be
</I>&gt;&gt;<i> &gt;started up when the Deferred fired.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Probably not.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>There is some discussion on
</I>&gt;&gt;<i>&lt;<A HREF="https://twistedmatrix.com/trac/ticket/5941">https://twistedmatrix.com/trac/ticket/5941</A>&gt;.
</I>&gt;<i>
</I>&gt;<i>That's helpful, thanks. I hadn't realized that startService was called
</I>&gt;<i>before the reactor started.
</I>&gt;<i>
</I>&gt;<i>Instead, I've passed in a Deferred to each service that needs to wait.
</I>&gt;<i>How does this look?
</I>&gt;<i>
</I>&gt;<i># -*- mode: python -*-
</I>&gt;<i>from twisted.application import service
</I>&gt;<i>from twisted.internet import defer, reactor
</I>&gt;<i>from twisted.internet.task import deferLater
</I>&gt;<i>
</I>&gt;<i>application = service.Application('Dependencies')
</I>&gt;<i>
</I>&gt;<i>def report(error):
</I>&gt;<i>    print 'ERROR', error
</I>&gt;<i>    reactor.stop()
</I>&gt;<i>
</I>&gt;<i>class Runner(service.Service):
</I>&gt;<i>    def __init__(self, baton):
</I>&gt;<i>        self.baton = baton
</I>&gt;<i>
</I>&gt;<i>    def startService(self):
</I>&gt;<i>        print 'startService', self.name, reactor.running
</I>&gt;<i>        self.baton.addCallback(lambda ignore:deferLater(reactor, 1.0,
</I>&gt;<i>        self.realStartService))
</I>&gt;<i>        self.baton.addErrback(report)
</I>
I'd be concerned with the state of `Runner` at this point in the 
process.

What happens if the application gets shut down while that `deferLater` 
is still pending?

`stopService` has a harder job because it might need to deal with a 
service that is partially initialized or a service that is completely 
initialized (and &quot;partially initialized&quot; may cover a multitude of 
different states depending on the complexity of your service).
&gt;<i>
</I>&gt;<i>    def realStartService(self):
</I>&gt;<i>        print 'realStartService', self.name, reactor.running
</I>&gt;<i>
</I>&gt;<i>baton = defer.succeed('pass me to each service')
</I>&gt;<i>
</I>&gt;<i>foo = Runner(baton)
</I>&gt;<i>foo.setName('foo')
</I>&gt;<i>foo.setServiceParent(application)
</I>&gt;<i>
</I>&gt;<i>bar = Runner(baton)
</I>&gt;<i>bar.setName('bar')
</I>&gt;<i>bar.setServiceParent(application)
</I>
What about something like this instead?

  @implementer(IService)
  class Runner(object):
      ...
      @classmethod
      def loadFromWhatever(cls, name):
          return deferLater(reactor, Runner, name)

      def __init__(self, name):
          self.name = name

      def startService(self):
          self.running = True
          print 'realStartService', self.name, reactor.running

  def parent(service):
      application.setServiceParent(service)

  loading = Runner.initializeFromWhatever(&quot;foo&quot;)
  loading.addCallback(parent)
  loading.addCallback(lambda ignored: 
Runner.initializeFromWhatever(&quot;bar&quot;))
  loading.addCallback(parent)
  loading.addErrback(stopTheReactorOrWhatever)

The advantage I see of this approach is that a `Runner` never exists in
the service hierarchy until it is fully initialized, started, and 
running.

If a `Runner` is only partially ready and the process shuts down then 
its `stopService` method isn't called because it's not part of the 
service hierarchy.

I could definitely imagine a library to help with this kind of thing. 
For example, perhaps you want the above encapsulated as:

  asynchronouslySetUpServices(application, [
      lambda: Runner.initializeFromWhatever(&quot;foo&quot;),
      lambda: Runner.initialifrFromWhatever(&quot;bar&quot;)])

And maybe then you want to add in some logic so that if the application 
gets shut down while some things are still being initialized then you 
cancel their Deferred.  Then you have good cleanup support for the 
uninitialized case - without complicating `stopService` (the cleanup 
logic is isolated in the implementation of Deferred cancellation where 
it belongs - eg, with this `deferLater`-based asynchronousness it's 
alreay present since deferLater implements cancellation already).

Jean-Paul


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="060246.html">[Twisted-Python] Could Service.startService return a Deferred?
</A></li>
	<LI>Next message (by thread): <A HREF="060253.html">[Twisted-Python] Could Service.startService return a Deferred?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#60247">[ date ]</a>
              <a href="thread.html#60247">[ thread ]</a>
              <a href="subject.html#60247">[ subject ]</a>
              <a href="author.html#60247">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
