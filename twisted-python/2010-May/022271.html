<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] major changes, release engineering,	and learning 	cost
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20major%20changes%2C%20release%20engineering%2C%0A%09and%20learning%20%09cost&In-Reply-To=7A3FDB76-0666-4827-B742-DEACDD9345EB%40twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022266.html">
   <LINK REL="Next"  HREF="022272.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] major changes, release engineering,	and learning 	cost</H1>
    <B>Laurens Van Houtven</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20major%20changes%2C%20release%20engineering%2C%0A%09and%20learning%20%09cost&In-Reply-To=7A3FDB76-0666-4827-B742-DEACDD9345EB%40twistedmatrix.com"
       TITLE="[Twisted-Python] major changes, release engineering,	and learning 	cost">lvh at laurensvh.be
       </A><BR>
    <I>Thu May 27 16:27:13 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="022266.html">[Twisted-Python] major changes, release engineering,	and learning cost
</A></li>
        <LI>Next message: <A HREF="022272.html">[Twisted-Python] major changes, release engineering,	and learning cost
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22271">[ date ]</a>
              <a href="thread.html#22271">[ thread ]</a>
              <a href="subject.html#22271">[ subject ]</a>
              <a href="author.html#22271">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>For clarity: I think Launchpad replacing Trac is a good thing. I realize
that's a huge ordeal. However, I don't think the basic ideas are so
different that it'd be impossible. As discussed on IRC, the main
downside (aka why we can't do it right now) is lack of notifications, so
it's hard to integrate stuff like buildbot yet, but that's being worked
on.

The idea I'm proposing is probably doable without Launchpad, but it's
definitely much harder without bzr. Mixing bzr and svn, might work, but
the developers definitely need to be using bzr because branching really
can't be a pain for it to work.

I have diagrammed the quantum-transmogrifier example that I tried to
explain in the last email.

<A HREF="http://bit.ly/aA20Qs">http://bit.ly/aA20Qs</A>

On Thu, May 27, 2010 at 7:02 AM, Glyph Lefkowitz
&lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at twistedmatrix.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> On May 26, 2010, at 5:41 AM, Laurens Van Houtven wrote:
</I>&gt;<i>
</I>&gt;<i> So, while I can definitely sympathize with a certain animosity towards
</I>&gt;<i> trac, and I can appreciate the goals and sensibilities of launchpad, I
</I>&gt;<i> will probably flat-out veto any required / process-driven usage of
</I>&gt;<i> Launchpad blueprints. Bugs, features, enhancements, etc, are all units
</I>&gt;<i> of work that need to be tracked, and it's better to have one kind of
</I>&gt;<i> crummy interface for tracking _everything_ than three interfaces, even
</I>&gt;<i> three good interfaces, for tracking little bits stuff in different
</I>&gt;<i> ways according to arbitrary distinctions. (As someone recently opined
</I>&gt;<i> to me, Blueprints are a giant complicated interface for pasting the
</I>&gt;<i> URL to a Google Wave into a text field. We might as well skip the text
</I>&gt;<i> field and just link straight to the conversation from a Trac ticket.)
</I>
(was it dash? ;-))

I understand your point of view, but I don't think blueprints are that
bad. I'm not saying blueprints aren't fat pointers to URLs, but I just
don't think that would necessarily make them less useful. As far as
arbitrary distinctions go: I'd think new features are blueprints, and
bugs are bugs. It's not very arbitrary in my mind -- which is just a
different way of saying &quot;I can't think of any grey areas&quot;. (Yes, this
means there are very few blueprints. I think that's a good thing :))

I think I understand the reasoning behind your opinion from a project
lead/release management/developer perspective: both bugs and blueprints
are jobs that still need to be done, similarly tracked for releases, and
they both take developer time to be resolved. I don't think this
reasoning is wrong.

For both users and developers, I think thinking of bugs and new features
as separate things makes sense. Furthermore, Launchpad has stuff like
milestones and targeted releases, so I don't think the
three-good-interfaces thing is really that prohibitive. Personally, I
don't feel that split is bad for developers either.

(FWIW: yes, I think Launchpad's Whiteboard feature needs extending and
it probably needs a comment system. And once you do that, you might
indeed wonder what the difference with bugs still is -- but I'm not
arguing Launchpad is perfect, I'm arguing it's better than Trac ;-))

Even if blueprints are non-negotiable, I think most of what I said could
just as well be applied to Launchpad bugs: you'd treat Launchpad bugs
like you treat Trac tickets now. Merge proposals and the reviews they
come with are properties of branches in Launchpad, and not of blueprints
or bugs (IIRC). So, feel free to scrap blueprints, it's not that big a
deal :)

&gt;<i> lp:~lvh... isn't a verb. What do you do with that string? :)
</I>
Sorry, bad emacs VC mode habit. I meant 'create a branch lp:~lvh/...'

&gt;<i> &gt; and it turns out FTL travel is really really hard so I need two
</I>&gt;<i> &gt; smaller branches lp:~lvh/twisted/quantum-transmogrification-tunnels
</I>&gt;<i> &gt; and lp:~lvh/twisted/quantum-transmogrification-ansible. Both are
</I>&gt;<i> &gt; good, so they get put back into
</I>&gt;<i> &gt; ~lvh/twisted/quantum-transmogrification-ftl-travel.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Each review would verify that all children (if any) have also been
</I>&gt;<i> &gt; reviewed. So, the final review is pretty small, as suggested :-)
</I>&gt;<i>
</I>&gt;<i> The review wouldn't verify that the parent had been reviewed, though.
</I>&gt;<i> If you started this process by writing a bunch of code in the q-t-f-t
</I>&gt;<i> branch, *that* code would never have been reviewed; unless q-t-f-t
</I>&gt;<i> needs to be reviewed in its entirety before landing on trunk. Which is
</I>&gt;<i> precisely what I'm trying to avoid.
</I>
Yeah, this is sort-of fixed in practice by my point (1) below, but
requires some conscious effort and discipline from the developer. An
alternative idea to just having merges of reviewed branches in q-t,
would be to have the review of q-t be &quot;all of the commits that aren't
reviewed merges from other branches&quot;. That sounds really, really
annoying, so I'd rather do it the first way. Specifically, that means
&quot;don't do that, branch early and often, merging is easy but branching
halfway is confusing&quot;.

&gt;<i>
</I>&gt;<i> &gt; This does not limit a developer's freedom to branch at will, because
</I>&gt;<i> &gt; code review is opt-in (merge proposal), not opt-out. If you don't do
</I>&gt;<i> &gt; it, that code in that branch isn't covered by a previous review, and
</I>&gt;<i> &gt; must be reviewed later.
</I>&gt;<i>
</I>&gt;<i> This strikes me as placing a pretty nasty burden on the reviewer. The
</I>&gt;<i> reviewer has to figure out if there are any commits that went only to
</I>&gt;<i> the integration branch, isolate them, review them, get that branch
</I>&gt;<i> into an OK-it's-reviewed state, while meanwhile other developers might
</I>&gt;<i> be committing stuff to that branch and changing its contents, both
</I>&gt;<i> from regular working commits and from reviewed merges. It sounds like
</I>&gt;<i> a nightmare. Maybe bzr makes it easier than it sounds, but it sounds
</I>&gt;<i> bad enough that even a big improvement would still be pretty bad ;).
</I>
Again, I think point (1) addresses this: yes, but not if you promise to
make branches off your first branch off trunk (wording is a bit off, but
look at the diagram for clarification). That way they only have merges
from other branches, and those merges are reviewed.

As long as you don't do that, and keep your development out of review
branches, there is no problem. That sounds like a very big caveat, but
we have found it to work in practice. I'm not sure why, but one
explanation would be that people sometimes hugely underestimate how much
time something takes to develop, but guesstimates about the complexity
of a particular feature tend to be much more accurate. Even if that goes
awry, there is quite some leeway here: the complexity of a review branch
has to really completely get out of hand before it wouldn't be okay for
it to be one code review anymore -- up to the point that it probably
wouldn't pass review anymore under the old design.

An added bonus is that there is reduced incentive to keep piling on
features in a single review branch, because all of it has to be
reviewable in one go. I think this is a good idea, because it encourages
proper planning and up-front specs of which features you want to
implement. This effect might be stronger in a small, tight development
team such as in a small development house than with a distributed
development team like Twisted (screwing over your reviewer just means
he'll be less friendly to you next time you have to do reviews, and you
still have to work with these people later on), but I'm going to be
optimistic and pretend we're all nice people :-)

&gt;<i> &gt; How exactly code review coverage would work is somewhat of an open
</I>&gt;<i> &gt; question and it's the obvious failure in this system. We use it in
</I>&gt;<i> &gt; production and it turns out to not be a problem, because people
</I>&gt;<i> &gt; always end up doing two things:
</I>&gt;<i>
</I>&gt;<i> Who is &quot;we&quot;? What is &quot;production&quot;? Are you talking about Twisted or a
</I>&gt;<i> hypothetical project which uses Twisted, or a fork of Twisted on
</I>&gt;<i> Launchpad? Is this a hypothetical project or a real proejct? I am
</I>&gt;<i> super confused.
</I>
This is a real project that uses (amongst other things) Twisted.


&gt;<i> &gt; 1) always branch at least once from the first branch off trunk (so
</I>&gt;<i> &gt; branch off lp:~lvh/twisted/quantum-transmogrification). Net result:
</I>&gt;<i> &gt; lp:~lvh/twisted/quantum-transmogrification only introduces code in
</I>&gt;<i> &gt; the form of merges.
</I>&gt;<i>
</I>&gt;<i> That's pretty much what I'm proposing, except I don't actually care
</I>&gt;<i> whether they're merges or patches or individual commits, as long as
</I>&gt;<i> they've cycled through code-review properly.
</I>
Right, but wouldn't it then be hard for reviewers to know what has been
reviewed and what hasn't?

&gt;<i>
</I>&gt;<i> &gt; 2) always do code review on branches being merged into your first
</I>&gt;<i> &gt; branch off trunk (so everything merged into
</I>&gt;<i> &gt; lp:~lvh/twisted/quantum-transmogrification has to be reviewed
</I>&gt;<i> &gt; already)
</I>&gt;<i>
</I>&gt;<i> And this is what we already do.
</I>
Huh? I thought it got reviewed when it was put up for review for
suggested merging into trunk. My suggestion is the same thing, except
s/trunk/q-t/. There's a second review when q-t itself gets merged into
trunk, but as long as those are all merges of reviewed branches, that
review is trivial. See diagram, points 16 and 17.

&gt;<i> &gt; Note that our merges into trunk are automagic.
</I>&gt;<i>
</I>&gt;<i> (Again, who is &quot;we&quot;, and by what mechanism are they automated? Are you
</I>&gt;<i> proposing that we do this, or are you stating that some other people
</I>&gt;<i> do?)
</I>
The aforementioned project using Twisted. I'd prefer not going into a
lot of detail, maybe we should forget about it for purposes of keeping
the discussing focused.

Perhaps what _can_ be taken home from this for purposes of the
discussion is that this way of organizing branches does actually work
for at least one development team somewhere. I'm not sure to what extent
this carries over to Twisted. All I know is that the distributedness of
Twisted development isn't much of a problem, since I had no issues and I
spent 99% working from home/university.

&gt;<i> &gt; If it's merged into a direct branch off of trunk and it satisfies
</I>&gt;<i> &gt; some qualities (such as full test coverage :)), it gets put into
</I>&gt;<i> &gt; trunk, and that gets pushed to production servers. No human
</I>&gt;<i> &gt; interaction. Scary at first, but then you realize humans were
</I>&gt;<i> &gt; already involved in the QC process extensively at every point --
</I>&gt;<i> &gt; doing it this way just makes them take testing more seriously :)
</I>&gt;<i>
</I>&gt;<i> Human interaction of some kind should definitely be required for
</I>&gt;<i> Twisted. This is not just pushing some new widget to a web site; this
</I>&gt;<i> is potentially pushing out new APIs that need to be documented and
</I>&gt;<i> supported to a whole ton of developers. The whole point of the process
</I>&gt;<i> modification I've proposed is to make sure that features arrive in
</I>&gt;<i> releases as coherent, comprehensible whole pieces, not to allow things
</I>&gt;<i> we can automatically verify (like docstring and test coverage) to be
</I>&gt;<i> deferred to later merges. These properties of the code should still be
</I>&gt;<i> verified on every merge to the integration branch; the interesting
</I>&gt;<i> thing about the merge to trunk is the verification that the unit is a
</I>&gt;<i> coherent whole (and in the case of a deprecation / replacement, that
</I>&gt;<i> the replacement is a functionally adequate upgrade).
</I>
Yeah, I can see that. My point is not so much an argument for
implementing automatic merging into trunk for Twisted, but mostly that
this method, when properly implemented, results in a very high
confidence level of the quality of your implementation branches, up to
the point where people have successfully automated it :)

As far as the coherent, comprehensible releases, that's one of the
reasons I like Launchpad's milestones, series, blueprints... You want to
do all of that and I think it's a great idea, and I think that they're
good tools for making all of the specifics of that intent (coherent,
comprehensible releases) more transparent to the outside world.


&gt;<i> Thanks,
</I>&gt;<i>
</I>&gt;<i> -glyph
</I>
Thanks,
Laurens

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022266.html">[Twisted-Python] major changes, release engineering,	and learning cost
</A></li>
	<LI>Next message: <A HREF="022272.html">[Twisted-Python] major changes, release engineering,	and learning cost
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22271">[ date ]</a>
              <a href="thread.html#22271">[ thread ]</a>
              <a href="subject.html#22271">[ subject ]</a>
              <a href="author.html#22271">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
