<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Hanging Deferreds in PB Paging code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20Hanging%20Deferreds%20in%20PB%20Paging%20code&In-Reply-To=%3C45B15D77.7000103%40eepatents.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="047161.html">
   <LINK REL="Next"  HREF="047193.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Hanging Deferreds in PB Paging code</H1>
    <B>Ed Suominen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20Hanging%20Deferreds%20in%20PB%20Paging%20code&In-Reply-To=%3C45B15D77.7000103%40eepatents.com%3E"
       TITLE="[Twisted-Python] Re: Hanging Deferreds in PB Paging code">general at eepatents.com
       </A><BR>
    <I>Fri Jan 19 17:08:23 MST 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="047161.html">[Twisted-Python] Hanging Deferreds in PB Paging code
</A></li>
        <LI>Next message (by thread): <A HREF="047193.html">[Twisted-Python] Re: Hanging Deferreds in PB Paging code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47192">[ date ]</a>
              <a href="thread.html#47192">[ thread ]</a>
              <a href="subject.html#47192">[ subject ]</a>
              <a href="author.html#47192">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>From: &quot;Brian Granger&quot; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ellisonbg.net at gmail.com</A>&gt;
&gt;<i> We are using PB as an initial protocol for some IPython related
</I>&gt;<i> stuff. Overall, PB is working well, but we need to be able to send
</I>&gt;<i> larger things around so we have been trying to implement things using
</I>&gt;<i> the pb.util.Pager stuff.  I have spent a fair amount of time
</I>&gt;<i> understanding how the Paging works.
</I>
I looked at the PB paging stuff and decided to write my own simple
solution for it, borrowing the original code as needed. At the server,
just pass one of these to your PB client:

&gt;<i> class Receiver(pb.Referenceable):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Give a PB client a remote reference to an instance of me and it will
</I>&gt;<i>     have a way to upload a file in chunks of whatever size it likes.
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     def __init__(self, destPath):
</I>&gt;<i>         self.file = open(destPath, 'w')
</I>&gt;<i> 
</I>&gt;<i>     def remote_chunk(self, data):
</I>&gt;<i>         self.file.write(data)
</I>&gt;<i>         return True
</I>&gt;<i> 
</I>&gt;<i>     def remote_done(self, ok):
</I>&gt;<i>         self.file.close()
</I>
At the client side, use the source path for the file and the reference
to the Receiver object to construct an Uploader object:

&gt;<i> from twisted.internet import defer, interfaces
</I>&gt;<i> from twisted.python.filepath import FilePath
</I>&gt;<i> 
</I>&gt;<i> class Uploader(object):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     I upload the file at the specified I{sourcePath} to the I{referenced} PB
</I>&gt;<i>     referenceable object, both of which are supplied to my constructor.
</I>&gt;<i> 
</I>&gt;<i>     @ivar d: A deferred that fires when the file has been completely uploaded.
</I>&gt;<i>     
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     implements(interfaces.IConsumer)
</I>&gt;<i> 
</I>&gt;<i>     def __init__(self, sourcePath, referenced):
</I>&gt;<i>         self.ref = referenced
</I>&gt;<i>         # The source file
</I>&gt;<i>         fp = FilePath(sourcePath)
</I>&gt;<i>         if not fp.isfile():
</I>&gt;<i>             raise OSError(&quot;'%s' is not a valid file path&quot; % result)
</I>&gt;<i>         self.basename = fp.basename()
</I>&gt;<i>         self.bytes = [0, fp.getsize()]
</I>&gt;<i>         self.fh = fp.open()
</I>&gt;<i>         # Pull producer for reading the file locally
</I>&gt;<i>         self.producer = FileSender()
</I>&gt;<i>         # Set up the deferred that fires when the upload is done
</I>&gt;<i>         d = self.d = defer.Deferred()
</I>&gt;<i>         d.addCallback(lambda ok: self.ref.callRemote('done', ok))
</I>&gt;<i>         # Start the transfer at the file producer
</I>&gt;<i>         self.producer.beginProducing(self.fh, self)
</I>&gt;<i> 
</I>&gt;<i>     def cancel(self):
</I>&gt;<i>         if not self.d.called:
</I>&gt;<i>             self.d.callback(False)
</I>&gt;<i>         self.producer.stopProducing()
</I>&gt;<i> 
</I>&gt;<i>     #--- IConsumer API --------------------------------------------------------
</I>&gt;<i>     
</I>&gt;<i>     def registerProducer(self, producer, streaming):
</I>&gt;<i>         self.producer = producer
</I>&gt;<i>         if not streaming:
</I>&gt;<i>             self.producer.resumeProducing()
</I>&gt;<i> 
</I>&gt;<i>     def unregisterProducer(self):
</I>&gt;<i>         if not self.d.called:
</I>&gt;<i>             self.d.callback(True)
</I>&gt;<i> 
</I>&gt;<i>     def write(self, data):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Writes the supplied chunk of file I{data}, no larger than
</I>&gt;<i>         L{FileSender.CHUNK_SIZE} bytes, to the server using the referenceable
</I>&gt;<i>         I've been given.
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         def oops(failure):
</I>&gt;<i>             failure.printTraceback()
</I>&gt;<i>             self.cancel()
</I>&gt;<i> 
</I>&gt;<i>         def update(sent):
</I>&gt;<i>             sent = self.bytes[0] + sent
</I>&gt;<i>             self.p.setValue(sent)
</I>&gt;<i>             self.bytes[0] = sent
</I>&gt;<i> 
</I>&gt;<i>         d = self.ref.callRemote('chunk', data)
</I>&gt;<i>         d.addCallback(lambda _: update(len(data)))
</I>&gt;<i>         d.addCallback(lambda _: self.producer.resumeProducing())
</I>&gt;<i>         d.addErrback(oops)
</I>
I excerpted this from code that queues up the remote calls via my
asynchronous task queue, and I'm not sure whether it will work well
without it. The taskqueue subpackage is part of
Twisted-Goodies, see <A HREF="http://foss.eepatents.com/Twisted-Goodies.">http://foss.eepatents.com/Twisted-Goodies.</A>

Anyhow, given how much it borrows from Twisted's own code, I hereby
license this code snippet for use under the same MIT-like license that
Twisted itself uses.

Best regards, Ed



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="047161.html">[Twisted-Python] Hanging Deferreds in PB Paging code
</A></li>
	<LI>Next message (by thread): <A HREF="047193.html">[Twisted-Python] Re: Hanging Deferreds in PB Paging code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47192">[ date ]</a>
              <a href="thread.html#47192">[ thread ]</a>
              <a href="subject.html#47192">[ subject ]</a>
              <a href="author.html#47192">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
