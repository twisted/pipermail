<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Hanging Deferreds in PB Paging code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20Hanging%20Deferreds%20in%20PB%20Paging%20code&In-Reply-To=%3C6ce0ac130701191648j20cff55dlee005cc27365a3bf%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="047192.html">
   <LINK REL="Next"  HREF="047196.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Hanging Deferreds in PB Paging code</H1>
    <B>Brian Granger</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20Hanging%20Deferreds%20in%20PB%20Paging%20code&In-Reply-To=%3C6ce0ac130701191648j20cff55dlee005cc27365a3bf%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Re: Hanging Deferreds in PB Paging code">ellisonbg.net at gmail.com
       </A><BR>
    <I>Fri Jan 19 17:48:23 MST 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="047192.html">[Twisted-Python] Re: Hanging Deferreds in PB Paging code
</A></li>
        <LI>Next message (by thread): <A HREF="047196.html">[Twisted-Python] Hanging Deferreds in PB Paging code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47193">[ date ]</a>
              <a href="thread.html#47193">[ thread ]</a>
              <a href="subject.html#47193">[ subject ]</a>
              <a href="author.html#47193">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ed,

Thanks for the code snippet.  I had thought about trying to implement
my own, less complicated solution for this issue but hadn't done
anything yet.  I will have a look at your code to see if I can adapt
it.  I am not dealing with files, but most of the ideas are the same.

Also, the task queue stuff looks interesting.  It is actually pretty
similar to what we have implemented in IPython:

<A HREF="http://ipython.scipy.org/moin/Parallel_Computing">http://ipython.scipy.org/moin/Parallel_Computing</A>

We have abstracted things at a slightly lower level to allow various
types of higher level constructs (such as task farming) to be built
easily.  We haven't build the task farming interface fully yet, but
that is on our list of todos soon.  It might be nice to use some of
your work when we implement the task farming interface, but
unfortunately, IPython is BSD, so your GPL code won't help us much.

Brian

On 1/19/07, Ed Suominen &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">general at eepatents.com</A>&gt; wrote:
&gt;<i> From: &quot;Brian Granger&quot; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ellisonbg.net at gmail.com</A>&gt;
</I>&gt;<i> &gt; We are using PB as an initial protocol for some IPython related
</I>&gt;<i> &gt; stuff. Overall, PB is working well, but we need to be able to send
</I>&gt;<i> &gt; larger things around so we have been trying to implement things using
</I>&gt;<i> &gt; the pb.util.Pager stuff.  I have spent a fair amount of time
</I>&gt;<i> &gt; understanding how the Paging works.
</I>&gt;<i>
</I>&gt;<i> I looked at the PB paging stuff and decided to write my own simple
</I>&gt;<i> solution for it, borrowing the original code as needed. At the server,
</I>&gt;<i> just pass one of these to your PB client:
</I>&gt;<i>
</I>&gt;<i> &gt; class Receiver(pb.Referenceable):
</I>&gt;<i> &gt;     &quot;&quot;&quot;
</I>&gt;<i> &gt;     Give a PB client a remote reference to an instance of me and it will
</I>&gt;<i> &gt;     have a way to upload a file in chunks of whatever size it likes.
</I>&gt;<i> &gt;     &quot;&quot;&quot;
</I>&gt;<i> &gt;     def __init__(self, destPath):
</I>&gt;<i> &gt;         self.file = open(destPath, 'w')
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def remote_chunk(self, data):
</I>&gt;<i> &gt;         self.file.write(data)
</I>&gt;<i> &gt;         return True
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def remote_done(self, ok):
</I>&gt;<i> &gt;         self.file.close()
</I>&gt;<i>
</I>&gt;<i> At the client side, use the source path for the file and the reference
</I>&gt;<i> to the Receiver object to construct an Uploader object:
</I>&gt;<i>
</I>&gt;<i> &gt; from twisted.internet import defer, interfaces
</I>&gt;<i> &gt; from twisted.python.filepath import FilePath
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; class Uploader(object):
</I>&gt;<i> &gt;     &quot;&quot;&quot;
</I>&gt;<i> &gt;     I upload the file at the specified I{sourcePath} to the I{referenced} PB
</I>&gt;<i> &gt;     referenceable object, both of which are supplied to my constructor.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     @ivar d: A deferred that fires when the file has been completely uploaded.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     &quot;&quot;&quot;
</I>&gt;<i> &gt;     implements(interfaces.IConsumer)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def __init__(self, sourcePath, referenced):
</I>&gt;<i> &gt;         self.ref = referenced
</I>&gt;<i> &gt;         # The source file
</I>&gt;<i> &gt;         fp = FilePath(sourcePath)
</I>&gt;<i> &gt;         if not fp.isfile():
</I>&gt;<i> &gt;             raise OSError(&quot;'%s' is not a valid file path&quot; % result)
</I>&gt;<i> &gt;         self.basename = fp.basename()
</I>&gt;<i> &gt;         self.bytes = [0, fp.getsize()]
</I>&gt;<i> &gt;         self.fh = fp.open()
</I>&gt;<i> &gt;         # Pull producer for reading the file locally
</I>&gt;<i> &gt;         self.producer = FileSender()
</I>&gt;<i> &gt;         # Set up the deferred that fires when the upload is done
</I>&gt;<i> &gt;         d = self.d = defer.Deferred()
</I>&gt;<i> &gt;         d.addCallback(lambda ok: self.ref.callRemote('done', ok))
</I>&gt;<i> &gt;         # Start the transfer at the file producer
</I>&gt;<i> &gt;         self.producer.beginProducing(self.fh, self)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def cancel(self):
</I>&gt;<i> &gt;         if not self.d.called:
</I>&gt;<i> &gt;             self.d.callback(False)
</I>&gt;<i> &gt;         self.producer.stopProducing()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     #--- IConsumer API --------------------------------------------------------
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def registerProducer(self, producer, streaming):
</I>&gt;<i> &gt;         self.producer = producer
</I>&gt;<i> &gt;         if not streaming:
</I>&gt;<i> &gt;             self.producer.resumeProducing()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def unregisterProducer(self):
</I>&gt;<i> &gt;         if not self.d.called:
</I>&gt;<i> &gt;             self.d.callback(True)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def write(self, data):
</I>&gt;<i> &gt;         &quot;&quot;&quot;
</I>&gt;<i> &gt;         Writes the supplied chunk of file I{data}, no larger than
</I>&gt;<i> &gt;         L{FileSender.CHUNK_SIZE} bytes, to the server using the referenceable
</I>&gt;<i> &gt;         I've been given.
</I>&gt;<i> &gt;         &quot;&quot;&quot;
</I>&gt;<i> &gt;         def oops(failure):
</I>&gt;<i> &gt;             failure.printTraceback()
</I>&gt;<i> &gt;             self.cancel()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         def update(sent):
</I>&gt;<i> &gt;             sent = self.bytes[0] + sent
</I>&gt;<i> &gt;             self.p.setValue(sent)
</I>&gt;<i> &gt;             self.bytes[0] = sent
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         d = self.ref.callRemote('chunk', data)
</I>&gt;<i> &gt;         d.addCallback(lambda _: update(len(data)))
</I>&gt;<i> &gt;         d.addCallback(lambda _: self.producer.resumeProducing())
</I>&gt;<i> &gt;         d.addErrback(oops)
</I>&gt;<i>
</I>&gt;<i> I excerpted this from code that queues up the remote calls via my
</I>&gt;<i> asynchronous task queue, and I'm not sure whether it will work well
</I>&gt;<i> without it. The taskqueue subpackage is part of
</I>&gt;<i> Twisted-Goodies, see <A HREF="http://foss.eepatents.com/Twisted-Goodies.">http://foss.eepatents.com/Twisted-Goodies.</A>
</I>&gt;<i>
</I>&gt;<i> Anyhow, given how much it borrows from Twisted's own code, I hereby
</I>&gt;<i> license this code snippet for use under the same MIT-like license that
</I>&gt;<i> Twisted itself uses.
</I>&gt;<i>
</I>&gt;<i> Best regards, Ed
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="047192.html">[Twisted-Python] Re: Hanging Deferreds in PB Paging code
</A></li>
	<LI>Next message (by thread): <A HREF="047196.html">[Twisted-Python] Hanging Deferreds in PB Paging code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47193">[ date ]</a>
              <a href="thread.html#47193">[ thread ]</a>
              <a href="subject.html#47193">[ subject ]</a>
              <a href="author.html#47193">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
