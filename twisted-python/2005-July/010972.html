<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Understanding%20the%20IOCP%20reactor%20and%20adding%0A%09spawnProcess&In-Reply-To=20050711134904.3555c1f6%40dunce">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010970.html">
   <LINK REL="Next"  HREF="010975.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess</H1>
    <B>Justin Johnson</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Understanding%20the%20IOCP%20reactor%20and%20adding%0A%09spawnProcess&In-Reply-To=20050711134904.3555c1f6%40dunce"
       TITLE="[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess">justinjohnson at gmail.com
       </A><BR>
    <I>Mon Jul 11 16:57:39 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010970.html">[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
</A></li>
        <LI>Next message: <A HREF="010975.html">[Twisted-Python] exceptions in adbapi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10972">[ date ]</a>
              <a href="thread.html#10972">[ thread ]</a>
              <a href="subject.html#10972">[ subject ]</a>
              <a href="author.html#10972">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 7/11/05, Pavel Pergamenshchik &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">pp64 at codelock.com</A>&gt; wrote: 
&gt;<i> 
</I>&gt;<i> On Mon, 11 Jul 2005 10:52:14 -0500
</I>&gt;<i> Justin Johnson &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">justinjohnson at gmail.com</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; I am attempting to add spawnProcess to iocpreactor. In order to begin
</I>&gt;<i> this
</I>&gt;<i> &gt; task I've had to do a lot of reading on Windows network programming,
</I>&gt;<i> &gt; specifically the various Windows I/O methods, to attempt to understand
</I>&gt;<i> what
</I>&gt;<i> &gt; win32eventreactor and iocpreactor are doing, and also just increase my
</I>&gt;<i> 
</I>&gt;<i> &gt; understanding of how reactors work in general. To understand the
</I>&gt;<i> various
</I>&gt;<i> &gt; Winsock 2 methods that both of these reactors rely upon, I read
</I>&gt;<i> chapters 1-5
</I>&gt;<i> &gt; of Network Programming for Microsoft Windows[1].
</I>&gt;<i> &gt; Before actually attempting to add spawnProcess, I would like to
</I>&gt;<i> present how
</I>&gt;<i> &gt; I think iocpreactor works and how I think I should add spawnProcess,
</I>&gt;<i> and
</I>&gt;<i> &gt; hopefully be corrected or confirmed in my understanding. If I'm too
</I>&gt;<i> vague
</I>&gt;<i> &gt; there's a good chance it's because I don't understand it very well.
</I>&gt;<i> Please
</I>&gt;<i> &gt; feel free to point out things that you might think are obvious but
</I>&gt;<i> aren't
</I>&gt;<i> &gt; sure I understand.
</I>&gt;<i> &gt; How iocpreactor works
</I>&gt;<i> &gt; ---------------------------------
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. Create an IO Completion Port.
</I>&gt;<i> &gt; 2. Create a socket and associate it with the IOCP. This is the
</I>&gt;<i> socket
</I>&gt;<i> &gt; we will call AcceptEx (a non-blocking accept) on. The association
</I>&gt;<i> with the
</I>&gt;<i> &gt; IOCP is made via CreateIoCompletionPort.
</I>&gt;<i> &gt; 3. Setup any scheduled tasks on the reactor.
</I>&gt;<i> &gt; 4. Call AcceptEx (which doesn't block) on the socket. AcceptEx
</I>&gt;<i> takes
</I>&gt;<i> &gt; an overlapped structure as a parameter. Before making the call, we
</I>&gt;<i> set two
</I>&gt;<i> &gt; attributes of the struct: the callback and callback_args which will
</I>&gt;<i> be
</I>&gt;<i> &gt; called when an accept event completes on the socket. The Winsock 2
</I>&gt;<i> methods
</I>&gt;<i> &gt; don't actually call the callback. The Winsock 2 methods handle
</I>&gt;<i> copying data
</I>&gt;<i> &gt; related to the network event that occurred on the socket into the
</I>&gt;<i> overlapped
</I>&gt;<i> &gt; structure and making that overlapped structure available to
</I>&gt;<i> &gt; GetQueuedCompletionStatus. So when we handle events on sockets via
</I>&gt;<i> &gt; GetQueuedCompletionStatus from within doIteration, we have access
</I>&gt;<i> to the
</I>&gt;<i> &gt; data related to the event as well as the callback and callback_args
</I>&gt;<i> we call
</I>&gt;<i> &gt; to handle that event. The callbacks are setup in the xxxOp classes
</I>&gt;<i> in
</I>&gt;<i> &gt; ops.py and always result in some transport method getting called
</I>&gt;<i> (such
</I>&gt;<i> &gt; as readDone, connectionDone, etc).
</I>&gt;<i> &gt; 5. From within doIteration, call GetQueuedCompletionStatus (which
</I>&gt;<i> does
</I>&gt;<i> &gt; block) with a timeout of the time until the next scheduled task
</I>&gt;<i> needs to be
</I>&gt;<i> &gt; run. If any event occurs on the sockets currently associated with
</I>&gt;<i> the IOCP
</I>&gt;<i> &gt; before that time expires, GetQueuedCompletionStatus will return
</I>&gt;<i> (stop
</I>&gt;<i> &gt; blocking). Now we have access to the overlapped structure
</I>&gt;<i> containing data
</I>&gt;<i> &gt; associated with the event which was copied into the overlapped
</I>&gt;<i> structure's
</I>&gt;<i> &gt; buffer, such as data received from WSARecv calls, as well as the
</I>&gt;<i> callback
</I>&gt;<i> &gt; and callback_args. From within doIteration we call the callbacks
</I>&gt;<i> passing in
</I>&gt;<i> &gt; the data related to the event. Depending on the events we are
</I>&gt;<i> handling, we
</I>&gt;<i> &gt; may create new sockets (e.g. end point sockets in TCP connections)
</I>&gt;<i> and
</I>&gt;<i> &gt; associate them with the IOCP as well. All Winsock 2 API calls made
</I>&gt;<i> are
</I>&gt;<i> &gt; non-blocking accept for GetQueuedCompletionStatus.
</I>&gt;<i> &gt; 6. Step 5 continues until the reactor stops.
</I>&gt;<i> 
</I>&gt;<i> This sounds about right. Note how this is different from the usual
</I>&gt;<i> reactor thing -- iocp notifies you when the operation is _finished_,
</I>&gt;<i> not when it can success without blocking.
</I>
 Right. Understood.

&gt;<i> How to add spawnProcess
</I>&gt;<i> &gt; ---------------------------------------
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. Create the processes via Windows APIs and associate their
</I>&gt;<i> &gt; stdout/err with with the IOCP via CreateIoCompletionPort calls.
</I>&gt;<i> &gt; 2. Close stdin.
</I>&gt;<i> &gt; 3. Notify the ProcessProtocol via protocol.makeConnection (not sure
</I>&gt;<i> 
</I>&gt;<i> &gt; why, looking at win32eventreactor)
</I>&gt;<i> &gt; 4. Receive data from stdout/err via the completion port by calling
</I>&gt;<i> &gt; GetQueuedCompletionStatus from within doIteration. Is this really
</I>&gt;<i> possible?
</I>&gt;<i> &gt; ProcessProtocol's methods won't get called appropriately by letting
</I>&gt;<i> the
</I>&gt;<i> &gt; existing callbacks in ops.py make calls to the transport (e.g.
</I>&gt;<i> &gt; connectionDone, readDone)?
</I>&gt;<i> 
</I>&gt;<i> Hrm. Not quite. In iocp, you always have a read call pending
</I>&gt;<i> (ReadFileEx, for stdout/err handles). When it completes, you get a
</I>&gt;<i> notification in GetQueuedCompletionStatus, pass the data to your
</I>&gt;<i> Protocol and schedule the read again.
</I>&gt;<i> Do that for stdout and stderr.
</I>&gt;<i> ops.py already has a wrapper for ReadFile, but it always calls readDone
</I>&gt;<i> and readErr on your transport. You'll need to fix that.
</I>
 I think we're on the same page here. See my previous emails correcting my 
original idea on how this would work. At this point I've defined custom 
xxxOp classes as follows.

class ReadOutOp(OverlappedOp):
def ovDone(self, ret, bytes, (handle, buffer)):
if ret or not bytes:
#self.transport.readErr(ret, bytes)
self.transport.outConnectionLost()
else:
#self.transport.readDone(bytes)
self.transport.protocol.outReceived(bytes)
 
def initiateOp(self, handle, buffer):
self.reactor.issueReadFile(handle, buffer, self.ovDone, (handle, buffer))

class ReadErrOp(OverlappedOp):
def ovDone(self, ret, bytes, (handle, buffer)):
if ret or not bytes:
#self.transport.readErr(ret, bytes)
self.transport.errConnectionLost()
else:
#self.transport.readDone(bytes)
self.transport.protocol.errReceived(bytes)

def initiateOp(self, handle, buffer):
self.reactor.issueReadFile(handle, buffer, self.ovDone, (handle, buffer))

class WriteInOp(OverlappedOp):
def ovDone(self, ret, bytes, (handle, buffer)):
# log.msg(&quot;WriteFileOp.ovDone&quot;, time.time())
if ret or not bytes:
#self.transport.writeErr(ret, bytes)
self.transport.inConnectionLost()
else:
#self.transport.writeDone(bytes)
pass

def initiateOp(self, handle, buffer):
# log.msg(&quot;WriteFileOp.initiateOp&quot;, time.time())
self.reactor.issueWriteFile(handle, buffer, self.ovDone, (handle, buffer))
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20050711/3f095226/attachment.htm">http://twistedmatrix.com/pipermail/twisted-python/attachments/20050711/3f095226/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010970.html">[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
</A></li>
	<LI>Next message: <A HREF="010975.html">[Twisted-Python] exceptions in adbapi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10972">[ date ]</a>
              <a href="thread.html#10972">[ thread ]</a>
              <a href="subject.html#10972">[ subject ]</a>
              <a href="author.html#10972">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
