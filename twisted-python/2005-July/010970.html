<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Understanding%20the%20IOCP%20reactor%20and%20adding%0A%09spawnProcess&In-Reply-To=94a776e7050711085220094f1c%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010968.html">
   <LINK REL="Next"  HREF="010972.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess</H1>
    <B>Pavel Pergamenshchik</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Understanding%20the%20IOCP%20reactor%20and%20adding%0A%09spawnProcess&In-Reply-To=94a776e7050711085220094f1c%40mail.gmail.com"
       TITLE="[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess">pp64 at codelock.com
       </A><BR>
    <I>Mon Jul 11 16:49:04 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010968.html">[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
</A></li>
        <LI>Next message: <A HREF="010972.html">[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10970">[ date ]</a>
              <a href="thread.html#10970">[ thread ]</a>
              <a href="subject.html#10970">[ subject ]</a>
              <a href="author.html#10970">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 11 Jul 2005 10:52:14 -0500
Justin Johnson &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">justinjohnson at gmail.com</A>&gt; wrote:

&gt;<i> I am attempting to add spawnProcess to iocpreactor. In order to begin
</I>this 
&gt;<i> task I've had to do a lot of reading on Windows network programming, 
</I>&gt;<i> specifically the various Windows I/O methods, to attempt to understand
</I>what 
&gt;<i> win32eventreactor and iocpreactor are doing, and also just increase my
</I>
&gt;<i> understanding of how reactors work in general. To understand the
</I>various 
&gt;<i> Winsock 2 methods that both of these reactors rely upon, I read
</I>chapters 1-5 
&gt;<i> of Network Programming for Microsoft Windows[1].
</I>&gt;<i>  Before actually attempting to add spawnProcess, I would like to
</I>present how 
&gt;<i> I think iocpreactor works and how I think I should add spawnProcess,
</I>and 
&gt;<i> hopefully be corrected or confirmed in my understanding. If I'm too
</I>vague 
&gt;<i> there's a good chance it's because I don't understand it very well.
</I>Please 
&gt;<i> feel free to point out things that you might think are obvious but
</I>aren't 
&gt;<i> sure I understand.
</I>&gt;<i>  How iocpreactor works
</I>&gt;<i> ---------------------------------
</I>&gt;<i> 
</I>&gt;<i>    1. Create an IO Completion Port. 
</I>&gt;<i>    2. Create a socket and associate it with the IOCP. This is the
</I>socket 
&gt;<i>    we will call AcceptEx (a non-blocking accept) on. The association
</I>with the 
&gt;<i>    IOCP is made via CreateIoCompletionPort. 
</I>&gt;<i>    3. Setup any scheduled tasks on the reactor. 
</I>&gt;<i>    4. Call AcceptEx (which doesn't block) on the socket. AcceptEx
</I>takes 
&gt;<i>    an overlapped structure as a parameter. Before making the call, we
</I>set two 
&gt;<i>    attributes of the struct: the callback and callback_args which will
</I>be 
&gt;<i>    called when an accept event completes on the socket. The Winsock 2
</I>methods 
&gt;<i>    don't actually call the callback. The Winsock 2 methods handle
</I>copying data 
&gt;<i>    related to the network event that occurred on the socket into the
</I>overlapped 
&gt;<i>    structure and making that overlapped structure available to 
</I>&gt;<i>    GetQueuedCompletionStatus. So when we handle events on sockets via 
</I>&gt;<i>    GetQueuedCompletionStatus from within doIteration, we have access
</I>to the 
&gt;<i>    data related to the event as well as the callback and callback_args
</I>we call 
&gt;<i>    to handle that event. The callbacks are setup in the xxxOp classes
</I>in 
&gt;<i>    ops.py and always result in some transport method getting called
</I>(such 
&gt;<i>    as readDone, connectionDone, etc). 
</I>&gt;<i>    5. From within doIteration, call GetQueuedCompletionStatus (which
</I>does 
&gt;<i>    block) with a timeout of the time until the next scheduled task
</I>needs to be 
&gt;<i>    run. If any event occurs on the sockets currently associated with
</I>the IOCP 
&gt;<i>    before that time expires, GetQueuedCompletionStatus will return
</I>(stop 
&gt;<i>    blocking). Now we have access to the overlapped structure
</I>containing data 
&gt;<i>    associated with the event which was copied into the overlapped
</I>structure's 
&gt;<i>    buffer, such as data received from WSARecv calls, as well as the
</I>callback 
&gt;<i>    and callback_args. From within doIteration we call the callbacks
</I>passing in 
&gt;<i>    the data related to the event. Depending on the events we are
</I>handling, we 
&gt;<i>    may create new sockets (e.g. end point sockets in TCP connections)
</I>and 
&gt;<i>    associate them with the IOCP as well. All Winsock 2 API calls made
</I>are 
&gt;<i>    non-blocking accept for GetQueuedCompletionStatus. 
</I>&gt;<i>    6. Step 5 continues until the reactor stops.
</I>
This sounds about right. Note how this is different from the usual
reactor thing -- iocp notifies you when the operation is _finished_,
not when it can success without blocking.

&gt;<i>   How to add spawnProcess
</I>&gt;<i> ---------------------------------------
</I>&gt;<i> 
</I>&gt;<i>    1. Create the processes via Windows APIs and associate their 
</I>&gt;<i>    stdout/err with with the IOCP via CreateIoCompletionPort calls. 
</I>&gt;<i>    2. Close stdin. 
</I>&gt;<i>    3. Notify the ProcessProtocol via protocol.makeConnection (not sure
</I>
&gt;<i>    why, looking at win32eventreactor) 
</I>&gt;<i>    4. Receive data from stdout/err via the completion port by calling 
</I>&gt;<i>    GetQueuedCompletionStatus from within doIteration. Is this really
</I>possible? 
&gt;<i>    ProcessProtocol's methods won't get called appropriately by letting
</I>the 
&gt;<i>    existing callbacks in ops.py make calls to the transport (e.g. 
</I>&gt;<i>    connectionDone, readDone)?
</I>
Hrm. Not quite. In iocp, you always have a read call pending
(ReadFileEx, for stdout/err handles). When it completes, you get a
notification in GetQueuedCompletionStatus, pass the data to your
Protocol and schedule the read again.
Do that for stdout and stderr.
ops.py already has a wrapper for ReadFile, but it always calls readDone
and readErr on your transport. You'll need to fix that.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010968.html">[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
</A></li>
	<LI>Next message: <A HREF="010972.html">[Twisted-Python] Understanding the IOCP reactor and adding	spawnProcess
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10970">[ date ]</a>
              <a href="thread.html#10970">[ thread ]</a>
              <a href="subject.html#10970">[ subject ]</a>
              <a href="author.html#10970">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
