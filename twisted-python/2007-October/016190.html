<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Should I use asynchronous programming in my own	modules?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Should%20I%20use%20asynchronous%20programming%20in%20my%20own%0A%09modules%3F&In-Reply-To=47175482.1090809%40gmx.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016195.html">
   <LINK REL="Next"  HREF="016193.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Should I use asynchronous programming in my own	modules?</H1>
    <B>Jean-Paul Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Should%20I%20use%20asynchronous%20programming%20in%20my%20own%0A%09modules%3F&In-Reply-To=47175482.1090809%40gmx.net"
       TITLE="[Twisted-Python] Should I use asynchronous programming in my own	modules?">exarkun at divmod.com
       </A><BR>
    <I>Thu Oct 18 09:31:51 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="016195.html">[Twisted-Python] Should I use asynchronous programming in my	own	modules?
</A></li>
        <LI>Next message: <A HREF="016193.html">[Twisted-Python] Should I use asynchronous programming in my	own	modules?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16190">[ date ]</a>
              <a href="thread.html#16190">[ thread ]</a>
              <a href="subject.html#16190">[ subject ]</a>
              <a href="author.html#16190">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 18 Oct 2007 14:41:38 +0200, J&#252;rgen Strass &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">jrg718 at gmx.net</A>&gt; wrote:
&gt;<i>Hello,
</I>&gt;<i>
</I>&gt;<i>I'm rather new to twisted and asynchronous programming in general. Overall, 
</I>&gt;<i>I think I've understood the asynchronous programming model and its 
</I>&gt;<i>implications quite well. Nevertheless, there are some remaining questions.
</I>&gt;<i>
</I>&gt;<i>To give some example, I'd like to develop my own simplified document format 
</I>&gt;<i>in XML and a corresponding parser. The output of the parser (a specialized 
</I>&gt;<i>document object model) will be traversed and translated into HTML 
</I>&gt;<i>afterwards. This module could be useful outside any twisted application, of 
</I>&gt;<i>course. Instead of generating HTML one could develop a generator that 
</I>&gt;<i>produces LaTeX, for example. But it could also be used to render HTML pages 
</I>&gt;<i>in a twisted web application.
</I>
Have you seen Lore?

&gt;<i>The question is this: since parsing and 
</I>&gt;<i>generating large documents could block the reactor in a twisted app, should 
</I>&gt;<i>I use any of twisted's asynchronous programming features in this module (for 
</I>&gt;<i>better integration with twisted) or should I rather develop it in a 
</I>&gt;<i>traditional way and run it in a thread?
</I>
Incremental parsing is often useful and simpler than the alternative.  If
you are accepting a document over the network, why buffer it yourself and
then parse it when you could just be giving each piece directly to the
parser?  Done this way, it often is the case that even large documents can
be parsed without blocking for an unreasonable amount of time.

&gt;<i>
</I>&gt;<i>The question came to my mind, because somewhere I read that long lasting 
</I>&gt;<i>operations in third party modules should be called in a thread. This is 
</I>&gt;<i>clear. I also read that if one has the opportunity to develop an application 
</I>&gt;<i>from scratch, one should rather go for using twisted's asynchronous 
</I>&gt;<i>programming features and divide long lasting operations into small chunks. 
</I>
The CPU differs from the network.  There are rarely points in a CPU-bound
task where suspending to work on something else would not be an arbitrary
decision.  When dealing with the network, these points are obvious and
not at all arbitrary.  So, when dealing with the network, it's almost
unarguable that you should use Twisted's APIs instead of using blocking
APIs.  However, Twisted doesn't provide any functionality specifically
for breaking up CPU-bound tasks, primarily because any such functionality
would be arbitrary.

&gt;<i>In principal, this approach is clear to me, but does it also apply for 
</I>&gt;<i>modules which are entirely independent from twisted networking code? And if 
</I>&gt;<i>so, is there any way to decouple them from the twisted library for reuse in 
</I>&gt;<i>other applications?
</I>
It's typically trivial to drive code written to be used asynchronously in
a synchronous manner.  The opposite is rarely, if ever, true.  Consider a
parser API which consists of a &quot;feed&quot; method taking a string giving some
more bytes from the input document.  You can use this by passing in small
chunks repeatedly until the entire document has been passed in, or you can
pass in the entire document at once.  Now consider an API where the entire
document must be supplied at once: how do you use that without blocking?

&gt;<i>
</I>&gt;<i>The last question is what criteria I could use to divide long lasting 
</I>&gt;<i>operations into chunks. In almost all books about asynchronous programming I 
</I>&gt;<i>only read that if they're too big, they could block the event loop. Of 
</I>&gt;<i>course, but how big is too big? And what's the measure for it? Milliseconds, 
</I>&gt;<i>number of operations, number of code lines - or what? Doesn't it depend 
</I>&gt;<i>entirely on the application at hand and how reactive it has to be?
</I>
Yes.

&gt;<i>Moreover, 
</I>&gt;<i>depending on the hardware used, on a Pentium II less chunks can be processed 
</I>&gt;<i>at the same time than on a Athlon 64, for example.
</I>
True as well.  However, is your primary goal to provide ideal scheduling
behavior both on a CPU released this year and a CPU released ten years ago?

&gt;<i>And couldn't chunks also 
</I>&gt;<i>be too small, spending more time than necessary in putting them into the 
</I>&gt;<i>reactor's queue, then maybe sorting them and then calling them? In case the 
</I>&gt;<i>overhead involved in scheduling some chunk is bigger than the processing 
</I>&gt;<i>time of the chunk itself, the chunks are too small, aren't they?
</I>
Correct again.

These problems can all be mitigated, at least partially, by allowing the
application to decide how much work is done at once.  Parsing one byte from
an input document should take less time than parsing one megabyte.  Let the
application decide how much work is done at a time.  Size of input is only
one way in which this can be controlled.  You could support explicit tuning
of these parameters with a dedicated API, or you could support stepwise
processing and let the application explicitly step it as far as it wants to
at a time.  In this direction, there are some extremely primitive tools in
twisted.internet.task.  They will not solve the problem for you, but they
may give you some ideas or save you a bit of typing.

&gt;<i>
</I>&gt;<i>Thanks in advance for any answers,
</I>&gt;<i>J&#252;rgen
</I>&gt;<i>
</I>
Jean-Paul


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016195.html">[Twisted-Python] Should I use asynchronous programming in my	own	modules?
</A></li>
	<LI>Next message: <A HREF="016193.html">[Twisted-Python] Should I use asynchronous programming in my	own	modules?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16190">[ date ]</a>
              <a href="thread.html#16190">[ thread ]</a>
              <a href="subject.html#16190">[ subject ]</a>
              <a href="author.html#16190">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
