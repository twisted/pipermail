<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Should I use asynchronous programming in my	own modules?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Should%20I%20use%20asynchronous%20programming%20in%20my%0A%09own%20modules%3F&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016192.html">
   <LINK REL="Next"  HREF="016196.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Should I use asynchronous programming in my	own modules?</H1>
    <B>Toby Dickenson</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Should%20I%20use%20asynchronous%20programming%20in%20my%0A%09own%20modules%3F&In-Reply-To="
       TITLE="[Twisted-Python] Re: Should I use asynchronous programming in my	own modules?">tdickenson at geminidataloggers.com
       </A><BR>
    <I>Thu Oct 18 13:49:21 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="016192.html">[Twisted-Python] Should I use asynchronous programming in my	own modules?
</A></li>
        <LI>Next message: <A HREF="016196.html">[Twisted-Python] Re: Should I use asynchronous programming in	my	own modules?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16194">[ date ]</a>
              <a href="thread.html#16194">[ thread ]</a>
              <a href="subject.html#16194">[ subject ]</a>
              <a href="author.html#16194">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>J&#252;rgen Strass wrote:

&gt;<i> My idea now is that depending on the number of child elements, looping
</I>&gt;<i> could take some time. So instead I'd use twisted's reactor, specifically
</I>&gt;<i> its callLater method like this (it's only pseudo code!):
</I>&gt;<i> 
</I>&gt;<i> class Generator:
</I>&gt;<i> 
</I>&gt;<i>    def generate_html( self ):
</I>&gt;<i>       self.d = defer.Deferred()
</I>&gt;<i>       self.startProcessing()
</I>&gt;<i>       return self.d
</I>&gt;<i> 
</I>&gt;<i>    def startProcessing( self ):
</I>&gt;<i>       self.current_element = root_elem
</I>&gt;<i>       self.processNextElement()
</I>&gt;<i> 
</I>&gt;<i>    def processNextElement( self ):
</I>&gt;<i>       if more elements to process:
</I>&gt;<i>          if current_element.type = chapter
</I>&gt;<i>             reactor.callLater( 0, processChapter, current_element )
</I>&gt;<i>       .....
</I>&gt;<i>       else:
</I>&gt;<i>          d.callback( &quot;finished&quot; )
</I>
This is not so good. You have taken away your users option to control which
thread this processing is performed in, because it has to run in the
reactor's thread to avoid breaking Deferred's threading rules. Also your
users are not getting any benefit from the incremental nature of this code.
For example they cant get access to the first chunk of html until after
callback(&quot;finished&quot;). At least, not without more complexity. They cant
decide to stop processing early because they were only interested in the
html &lt;head&gt;.

&gt;<i> It's more or less clear to me how to divide the traversal of such a dom
</I>&gt;<i> tree into discrete steps
</I>
It seems like you are confusing this goal - the ability to perform work in
incremental steps - with the use of twisted's reactor to schedule those
steps.

Set twisted aside for a moment. I propose one good pythonic interface to
your html creation code may be a generate_html_iter() method, which returns
an iterator over the documents html fragments. You can implement this using
the processNextElement approach you suggested, although python generator
functions may be more convenient.


A thin wrapper around this iterator could use reactor.callLater to schedule
it, then fire a callback when complete. An equally thin wrapper could use
PostMessage to calculate the document in the background of a win32 gui. Or
it could feed a pull producer.  Alternatively it could be run in another
thread with deferToThread(lambda:''.join(g.generate_html_iter()))

I hope this helps,




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016192.html">[Twisted-Python] Should I use asynchronous programming in my	own modules?
</A></li>
	<LI>Next message: <A HREF="016196.html">[Twisted-Python] Re: Should I use asynchronous programming in	my	own modules?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16194">[ date ]</a>
              <a href="thread.html#16194">[ thread ]</a>
              <a href="subject.html#16194">[ subject ]</a>
              <a href="author.html#16194">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
