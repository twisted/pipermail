<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Should I use asynchronous programming in my	own modules?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Should%20I%20use%20asynchronous%20programming%20in%20my%0A%09own%20modules%3F&In-Reply-To=%3C471772C2.1020107%40gmx.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="048696.html">
   <LINK REL="Next"  HREF="048702.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Should I use asynchronous programming in my	own modules?</H1>
    <B>Jürgen Strass</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Should%20I%20use%20asynchronous%20programming%20in%20my%0A%09own%20modules%3F&In-Reply-To=%3C471772C2.1020107%40gmx.net%3E"
       TITLE="[Twisted-Python] Should I use asynchronous programming in my	own modules?">jrg718 at gmx.net
       </A><BR>
    <I>Thu Oct 18 08:50:42 MDT 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="048696.html">[Twisted-Python] Should I use asynchronous programming in my	own modules?
</A></li>
        <LI>Next message (by thread): <A HREF="048702.html">[Twisted-Python] Re: Should I use asynchronous programming in my	own modules?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#48700">[ date ]</a>
              <a href="thread.html#48700">[ thread ]</a>
              <a href="subject.html#48700">[ subject ]</a>
              <a href="author.html#48700">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Itamar Shtull-Trauring wrote:
&gt;<i> [...]
</I>&gt;<i> What you mean by &quot;traditional&quot; is actually a pull parser. Parsing APIs
</I>&gt;<i> can be pull or push (i.e. asynchronous). Well-designed parsers are
</I>&gt;<i> always push, because push parsers can be trivially converted to blocking
</I>&gt;<i> pull parsers, but not vice-versa. Some examples of push/asynch parsers:
</I>&gt;<i> twisted's Protocol class, or the SAX API.
</I>Sorry, I think my example was somewhat misleading and it also becomes 
clear to me that I haven't used the word &quot;asynchronous&quot; correctly. I 
didn't consider that one can also register callbacks with a parser, for 
example, and call this type of programming asynchronous. (The principle 
&quot;Don't call us, we call you&quot; would apply here, too, of course.)

No, what I really meant by &quot;traditional&quot; was to write parsers and 
generators which traverse the document as a whole in one large step, 
without giving a chance to the twisted reactor to process any other 
events. Let's assume I got a dom tree from pythons XML parser. First, 
I'd traverse that tree and build up another tree consisting of element 
objects. Each element object is an instance of a class corresponding to 
a tag, for example for tag &lt;chapter&gt; I'd create a class &quot;chapter&quot;. This 
is necessary because there's not always a one-to-one correspondence 
between tags and my document elements and to associate some additional 
attributes with such elements later, for example automatically generated 
chapter numbers. I'd then use the generator to traverse that element 
tree, calling &quot;render_element&quot; methods on my way. For element chapter 
with attribute title I'd call &quot;render_chapter( node )&quot;, which then 
generates &quot;&lt;h1&gt;chapter_title&lt;/h1&gt;&quot;.

Let's assume I had some element with child elements. Without knowing 
about twisted at all, I'd have created a foreach loop to process each 
child like this:

foreach child_node in root_elem.children:
   if child_node.type = chapter:
      processChapter( child_node )

My idea now is that depending on the number of child elements, looping 
could take some time. So instead I'd use twisted's reactor, specifically 
its callLater method like this (it's only pseudo code!):

class Generator:

   def generate_html( self ):
      self.d = defer.Deferred()
      self.startProcessing()
      return self.d

   def startProcessing( self ):
      self.current_element = root_elem
      self.processNextElement()

   def processNextElement( self ):
      if more elements to process:
         if current_element.type = chapter
            reactor.callLater( 0, processChapter, current_element )
      .....
      else:
         d.callback( &quot;finished&quot; )

In this way any twisted user could get a Deferred from the generate_html 
method and get called when the Generator has generated all HTML. The 
problem with this is that I couldn't ever use such code without also 
installing twisted, of course.

It's more or less clear to me how to divide the traversal of such a dom 
tree into discrete steps, but it's not so clear how to call the 
processNextElement with reactor.callLater from the outside. Although, 
after I've read the other answers, it seems to me I'm not far from a 
solution. I think I could also create two classes: the Generator class, 
which would provide a processNextElement method and doesn't need to 
depend on the twisted framework, and a TwistedGenerator class, which 
would do exactly the same like the code above and repeatedly call 
processNextElement with reactor.callLater. But the internal housekeeping 
which element to process next could be more difficult than with the 
solution above, couldn't it? (Because instead of seperate methods like 
&quot;processChapter&quot;, &quot;processList&quot;, etc. I'd only have one method to call 
from outside, &quot;processNextElement&quot; (and something like 
&quot;moreElementsToProcess&quot;). The TwistedGenerator wrapper shouldn't know 
about the internal state of the Generator, I think.)

Many greetings,
Jürgen



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="048696.html">[Twisted-Python] Should I use asynchronous programming in my	own modules?
</A></li>
	<LI>Next message (by thread): <A HREF="048702.html">[Twisted-Python] Re: Should I use asynchronous programming in my	own modules?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#48700">[ date ]</a>
              <a href="thread.html#48700">[ thread ]</a>
              <a href="subject.html#48700">[ subject ]</a>
              <a href="author.html#48700">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
