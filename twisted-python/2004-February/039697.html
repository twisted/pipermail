<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Components
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Components&In-Reply-To=%3C5.1.0.14.0.20040227092743.03091a70%40mail.telecommunity.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="039695.html">
   <LINK REL="Next"  HREF="039724.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Components</H1>
    <B>Phillip J. Eby</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Components&In-Reply-To=%3C5.1.0.14.0.20040227092743.03091a70%40mail.telecommunity.com%3E"
       TITLE="[Twisted-Python] Components">pje at telecommunity.com
       </A><BR>
    <I>Fri Feb 27 07:58:23 MST 2004</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="039695.html">[Twisted-Python] Components
</A></li>
        <LI>Next message (by thread): <A HREF="039724.html">[Twisted-Python] Generic functions using PyProtocols (was Re:  Components)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39697">[ date ]</a>
              <a href="thread.html#39697">[ thread ]</a>
              <a href="subject.html#39697">[ subject ]</a>
              <a href="author.html#39697">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 12:40 AM 2/27/04 -0500, Glyph Lefkowitz wrote:

&gt;<i>Considering that this is a rather uncommon use-case, can it be made into
</I>&gt;<i>the non-default Interface class?  Or an attribute/feature of the default
</I>&gt;<i>one, such as
</I>&gt;<i>
</I>&gt;<i>         class MyAbstractSub(IMyAbstract.ABC):
</I>&gt;<i>                 pass
</I>&gt;<i>
</I>&gt;<i>         class DontUseABC:
</I>&gt;<i>                 __implements__ = MyAbstractSub.Interface
</I>
Hmm.  I suppose it's possible I could have a 'protocols.Abstract' that 
could be subclassed in place of Interface, if you wanted to use the ABC 
style.  But then, couldn't you also use an 'adapt()' method, i.e.:

foo = IWhatever.adapt(bar)

?

&gt;<i> &gt; Again, this would be easily solved by a Twisted-specific subclass of
</I>&gt;<i> &gt; protocols.InterfaceClass, and I don't see that doing it is necessarily a
</I>&gt;<i> &gt; bad thing for either Twisted or PyProtocols, although it may be that it
</I>&gt;<i> &gt; should be considered simply a transitional, backward-compatibility thing.
</I>&gt;<i>
</I>&gt;<i>The __call__ hack, for me, is more than just syntactic sugar, or a
</I>&gt;<i>&quot;transitional, backward-compatibility thing&quot;.  It's fundamental to my
</I>&gt;<i>personal use of the component system.  One-argument callables are used
</I>&gt;<i>_everywhere_ in Twisted, thanks mostly to Deferreds, but also because
</I>&gt;<i>&quot;thing which takes one argument&quot; is a very convenient interface for
</I>&gt;<i>using for a variety of different kinds of processing.  An idiom I find
</I>&gt;<i>tremendously convenient (even, perhaps especially, when debugging) is
</I>&gt;<i>&quot;return foo.doSomethingDeferred().addCallback(IWhatever)&quot;.  IWhatever is
</I>&gt;<i>sometimes a variable, too - and it's quite common to use 'str', 'int',
</I>&gt;<i>or 'list' there instead of an interface.
</I>&gt;<i>
</I>&gt;<i>Of course, I like the syntactic sugar quite a bit, too :).  It's
</I>&gt;<i>self-documenting.  When I have run tutorials for others on the use of
</I>&gt;<i>components, showing them an error on x.what(), and then success on
</I>&gt;<i>IWhatever(x).what() is enlightening.  Previously,  our analogue of
</I>&gt;<i>&quot;adapt&quot;, &quot;getAdapter&quot;, was difficult to explain.
</I>
Certainly, the convenience is tempting.  I worry more about the lack of 
commonality between 'IFoo(x)' and 'adapt(x,IFoo,somedefault)', from a 
presentation standpoint.

I think I'd like to hear some opinions from some existing PyProtocols users 
who aren't Twisted users before I &quot;pronounce&quot; on this.


&gt;<i>(BTW: a common idiom for using interfaces is to scope method names.  An
</I>&gt;<i>optimization I want to add to Twisted at some point is stateless
</I>&gt;<i>interface-method-call syntax which can do this efficiently, something
</I>&gt;<i>like: IWhatever.what(x).  I believe you should be able to avoid a bunch
</I>&gt;<i>of Python object allocation overhead by doing it that way.  Does
</I>&gt;<i>PyProtocols provide any such facility?)
</I>
Not at the moment.  What I'd like to do at some point is add 
single-dispatch generic functions, though.  Then

class IWhatever:

     def what(self,...):
         ....

would be the default behavior for IWhatever.what(x), and you would define 
implementations via something like:

def what_foo(self,...):
     ...

IWhatever.what.add(what_foo, forTypes=[Foo])



&gt;<i> &gt; Actually, if I understand correctly, these mostly sound like things 
</I>&gt;<i> outside
</I>&gt;<i> &gt; PyProtocols' scope.  peak.binding and peak.config implement some of this
</I>&gt;<i> &gt; stuff by defining various interfaces they want, and using PyProtocols to
</I>&gt;<i> &gt; adapt things to those interfaces.  But that's entirely independent of
</I>&gt;<i> &gt; PyProtocols itself.
</I>&gt;<i>
</I>&gt;<i> &gt; In other words, PyProtocols isn't tightly coupled to a component
</I>&gt;<i> &gt; architecture, but is instead a convenient base for building component
</I>&gt;<i> &gt; architectures.
</I>&gt;<i>
</I>&gt;<i>Perhaps we should be discussing Twisted using PEAK, then?  I don't want
</I>&gt;<i>to use half a component system and implement the other half myself.
</I>
Okay.  The main issue there is going to be that PEAK is definitely still 
alpha, although the core CA stuff is *beginning* to approach PyProtocols' 
stability.  But it's nowhere near PyProtocols in documentedness, of course.


&gt;<i>Maybe you can come up with a counterexample, but it seems to me that the
</I>&gt;<i>benefit of a common protocol system would be lost without the use of a
</I>&gt;<i>common component model.
</I>
I don't really see it that way.  Right now, using PyProtocols, one can 
write components that play in both Zope and PEAK's component 
architectures.  (Granted, that's to some extent because Zope changed their 
CA to be more like PEAK, with interfaces for walking to parents and getting 
config data out of them.)

Not that I'm trying to talk you out of using PEAK's CA, mind.  I'm just 
saying that if you have radically different requirements, you might prefer 
to build your own.  If it's built atop PyProtocols, it'll be even easier to 
integrate your CA with other CAs if people have a need or desire to do so.



&gt;<i> &gt; Let's take a specific example: you mentioned locating nearby services by
</I>&gt;<i> &gt; interface.  peak.config does this with two interfaces: IConfigSource and
</I>&gt;<i> &gt; IConfigKey:
</I>&gt;<i>
</I>&gt;<i>Woah there, sparky!  That looks a lot like the earlier documentation I
</I>&gt;<i>was having trouble with.  A brief example, maybe? :)
</I>
Okay, let's say I want to get a hold of the event loop I should be a 
participant of...

class SomethingThatNeedsEvents(binding.Component):

     eventLoop = binding.Obtain(events.IEventLoop)

Okay, that's it.  That's the brief example.  :)  Seriously, this class is a 
component that, when used as part of a larger application, will 
automatically find the IEventLoop it's supposed to be using.  It may be 
defined in an .ini file, like this:

[Component Factories]
peak.events.interfaces.IEventLoop = &quot;peak.events.io_events.EventLoop&quot;

This says that when somebody asks for an IEventLoop, we will look at the 
requester's &quot;service area&quot; (a specially designated parent component), and 
if the service area doesn't already have one, we'll create a &quot;singleton&quot; 
instance of the peak.events.io_events.EventLoop class.

I say &quot;singleton&quot; in quotes because PEAK avoids true singletons like the 
plague.  Services are homed in a &quot;service area&quot;, so there is usually one 
service instance per service area.  Typically, an app will do all its work 
in a single service area, but sometimes there are reasons to have 
additional service areas.

The other way you can make a service available (besides configuration for a 
service area) is to &quot;offer&quot; them from other components.  For example:

class SomethingWithACustomEventLoop(binding.Component):

     eventLoop = binding.Make(MyEventLoopClass, offerAs=[events.IEventLoop])

Each instance of this component will have its own private event loop 
instance.  In addition, any child component of an instance of this class 
will receive the instance's event loop whenever it requests an IEventLoop 
service.  So, if an instance of the first example class is made a child of 
an instance of this second example class, it will end up iwth a 
MyEventLoopClass instance as its eventLoop attribute.

Is this the sort of thing you're asking about?


&gt;<i> &gt; By the way, though, I don't know what you mean by &quot;default adapter&quot;.  Do
</I>&gt;<i> &gt; you mean the adapter for type 'object', perhaps?  I can't imagine why
</I>&gt;<i> &gt; somebody would care about that, though.
</I>&gt;<i>
</I>&gt;<i>I mean the adapter for type &quot;Thing&quot;, mostly.  The general idea being
</I>&gt;<i>that you want to override what happens before someone picks up a
</I>&gt;<i>&quot;normal&quot; object when they're under the influence of a particular
</I>&gt;<i>enchantment.  It is difficult to specify rules for which enchantment's
</I>&gt;<i>hook takes precedence, so authors get into fights by specifying
</I>&gt;<i>ever-lower numbers.
</I>
Ah.  That sounds like something that calls for a more explicit chain of 
responsibility that's not adapter driven.  That is, a component 
architecture issue.  Adaptation should be something you do to elements in 
the chain of responsibility in order to see if they want to participate in 
the current event.  But maybe I'm misunderstanding something about your use 
case.


&gt;<i>Really, an interface specification / lookup system is a pretty basic
</I>&gt;<i>part of a system which uses it, on par with a function calling
</I>&gt;<i>convention.  I want to know _exactly_ what goes on when I use it; I
</I>&gt;<i>never want to be surprised by a weird component getting looked up when
</I>&gt;<i>that wasn't what I intended.  With so much indirection in place that's
</I>&gt;<i>too easy already.
</I>
There's really an easy solution to that.  If you want to be sure there's no 
confusion, define a new interface when you have a new use case.  And if an 
old interface mostly fits, you can make the new one a Variation of it or 
declare it to be implied by the old one.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="039695.html">[Twisted-Python] Components
</A></li>
	<LI>Next message (by thread): <A HREF="039724.html">[Twisted-Python] Generic functions using PyProtocols (was Re:  Components)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39697">[ date ]</a>
              <a href="thread.html#39697">[ thread ]</a>
              <a href="subject.html#39697">[ subject ]</a>
              <a href="author.html#39697">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
