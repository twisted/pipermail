<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Components
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Components&In-Reply-To=%3C1077836183.3688.137.camel%40localhost%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="039657.html">
   <LINK REL="Next"  HREF="039676.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Components</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Components&In-Reply-To=%3C1077836183.3688.137.camel%40localhost%3E"
       TITLE="[Twisted-Python] Components">glyph at twistedmatrix.com
       </A><BR>
    <I>Thu Feb 26 15:56:23 MST 2004</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="039657.html">[Twisted-Python] Components
</A></li>
        <LI>Next message (by thread): <A HREF="039676.html">[Twisted-Python] Components
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39674">[ date ]</a>
              <a href="thread.html#39674">[ thread ]</a>
              <a href="subject.html#39674">[ subject ]</a>
              <a href="author.html#39674">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 2004-02-26 at 14:59, Phillip J. Eby wrote:
&gt;<i> At 02:43 PM 2/26/04 -0500, Bob Ippolito wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt;How about just migrating off of t.p.components and switching to 
</I>&gt;<i> &gt;PyProtocols?  The license is compatible, it has PEP-backing, it is a 
</I>&gt;<i> &gt;superset of what t.p.components does, has optional Pyrex acceleration, and 
</I>&gt;<i> &gt;is compatible with Interfaces from itself, t.p.components, and 
</I>&gt;<i> &gt;zope.components.  The default Interface implementation does not support 
</I>&gt;<i> &gt;the __call__ adaptation that we all know and love, but it is actually 
</I>&gt;<i> &gt;generic enough to allow it.
</I>&gt;<i> 
</I>&gt;<i> Yep, just subclass InterfaceClass and add a __call__ method that calls back 
</I>&gt;<i> to adapt() and you'd be all set.  One other benefit to PyProtocols is that 
</I>&gt;<i> you can track what interfaces an *instance* supports, independent of what 
</I>&gt;<i> its class supports.
</I>
Would you consider adding this to PyProtocols directly?  If we're going
to maintain a component system as part of Twisted, I would like to at
least get the benefit of having full control over the component system
within Twisted.  I don't want to have some people using PyProtocols and
others using PyProtocols+TwistedHacks.

There are a lot of features I'd add to Twisted's component system if I
had time, such as:

	- implicit context-dependent location of closest running t.a.service
services by interface
	- interface-based context (moshez's context trick)
	- automatic generation of interfaces from any class
	- IComponentized
	- context / interface based log separations

And of course, integrating foom's string-based components would be great
too.  There is a lot of friction even to add something like this to
Twisted.  I imagine that adding something like this to PyProtocols, with
potentially more projects out there depending on the exact specifics of
all its semantics, would be even worse.

The other alternative is to add a bunch of specific hacks to PyProtocols
that get loaded only when Twisted gets loaded, which could potentially
introduce compatibility problems with other PyProtocols-using code,
which would sort of invalidate the whole point of using a common
components system in the first place.

Then we have the issue of the PyProtocols dependency; dependency
management can be quite hairy on windows.

&gt;<i> The more controversial aspect, however, is transitive adaptation.  IIRC, 
</I>&gt;<i> some of the core Twisted developers consider implicit transitive adaptation 
</I>&gt;<i> to be dangerous and/or evil.  However, that could possibly also be dealt 
</I>&gt;<i> with in a protocols.Interface subclass by disabling the parts that support 
</I>&gt;<i> that.
</I>
Before veering off into this, I'd like to retract any comments about
performance.  I tried pyprotocols a while ago, on some simple cases, and
it was pretty slow compared to Twisted's dirt-simple code.  I don't
think I was using the C code path, but it was more than a 2-4x
difference at the time.

I will test again with more reasonable cases before saying anything more
specific.  I bet Twisted has gotten slower and PyProtocols has gotten
faster since then, though.

Parts of PyProtocols do strike me as dangerous, evil, and overcomplex,
though :)  In particular,

<A HREF="http://peak.telecommunity.com/protocol_ref/proto-implication.html">http://peak.telecommunity.com/protocol_ref/proto-implication.html</A>

The idea of passing numeric priorities for different implementations has
always seemed deeply wrong to me.  I have worked with one or two systems
like this in the past (some MUD code in C++) where, inevitably, someone
will want to make the 'real' default adapter for interface X; then
someone else will want to make the 'really real' default adapter. 
Different developers will eventually keep trying to write comparison
methods that leapfrog each other backwards to get to the correct result
for last-most-from-greater-than-everything, which turns into a
bug-ridden mess (and it's never really clear who should be &quot;winning&quot;
this race to be the final overrider anyway).

More importantly I don't really understand if that's in fact what the
'depth' value is used for, because my eyes glaze over halfway through
the above web page :)  PyProtocols feels to me like it's gone out of
even the upper levels of abstraction that the Twisted team is used to
inhabiting, straight into the Zopeosphere... 4000 lines of code related
to components, whereas t.p.components has 300?  It worries me.

Maybe I'm alone in these concerns, though.  Does anyone else feel that
depending on PyProtocols would increase the learning curve for Twisted
even more?  Or is this common knowledge in the Python community that
could be leveraged to actually make the curve shallower?  I can
certainly learn to wrap my head around the whole thing if nobody else
has trouble with it :)

&gt;<i> There might be some other issues that could come up, but I'm definitely 
</I>&gt;<i> willing to try to &quot;adapt&quot; to Twisted's needs in these areas, especially if 
</I>&gt;<i> it means I could get rid of PyProtocols' wrapper code and wrapping tests 
</I>&gt;<i> for Twisted's existing interface class.  :)
</I>
This is clearly something that we need to talk about more.  As many
silly disagreements about design as I can come up with, a common
components system would be beneficial to everyone involved.  Are you
coming to PyCon? :)



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="039657.html">[Twisted-Python] Components
</A></li>
	<LI>Next message (by thread): <A HREF="039676.html">[Twisted-Python] Components
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39674">[ date ]</a>
              <a href="thread.html#39674">[ thread ]</a>
              <a href="subject.html#39674">[ subject ]</a>
              <a href="author.html#39674">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
