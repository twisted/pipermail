<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Factory question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Factory%20question&In-Reply-To=%3C47C7DFC6.3040107%40evotex.ch%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="049423.html">
   <LINK REL="Next"  HREF="049388.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Factory question</H1>
    <B>Gabriel Rossetti</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Factory%20question&In-Reply-To=%3C47C7DFC6.3040107%40evotex.ch%3E"
       TITLE="[Twisted-Python] Factory question">mailing_lists at evotex.ch
       </A><BR>
    <I>Fri Feb 29 03:34:46 MST 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="049423.html">[Twisted-Python] Factory question
</A></li>
        <LI>Next message (by thread): <A HREF="049388.html">[Twisted-Python] How to get an unused port 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49430">[ date ]</a>
              <a href="thread.html#49430">[ thread ]</a>
              <a href="subject.html#49430">[ subject ]</a>
              <a href="author.html#49430">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Gabriel Rossetti wrote:
&gt;<i> Drew Smathers wrote:
</I>&gt;&gt;<i> On Thu, Feb 28, 2008 at 9:42 AM, Gabriel Rossetti
</I>&gt;&gt;<i> &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing_lists at evotex.ch</A>&gt; wrote:
</I>&gt;&gt;<i>  
</I>&gt;&gt;&gt;<i> Drew Smathers wrote:
</I>&gt;&gt;&gt;<i>  &gt; On Wed, Feb 27, 2008 at 3:32 AM, Gabriel Rossetti
</I>&gt;&gt;&gt;<i>  &gt; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing_lists at evotex.ch</A>&gt; wrote:
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt;&gt; Hello everyone,
</I>&gt;&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;&gt;<i>  &gt;&gt;  I have a small question, I have a service which needs to 
</I>&gt;&gt;&gt;<i> sometimes send
</I>&gt;&gt;&gt;<i>  &gt;&gt;  data (without having received any prior to sending) and sometimes
</I>&gt;&gt;&gt;<i>  &gt;&gt;  receive data, which is better :
</I>&gt;&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;&gt;<i>  &gt;&gt;  1) create a factory that inherits from ServerFactory and 
</I>&gt;&gt;&gt;<i> ClientFactory,
</I>&gt;&gt;&gt;<i>  &gt;&gt;  thus it can listen and send data
</I>&gt;&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;&gt;<i>  &gt;&gt;  2) create a factory that inherits from ServerFactory only and 
</I>&gt;&gt;&gt;<i> uses a
</I>&gt;&gt;&gt;<i>  &gt;&gt;  single-use client (ClientCreator, as shown in the writing 
</I>&gt;&gt;&gt;<i> clients howto)
</I>&gt;&gt;&gt;<i>  &gt;&gt;  when it needs to send data
</I>&gt;&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt; I'm not sure of there's a single right way to do it, but I wouldn't
</I>&gt;&gt;&gt;<i>  &gt; bother inheriting from both ClientFactory and ServerFactory.  I 
</I>&gt;&gt;&gt;<i> think
</I>&gt;&gt;&gt;<i>  &gt; you're on the write track with 2, though.
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  I had taken route 1 up until now (I'm thinking about switching...)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  Maybe there's something I haven't quite gotten, when ClientA initially
</I>&gt;&gt;&gt;<i>  connects to the server, the factory creates an instance of the 
</I>&gt;&gt;&gt;<i> protocol,
</I>&gt;&gt;&gt;<i>  correct?
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>&gt;<i> Ok
</I>&gt;&gt;&gt;<i> Now ClientA sends some data to the server, which processes it
</I>&gt;&gt;&gt;<i>  and sends something back. After that, the TCP session ends, and the
</I>&gt;&gt;&gt;<i>  client disconnects, and the protocols instance dies. Is this 
</I>&gt;&gt;&gt;<i> correct or
</I>&gt;&gt;&gt;<i>  does it live on and get reused somehow?
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The protocol instance does not get reused.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>&gt;<i> Ok, so every time there is data exchanged (new tcp/ip session) then a 
</I>&gt;<i> new protocol instance is created. Any persistence/state data must 
</I>&gt;<i> therefore be stored in the factory if I understand correctly.
</I>&gt;&gt;&gt;<i>  I ask this because since
</I>&gt;&gt;&gt;<i>  initially the clients send data to the server (registration), the 
</I>&gt;&gt;&gt;<i> server
</I>&gt;&gt;&gt;<i>  will there after send data to the clients. This makes the client 
</I>&gt;&gt;&gt;<i> have to
</I>&gt;&gt;&gt;<i>  connect to the server initially though a port using 
</I>&gt;&gt;&gt;<i> reactor.connectTCP()
</I>&gt;&gt;&gt;<i>  and listen to a port (that the server now knows since the client
</I>&gt;&gt;&gt;<i>  registered itself) using reactor.listenTCP().
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is might be a bad idea - depending on the locality of your
</I>&gt;&gt;<i> servers and clients. Why not just use the established connection?  
</I>&gt;<i> The idea is to have services register on a central server then they 
</I>&gt;<i> transmit messages to the daemon which routes/relays them to the 
</I>&gt;<i> correct service, sort of like a micro-kernel. So, sometimes the 
</I>&gt;<i> services initiate the communication process and sometimes they don't, 
</I>&gt;<i> the central server does. This makes the services be servers and 
</I>&gt;<i> clients. Imagine this :
</I>&gt;<i>
</I>&gt;<i> service1 has some data that needs to be processed by service2 (which 
</I>&gt;<i> will in turn send it to another service), is sends it to the central 
</I>&gt;<i> server, which sends it to service2. Service2 does whatever it has to 
</I>&gt;<i> do, and then sends it to the central server to route to service_n.
</I>&gt;<i>
</I>&gt;<i> So the established connection is usually useless, except for sending 
</I>&gt;<i> some sort of ACK maybe.
</I>&gt;<i>
</I>&gt;&gt;<i> If
</I>&gt;&gt;<i> the *client* is listening on a port then it isn't just a client - it's
</I>&gt;&gt;<i> a server, or a peer in a clustered system.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>&gt;<i> I guess it's/they a sort of peer(s) in a clustered system, it/they may 
</I>&gt;<i> reside on the same machine as the central server or not.
</I>&gt;&gt;&gt;<i>  I think I have to use
</I>&gt;&gt;&gt;<i>  reactor.connectTCP() instead of  ClientCreator since the connection 
</I>&gt;&gt;&gt;<i> has
</I>&gt;&gt;&gt;<i>  to happen at the beginning and a transport needs to exist before I can
</I>&gt;&gt;&gt;<i>  send anything. Well...now that I think about it, I could have the
</I>&gt;&gt;&gt;<i>  factory register the client...... that would make me not have to 
</I>&gt;&gt;&gt;<i> inherit
</I>&gt;&gt;&gt;<i>  from the Client factory.... (I've now switched to solution 2, see last
</I>&gt;&gt;&gt;<i>  part of this email).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ok.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  
</I>&gt;&gt;&gt;&gt;<i> In most use cases you shouldn't have to create custom factories.
</I>&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;<i>  I have to since I need a non-reconnecting client xmlstream, and the
</I>&gt;&gt;&gt;<i>  factory used with xmlstreams is a reconnecting client.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>    
</I>&gt;&gt;&gt;&gt;<i> Just
</I>&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;<i>  &gt; write the protocol to support bidirectional comm and to create the
</I>&gt;&gt;&gt;<i>  &gt; server:
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt; f = Factory()
</I>&gt;&gt;&gt;<i>  &gt; f.protocol = YourBidirectionalProtocol
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt; Regarding the client, how you implement it depends on whether or not
</I>&gt;&gt;&gt;<i>  &gt; the server is establishing the connection vs. reusing the existing
</I>&gt;&gt;&gt;<i>  &gt; connection.
</I>&gt;&gt;&gt;<i>  What exactly do you mean by reusing an existing connection?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>    
</I>&gt;&gt;&gt;&gt;<i> If you're establishing the connection (like in a cluster
</I>&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;<i>  &gt; app with known peers), just use ClientCreator.  If you're reusing 
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i>  &gt; existing connection, then you might not have to anything, unless you
</I>&gt;&gt;&gt;<i>  &gt; have some state to set up which could be done by overriding
</I>&gt;&gt;&gt;<i>  &gt; connectionMade on your Protocol.
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt; Finally, take everything I've stated above with a grain of salt.
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  &gt;
</I>&gt;&gt;&gt;<i>  Thanks, I find it fairly hard to get used to Twisted, I wanted to buy
</I>&gt;&gt;&gt;<i>  the book, but it was written in 2005 and I'm not sure if it's still
</I>&gt;&gt;&gt;<i>  valid with today's version.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The book it is not up to date.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  
</I>&gt;&gt;&gt;<i>  BTW, any idea why I'm getting this type of behavior (one server, 3
</I>&gt;&gt;&gt;<i>  distinct connections from clients) :
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Without seeing your code, no.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>Ok, I figured out what is wrong, when the factories are created, I add a 
bootstrap to an event that will call a callback when that event is 
received. In the central server, when a client/service connects, the 
callback is called and xml event observers are added (and now I added a 
method that removes them when the client disconnects). What happens is 
when a second client connects, the event calls the callback for every 
instance of the protocol, not just the one for the current connection. I 
traced it down to the following code in   :

        self.addBootstrap(xmlstream.STREAM_START_EVENT, xs._connected)
        self.addBootstrap(xmlstream.STREAM_END_EVENT, xs._disconnected)
       
        for event, fn in self.bootstraps:
            xs.addObserver(event, fn)

since the original XmlStreamFactory/XmlStreamFactoryMixin was designed 
to be a XML client and not a server, it has no notion of differentiating 
protocol instances (since there is only one)

Gabriel
&gt;<i> ok, it's a bit long.....
</I>&gt;<i>
</I>&gt;<i> -------------------------&quot;Central server&quot; aka 
</I>&gt;<i> Daemon--------------------------------------------------------------------------- 
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class MdfXmlStreamFactory(XmlStreamFactoryMixin):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    The factory class used by the daemon and services to create
</I>&gt;<i>    protocol instances
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>      def __init__(self, proto, *args, **kwargs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Constructor
</I>&gt;<i>              @param proto: the protocol to use
</I>&gt;<i>        @type proto: a subclass of 
</I>&gt;<i> L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
</I>&gt;<i>        @param args: misc args
</I>&gt;<i>        @type args: C{tuple}
</I>&gt;<i>        @param kwargs: misc keyword args
</I>&gt;<i>        @type kwargs: C{dict}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        XmlStreamFactoryMixin.__init__(self)
</I>&gt;<i>        self.args = args
</I>&gt;<i>        self.kwargs = kwargs
</I>&gt;<i>        self.protocol = proto
</I>&gt;<i>
</I>&gt;<i>    def buildProtocol(self, addr):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Builds the protocol and
</I>&gt;<i>              @param addr: The address (protocol, IP, port) of the 
</I>&gt;<i> connection
</I>&gt;<i>        @type addr: 
</I>&gt;<i> L{IPv4Address&lt;twisted.internet.address._ServerFactoryIPv4Address&gt;}
</I>&gt;<i>              @return: an instance of the built protocol
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        #self.resetDelay()
</I>&gt;<i>        xs = self.protocol(*self.args, **self.kwargs)
</I>&gt;<i>        xs.factory = self
</I>&gt;<i>        self.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT, 
</I>&gt;<i> xs.connected) # stream connect event or xml start event???
</I>&gt;<i>        for event, fn in self.bootstraps:
</I>&gt;<i>            xs.addObserver(event, fn)
</I>&gt;<i>
</I>&gt;<i>        return xs
</I>&gt;<i>
</I>&gt;<i> class MdfXmlStreamServerFactory(MdfXmlStreamFactory, ServerFactory):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    The factory class used by the daemon to create
</I>&gt;<i>    protocol instances
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>      # The registered services
</I>&gt;<i>    _services = {}
</I>&gt;<i>      def __init__(self, proto, *args, **kwargs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Constructor
</I>&gt;<i>              @param proto: the protocol to use
</I>&gt;<i>        @type proto: a subclass of 
</I>&gt;<i> L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
</I>&gt;<i>        @param args: misc args
</I>&gt;<i>        @type args: C{tuple}
</I>&gt;<i>        @param kwargs: misc keyword args
</I>&gt;<i>        @type kwargs: C{dict}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        MdfXmlStreamFactory.__init__(self, proto, *args, **kwargs)
</I>&gt;<i>
</I>&gt;<i> class Daemon(xmlstream.XmlStream):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    The daemon is the implementation of a microkernel type inter-service
</I>&gt;<i>    communication (ISC) routing daemon. Here is how it works :
</I>&gt;<i>          - Services announce their presence to the daemon by giving 
</I>&gt;<i> their name,
</I>&gt;<i>          version, ip, port and a list of message-types that they accept
</I>&gt;<i>        - The daemon listens for messages from the attached services, 
</I>&gt;<i> when one
</I>&gt;<i>          is received, it routes the message to the correct service
</I>&gt;<i>      @todo: add unique id generation/verification
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>      # Holds the real method
</I>&gt;<i>    __dataReceived = xmlstream.XmlStream.dataReceived
</I>&gt;<i>      # The registered services
</I>&gt;<i>    #__services = {}
</I>&gt;<i>    cnt = 1
</I>&gt;<i>      def __init__(self, *args, **kwargs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Constructor
</I>&gt;<i>              @param args: non-keyword args
</I>&gt;<i>        @type args: C{tuple}
</I>&gt;<i>        @param kwargs: keyword args
</I>&gt;<i>        @type kwargs: C{dict}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        xmlstream.XmlStream.__init__(self)
</I>&gt;<i>        self.__routeTo = None
</I>&gt;<i>        self.__lastMsgType = None
</I>&gt;<i>        self.__lastMsgId = None
</I>&gt;<i>        self.inst = Daemon.cnt
</I>&gt;<i>        Daemon.cnt += 1
</I>&gt;<i>        print &quot;daemon proto instance %d&quot; % self.inst
</I>&gt;<i>            def connectionMade(self):
</I>&gt;<i>        xmlstream.XmlStream.connectionMade(self)
</I>&gt;<i>      def dataReceived(self, data):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Called everytime data is received
</I>&gt;<i>              @param data: the data received
</I>&gt;<i>        @type data: C{object} (anything)
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        self.__dataReceived(data)
</I>&gt;<i>          def connectionLost(self, reason):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Called when the connection is shut down, restores the
</I>&gt;<i>        dataReceived method
</I>&gt;<i>              @param reason: the reason why the connection was lost
</I>&gt;<i>        @type reason: C{str}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        self.__dataReceived = xmlstream.XmlStream.dataReceived
</I>&gt;<i>        self.__routeTo = None
</I>&gt;<i>        xmlstream.XmlStream.connectionLost(self, reason)
</I>&gt;<i>      def __onHeader(self, element):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Analyse a header and set the data's recipiant
</I>&gt;<i>              @param element: the header element (XML)
</I>&gt;<i>        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        print &quot;got header from %s:%s : %s&quot; % 
</I>&gt;<i> (str(self.transport.getPeer().host), 
</I>&gt;<i> str(self.transport.getPeer().port), element.toXml())
</I>&gt;<i>              self.__lastMsgId = element.getAttribute(&quot;id&quot;)
</I>&gt;<i>        self.__lastMsgType = element.getAttribute(&quot;type&quot;)
</I>&gt;<i>        if(self.__lastMsgType != constants._REG_MSG_TYPE):
</I>&gt;<i>            self.__routeTo = self.factory._services[type]
</I>&gt;<i>            self.__dataReceived = __routeDataReceived
</I>&gt;<i>      def __onReg(self, element):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Register a service
</I>&gt;<i>              @param element: the registeration element (XML)
</I>&gt;<i>        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        print &quot;got reg from %s:%s : %s&quot; % 
</I>&gt;<i> (str(self.transport.getPeer().host), 
</I>&gt;<i> str(self.transport.getPeer().port), element.toXml())
</I>&gt;<i>
</I>&gt;<i>        name = 
</I>&gt;<i> str(xpath.XPathQuery(&quot;/body/reg/name&quot;).queryForNodes(element)[0])
</I>&gt;<i>        version = 
</I>&gt;<i> str(xpath.XPathQuery(&quot;/body/reg/version&quot;).queryForNodes(element)[0])
</I>&gt;<i>        #address = 
</I>&gt;<i> str(xpath.XPathQuery(&quot;/body/reg/address&quot;).queryForNodes(element)[0])
</I>&gt;<i>        port = 
</I>&gt;<i> int(str(xpath.XPathQuery(&quot;/body/reg/port&quot;).queryForNodes(element)[0]))
</I>&gt;<i>        msgs = [ str(m) for m in 
</I>&gt;<i> xpath.XPathQuery(&quot;/body/reg/message_type&quot;).queryForNodes(element) ]
</I>&gt;<i>              address = self.transport.getPeer().host
</I>&gt;<i>        #port = self.transport.getPeer().port
</I>&gt;<i>        serv = ServiceReg(name, version, msgs, address, port)
</I>&gt;<i>        self.__registerService(serv)
</I>&gt;<i>          def connected(self, xs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Called when a client connects using an XML stream
</I>&gt;<i>              @param xs: the current xml stream
</I>&gt;<i>        @type xs: L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>              print 'Connection from %s:%s!' % 
</I>&gt;<i> (str(self.transport.getPeer().host), str(self.transport.getPeer().port))
</I>&gt;<i>        xs.addObserver(&quot;/header&quot;, self.__onHeader)
</I>&gt;<i>        xs.addObserver(&quot;/body/reg&quot;, self.__onReg)
</I>&gt;<i>          def __routeDataReceived(self, data):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Pushes the messages to the correct service
</I>&gt;<i>              @param data: the data received
</I>&gt;<i>        @type data: C{object} (anything)
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        print &quot;route '%s' to : %s&quot; % (str(data), self.__routeTo)
</I>&gt;<i>              utils.sendMessage(self.__routeTo.ip, self.__routeTo.port, 
</I>&gt;<i> data)
</I>&gt;<i>        #self.send(data)
</I>&gt;<i>          def __registerService(self, service):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Register a service
</I>&gt;<i>              @param service: the service to register
</I>&gt;<i>        @type service: L{ServiceReg}
</I>&gt;<i>              @raise ServiceMessageConflictError: if another service 
</I>&gt;<i> already has a
</I>&gt;<i>                                            message registered that the 
</I>&gt;<i> current
</I>&gt;<i>                                            service is trying to register
</I>&gt;<i>              @todo: what is to be done with the exception once 
</I>&gt;<i> raised???? Finish status message...
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>              def foundConflict(self, msgTypes):
</I>&gt;<i>            &quot;&quot;&quot;
</I>&gt;<i>            Check if there is a conflict with message types to be 
</I>&gt;<i> registered
</I>&gt;<i>            by this service
</I>&gt;<i>                      @param service: the service messages to check for 
</I>&gt;<i> conflicts
</I>&gt;<i>            @type service: C{str}
</I>&gt;<i>                      @return: the conflicting service type or None if no
</I>&gt;<i>                    conflict is found
</I>&gt;<i>            &quot;&quot;&quot;
</I>&gt;<i>            for mt in msgTypes:
</I>&gt;<i>                if(self.factory._services.has_key(mt)):
</I>&gt;<i>                    return mt
</I>&gt;<i>            return None
</I>&gt;<i>              print &quot;Registering service : &quot;, str(service)
</I>&gt;<i>              try:
</I>&gt;<i>            #
</I>&gt;<i>            # Check if another service already registered a message 
</I>&gt;<i> type that
</I>&gt;<i>            # the current service is trying to register
</I>&gt;<i>            #
</I>&gt;<i>            conflict = foundConflict(self, service.acceptedMsgs)
</I>&gt;<i>            if(conflict != None):
</I>&gt;<i>                raise ServiceMessageConflictError(conflict)
</I>&gt;<i>                      #
</I>&gt;<i>            # Regrister the message types and this service
</I>&gt;<i>            #
</I>&gt;<i>            for msgType in service.acceptedMsgs:
</I>&gt;<i>                self.factory._services[msgType] = service
</I>&gt;<i>                      except ServiceMessageConflictError, reason:
</I>&gt;<i>            status = 
</I>&gt;<i> utils.createConfirmationMsgBody(constants._MSG_FAILURE_TYPE,
</I>&gt;<i>                                                     self.__lastMsgId, 
</I>&gt;<i> str(reason))
</I>&gt;<i>        else:
</I>&gt;<i>            status = 
</I>&gt;<i> utils.createConfirmationMsgBody(constants._MSG_SUCCESS_TYPE,
</I>&gt;<i>                                                     self.__lastMsgId)
</I>&gt;<i>                  #
</I>&gt;<i>        # Send registeration confirmation (succeeded or failed)
</I>&gt;<i>        #
</I>&gt;<i>        msgRoot = utils.createMessage(constants._REG_MSG_CONFIRM_TYPE,
</I>&gt;<i>                                      constants._CONF_MSG_ID,
</I>&gt;<i>                                      constants._DAEMON_SERVICE_NAME,
</I>&gt;<i>                                      constants._MSG_SPEC_VERSION,
</I>&gt;<i>                                      constants._STATUS_DATA_TYPE, status)
</I>&gt;<i>              print &quot;Sending confirmation message to %s : %s&quot; % 
</I>&gt;<i> (self.transport.getPeer().host, msgRoot.toXml())
</I>&gt;<i>              #self.send(msgRoot)
</I>&gt;<i>        utils.sendMessage(self.transport.getPeer().host, service.port, 
</I>&gt;<i> msgRoot)
</I>&gt;<i>   if(__name__ == &quot;__main__&quot;):
</I>&gt;<i>
</I>&gt;<i>    reactor.listenTCP(4321, MdfXmlStreamServerFactory(Daemon))
</I>&gt;<i>    print &quot;Listening for connections...&quot;
</I>&gt;<i>    reactor.run()
</I>&gt;<i>
</I>&gt;<i> ----------------------------------------&quot;Service&quot;----------------------------------------------------------------------------------------------------- 
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class MdfXmlStreamClientFactory(MdfXmlStreamServerFactory):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    The factory class used by the services to create
</I>&gt;<i>    protocol instances
</I>&gt;<i>      @attention: this class might dissapear, I have to see if it's 
</I>&gt;<i> useful to keep it or not
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>      __daemonAddrs = None
</I>&gt;<i>    __daemonPort = None
</I>&gt;<i>      def __init__(self, proto, *args, **kwargs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Constructor
</I>&gt;<i>              @param proto: the protocol to use
</I>&gt;<i>        @type proto: a subclass of 
</I>&gt;<i> L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
</I>&gt;<i>        @param args: misc args
</I>&gt;<i>        @type args: C{tuple}
</I>&gt;<i>        @param kwargs: misc keyword args
</I>&gt;<i>        @type kwargs: C{dict}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        MdfXmlStreamServerFactory.__init__(self, proto, *args, **kwargs)
</I>&gt;<i>        self._serviceInfo = ServiceReg(kwargs[&quot;name&quot;], 
</I>&gt;<i> kwargs[&quot;version&quot;], list(kwargs.get(&quot;messageTypes&quot;, [])))
</I>&gt;<i>        MdfXmlStreamClientFactory.__daemonAddrs = kwargs[&quot;address&quot;]
</I>&gt;<i>        MdfXmlStreamClientFactory.__daemonPort = kwargs[&quot;port&quot;]
</I>&gt;<i>          def register(self, port):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Register the service
</I>&gt;<i>              @param port: the service's port
</I>&gt;<i>        @type port: C{int}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        self._serviceInfo.port = port
</I>&gt;<i>        msgBodyData = utils.createRegMsgBody(self._serviceInfo.name,
</I>&gt;<i>                                             self._serviceInfo.version,
</I>&gt;<i>                                             str(self._serviceInfo.port),
</I>&gt;<i>                                             
</I>&gt;<i> self._serviceInfo.acceptedMsgs)
</I>&gt;<i>              msgRoot = utils.createMessage(constants._REG_MSG_TYPE,
</I>&gt;<i>                                      constants._REG_MSG_ID,
</I>&gt;<i>                                      self._serviceInfo.name,
</I>&gt;<i>                                      constants._MSG_SPEC_VERSION,
</I>&gt;<i>                                      constants._REG_DATA_TYPE, 
</I>&gt;<i> msgBodyData)
</I>&gt;<i>              utils.sendMessage(MdfXmlStreamClientFactory.__daemonAddrs,
</I>&gt;<i>                          MdfXmlStreamClientFactory.__daemonPort,
</I>&gt;<i>                          msgRoot)
</I>&gt;<i>
</I>&gt;<i> class BaseService(xmlstream.XmlStream):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    The service is the implementation of a microkernel type inter-service
</I>&gt;<i>    communication (ISC) endpoint. Here is how it works :
</I>&gt;<i>          - Services announce their presence to the daemon by giving 
</I>&gt;<i> their name,
</I>&gt;<i>          version, ip, port and a list of message-types that they accept
</I>&gt;<i>        - The daemon listens for messages from the attached services, 
</I>&gt;<i> when one
</I>&gt;<i>          is received, it routes the message to the correct service
</I>&gt;<i>            @todo: add unique id generation/verification
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>      def __init__(self, *args, **kwargs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Constructor
</I>&gt;<i>              @param args: non-keyword args
</I>&gt;<i>        @type args: C{tuple}
</I>&gt;<i>        @param kwargs: keyword args
</I>&gt;<i>        @type kwargs: C{dict}
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        xmlstream.XmlStream.__init__(self)
</I>&gt;<i>        self._msgSrc = None
</I>&gt;<i>        self._msgDest = None
</I>&gt;<i>        self._msgBodyData = None
</I>&gt;<i>        self._registered = False
</I>&gt;<i>      def _onHeader(self, element):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Analyse a header and save the source and destination
</I>&gt;<i>              @param element: the header element (XML)
</I>&gt;<i>        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
</I>&gt;<i>              @todo: add msg spec version verification
</I>&gt;<i>        @todo: add id verification???
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        print &quot;got header from %s:%s : %s&quot; % 
</I>&gt;<i> (str(self.transport.getPeer().host), 
</I>&gt;<i> str(self.transport.getPeer().port), element.toXml())
</I>&gt;<i>              self._msgSrc = 
</I>&gt;<i> xpath.XPathQuery(&quot;/header&quot;).queryForNodes(element)[0].getAttribute(&quot;source&quot;) 
</I>&gt;<i>
</I>&gt;<i>        self._msgDest = 
</I>&gt;<i> xpath.XPathQuery(&quot;/header&quot;).queryForNodes(element)[0].getAttribute(&quot;destination&quot;) 
</I>&gt;<i>
</I>&gt;<i>          def _onBody(self, element):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Get the body act accordingly
</I>&gt;<i>              @param element: the body element (XML)
</I>&gt;<i>        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
</I>&gt;<i>              @todo: add data type verification
</I>&gt;<i>        @todo: call data action callbacks
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        self._msgBodyData = 
</I>&gt;<i> xpath.XPathQuery(&quot;/body&quot;).queryForNodes(element)[0].toXml()
</I>&gt;<i>        print &quot;_onbody : &quot;, self._msgBodyData
</I>&gt;<i>          def _onConfirm(self, element):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Get the confirmation message and act accordingly
</I>&gt;<i>              @param element: the confirmation element (XML)
</I>&gt;<i>        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
</I>&gt;<i>              @todo: add data type verification
</I>&gt;<i>        @todo: call data action callbacks
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        status = 
</I>&gt;<i> str(xpath.XPathQuery(&quot;/body/conf/status&quot;).queryForNodes(element)[0])
</I>&gt;<i>        id = 
</I>&gt;<i> int(str(xpath.XPathQuery(&quot;/body/conf/id&quot;).queryForNodes(element)[0]))
</I>&gt;<i>        msg = 
</I>&gt;<i> str(xpath.XPathQuery(&quot;/body/conf/msg&quot;).queryForNodes(element)[0])
</I>&gt;<i>        if(id == constants._REG_MSG_ID):
</I>&gt;<i>            if(status == constants._MSG_SUCCESS_TYPE):
</I>&gt;<i>                self._registered = True
</I>&gt;<i>          def connected(self, xs):
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        Called when a client connects using an XML stream
</I>&gt;<i>              @param xs: the current xml stream
</I>&gt;<i>        @type xs: L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
</I>&gt;<i>              @todo: add data action callbacks
</I>&gt;<i>        &quot;&quot;&quot;
</I>&gt;<i>        print 'Connection from %s:%s!' % 
</I>&gt;<i> (str(self.transport.getPeer().host), str(self.transport.getPeer().port))
</I>&gt;<i>        xs.addObserver(&quot;/header&quot;, self._onHeader)
</I>&gt;<i>        xs.addObserver(&quot;/body/conf&quot;, self._onConfirm)
</I>&gt;<i>        xs.addObserver(&quot;/body&quot;, self._onBody)
</I>&gt;<i>      
</I>&gt;<i> def start(daemonAddrs, daemonPort, serviceRef, serviceName, 
</I>&gt;<i> serviceVersion, serviceMessageTypes):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    Start the daemon
</I>&gt;<i>      @param daemonPort: the port the daemon listens on
</I>&gt;<i>    @type daemonPort: C{int}
</I>&gt;<i>    @param serviceRef: a reference to the service's class
</I>&gt;<i>    @type serviceRef: a subclass of L{BaseService&lt;service.BaseService&gt;}
</I>&gt;<i>    @param serviceName: the service's name
</I>&gt;<i>    @type serviceName: C{str}
</I>&gt;<i>    @param serviceVersion: the service's version
</I>&gt;<i>    @type serviceVersion: C{str}
</I>&gt;<i>    @param serviceMessageTypes: the list of messages the service registers
</I>&gt;<i>    @type serviceMessageTypes: C{str list}
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    f = MdfXmlStreamClientFactory(serviceRef, address=daemonAddrs, 
</I>&gt;<i> port=daemonPort, name=serviceName, version=serviceVersion, 
</I>&gt;<i> messageTypes=serviceMessageTypes)
</I>&gt;<i>    port = reactor.listenTCP(0, f).getHost().port
</I>&gt;<i>    f.register(port)
</I>&gt;<i>    print port
</I>&gt;<i>      reactor.run()
</I>&gt;<i>
</I>&gt;<i> if(__name__ == &quot;__main__&quot;):
</I>&gt;<i>
</I>&gt;<i>    start(&quot;localhost&quot;, 4321, BaseService, &quot;service_base&quot;, &quot;1.0&quot;, [&quot;all&quot;])
</I>&gt;&gt;&gt;<i>  Daemon listening for connections...
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  daemon proto instance 1
</I>&gt;&gt;&gt;<i>  Connection from 127.0.0.1:57821! &lt;-- ok, Client1
</I>&gt;&gt;&gt;<i>  ....
</I>&gt;&gt;&gt;<i>  daemon proto instance 2
</I>&gt;&gt;&gt;<i>  Connection from 127.0.0.1:57821! &lt;-- Client1 again????? why?
</I>&gt;&gt;&gt;<i>  Connection from 127.0.0.1:57823! &lt;-- ok, Client2
</I>&gt;&gt;&gt;<i>  ....
</I>&gt;&gt;&gt;<i>  daemon proto instance 3
</I>&gt;&gt;&gt;<i>  Connection from 127.0.0.1:57821! &lt;-- ok, Client1 again????? why?
</I>&gt;&gt;&gt;<i>  Connection from 127.0.0.1:57823! &lt;-- ok, Client2 again????? why?
</I>&gt;&gt;&gt;<i>  Connection from 127.0.0.1:57824! &lt;-- ok, Client3
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  Oh, and by the time I finished writing this email, I've switched to
</I>&gt;&gt;&gt;<i>  solution 2, but I still get the  behavior above.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  _______________________________________________
</I>&gt;&gt;&gt;<i>  Twisted-Python mailing list
</I>&gt;&gt;&gt;<i>  <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;&gt;&gt;<i>  <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>&gt;<i> Thank you,
</I>&gt;<i> Gabriel
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="049423.html">[Twisted-Python] Factory question
</A></li>
	<LI>Next message (by thread): <A HREF="049388.html">[Twisted-Python] How to get an unused port 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49430">[ date ]</a>
              <a href="thread.html#49430">[ thread ]</a>
              <a href="subject.html#49430">[ subject ]</a>
              <a href="author.html#49430">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
