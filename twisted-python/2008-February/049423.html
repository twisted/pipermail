<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Factory question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Factory%20question&In-Reply-To=%3C47C6DDE5.7030207%40evotex.ch%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="049422.html">
   <LINK REL="Next"  HREF="049430.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Factory question</H1>
    <B>Gabriel Rossetti</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Factory%20question&In-Reply-To=%3C47C6DDE5.7030207%40evotex.ch%3E"
       TITLE="[Twisted-Python] Factory question">mailing_lists at evotex.ch
       </A><BR>
    <I>Thu Feb 28 09:14:29 MST 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="049422.html">[Twisted-Python] Factory question
</A></li>
        <LI>Next message (by thread): <A HREF="049430.html">[Twisted-Python] Factory question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49423">[ date ]</a>
              <a href="thread.html#49423">[ thread ]</a>
              <a href="subject.html#49423">[ subject ]</a>
              <a href="author.html#49423">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Drew Smathers wrote:
&gt;<i> On Thu, Feb 28, 2008 at 9:42 AM, Gabriel Rossetti
</I>&gt;<i> &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing_lists at evotex.ch</A>&gt; wrote:
</I>&gt;<i>   
</I>&gt;&gt;<i> Drew Smathers wrote:
</I>&gt;&gt;<i>  &gt; On Wed, Feb 27, 2008 at 3:32 AM, Gabriel Rossetti
</I>&gt;&gt;<i>  &gt; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing_lists at evotex.ch</A>&gt; wrote:
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt;&gt; Hello everyone,
</I>&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;<i>  &gt;&gt;  I have a small question, I have a service which needs to sometimes send
</I>&gt;&gt;<i>  &gt;&gt;  data (without having received any prior to sending) and sometimes
</I>&gt;&gt;<i>  &gt;&gt;  receive data, which is better :
</I>&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;<i>  &gt;&gt;  1) create a factory that inherits from ServerFactory and ClientFactory,
</I>&gt;&gt;<i>  &gt;&gt;  thus it can listen and send data
</I>&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;<i>  &gt;&gt;  2) create a factory that inherits from ServerFactory only and uses a
</I>&gt;&gt;<i>  &gt;&gt;  single-use client (ClientCreator, as shown in the writing clients howto)
</I>&gt;&gt;<i>  &gt;&gt;  when it needs to send data
</I>&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;<i>  &gt;&gt;
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt; I'm not sure of there's a single right way to do it, but I wouldn't
</I>&gt;&gt;<i>  &gt; bother inheriting from both ClientFactory and ServerFactory.  I think
</I>&gt;&gt;<i>  &gt; you're on the write track with 2, though.
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  I had taken route 1 up until now (I'm thinking about switching...)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  Maybe there's something I haven't quite gotten, when ClientA initially
</I>&gt;&gt;<i>  connects to the server, the factory creates an instance of the protocol,
</I>&gt;&gt;<i>  correct?
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Yes.
</I>&gt;<i>
</I>&gt;<i>   
</I>Ok
&gt;&gt;<i> Now ClientA sends some data to the server, which processes it
</I>&gt;&gt;<i>  and sends something back. After that, the TCP session ends, and the
</I>&gt;&gt;<i>  client disconnects, and the protocols instance dies. Is this correct or
</I>&gt;&gt;<i>  does it live on and get reused somehow?
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> The protocol instance does not get reused.
</I>&gt;<i>
</I>&gt;<i>   
</I>Ok, so every time there is data exchanged (new tcp/ip session) then a 
new protocol instance is created. Any persistence/state data must 
therefore be stored in the factory if I understand correctly.
&gt;&gt;<i>  I ask this because since
</I>&gt;&gt;<i>  initially the clients send data to the server (registration), the server
</I>&gt;&gt;<i>  will there after send data to the clients. This makes the client have to
</I>&gt;&gt;<i>  connect to the server initially though a port using reactor.connectTCP()
</I>&gt;&gt;<i>  and listen to a port (that the server now knows since the client
</I>&gt;&gt;<i>  registered itself) using reactor.listenTCP().
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> This is might be a bad idea - depending on the locality of your
</I>&gt;<i> servers and clients. Why not just use the established connection?  
</I>The idea is to have services register on a central server then they 
transmit messages to the daemon which routes/relays them to the correct 
service, sort of like a micro-kernel. So, sometimes the services 
initiate the communication process and sometimes they don't, the central 
server does. This makes the services be servers and clients. Imagine this :

service1 has some data that needs to be processed by service2 (which 
will in turn send it to another service), is sends it to the central 
server, which sends it to service2. Service2 does whatever it has to do, 
and then sends it to the central server to route to service_n.

So the established connection is usually useless, except for sending 
some sort of ACK maybe.

&gt;<i> If
</I>&gt;<i> the *client* is listening on a port then it isn't just a client - it's
</I>&gt;<i> a server, or a peer in a clustered system.
</I>&gt;<i>
</I>&gt;<i>   
</I>I guess it's/they a sort of peer(s) in a clustered system, it/they may 
reside on the same machine as the central server or not.
&gt;&gt;<i>  I think I have to use
</I>&gt;&gt;<i>  reactor.connectTCP() instead of  ClientCreator since the connection has
</I>&gt;&gt;<i>  to happen at the beginning and a transport needs to exist before I can
</I>&gt;&gt;<i>  send anything. Well...now that I think about it, I could have the
</I>&gt;&gt;<i>  factory register the client...... that would make me not have to inherit
</I>&gt;&gt;<i>  from the Client factory.... (I've now switched to solution 2, see last
</I>&gt;&gt;<i>  part of this email).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Ok.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;&gt;<i> In most use cases you shouldn't have to create custom factories.
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i>  I have to since I need a non-reconnecting client xmlstream, and the
</I>&gt;&gt;<i>  factory used with xmlstreams is a reconnecting client.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i> Just
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i>  &gt; write the protocol to support bidirectional comm and to create the
</I>&gt;&gt;<i>  &gt; server:
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt; f = Factory()
</I>&gt;&gt;<i>  &gt; f.protocol = YourBidirectionalProtocol
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt; Regarding the client, how you implement it depends on whether or not
</I>&gt;&gt;<i>  &gt; the server is establishing the connection vs. reusing the existing
</I>&gt;&gt;<i>  &gt; connection.
</I>&gt;&gt;<i>  What exactly do you mean by reusing an existing connection?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i> If you're establishing the connection (like in a cluster
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i>  &gt; app with known peers), just use ClientCreator.  If you're reusing the
</I>&gt;&gt;<i>  &gt; existing connection, then you might not have to anything, unless you
</I>&gt;&gt;<i>  &gt; have some state to set up which could be done by overriding
</I>&gt;&gt;<i>  &gt; connectionMade on your Protocol.
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt; Finally, take everything I've stated above with a grain of salt.
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  &gt;
</I>&gt;&gt;<i>  Thanks, I find it fairly hard to get used to Twisted, I wanted to buy
</I>&gt;&gt;<i>  the book, but it was written in 2005 and I'm not sure if it's still
</I>&gt;&gt;<i>  valid with today's version.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> The book it is not up to date.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i>  BTW, any idea why I'm getting this type of behavior (one server, 3
</I>&gt;&gt;<i>  distinct connections from clients) :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Without seeing your code, no.
</I>&gt;<i>
</I>&gt;<i>   
</I>ok, it's a bit long.....

-------------------------&quot;Central server&quot; aka 
Daemon---------------------------------------------------------------------------

class MdfXmlStreamFactory(XmlStreamFactoryMixin):
    &quot;&quot;&quot;
    The factory class used by the daemon and services to create
    protocol instances
    &quot;&quot;&quot;
   
    def __init__(self, proto, *args, **kwargs):
        &quot;&quot;&quot;
        Constructor
       
        @param proto: the protocol to use
        @type proto: a subclass of 
L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
        @param args: misc args
        @type args: C{tuple}
        @param kwargs: misc keyword args
        @type kwargs: C{dict}
        &quot;&quot;&quot;
        XmlStreamFactoryMixin.__init__(self)
        self.args = args
        self.kwargs = kwargs
        self.protocol = proto

    def buildProtocol(self, addr):
        &quot;&quot;&quot;
        Builds the protocol and
       
        @param addr: The address (protocol, IP, port) of the connection
        @type addr: 
L{IPv4Address&lt;twisted.internet.address._ServerFactoryIPv4Address&gt;}
       
        @return: an instance of the built protocol
        &quot;&quot;&quot;
        #self.resetDelay()
        xs = self.protocol(*self.args, **self.kwargs)
        xs.factory = self
        self.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT, 
xs.connected) # stream connect event or xml start event???
        for event, fn in self.bootstraps:
            xs.addObserver(event, fn)

        return xs

class MdfXmlStreamServerFactory(MdfXmlStreamFactory, ServerFactory):
    &quot;&quot;&quot;
    The factory class used by the daemon to create
    protocol instances
    &quot;&quot;&quot;
   
    # The registered services
    _services = {}
   
    def __init__(self, proto, *args, **kwargs):
        &quot;&quot;&quot;
        Constructor
       
        @param proto: the protocol to use
        @type proto: a subclass of 
L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
        @param args: misc args
        @type args: C{tuple}
        @param kwargs: misc keyword args
        @type kwargs: C{dict}
        &quot;&quot;&quot;
        MdfXmlStreamFactory.__init__(self, proto, *args, **kwargs)

class Daemon(xmlstream.XmlStream):
    &quot;&quot;&quot;
    The daemon is the implementation of a microkernel type inter-service
    communication (ISC) routing daemon. Here is how it works :
   
        - Services announce their presence to the daemon by giving their 
name,
          version, ip, port and a list of message-types that they accept
        - The daemon listens for messages from the attached services, 
when one
          is received, it routes the message to the correct service
   
    @todo: add unique id generation/verification
    &quot;&quot;&quot;
   
    # Holds the real method
    __dataReceived = xmlstream.XmlStream.dataReceived
   
    # The registered services
    #__services = {}
    cnt = 1
   
    def __init__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Constructor
       
        @param args: non-keyword args
        @type args: C{tuple}
        @param kwargs: keyword args
        @type kwargs: C{dict}
        &quot;&quot;&quot;
        xmlstream.XmlStream.__init__(self)
        self.__routeTo = None
        self.__lastMsgType = None
        self.__lastMsgId = None
        self.inst = Daemon.cnt
        Daemon.cnt += 1
        print &quot;daemon proto instance %d&quot; % self.inst
       
   
    def connectionMade(self):
        xmlstream.XmlStream.connectionMade(self)
   
    def dataReceived(self, data):
        &quot;&quot;&quot;
        Called everytime data is received
       
        @param data: the data received
        @type data: C{object} (anything)
        &quot;&quot;&quot;
        self.__dataReceived(data)
       
    def connectionLost(self, reason):
        &quot;&quot;&quot;
        Called when the connection is shut down, restores the
        dataReceived method
       
        @param reason: the reason why the connection was lost
        @type reason: C{str}
        &quot;&quot;&quot;
        self.__dataReceived = xmlstream.XmlStream.dataReceived
        self.__routeTo = None
        xmlstream.XmlStream.connectionLost(self, reason)
   
    def __onHeader(self, element):
        &quot;&quot;&quot;
        Analyse a header and set the data's recipiant
       
        @param element: the header element (XML)
        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
        &quot;&quot;&quot;
        print &quot;got header from %s:%s : %s&quot; % 
(str(self.transport.getPeer().host), str(self.transport.getPeer().port), 
element.toXml())
       
        self.__lastMsgId = element.getAttribute(&quot;id&quot;)
        self.__lastMsgType = element.getAttribute(&quot;type&quot;)
        if(self.__lastMsgType != constants._REG_MSG_TYPE):
            self.__routeTo = self.factory._services[type]
            self.__dataReceived = __routeDataReceived
   
    def __onReg(self, element):
        &quot;&quot;&quot;
        Register a service
       
        @param element: the registeration element (XML)
        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
        &quot;&quot;&quot;
        print &quot;got reg from %s:%s : %s&quot; % 
(str(self.transport.getPeer().host), str(self.transport.getPeer().port), 
element.toXml())

        name = 
str(xpath.XPathQuery(&quot;/body/reg/name&quot;).queryForNodes(element)[0])
        version = 
str(xpath.XPathQuery(&quot;/body/reg/version&quot;).queryForNodes(element)[0])
        #address = 
str(xpath.XPathQuery(&quot;/body/reg/address&quot;).queryForNodes(element)[0])
        port = 
int(str(xpath.XPathQuery(&quot;/body/reg/port&quot;).queryForNodes(element)[0]))
        msgs = [ str(m) for m in 
xpath.XPathQuery(&quot;/body/reg/message_type&quot;).queryForNodes(element) ]
       
        address = self.transport.getPeer().host
        #port = self.transport.getPeer().port
        serv = ServiceReg(name, version, msgs, address, port)
        self.__registerService(serv)
       
    def connected(self, xs):
        &quot;&quot;&quot;
        Called when a client connects using an XML stream
       
        @param xs: the current xml stream
        @type xs: L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
        &quot;&quot;&quot;
       
        print 'Connection from %s:%s!' % 
(str(self.transport.getPeer().host), str(self.transport.getPeer().port))
        xs.addObserver(&quot;/header&quot;, self.__onHeader)
        xs.addObserver(&quot;/body/reg&quot;, self.__onReg)
       
    def __routeDataReceived(self, data):
        &quot;&quot;&quot;
        Pushes the messages to the correct service
       
        @param data: the data received
        @type data: C{object} (anything)
        &quot;&quot;&quot;
        print &quot;route '%s' to : %s&quot; % (str(data), self.__routeTo)
       
        utils.sendMessage(self.__routeTo.ip, self.__routeTo.port, data)
        #self.send(data)
       
    def __registerService(self, service):
        &quot;&quot;&quot;
        Register a service
       
        @param service: the service to register
        @type service: L{ServiceReg}
       
        @raise ServiceMessageConflictError: if another service already 
has a
                                            message registered that the 
current
                                            service is trying to register
       
        @todo: what is to be done with the exception once raised???? 
Finish status message...
        &quot;&quot;&quot;
       
        def foundConflict(self, msgTypes):
            &quot;&quot;&quot;
            Check if there is a conflict with message types to be registered
            by this service
           
            @param service: the service messages to check for conflicts
            @type service: C{str}
           
            @return: the conflicting service type or None if no
                    conflict is found
            &quot;&quot;&quot;
            for mt in msgTypes:
                if(self.factory._services.has_key(mt)):
                    return mt
            return None
       
        print &quot;Registering service : &quot;, str(service)
       
        try:
            #
            # Check if another service already registered a message type 
that
            # the current service is trying to register
            #
            conflict = foundConflict(self, service.acceptedMsgs)
            if(conflict != None):
                raise ServiceMessageConflictError(conflict)
           
            #
            # Regrister the message types and this service
            #
            for msgType in service.acceptedMsgs:
                self.factory._services[msgType] = service
               
        except ServiceMessageConflictError, reason:
            status = 
utils.createConfirmationMsgBody(constants._MSG_FAILURE_TYPE,
                                                     self.__lastMsgId, 
str(reason))
        else:
            status = 
utils.createConfirmationMsgBody(constants._MSG_SUCCESS_TYPE,
                                                     self.__lastMsgId)
           
        #
        # Send registeration confirmation (succeeded or failed)
        #
        msgRoot = utils.createMessage(constants._REG_MSG_CONFIRM_TYPE,
                                      constants._CONF_MSG_ID,
                                      constants._DAEMON_SERVICE_NAME,
                                      constants._MSG_SPEC_VERSION,
                                      constants._STATUS_DATA_TYPE, status)
       
        print &quot;Sending confirmation message to %s : %s&quot; % 
(self.transport.getPeer().host, msgRoot.toXml())
       
        #self.send(msgRoot)
        utils.sendMessage(self.transport.getPeer().host, service.port, 
msgRoot)
   
if(__name__ == &quot;__main__&quot;):

    reactor.listenTCP(4321, MdfXmlStreamServerFactory(Daemon))
    print &quot;Listening for connections...&quot;
    reactor.run()

----------------------------------------&quot;Service&quot;-----------------------------------------------------------------------------------------------------

class MdfXmlStreamClientFactory(MdfXmlStreamServerFactory):
    &quot;&quot;&quot;
    The factory class used by the services to create
    protocol instances
   
    @attention: this class might dissapear, I have to see if it's useful 
to keep it or not
    &quot;&quot;&quot;
   
    __daemonAddrs = None
    __daemonPort = None
   
    def __init__(self, proto, *args, **kwargs):
        &quot;&quot;&quot;
        Constructor
       
        @param proto: the protocol to use
        @type proto: a subclass of 
L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
        @param args: misc args
        @type args: C{tuple}
        @param kwargs: misc keyword args
        @type kwargs: C{dict}
        &quot;&quot;&quot;
        MdfXmlStreamServerFactory.__init__(self, proto, *args, **kwargs)
        self._serviceInfo = ServiceReg(kwargs[&quot;name&quot;], 
kwargs[&quot;version&quot;], list(kwargs.get(&quot;messageTypes&quot;, [])))
        MdfXmlStreamClientFactory.__daemonAddrs = kwargs[&quot;address&quot;]
        MdfXmlStreamClientFactory.__daemonPort = kwargs[&quot;port&quot;]
       
    def register(self, port):
        &quot;&quot;&quot;
        Register the service
       
        @param port: the service's port
        @type port: C{int}
        &quot;&quot;&quot;
        self._serviceInfo.port = port
        msgBodyData = utils.createRegMsgBody(self._serviceInfo.name,
                                             self._serviceInfo.version,
                                             str(self._serviceInfo.port),
                                             self._serviceInfo.acceptedMsgs)
       
        msgRoot = utils.createMessage(constants._REG_MSG_TYPE,
                                      constants._REG_MSG_ID,
                                      self._serviceInfo.name,
                                      constants._MSG_SPEC_VERSION,
                                      constants._REG_DATA_TYPE, msgBodyData)
       
        utils.sendMessage(MdfXmlStreamClientFactory.__daemonAddrs,
                          MdfXmlStreamClientFactory.__daemonPort,
                          msgRoot)

class BaseService(xmlstream.XmlStream):
    &quot;&quot;&quot;
    The service is the implementation of a microkernel type inter-service
    communication (ISC) endpoint. Here is how it works :
   
        - Services announce their presence to the daemon by giving their 
name,
          version, ip, port and a list of message-types that they accept
        - The daemon listens for messages from the attached services, 
when one
          is received, it routes the message to the correct service
         
    @todo: add unique id generation/verification
    &quot;&quot;&quot;
   
    def __init__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Constructor
       
        @param args: non-keyword args
        @type args: C{tuple}
        @param kwargs: keyword args
        @type kwargs: C{dict}
        &quot;&quot;&quot;
        xmlstream.XmlStream.__init__(self)
        self._msgSrc = None
        self._msgDest = None
        self._msgBodyData = None
        self._registered = False
   
    def _onHeader(self, element):
        &quot;&quot;&quot;
        Analyse a header and save the source and destination
       
        @param element: the header element (XML)
        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
       
        @todo: add msg spec version verification
        @todo: add id verification???
        &quot;&quot;&quot;
        print &quot;got header from %s:%s : %s&quot; % 
(str(self.transport.getPeer().host), str(self.transport.getPeer().port), 
element.toXml())
       
        self._msgSrc = 
xpath.XPathQuery(&quot;/header&quot;).queryForNodes(element)[0].getAttribute(&quot;source&quot;)
        self._msgDest = 
xpath.XPathQuery(&quot;/header&quot;).queryForNodes(element)[0].getAttribute(&quot;destination&quot;)
       
    def _onBody(self, element):
        &quot;&quot;&quot;
        Get the body act accordingly
       
        @param element: the body element (XML)
        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
       
        @todo: add data type verification
        @todo: call data action callbacks
        &quot;&quot;&quot;
        self._msgBodyData = 
xpath.XPathQuery(&quot;/body&quot;).queryForNodes(element)[0].toXml()
        print &quot;_onbody : &quot;, self._msgBodyData
       
    def _onConfirm(self, element):
        &quot;&quot;&quot;
        Get the confirmation message and act accordingly
       
        @param element: the confirmation element (XML)
        @type element: L{Element&lt;twisted.words.xish.domish.Element&gt;}
       
        @todo: add data type verification
        @todo: call data action callbacks
        &quot;&quot;&quot;
        status = 
str(xpath.XPathQuery(&quot;/body/conf/status&quot;).queryForNodes(element)[0])
        id = 
int(str(xpath.XPathQuery(&quot;/body/conf/id&quot;).queryForNodes(element)[0]))
        msg = 
str(xpath.XPathQuery(&quot;/body/conf/msg&quot;).queryForNodes(element)[0])
        if(id == constants._REG_MSG_ID):
            if(status == constants._MSG_SUCCESS_TYPE):
                self._registered = True
       
    def connected(self, xs):
        &quot;&quot;&quot;
        Called when a client connects using an XML stream
       
        @param xs: the current xml stream
        @type xs: L{XmlStream&lt;twisted.words.xish.xmlstream.XmlStream&gt;}
       
        @todo: add data action callbacks
        &quot;&quot;&quot;
        print 'Connection from %s:%s!' % 
(str(self.transport.getPeer().host), str(self.transport.getPeer().port))
        xs.addObserver(&quot;/header&quot;, self._onHeader)
        xs.addObserver(&quot;/body/conf&quot;, self._onConfirm)
        xs.addObserver(&quot;/body&quot;, self._onBody)
       

def start(daemonAddrs, daemonPort, serviceRef, serviceName, 
serviceVersion, serviceMessageTypes):
    &quot;&quot;&quot;
    Start the daemon
   
    @param daemonPort: the port the daemon listens on
    @type daemonPort: C{int}
    @param serviceRef: a reference to the service's class
    @type serviceRef: a subclass of L{BaseService&lt;service.BaseService&gt;}
    @param serviceName: the service's name
    @type serviceName: C{str}
    @param serviceVersion: the service's version
    @type serviceVersion: C{str}
    @param serviceMessageTypes: the list of messages the service registers
    @type serviceMessageTypes: C{str list}
    &quot;&quot;&quot;
    f = MdfXmlStreamClientFactory(serviceRef, address=daemonAddrs, 
port=daemonPort, name=serviceName, version=serviceVersion, 
messageTypes=serviceMessageTypes)
    port = reactor.listenTCP(0, f).getHost().port
    f.register(port)
    print port
   
    reactor.run()

if(__name__ == &quot;__main__&quot;):

    start(&quot;localhost&quot;, 4321, BaseService, &quot;service_base&quot;, &quot;1.0&quot;, [&quot;all&quot;])
&gt;&gt;<i>  Daemon listening for connections...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  daemon proto instance 1
</I>&gt;&gt;<i>  Connection from 127.0.0.1:57821! &lt;-- ok, Client1
</I>&gt;&gt;<i>  ....
</I>&gt;&gt;<i>  daemon proto instance 2
</I>&gt;&gt;<i>  Connection from 127.0.0.1:57821! &lt;-- Client1 again????? why?
</I>&gt;&gt;<i>  Connection from 127.0.0.1:57823! &lt;-- ok, Client2
</I>&gt;&gt;<i>  ....
</I>&gt;&gt;<i>  daemon proto instance 3
</I>&gt;&gt;<i>  Connection from 127.0.0.1:57821! &lt;-- ok, Client1 again????? why?
</I>&gt;&gt;<i>  Connection from 127.0.0.1:57823! &lt;-- ok, Client2 again????? why?
</I>&gt;&gt;<i>  Connection from 127.0.0.1:57824! &lt;-- ok, Client3
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  Oh, and by the time I finished writing this email, I've switched to
</I>&gt;&gt;<i>  solution 2, but I still get the  behavior above.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  _______________________________________________
</I>&gt;&gt;<i>  Twisted-Python mailing list
</I>&gt;&gt;<i>  <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;&gt;<i>  <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>   
</I>Thank you,
Gabriel


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="049422.html">[Twisted-Python] Factory question
</A></li>
	<LI>Next message (by thread): <A HREF="049430.html">[Twisted-Python] Factory question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49423">[ date ]</a>
              <a href="thread.html#49423">[ thread ]</a>
              <a href="subject.html#49423">[ subject ]</a>
              <a href="author.html#49423">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
