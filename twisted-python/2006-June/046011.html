<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] reset/restart reactor problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20reset/restart%20reactor%20problem&In-Reply-To=%3Cbff8eeef0606250439h1aefc9b9v42a79815cf900ab7%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="046009.html">
   <LINK REL="Next"  HREF="046012.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] reset/restart reactor problem</H1>
    <B>Moof</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20reset/restart%20reactor%20problem&In-Reply-To=%3Cbff8eeef0606250439h1aefc9b9v42a79815cf900ab7%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] reset/restart reactor problem">moof at metamoof.net
       </A><BR>
    <I>Sun Jun 25 05:39:16 MDT 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="046009.html">[Twisted-Python] reset/restart reactor problem
</A></li>
        <LI>Next message (by thread): <A HREF="046012.html">[Twisted-Python] reset/restart reactor problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46011">[ date ]</a>
              <a href="thread.html#46011">[ thread ]</a>
              <a href="subject.html#46011">[ subject ]</a>
              <a href="author.html#46011">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> &gt;I am porting an academic middleware project, currently implemented in  C++
</I>&gt;<i> &gt;and Java, to python. It extensively uses multicast for  communicating
</I>&gt;<i> &gt;general events and TCP to communicate with a database.  The multicast
</I>&gt;<i> &gt;messages that I send out depend on the results that I  first obtain from the
</I>&gt;<i> &gt;database. I would prefer to serialise each of  these requests in turn, but
</I>&gt;<i> &gt;its not immediately obvious to me what  the best way to do this using
</I>&gt;<i> &gt;Twisted is.
</I>&gt;<i>
</I>&gt;<i> There are quite a few possible techniques to apply here.  One I would
</I>&gt;<i> recommend is to keep a list of objects which represent pending tasks
</I>&gt;<i> which need to be executed serially.  When each task completes, pop the
</I>&gt;<i> next one from the list and begin processing it.  When a new task needs
</I>&gt;<i> to be performed, push it onto the list.
</I>
[snip code]

This has already been implemented in twisted.

from twisted.internet import defer

requestqueue = defer.DeferredSemaphore(1) # only allow one token to be
in use at a time
d = requestqueue.run(object.method, arg1, arg2, arg3=3)

d is a deferred that will return the result of the method call in the
standard manner. The semaphore will store the function call in a FIFO
queue and run it when a token becomes available, acquiring the lock,
running, and releasing it once run. It allows for multiple tokens, so
it's normally used to run a maximum of, say, 30 things at a time, but
there's no reson not to set a maximum of 1. This guarantees that only
one call in the notional queue will be run at a time, effectively
serialising your requests.

Keep in mind that twisted is inherently single-threaded, and hence, to
an extent, serial in nature anyway, there are very few times in a
twisted programme when it becomes multi-threaded, database access with
twisted.enterprise being one of them. The general strategy would be to
keep only the part of your programme that needs to be transactional in
a queue like this, leaving the rest of the programme (like sending the
multicast data) in twisted's normal asynchronous execution space. In
fact, the only reason to do it this way is if you need to process the
data in the order it's received. If the order is not important, then
you can use your own database's transaction model to solve the
concurrency issues, (see
twisted.enterprise.adbapi.ConnectionPool.runInteraction), and just let
twisted gets on with doing things the way it knows best.

Hope this helps,

Moof


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="046009.html">[Twisted-Python] reset/restart reactor problem
</A></li>
	<LI>Next message (by thread): <A HREF="046012.html">[Twisted-Python] reset/restart reactor problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46011">[ date ]</a>
              <a href="thread.html#46011">[ thread ]</a>
              <a href="subject.html#46011">[ subject ]</a>
              <a href="author.html#46011">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
