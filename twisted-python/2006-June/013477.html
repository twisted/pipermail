<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: [Twisted-commits] r17325 - merge sob-491,	fixes #491
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20%5BTwisted-commits%5D%20r17325%20-%20merge%20sob-491%2C%0A%09fixes%20%23491&In-Reply-To=20060622030005.29014.198663675.divmod.quotient.6335%40ohm">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013476.html">
   <LINK REL="Next"  HREF="013455.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: [Twisted-commits] r17325 - merge sob-491,	fixes #491</H1>
    <B>Andrew Bennetts</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20%5BTwisted-commits%5D%20r17325%20-%20merge%20sob-491%2C%0A%09fixes%20%23491&In-Reply-To=20060622030005.29014.198663675.divmod.quotient.6335%40ohm"
       TITLE="[Twisted-Python] Re: [Twisted-commits] r17325 - merge sob-491,	fixes #491">andrew-twisted at puzzling.org
       </A><BR>
    <I>Thu Jun 22 00:57:39 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="013476.html">[Twisted-Python] Re: [Twisted-commits] r17325 - merge sob-491,	fixes #491
</A></li>
        <LI>Next message: <A HREF="013455.html">[Twisted-Python] Twisters at EuroPython ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13477">[ date ]</a>
              <a href="thread.html#13477">[ thread ]</a>
              <a href="subject.html#13477">[ subject ]</a>
              <a href="author.html#13477">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Jun 21, 2006 at 11:00:05PM -0400, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
[...]
&gt;<i> 
</I>&gt;<i> I've received this suggestion a few times privately and I'm still mulling 
</I>&gt;<i> it over.  On the face of it, it's a good idea, buuuuuut:
</I>&gt;<i> 
</I>&gt;<i> 1. I've had a series of disastrous experiences with commit hooks rejecting 
</I>&gt;<i> changes.  The guy who wrote the commit hook goes on vacation for 3 days, 
</I>&gt;<i> there's a bug in it, and nobody can figure out how to merge code or turn it 
</I>&gt;<i> off for 8 hours; meanwhile the guy trying to commit in bangalore goes to 
</I>&gt;<i> sleep, then doesn't show up again for a week, and the changes are lost.  
</I>&gt;<i> (Having changes on a branch prior to trunk would alleviate this somewhat, I 
</I>&gt;<i> think, but it would be just as much of a pain to be blocked on some stupid 
</I>&gt;<i> merge-script bug.)
</I>
Two things make this a non-issue, hopefully:
  - a script that checks that a commit message matches a regex is pretty damn
    simple.
  - in case of emergency, it shouldn't be hard to just disable the offending
    commit-hook until such time as it can be fixed properly.

&gt;<i> 2. The most important thing, really, is a sufficiently descriptive 
</I>&gt;<i> explanation for the change.  Any programmatic attempt to enforce this is 
</I>&gt;<i> sure to drive artificial gaming of the metric; i.e. if we require 3 
</I>&gt;<i> sentences, &quot;fixed random junk in foo module&quot; will become &quot;Fixed random. 
</I>&gt;<i> Junk in. Foo module.&quot;
</I>
Well, I was really only suggesting that the presence of mandatory metadata is
checked for, not that we write an AI to check that the text of the messages make
sense :)

&gt;<i> 3. 99% of the time (e.g. all &quot;normal&quot; commits) should be in this format; 
</I>&gt;<i> however, the underlying tools, to be honest, are still kind of primitive, 
</I>&gt;<i> and we still have to leave a little wiggle room to deal with their foibles. 
</I>&gt;<i> At least it isn't the masochistic chewing-gum-and-duct-tape perpetual 
</I>&gt;<i> catastrophe of CVS, but SVN still does annoying things like screwing up 
</I>&gt;<i> merges.  If there is a commit with a nice long description and a 'fixes' 
</I>&gt;<i> and everything, which needs to be reverted and reapplied for some dumb 
</I>&gt;<i> technical reason, I'd like to see
</I>&gt;<i> 
</I>&gt;<i>  r1234: &quot;author: foo; reviewer: bar; wonderful wonderful description ...&quot;
</I>&gt;<i>  r1235: &quot;crap, reverting r1234 because of svn bug #9813741&quot;
</I>&gt;<i>  r1236: &quot;reapplying r1234 merged in utterly retarded way to work around svn 
</I>&gt;<i>  bug #9813741&quot;
</I>&gt;<i> 
</I>&gt;<i> not the entire description of r1234 repeated twice -- or, more 
</I>&gt;<i> realistically, three times, since the revert in the middle would also have 
</I>&gt;<i> to have a conformant commit message.
</I>
Good point.  So there either needs to be a way to explicitly flag that this
message is ok despite not being in the usual format, or we need to anticipate
all possible forms of exceptional commits.  Requiring e.g. &quot;[override=reason]&quot;
in the text of the commit message somewhere could do this.  This of course
complicates the checker slightly, which relates to point 1, but not impossibly
so.

&gt;<i> 4. precommit hooks keep the SVN SSH transport alive to report errors to the 
</I>&gt;<i> client for the duration of the hook.  When I last investigated (although 
</I>&gt;<i> this was in an SVN pre-release, a good 2+ years ago) if the connection 
</I>&gt;<i> drops while you're validating the commit message, it rejects the commit.  
</I>&gt;<i> This would be especially annoying if you were committing an important fix 
</I>&gt;<i> over some intermittent link, like a GPRS modem.  That's not a common 
</I>&gt;<i> occurrance, but then again, if something were important enough that someone 
</I>&gt;<i> needed to commit code on a *GPRS modem* that is probably the time they 
</I>&gt;<i> would _least_ like something technical to go wrong with the process.
</I>
The time it takes to validate a commit message against a regex should be
negligible.  I doubt this will be a real problem.

&gt;<i> This is basically just the same reason that, despite our hardcore attitude 
</I>&gt;<i> towards tests, we don't have buildbot automatically reject or revert 
</I>&gt;<i> commits based on automated test failures.  The tools (in that case, 
</I>&gt;<i> buildbot, trial, and our test suite) are too primitive to rely on without 
</I>&gt;<i> some level of human judgement.  We've been moving to a stricter model so 
</I>&gt;<i> that the human judgements can be as mechanical and apolitical as possible 
</I>&gt;<i> (e.g. &quot;was this a test failure due to too much load on the buildbot / known 
</I>&gt;<i> intermittent failure&quot;, not &quot;is this an important enough area of code to 
</I>&gt;<i> worry about test failures in&quot;) but we still need it there.
</I>
There are important differences between a commit message checker and our test
suite.  Our test suite gives way too many false positives, and does so
unpredictably.  Our test suite takes many minutes to run, at best.  Our test
suite should be run on multiple platforms for full effectiveness.  Our test
suite is extremely complex.  A simple &quot;does the commit message match this regex&quot;
check has none of these problems, assuming the regex isn't insane.

&gt;<i> I am eager to be corrected however; the more work our tools can reliably do 
</I>&gt;<i> for us the better.  Has anybody had a good experience with 
</I>&gt;<i> automatically-rejected commits in another reasonably sized project before?
</I>
Yes, the Launchpad development process automatically rejects commits, both for
malformed commit messages[1] and for test failures.  It's generally worked quite
well.  The test suite takes similar lengths of time to Twisted's to run (but
without the portability concerns, thankfully), but we submit requests to merge
to trunk asynchronously (via gpg-signed email), so this isn't a killer for poor
connections.

We have occasionally had problems where a system upgrade or other supposedly
unrelated change causes the test suite on trunk to start failing, effectively
blocking all merges, requiring admin intervention.  Old processes from previous
test runs can also be an issue.  It's generally worked very well for us, though.
And it means we are forced to have zero tolerance of failing tests.  Developers
get unhappy if there's an intermittently failing test that's blocking their
merges :)

We use PQM (&quot;Patch Queue Manager&quot;, bzr branch available here:
<A HREF="http://people.ubuntu.com/~robertc/pqm/trunk/,">http://people.ubuntu.com/~robertc/pqm/trunk/,</A> bugs etc here:
<A HREF="https://launchpad.net/products/pqm">https://launchpad.net/products/pqm</A>) to do this.

-Andrew.

[1] We require either &quot;[trivial]&quot;, &quot;[r=reviewer]&quot;, or &quot;[rs=approver]&quot; to be in the
    message.  &quot;r=&quot; means &quot;reviewed and approved by&quot; and &quot;rs=&quot; means &quot;rubber
    stamped by&quot;, i.e. not closely reviewed by the person (generally a manager)
    approving it anyway is happy with it being merged despite that and is
    responsible for the result.  &quot;trivial&quot; should be obvious ;).  Regardless of
    commit message, the full test suite is always run.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013476.html">[Twisted-Python] Re: [Twisted-commits] r17325 - merge sob-491,	fixes #491
</A></li>
	<LI>Next message: <A HREF="013455.html">[Twisted-Python] Twisters at EuroPython ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13477">[ date ]</a>
              <a href="thread.html#13477">[ thread ]</a>
              <a href="subject.html#13477">[ subject ]</a>
              <a href="author.html#13477">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
