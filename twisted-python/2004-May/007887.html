<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Copyable%2C%20round%20trip%20objects%2C%09and%20untrusted%0A%09clients&In-Reply-To=Pine.LNX.4.53.0405210012100.15434%40a.shell.peak.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007864.html">
   <LINK REL="Next"  HREF="007889.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients</H1>
    <B>David Ripton</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Copyable%2C%20round%20trip%20objects%2C%09and%20untrusted%0A%09clients&In-Reply-To=Pine.LNX.4.53.0405210012100.15434%40a.shell.peak.org"
       TITLE="[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients">dripton at ripton.net
       </A><BR>
    <I>Sat May 22 18:32:43 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="007864.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
        <LI>Next message: <A HREF="007889.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7887">[ date ]</a>
              <a href="thread.html#7887">[ thread ]</a>
              <a href="subject.html#7887">[ subject ]</a>
              <a href="author.html#7887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jasper Phillips wrote:
&gt;<i> On Thu, 20 May 2004, David Ripton wrote:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>On 2004.05.20 02:25:20 +0000, Jasper Phillips wrote:
</I>
&gt;<i> I used to write Java code for a living;  I came to hate it's shortcomings
</I>&gt;<i> and IMHO Python is purely superior.  Still, was Titan really 50k lines of
</I>&gt;<i> Java?!  Mind boggling.
</I>
We have way too many chrome features, and the code is far from minimal. 
    (There's a lot of duplication between client and server, for 
example.)  A tighter and still reasonably complete implementation could 
be done in 10k LOC in Java.  I think 5k LOC in Python is a reasonable 
target.

&gt;<i> I'm treating event history as game state, although I haven't implemented it
</I>&gt;<i> yet.  Not so much for the AIs use, but to model it's effects on future
</I>&gt;<i> events.  IMHO treating it as game state is also a simpler model.
</I>
So future events depend on the exact sequence of events used to reach 
the current state, not just the current state?  That sounds expensive.

&gt;&gt;&gt;<i>IMHO handling this can avoid the 3rd problem you mention.  I have
</I>&gt;&gt;&gt;<i>Players send Actions for a given Turn as the only API to change Game
</I>&gt;&gt;&gt;<i>State.  These actions don't take game object as args, but rather Ids as
</I>&gt;&gt;&gt;<i>you suggest below.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I'm now back to wanting to do that in both directions.  Except using
</I>&gt;&gt;<i>strings instead of object IDs, since the parallel objects on the client 
</I>&gt;&gt;<i>and server will be distinct.  (But they will use the same class, which
</I>&gt;&gt;<i>is key to maintainability.  When you find yourself writing ClientGame
</I>&gt;&gt;<i>and ServerGame, scream until the urge passes, then decouple the concept
</I>&gt;&gt;<i>from its context until the need is gone.)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> IMHO this seems overly complex.  I don't like maintaining parallel objects
</I>&gt;<i> or parallel calculation, as it smells like ClientGame/ServerGame...
</I>
The problem with the separate ClientGame / ServerGame classes is that 
once you allow the big classes on each side to get coupled to their 
location, the small classes start coupling to those big classes, and 
pretty soon you have two slightly divergent copies of most of the code 
in the game, and double maintenance.

Having separate *objects* of the same classes on the two sides is fine, 
though.  In fact, in a game with hidden information, it's inevitable. 
The server Game object will hold the full state, and each client's Game 
object will hold a subset.  This is true whether the server sends 
censored copies of its state to clients, or whether it sends them 
subsets of the full event stream and lets clients generate their own 
censored copies.

&gt;&gt;<i>I want to make it symmetrical, so I want to build the client-side model
</I>&gt;&gt;<i>objects using the action stream, rather than copying them directly.  It
</I>&gt;&gt;<i>will be painfully boring, but I don't have *that* many actions, and
</I>&gt;&gt;<i>they're fully documented from last time I decided to go this way.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Why?  I see no advantage to symmetry here.  IMHO the a trusted-server / 
</I>&gt;<i> untrusted-client asymetrical design is clearly called for.
</I>
It is a trusted server and untrusted client.  But the trust is expressed 
by which events each can see.  Symmetry just means less code, because 
things work the same both ways.  I don't think it's necessary, but I do 
think it's good if you can get it.

&gt;<i> I disagree that sending objects isn't practical, IMHO it just helps to
</I>&gt;<i> approach it slightly differently.  I'll try to explain what I mean by
</I>&gt;<i> roughly describing my game as an example;  if my design is crappy please feel
</I>&gt;<i> free to shoot holes in it! :-)
</I>&gt;<i> 
</I>&gt;<i> Much of my game's logic is based upon Copyable Actions which are used by
</I>&gt;<i> both Server and Client, e.g. MoveAction.  These have a .__call__(state)
</I>&gt;<i> which modifies the passed state as they see fit, as well as a
</I>&gt;<i> .validate(state) to ensure a move is legal.  Players create a list of such
</I>&gt;<i> Actions, and pass them to the Game server as their turn.  
</I>
Standard command pattern, but cleaner in Python because of __call__.

Do your turns have phases, requiring certain actions to occur at certain 
times?

Can other players interrupt your turn with actions, or are their replies 
(e.g. strikebacks to your attacks) completely automated or deferred 
until their turns?

&gt;<i> All the args for
</I>&gt;<i> Action are literals (such as Unit ids and movement direction), with Actions
</I>&gt;<i> knowing how to find the corresponding objects on passed in State.
</I>&gt;<i> 
</I>&gt;<i> With only literal args these Action objects can be passed safely to the
</I>&gt;<i> game, which will reconstitue it's own versions, validate them, then invoke
</I>&gt;<i> them by passing in it's True State.  Players are given their own PlayerState
</I>&gt;<i> view of TrueState each turn, with real (copies of) objects they can use for
</I>&gt;<i> display, UI and validation.
</I>
It seems that only sending game state updates once per turn would reduce 
interactivity too much.  I want to see my opponents' (visible) moves as 
they happen, not batched up at the end of his turn.  Beware of 
sequential solitaire.

PlayerState / TrueState sounds like the ClientGame / ServerGame problem 
I was warning about.  It's not necessarily bad if they have the same 
interface and PlayerState just has a subset of the data, but look out 
for duplicate code.

&gt;<i> Basically it works like passing objects both ways, except it's safe.  The
</I>&gt;<i> costs are minor: referenceable objects must have Ids, Clients must create
</I>&gt;<i> Actions with 'object.id' instead of 'object', and Actions need to either
</I>&gt;<i> 'object = state.getObject(objectId)' or use Game/State methods taking ids
</I>&gt;<i> for args.
</I>
I agree that passing handles instead of references definitely works 
better.  I find that an unfortunate limitation of current PB, though not 
a major one since (as Christopher Armstrong pointed out) the amount of 
code needed to convert back and forth each time is small.

&gt;<i> IMHO Making all of this essentially part of the API is cleaner than having
</I>&gt;<i> bulk &quot;Reconsitute Objects&quot; methods.
</I>
Yes.  Having direct support in PB for the idea of const (copy this 
object when I send it, but ignore any changes that were made to it on 
the other side if I get it back), so that you don't have to do any of 
this, would be even cleaner.  I don't know if there's much demand for 
this feature from other people, though.

Anyway, I'm looking forward to seeing your game at some point.

-- 
David Ripton     <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">dripton at ripton.net</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007864.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
	<LI>Next message: <A HREF="007889.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7887">[ date ]</a>
              <a href="thread.html#7887">[ thread ]</a>
              <a href="subject.html#7887">[ subject ]</a>
              <a href="author.html#7887">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
