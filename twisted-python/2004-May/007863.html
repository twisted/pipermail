<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Copyable%2C%20round%20trip%20objects%2C%09and%20untrusted%0A%09clients&In-Reply-To=40AD8B27.7090503%40twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007860.html">
   <LINK REL="Next"  HREF="007865.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients</H1>
    <B>David Ripton</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Copyable%2C%20round%20trip%20objects%2C%09and%20untrusted%0A%09clients&In-Reply-To=40AD8B27.7090503%40twistedmatrix.com"
       TITLE="[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients">dripton at ripton.net
       </A><BR>
    <I>Fri May 21 02:16:39 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="007860.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
        <LI>Next message: <A HREF="007865.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7863">[ date ]</a>
              <a href="thread.html#7863">[ thread ]</a>
              <a href="subject.html#7863">[ subject ]</a>
              <a href="author.html#7863">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Christopher Armstrong wrote:

&gt;<i> Ok, I'm going to debate this assumption of yours. It seems you're 
</I>&gt;<i> complaining about something that is barely a problem: let's talk about 
</I>&gt;<i> code size. Here's an example of how stuff could work.
</I>&gt;<i> 
</I>&gt;<i> In the client:
</I>&gt;<i> 
</I>&gt;<i> persp.callRemote(&quot;getCurrentGames&quot;).addCallback(_cbGotGames)
</I>&gt;<i> 
</I>&gt;<i> def _cbGotGames(self, games):
</I>&gt;<i>     # games is a list of complex objects, or whatever
</I>&gt;<i>     print &quot;games are&quot;, games
</I>&gt;<i>     print &quot;which one?&quot;
</I>&gt;<i>     ui.whichGame(games).addCallback(_cbChosenGame)
</I>&gt;<i> 
</I>&gt;<i> def _cbChosenGame(self, game):
</I>&gt;<i>     #here's what you think saves a lot of code space:
</I>&gt;<i>     persp.callRemote(&quot;chooseGame&quot;, game)
</I>&gt;<i>     #as opposed to
</I>&gt;<i>     persp.callRemote(&quot;chooseGame&quot;, game.id())
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hmm, I count a single extra method call there. That doesn't seem like a 
</I>&gt;<i> whole lot to me. :-) This is not worth getting worked up over. 
</I>
Probably not.  It's one more little piece of boilerplate all over. 
(Well, two -- the server has to lookup the game by id.)

I was worrying about code size more in the other subthread, the 
difference between

client.callRemote(&quot;send_game&quot;, game)

and

client.callRemote(&quot;send_stuff_about_game&quot;, game.name, game.owner, 
game.create_time, game.start_time, game.min_players, game.max_players, 
game.player_names)

Demonstrating the difference between passing complex objects and passing 
shredded bits of them.  This is what motivated my latest attempt to use 
Copyable instead of lots of little actions to manually push discrete 
changes to game state around.  (Which was probably a poor choice in any 
case; I really like the little discrete actions in most ways.)

Which is of course an exaggeration, because it would really be
client.callRemote(&quot;send_game_dict&quot;, game.as_dict())
Assuming we only need the atomic elements of game, not contained complex 
objects.  (Nested dicts get ugly fast.)  Also assuming it's okay to have 
one as_dict method that returns the superset of items we ever need, 
rather than a bunch of specialized versions.

&gt;<i> There's certainly applications using Copyable and Cacheable in 
</I>&gt;<i> production; I'm not sure what exactly you're talking about.
</I>
I'm not saying they don't work.  I agree that they work quite well, up 
to a point.  Just not up to the point I wanted and mostly expected. 
(Based on reading optimistic docs, or perhaps reading docs optimistically.)

PB is a very nice framework, but the combination of live remote 
references to complex objects and untrusted clients is tough.  Which is 
fine -- I can just pretend Copyable and Cacheable aren't there, and be 
happy that it's so easy to pass dicts and strings.  If newpb solves this 
problem, great, but if not, PB is still the best RPC framework I have.

-- 
David Ripton    <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">dripton at ripton.net</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007860.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
	<LI>Next message: <A HREF="007865.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7863">[ date ]</a>
              <a href="thread.html#7863">[ thread ]</a>
              <a href="subject.html#7863">[ subject ]</a>
              <a href="author.html#7863">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
