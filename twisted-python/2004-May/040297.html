<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Learning Twisted
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Learning%20Twisted&In-Reply-To=%3C40A81DCA.8030404%40injektilo.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="040294.html">
   <LINK REL="Next"  HREF="040291.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Learning Twisted</H1>
    <B>Jason Diamond</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Learning%20Twisted&In-Reply-To=%3C40A81DCA.8030404%40injektilo.org%3E"
       TITLE="[Twisted-Python] Learning Twisted">jason at injektilo.org
       </A><BR>
    <I>Sun May 16 20:04:58 MDT 2004</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="040294.html">[Twisted-Python] Learning Twisted
</A></li>
        <LI>Next message (by thread): <A HREF="040291.html">[Twisted-Python] integrating CompStrm//adding background processing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40297">[ date ]</a>
              <a href="thread.html#40297">[ thread ]</a>
              <a href="subject.html#40297">[ subject ]</a>
              <a href="author.html#40297">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jp Calderone wrote:

&gt;<i> Jason Diamond wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> This is what I came up with:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> from twisted.internet import reactor, protocol
</I>&gt;&gt;<i> from twisted.protocols import imap4
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> class MyIMAP4Client(imap4.IMAP4Client):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    def connectionMade(self):
</I>&gt;&gt;<i>        imap4.IMAP4Client.connectionMade(self)
</I>&gt;&gt;<i>        print &quot;connectionMade&quot;
</I>&gt;<i>
</I>&gt;<i>   The above works (as you noticed ;) but isn't quite as good as hooking =
</I>&gt;<i> into the &quot;serverGreeting&quot; method, which is called after the IMAP4 
</I>&gt;<i> server =
</I>&gt;<i> sends its initial message (I realize this isn't well documented).
</I>
Cool! This makes perfect sense and I'll look for methods like 
serverGreeting from now on.

Here's my updated test:

from twisted.internet import reactor, protocol
from twisted.protocols import imap4

server = &quot;xxx&quot;
username = &quot;yyy&quot;
password = &quot;zzz&quot;

debug = 0

class MyIMAP4Client(imap4.IMAP4Client):

    def serverGreeting(self, caps):
        if debug: print &quot;serverGreeting:&quot;, caps
        imap4.IMAP4Client.serverGreeting(self, caps)
        d = self.login(username, password)
        d.addCallback(self.loginCallback)

    def loginCallback(self, d):
        if debug: print &quot;loginCallback:&quot;, d
        de = self.select(&quot;INBOX&quot;)
        de.addCallback(self.selectCallback)

    def selectCallback(self, d):
        if debug: print &quot;selectCallback:&quot;, d
        print &quot;I have %d messages in my INBOX.&quot; % d[&quot;EXISTS&quot;]
        de = self.logout()
        de.addCallback(self.logoutCallback)

    def logoutCallback(self, d):
        if debug: print &quot;logoutCallback:&quot;, d
        reactor.stop()

    def connectionLost(self, reason):
        if debug: print &quot;connectionLost:&quot;, reason
        imap4.IMAP4Client.connectionLost(self)

    def sendLine(self, line):
        if debug: print &quot;sendLine:&quot;, line
        imap4.IMAP4Client.sendLine(self, line)

    def lineReceived(self, line):
        if debug: print &quot;lineReceived:&quot;, line
        imap4.IMAP4Client.lineReceived(self, line)

class MyIMAP4ClientFactory(protocol.ClientFactory):

    protocol = MyIMAP4Client

if __name__ == &quot;__main__&quot;:
    f = MyIMAP4ClientFactory()
    reactor.connectTCP(server, 143, f)
    reactor.run()

&gt;&gt;<i> [snip]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Note that this is *not* a method of the MyIMAP4Client class. But it
</I>&gt;&gt;<i> worked! I got this printed to the console:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> connectionMade
</I>&gt;&gt;<i> loginCallback: ([], 'OK LOGIN Ok.')
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't know, however, what the tuple represents. What's that empty
</I>&gt;&gt;<i> list? In a perfect world, would this be explained in the IMAP4Client
</I>&gt;&gt;<i> documentation? (I'm assuming that every callback would be different.)
</I>&gt;&gt;<i>
</I>&gt;<i>  The callback value here is something of an implementation detail.  =
</I>&gt;<i> Deferreds (somewhat informally) often fall into one of two categories: =
</I>&gt;<i> those which will eventually be called back with an interesting value =
</I>&gt;<i> which is necessary for further computations, and those which will =
</I>&gt;<i> eventually be called back with a not-so-interesting value which only =
</I>&gt;<i> serves to indicate that the desired operation has completed.  login() =
</I>&gt;<i> falls into the second category.
</I>
OK, this makes sense. But if the login callback doesn't have any useful 
information, why isn't it None (like the logout callback)? Or is that 
the implementation detail you're referring to that I should just forget 
about?

&gt;&gt;<i> [snip]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Am I correct in assuming that the IMAP4Client documentation needs some
</I>&gt;&gt;<i> buffing up? (Maybe I can help with that.) I didn't look at any source
</I>&gt;&gt;<i> code (other than in the HOWTOs) in implementing this so I think that's
</I>&gt;&gt;<i> a good sign. But as I mentioned above, I'm not clear on how I know
</I>&gt;&gt;<i> what the signature for my callbacks should be or what the parameters
</I>&gt;&gt;<i> to those callbacks mean in some cases.
</I>&gt;<i>
</I>&gt;<i>   Yep.  More documentation would be great.  The actual signature for =
</I>&gt;<i> callbacks is easy.  It's always a callable that takes one argument (by =
</I>&gt;<i> the way, this is why your code worked with both free functions and =
</I>&gt;<i> methods - it doesn't matter what kind of callable you use, as long as 
</I>&gt;<i> it =
</I>&gt;<i> takes one argument).  Further documentation about the specifics of what =
</I>&gt;<i> that one parameter means is definitely needed, though. 
</I>
I also just realized that a method attribute retrieved from an instance, 
even though it's declared as taking in two arguments (the first being 
self), returns a function that only has one argument--self is bound to 
the instance you used to grab the method.

-- Jason



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="040294.html">[Twisted-Python] Learning Twisted
</A></li>
	<LI>Next message (by thread): <A HREF="040291.html">[Twisted-Python] integrating CompStrm//adding background processing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40297">[ date ]</a>
              <a href="thread.html#40297">[ thread ]</a>
              <a href="subject.html#40297">[ subject ]</a>
              <a href="author.html#40297">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
