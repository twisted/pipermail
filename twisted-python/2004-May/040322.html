<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] More IMAP4Client/Deferred fun
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20More%20IMAP4Client/Deferred%20fun&In-Reply-To=%3C40A9C06C.2010609%40injektilo.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="040326.html">
   <LINK REL="Next"  HREF="040328.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] More IMAP4Client/Deferred fun</H1>
    <B>Jason Diamond</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20More%20IMAP4Client/Deferred%20fun&In-Reply-To=%3C40A9C06C.2010609%40injektilo.org%3E"
       TITLE="[Twisted-Python] More IMAP4Client/Deferred fun">jason at injektilo.org
       </A><BR>
    <I>Tue May 18 01:51:08 MDT 2004</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="040326.html">[Twisted-Python] thread migration and bsddb
</A></li>
        <LI>Next message (by thread): <A HREF="040328.html">[Twisted-Python] How to get the IP address of a client using XML-RPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40322">[ date ]</a>
              <a href="thread.html#40322">[ thread ]</a>
              <a href="subject.html#40322">[ subject ]</a>
              <a href="author.html#40322">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi.

I'm now trying to move beyond the simple exercise I did yesterday and
turn my IMAP4 &quot;client&quot; into something that could be reusable from
other classes.

This is my current script:

 &gt;&gt;&gt;
from twisted.internet import reactor, protocol
from twisted.protocols import imap4

server = &quot;xxx&quot;
username = &quot;yyy&quot;
password = &quot;zzz&quot;

debug = 0

class MyIMAP4Client(imap4.IMAP4Client):

    def serverGreeting(self, caps):
        if debug: print &quot;serverGreeting:&quot;, caps
        imap4.IMAP4Client.serverGreeting(self, caps)
        d = self.login(username, password)
        d.addCallback(self.loginCallback)

    def loginCallback(self, d):
        if debug: print &quot;loginCallback:&quot;, d
        de = self.select(&quot;INBOX&quot;)
        de.addCallback(self.selectCallback)

    def selectCallback(self, d):
        if debug: print &quot;selectCallback:&quot;, d
        print &quot;I have %d messages in my INBOX.&quot; % d[&quot;EXISTS&quot;]
        de = self.logout()
        de.addCallback(self.logoutCallback)

    def logoutCallback(self, d):
        if debug: print &quot;logoutCallback:&quot;, d
        reactor.stop()

    def connectionLost(self, reason):
        if debug: print &quot;connectionLost:&quot;, reason
        imap4.IMAP4Client.connectionLost(self)

    def sendLine(self, line):
        if debug: print &quot;sendLine:&quot;, line
        imap4.IMAP4Client.sendLine(self, line)

    def lineReceived(self, line):
        if debug: print &quot;lineReceived:&quot;, line
        imap4.IMAP4Client.lineReceived(self, line)

class MyIMAP4ClientFactory(protocol.ClientFactory):

    protocol = MyIMAP4Client

if __name__ == &quot;__main__&quot;:
    f = MyIMAP4ClientFactory()
    reactor.connectTCP(server, 143, f)
    reactor.run()
&lt;&lt;&lt;

(Since this is a learning exercise, I'm trying to keep things simple
by including everything in one script.)

The problem with the above is that it prints to stdout in
selectCallback and then stops the reactor in logoutCallback.

I want to use this class from a Resource's render method. But instead
of printing to stdout, I want to &quot;return&quot; the value so that the render
method can use that value while outputting HTML. It's probably also
not a good idea to stop the reactor while serving a request.

The reactor will already be started by the time render gets invoked on
my resorce so I won't be calling reactor.run, right? But I will need to
connect to my IMAP server. So I tried modifying the script to connect
*after* the reactor started:

 &gt;&gt;&gt;
if __name__ == &quot;__main__&quot;:
    def connect(f):
        reactor.connectTCP(server, 143, f)
    f = MyIMAP4ClientFactory()
    reactor.callLater(0, connect, f)
    reactor.run()
&lt;&lt;&lt;

This works just like before but feels weird to me. Is that the correct
usage for reactor.callLater? This was the only way I could figure out
how to invoke a functon *after* calling reactor.run. But this might be
a moot point since reactor.connectTCP probably just adds some events
to the queue and doesn't do anything until the reactor starts anyways,
right?

Looking at the documentation for connectTCP, I found out that it
returns an IConnector implementation but I'm not saving it to a
variable and doing anything with it so I'm not sure what it would buy
me and none of the methods on it look helpful here.

Anyways, I need to *not* print to the console:

 &gt;&gt;&gt;
    def selectCallback(self, d):
        if debug: print &quot;selectCallback:&quot;, d
        self.factory.count = d[&quot;EXISTS&quot;]
        de = self.logout()
        de.addCallback(self.logoutCallback)
&lt;&lt;&lt;

I'm now saving the count on the factory that created the protocol
instead of printing it directly to stdout.

At some point, I'm going to have to notify somebody that I've
retrieved the count so I figure I'm going to need a Deferred for
that. I modify the factory to hold on to a Deferred for me and set it
up to call a function to use the count:

 &gt;&gt;&gt;
if __name__ == &quot;__main__&quot;:
    def printCount(count):
        print count
    reactor.stop()
    f = MyIMAP4ClientFactory()
    f.deferred = defer.Deferred()
    f.deferred.addCallback(printCount)
    reactor.connectTCP(server, 143, f)
    reactor.run()
&lt;&lt;&lt;

But now I need to tell the Deferred to actually make that callback so
I modify logoutCallback and connectionLost:

 &gt;&gt;&gt;
    def logoutCallback(self, d):
        if debug: print &quot;logoutCallback:&quot;, d

    def connectionLost(self, reason):
        if debug: print &quot;connectionLost:&quot;, reason
        imap4.IMAP4Client.connectionLost(self)
        self.factory.deferred.callback(self.factory.count)
&lt;&lt;&lt;

Now logoutCallback is no longer stopping the reactor. And
connectionLost is using the factory's deferred object to inform some
function what the actual count is. This works but it seems messy.

First of all, it seems like it would be nice if my module could expose
a free function to do all this for me:

 &gt;&gt;&gt;
def getCount():
    f = MyIMAP4ClientFactory()
    f.deferred = defer.Deferred()
    reactor.connectTCP(server, 143, f)
    return f.deferred

if __name__ == &quot;__main__&quot;:
    def printCount(count):
        print count
        reactor.stop()
    getCount().addCallback(printCount)
    reactor.run()
&lt;&lt;&lt;

That's the best I can do. It works but I still don't feel all that
stoked on it. What am I doing wrong?

Is using my ClientFactory to hold data like this the correct thing to
do? In this case, there will only be one Protocol instance for this
ClientFactory, right?

Just for easy reference, here's the complete script in all its glory:

 &gt;&gt;&gt;
from twisted.internet import defer, reactor, protocol
from twisted.protocols import imap4

server = &quot;xxx&quot;
username = &quot;yyy&quot;
password = &quot;zzz&quot;

debug = 0

class MyIMAP4Client(imap4.IMAP4Client):

    def serverGreeting(self, caps):
        if debug: print &quot;serverGreeting:&quot;, caps
        imap4.IMAP4Client.serverGreeting(self, caps)
        d = self.login(username, password)
        d.addCallback(self.loginCallback)

    def loginCallback(self, d):
        if debug: print &quot;loginCallback:&quot;, d
        de = self.select(&quot;INBOX&quot;)
        de.addCallback(self.selectCallback)

    def selectCallback(self, d):
        if debug: print &quot;selectCallback:&quot;, d
        self.factory.count = d[&quot;EXISTS&quot;]
        de = self.logout()
        de.addCallback(self.logoutCallback)

    def logoutCallback(self, d):
        if debug: print &quot;logoutCallback:&quot;, d

    def connectionLost(self, reason):
        if debug: print &quot;connectionLost:&quot;, reason
        imap4.IMAP4Client.connectionLost(self)
        self.factory.deferred.callback(self.factory.count)

    def sendLine(self, line):
        if debug: print &quot;sendLine:&quot;, line
        imap4.IMAP4Client.sendLine(self, line)

    def lineReceived(self, line):
        if debug: print &quot;lineReceived:&quot;, line
        imap4.IMAP4Client.lineReceived(self, line)

class MyIMAP4ClientFactory(protocol.ClientFactory):

    protocol = MyIMAP4Client

def getCount():
    f = MyIMAP4ClientFactory()
    f.deferred = defer.Deferred()
    reactor.connectTCP(server, 143, f)
    return f.deferred

if __name__ == &quot;__main__&quot;:
    def printCount(count):
        print count
        reactor.stop()
    getCount().addCallback(printCount)
    reactor.run()
&lt;&lt;&lt;

Any suggestions for improvements or corrections to my thinking would
be greatly appreciated!

Thanks.

-- Jason


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="040326.html">[Twisted-Python] thread migration and bsddb
</A></li>
	<LI>Next message (by thread): <A HREF="040328.html">[Twisted-Python] How to get the IP address of a client using XML-RPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40322">[ date ]</a>
              <a href="thread.html#40322">[ thread ]</a>
              <a href="subject.html#40322">[ subject ]</a>
              <a href="author.html#40322">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
