<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Copyable%2C%20round%20trip%20objects%2C%09and%20untrusted%0A%09clients&In-Reply-To=20040521044512.GA28968%40vidar.dreamhost.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007859.html">
   <LINK REL="Next"  HREF="007887.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients</H1>
    <B>Jasper Phillips</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Copyable%2C%20round%20trip%20objects%2C%09and%20untrusted%0A%09clients&In-Reply-To=20040521044512.GA28968%40vidar.dreamhost.com"
       TITLE="[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients">jasper at peak.org
       </A><BR>
    <I>Fri May 21 04:39:41 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="007859.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted clients
</A></li>
        <LI>Next message: <A HREF="007887.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7864">[ date ]</a>
              <a href="thread.html#7864">[ thread ]</a>
              <a href="subject.html#7864">[ subject ]</a>
              <a href="author.html#7864">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Thu, 20 May 2004, David Ripton wrote:

&gt;<i> On 2004.05.20 02:25:20 +0000, Jasper Phillips wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Titan, I presume?  Nice game!
</I>&gt;<i> 
</I>&gt;<i> Yeah.  I don't have time to maintain 50k lines of Java code, so I need
</I>&gt;<i> to rewrite it in 5k lines of Python.  :-&gt;
</I>
I used to write Java code for a living;  I came to hate it's shortcomings
and IMHO Python is purely superior.  Still, was Titan really 50k lines of
Java?!  Mind boggling.


&gt;<i> &gt; I'm working on a game more akin to Civilization or Age of Wonders, but have
</I>&gt;<i> &gt; basically the same problem.
</I>&gt;<i> 
</I>&gt;<i> That if the Mongols upgrade early from horsies to tanks, Europe is toast,
</I>&gt;<i> but it's hard to make the game dynamic enough to show the Eiffel Yurt?
</I>
Heh. :-)  I meant the code. ;-P  Besides, while my game is in the same genre
as Civ and AoW it's more influenced by boardgames and miniatures.


&gt;<i> &gt; For me this was more complex, as what a Player knows is itself a true part
</I>&gt;<i> &gt; of the Game's State, potentially affecting Action/Event resolution.  I end
</I>&gt;<i> &gt; up calculating each Players state myself, and passing them explictly.
</I>&gt;<i> 
</I>&gt;<i> What happens if players conspire to share their secret information offline?
</I>&gt;<i> Is it okay if someone knows stuff but doesn't Officially Know it, or
</I>&gt;<i> does the whole game tend to fall over in the face of such weenie behavior?
</I>
It's ok, but won't have in game effects; such information is like secret
info only known to a few.  I'm considering a UI for information sharing, but
that'll just be for allies convenience.


&gt;<i> &gt; Plus this feels to me more like it should be part of the game itself,
</I>&gt;<i> &gt; rather than some oblique networking aspect.  Same end effect though.
</I>&gt;<i> 
</I>&gt;<i> I've decided to have the server and each client save the action stream
</I>&gt;<i> it's seen, which is somewhat similar.  I have code in the previous
</I>&gt;<i> version of this game to deduce and predict which stack hidden enemy 
</I>&gt;<i> units are in based on partial information.
</I>
I'm treating event history as game state, although I haven't implemented it
yet.  Not so much for the AIs use, but to model it's effects on future
events.  IMHO treating it as game state is also a simpler model.


&gt;<i> Why is what other players know an important part of your game state?
</I>&gt;<i> The exact extents of other players' knowledge can't be public, so nobody
</I>&gt;<i> but the server can really use this information, right?  What does the
</I>&gt;<i> server do with it?  I guess it's useful for diplomacy, if you allow
</I>&gt;<i> bartering information.
</I>
It can affect events and populations, and change how turns play out.  A
&quot;player&quot;'s knowledge represents roughly what an entire Faction knows, often
including population over which it rules.  For example knowledge of pending
invasion can spur population dispersal, unrest, etc.  Knowledge that a
foreign power is behind some act of espionage (whether true or untrue) can
affect public opinion and thus the practicality of war, etc.

Admitedly I'm not yet using this so it's just a nice potential, with the
main advantage IMHO being clearer code.


&gt;<i> &gt; IMHO handling this can avoid the 3rd problem you mention.  I have
</I>&gt;<i> &gt; Players send Actions for a given Turn as the only API to change Game
</I>&gt;<i> &gt; State.  These actions don't take game object as args, but rather Ids as
</I>&gt;<i> &gt; you suggest below.
</I>&gt;<i> 
</I>&gt;<i> I'm now back to wanting to do that in both directions.  Except using
</I>&gt;<i> strings instead of object IDs, since the parallel objects on the client 
</I>&gt;<i> and server will be distinct.  (But they will use the same class, which
</I>&gt;<i> is key to maintainability.  When you find yourself writing ClientGame
</I>&gt;<i> and ServerGame, scream until the urge passes, then decouple the concept
</I>&gt;<i> from its context until the need is gone.)
</I>
IMHO this seems overly complex.  I don't like maintaining parallel objects
or parallel calculation, as it smells like ClientGame/ServerGame...


&gt;<i> I want to make it symmetrical, so I want to build the client-side model
</I>&gt;<i> objects using the action stream, rather than copying them directly.  It
</I>&gt;<i> will be painfully boring, but I don't have *that* many actions, and
</I>&gt;<i> they're fully documented from last time I decided to go this way.
</I>
Why?  I see no advantage to symmetry here.  IMHO the a trusted-server / 
untrusted-client asymetrical design is clearly called for.


&gt;<i> &gt; IMHO it seems superflous to have the game update the information a
</I>&gt;<i> &gt; client sends, only to later access this same information for
</I>&gt;<i> &gt; calculations.  Why not just pass back the relavent Ids, and have the
</I>&gt;<i> &gt; Game API look up their True counterpart as needed?  This doesn't seem
</I>&gt;<i> &gt; onerous to me.
</I>&gt;<i> 
</I>&gt;<i> I wanted a way to bury this detail inside the framework, but it's not
</I>&gt;<i> currently practical so I'm flipping completely the other way.  I'd forgotten
</I>&gt;<i> how badly I want the ability to fast-forward and rewind through game history
</I>&gt;<i> by applying and undoing actions.  (Lets the AI free-run while giving the
</I>&gt;<i> ability to watch it as if it were moving more slowly.  Also lets you
</I>&gt;<i> review other people's savegames to pick up strategy hints.)
</I>
I disagree that sending objects isn't practical, IMHO it just helps to
approach it slightly differently.  I'll try to explain what I mean by
roughly describing my game as an example;  if my design is crappy please feel
free to shoot holes in it! :-)

Much of my game's logic is based upon Copyable Actions which are used by
both Server and Client, e.g. MoveAction.  These have a .__call__(state)
which modifies the passed state as they see fit, as well as a
.validate(state) to ensure a move is legal.  Players create a list of such
Actions, and pass them to the Game server as their turn.  All the args for
Action are literals (such as Unit ids and movement direction), with Actions
knowing how to find the corresponding objects on passed in State.

With only literal args these Action objects can be passed safely to the
game, which will reconstitue it's own versions, validate them, then invoke
them by passing in it's True State.  Players are given their own PlayerState
view of TrueState each turn, with real (copies of) objects they can use for
display, UI and validation.

Basically it works like passing objects both ways, except it's safe.  The
costs are minor: referenceable objects must have Ids, Clients must create
Actions with 'object.id' instead of 'object', and Actions need to either
'object = state.getObject(objectId)' or use Game/State methods taking ids
for args.

IMHO Making all of this essentially part of the API is cleaner than having
bulk &quot;Reconsitute Objects&quot; methods.


Hope this is at least food for thought!  In any event I find talking about
my designs is a good way for me to step back and look at them from another
angle.

-Jasper



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007859.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted clients
</A></li>
	<LI>Next message: <A HREF="007887.html">[Twisted-Python] pb.Copyable, round trip objects,	and untrusted	clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7864">[ date ]</a>
              <a href="thread.html#7864">[ thread ]</a>
              <a href="subject.html#7864">[ subject ]</a>
              <a href="author.html#7864">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
