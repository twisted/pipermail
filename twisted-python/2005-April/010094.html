<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] UDP asynchronous communication
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20UDP%20asynchronous%20communication&In-Reply-To=425951DE.3090607%40asylum-studios.ro">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010093.html">
   <LINK REL="Next"  HREF="010096.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] UDP asynchronous communication</H1>
    <B>Jp Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20UDP%20asynchronous%20communication&In-Reply-To=425951DE.3090607%40asylum-studios.ro"
       TITLE="[Twisted-Python] UDP asynchronous communication">exarkun at divmod.com
       </A><BR>
    <I>Sun Apr 10 12:48:40 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010093.html">[Twisted-Python] UDP asynchronous communication
</A></li>
        <LI>Next message: <A HREF="010096.html">[Twisted-Python] Any good examples?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10094">[ date ]</a>
              <a href="thread.html#10094">[ thread ]</a>
              <a href="subject.html#10094">[ subject ]</a>
              <a href="author.html#10094">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, 10 Apr 2005 19:18:38 +0300, Adrian Libotean &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">adrian.libotean at asylum-studios.ro</A>&gt; wrote:
&gt;<i>Tommi Virtanen wrote:
</I>&gt;<i>  &gt; Adrian Libotean wrote:
</I>&gt;<i>  &gt;
</I>&gt;<i>  &gt;&gt; Trust me I've read the document and after:
</I>&gt;<i>  &gt;&gt;
</I>&gt;<i>  &gt;&gt; reactor.listenUDP(...)
</I>&gt;<i>  &gt;&gt; reactor.run()
</I>&gt;<i>  &gt;&gt;
</I>&gt;<i>  &gt;&gt; the *client* just waits for incoming traffic.
</I>&gt;<i>  &gt;
</I>&gt;<i>  &gt;
</I>&gt;<i>  &gt; Set up things to happen, then call reactor.run() at the end
</I>&gt;<i>  &gt; of your main function.
</I>&gt;<i> 
</I>&gt;<i> That's the problem: I just want to start the client and then, when the 
</I>&gt;<i> user selects &quot;Scan&quot; from the interface, I must send the broadcast and 
</I>&gt;<i> then act on replies from servers completely independent of the main 
</I>&gt;<i> thread of the application.
</I>&gt;<i> 
</I>&gt;<i> So I have two choices: I run the reactor in a separate thread, or I find 
</I>&gt;<i> a way to do a non-blocking communication using onReceive/onSend events.
</I>&gt;<i> 
</I>
  The latter sounds like a great option to me.  Using a fictional widget library and a mega trivial protocol that just sends around &quot;int:string&quot; packets, here's how you do it:

    from twisted.internet import protocol, defer

    class ServiceDiscoveryDatagramProtocol(protocol.DatagramProtocol):
        def __init__(self):
            self.packets = {}
            self.counter = 0

        def _makeAPacket(self, hint):
            self.counter += 1
            d = self.packets[self.counter] = defer.Deferred()
            return d, '%d:%s' % (self.counter, hint)

        def _parseAPacket(self, bytes):
            counter, payload = bytes.split(':')
            return self.packets.pop(int(counter)), payload

        def discoverSomething(self, hint):
            d, pkt = self._makeAPacket(hint)
            self.transport.write(pkt)
            return d

        def datagramReceived(self, dgram, addr):
            d, stuff = self._parseAPacket(dgram)
            d.callback(stuff)

    from fiction import widgetlib

    class MainWidget(widgetlib.Frame):
        def __init__(self, proto):
            self.proto = proto
            self.discoverButton = widgetlib.Button(self, 
                                                   onClick=self._clicked)
            self.textArea = widgetlib.Text(self, 'Nothing to see')
            self.textArea.show()
            self.discoverButton.show()

        def _clicked(self):
            d = self.proto.discoverSomething('puppies')
            d.addCallback(self._discovered)

        def _discovered(self, what):
            self.textArea.setText(str(what))

    proto = ServiceDiscoveryDatagramProtocol()
    reactor.listenUDP(0, proto)
    main = MainWidget(proto)
    main.show()
    reactor.run()

  As you can see, all that is involved is hooking up sources of events to code which is interested in events.  Your widget library should generate events for user input.  Twisted will generate events for network traffic.  Each lets you define a function which is invoked when events occur.  All you need to do is define the functions in such a way as to make your program do what you want it to do :)

  Hope this helps,

  Jp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010093.html">[Twisted-Python] UDP asynchronous communication
</A></li>
	<LI>Next message: <A HREF="010096.html">[Twisted-Python] Any good examples?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10094">[ date ]</a>
              <a href="thread.html#10094">[ thread ]</a>
              <a href="subject.html#10094">[ subject ]</a>
              <a href="author.html#10094">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
