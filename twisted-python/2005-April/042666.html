<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Event dispatcher example and deferreds
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Event%20dispatcher%20example%20and%20deferreds&In-Reply-To=%3C8038a881050418151140a24554%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="042665.html">
   <LINK REL="Next"  HREF="042667.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Event dispatcher example and deferreds</H1>
    <B>Qvx 3000</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Event%20dispatcher%20example%20and%20deferreds&In-Reply-To=%3C8038a881050418151140a24554%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Event dispatcher example and deferreds">qvx3000 at gmail.com
       </A><BR>
    <I>Mon Apr 18 16:11:59 MDT 2005</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="042665.html">[Twisted-Python] Domain Filter Suggestions
</A></li>
        <LI>Next message (by thread): <A HREF="042667.html">[Twisted-Python] Twisted network games
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#42666">[ date ]</a>
              <a href="thread.html#42666">[ thread ]</a>
              <a href="subject.html#42666">[ subject ]</a>
              <a href="author.html#42666">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Consider the following twisted example::

class Event:
    def _parse ...
    def __str__ ...

class EventChannel(basic.Int32StringReceiver):
    def connectionMade(self):
        self.factory.eventConnectionMade(self)
    def connectionLost(self, reason):
        self.factory.eventConnectionLost(self, reason)
    def stringReceived(self, recd):
        event = Event._parse(recd)
        self.factory.eventReceived(self, event)
    def sendEvent(self, devent):
        devent.addCallback(lambda e: self.sendString(str(e)))

class EventService(service.Service):

    def __init__ (self):
        self.registry = {}
        self.clients = {}
        self.funcs = dict(bind=self._bind, unbind=self._unbind)

    def getEventFactory(self):
        f = protocol.ServerFactory()
        f.protocol = EventChannel
        f.eventConnectionMade = self.eventConnectionMade
        f.eventReceived       = self.eventReceived
        f.eventConnectionLost = self.eventConnectionLost
        return f

    def eventConnectionMade(self, proto):
        self.clients[id(proto)] = proto

    def eventReceived(self, proto, event):
        func = self.funcs.get(event.name, self._notify)
        func(event)

    def eventConnectionLost(self, proto, reason):
        # remove from list of clients
        if self.clients[id(proto)] == proto:
            del self.clients[id(proto)]
        # remove from registry
        for event_name, protos in self.registry.items():
            if proto in protos:
                protos.remove(proto)

    def _bind (self, event, proto):
        current = self.registry.setdefault(event.event_name, [])
        if proto not in current:
            current.append(proto)

    def _unbind (self, event, proto):
        protos = self.registry.get(event.event_name, [])
        if proto in protos:
            protos.remove(proto)

    def _notify (self, event):
        current = self.registry.get(event.name, [])
        for proto in current:
            #if proto connected:
            proto.sendEvent(defer.succeed(event))


This is a simple event dispatching service. 

It receives connections from clients (channels). Upon receiving new connection
service remembers the connection. Each connection can bind to specific event(s).
This is achieved by sending &lt;bind&gt; event. After the client binds to event, it
will receive event notifications whenever a dispatcher receives such events 
from any client.
It is similar to GUI messaging systems.


I have a few questions:

1. Do I have to use deferreds? And more importantly - HOW? 
I am worried that one slow connection could have impact on other connections.
I definitely want to avoid this.
(service is only dispatching events - there are no DB or filesystem operations)

2. What if I try to send event to recently closed channel of which I am 
not aware yet (connectionLost could be inside a long queue perhaps 
- am I talking any sense?).

3. How can I assign some kind of ID to automagically created EventChannel? 
I guess id(obj) is not good enough.

4. I'm curious: is there any limit to the number of open connections? 
Could twisted on Windows handle 10,000 or even 100,000 concurrent connections?
(I will test this, but maybe somebody has some kind of real life example)

Thanks,
Qvx


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="042665.html">[Twisted-Python] Domain Filter Suggestions
</A></li>
	<LI>Next message (by thread): <A HREF="042667.html">[Twisted-Python] Twisted network games
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#42666">[ date ]</a>
              <a href="thread.html#42666">[ thread ]</a>
              <a href="subject.html#42666">[ subject ]</a>
              <a href="author.html#42666">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
