<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Python3%20twistd%20daemon%20for%20Ubuntu%2014.04%0A%20alternatives&In-Reply-To=%3CE3F7A5E2-BDD1-4AE2-898E-A0A61F31A354%40twistedmatrix.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031228.html">
   <LINK REL="Next"  HREF="031239.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Python3%20twistd%20daemon%20for%20Ubuntu%2014.04%0A%20alternatives&In-Reply-To=%3CE3F7A5E2-BDD1-4AE2-898E-A0A61F31A354%40twistedmatrix.com%3E"
       TITLE="[Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives">glyph at twistedmatrix.com
       </A><BR>
    <I>Thu Feb 23 02:11:00 MST 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="031228.html">[Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives
</A></li>
        <LI>Next message: <A HREF="031239.html">[Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31233">[ date ]</a>
              <a href="thread.html#31233">[ thread ]</a>
              <a href="subject.html#31233">[ subject ]</a>
              <a href="author.html#31233">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
&gt;<i> On Feb 22, 2017, at 10:16 AM, Phil Mayers &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">p.mayers at imperial.ac.uk</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i> On 22/02/17 17:42, Hynek Schlawack wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> I have to disagree here:  I don&#8217;t want build tools of any kind in my
</I>&gt;&gt;<i> final containers therefore I build my artifacts separately no matter
</I>&gt;&gt;<i> what language.  Of course you can just build the venv on your build
</I>&gt;<i> 
</I>&gt;<i> Agreed, 100%. Apologies if I gave you the impression I was advocating otherwise.
</I>&gt;<i> 
</I>&gt;&gt;<i> server without wheeling up a temporary container and then package it
</I>&gt;&gt;<i> using Docker or DEB or whatever.  You should be separating building
</I>&gt;&gt;<i> and running anyway so Python &#8211; as much as I&#8217;d like Go-style single
</I>&gt;&gt;<i> binaries too &#8211; is in no way special here.  The nice thing about
</I>&gt;&gt;<i> temporary containers though is that I can do all of that on my Mac.
</I>&gt;<i> 
</I>&gt;<i> I agree that you need to separate building and installation, and I've got no particular beef with using a container, chroot, throwaway VM or whatever works for people in doing the build phase.
</I>&gt;<i> 
</I>&gt;<i> (What people do with the resultant build output - and in particular whether there is a lot of ignoring of the hard-learned lessons of system package managers going on now - I will not comment on ;o)
</I>&gt;<i> 
</I>&gt;<i> What I was trying to say - badly, apparently - was that the system python *could* be attractive to someone because many dependencies may exist in the OS package list in suitable form, but conversely may not exist in PyPI in binary form for Linux.
</I>
Yes, and building these binary artifacts is often harder than some people (cough, alpine, cough) seem to think.  But there are better ways to square this circle than restricting yourself to the versions of python libraries that happen to be available in your distro.

&gt;<i> As a very simple example: if you have a traditional (non-container) Linux system hosting a Python application in a virtualenv, and you deploy a Python app to a virtualenv e.g. using Puppet or Ansible, you either need to:
</I>&gt;<i> 
</I>&gt;<i> 1. Use no C extensions
</I>&gt;<i> 2. Hope there's a manylinux1 binary wheel
</I>&gt;<i> 3. Use the OS package and --system-site-packages
</I>&gt;<i> 4. Compile the C extensions and make them available to pip
</I>&gt;<i> 
</I>&gt;<i> #2 seems useful now that I know about it but - correct me if I'm wrong - the manylinux1 permitted C dependencies are super-tiny, and would not permit e.g. cryptography or psycopg2?
</I>
Cory already pointed this out tangentially, but I should emphasize: 'cryptography' and 'psycopg2' are things that you depend on at the Python level.  The things you depend on at the C level are libssl, libcrypto, and libpq.  If you want to build a manylinux wheel, you need to take this into account and statically link those C dependencies, which some projects are beginning to do.  (Cryptography _could_ do this today, they already have the infrastructure for doing it on macOS and Windows, the reason they're not shipping manylinux1 wheels right now has to do with the political implications of auto-shipping a second copy of openssl to Linux distros that expect to manage security upgrades centrally).

&gt;<i> #4 is what you are advocating for I believe? But can we agree that for smaller projects, that might seem like a lot of repeated work if the package is already available in the OS 
</I>
If you're going to do #4 with dh_virtualenv, your .deb can depend on the relevant packages that contain the relevant C libraries, and build linux wheels, which are vendor-specific and can dynamically link to whatever you want (i.e. not manylinux wheels, which are vendor-neutral and must statically link everything).  Manylinux wheels are required for uploading to PyPI, where you don't know who may be downloading - on your own infrastructure, where you are shipping inside an artifact (like a .deb) that specifically has metadata describing its dependencies, &quot;linux&quot; wheels are fine.  Alone, hanging around on PyPI as .whl files rather than as .debs in your infrastructure, they'd be mystery meat, but that is not the case if they have proper dependency metadata.

It might seem weird to use Python-specific tooling and per-application vendoring for Python dependencies, and yet use distro-global dynamic linking for C dependencies.  But, this is actually a perfectly cromulent strategy, and I think this bears a more in-depth explanation.

C, and particularly the ecosystem of weird dynamic linker ceremony around C, has an extremely robust side-by-side installation ecosystem, which distros leverage to great effect.  For example, on the Ubuntu machine sitting next to me as I write this, I have libasan0 (4.8.5) libasan1 (4.9.4) libasan2 (5.4.1) *and* libasan3 (6.2.0) installed, and this isn't even a computer with a particularly significant amount of stuff going on!  Nothing ever breaks and loads the wrong libasan.N.

Python, by contrast, tried to do this in a C-ish way, but that attempt resulted in this mess: <A HREF="https://packaging.python.org/multi_version_install/">https://packaging.python.org/multi_version_install/</A> &lt;<A HREF="https://packaging.python.org/multi_version_install/">https://packaging.python.org/multi_version_install/</A>&gt;, which almost nobody uses.  Right at the top of that document, &quot;For many use cases, virtual environments address this need without the complication ...&quot;.

Even if you are 100%, completely bought into a distro-style way of life, no containers at all, everything has to be in a system package to get installed, virtualenvs still make more sense than trying to sync up the whole system's Python library versions.

The reason nobody ever went back and tried to do multi-version installs &quot;right&quot; with Python is that the Python and C library ecosystems are fundamentally different in a bunch of important ways.  For one thing, Python libraries have no such thing as an enforceable ABI, so coupling between libraries and applications is much closer than in C.  For another, no SOVERSION.  Also, many small C utilities (the ones that would be some of the smaller entries in requirements.txt in a Python app) are vendored in or statically linked in applications, so the &quot;dependency management&quot; happens prior to the container build, in the source repo of the upstream, where it is hidden.  Python dependencies often have a far higher rate of churn than C dependencies because of the ease of development, which means both more divergence between required versions for different applications, and more benefits to being up-to-date for the applications that do rev faster.

Finally, the build process for Python packages is much simpler, since they're usually treated as archives of files that move around, rather than elaborate pre-build steps that are often required for C libraries to make sure everything is smashed into the .so at build time.

So think of your Python libraries as &quot;vendored in&quot; to your package for these reasons, rather than depended upon in the OS, and then participate in the broader distro (i.e. &quot;C&quot;) ecosystem by building wheels that dynamically link whatever distro-level dependencies they need to.

&gt;<i> Wondering out loud, I guess it would be possible for OS-compiled python extensions to be somehow virtualenv or relocation-compatible. One could envisage something like:
</I>&gt;<i> 
</I>&gt;<i> virtualenv t
</I>&gt;<i> . t/bin/activate
</I>&gt;<i> pip syspkg-install python-psycopg2
</I>&gt;<i> 
</I>&gt;<i> ...and this going off and grabbing the OS-provided dependency of that name, extracting it, and deploying it into the virtualenv, rather than the system Python.
</I>
This is sort of what dh_virtualenv is.  It doesn't set up the mapping for you automatically, but you can pretty quickly figure out that python-psycopg2 build-depends: libpq-dev.

&gt;<i> There are doubtless all sorts of reasons that is not practical.
</I>
The main thing is just that you have to decide on a standard format for distro-specific metadata, and then go encode it everywhere.  I'm pretty sure that distutils-sig would be open to codifying such an extension to the list of standardized metadata fields, so that tools can use it.

&gt;<i> Anyway, to be clear - I'm not advocating using the system Python. I'm trying to explain why, based on the efforts we expend locally, it could seem attractive to smaller sites.
</I>
To be even clearer, using the system python is fine - it's using the global python environment that has the most significant problem.

(Although, of course, the &quot;system python&quot; is probably CPython, and in most cases you want to be using PyPy, right?  So yeah don't use the system Python.)

I hope this explanation was helpful to those of you deploying with distro tooling!

-glyph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20170223/39b815b7/attachment-0001.html">http://twistedmatrix.com/pipermail/twisted-python/attachments/20170223/39b815b7/attachment-0001.html</A>&gt;
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031228.html">[Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives
</A></li>
	<LI>Next message: <A HREF="031239.html">[Twisted-Python] Python3 twistd daemon for Ubuntu 14.04 alternatives
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31233">[ date ]</a>
              <a href="thread.html#31233">[ thread ]</a>
              <a href="subject.html#31233">[ subject ]</a>
              <a href="author.html#31233">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
