<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Question%20on%20push/pull%20producers%20inter-workings%2C%20%0A%09was%20%3A%20%22Is%20there%20a%20simple%20Producer/Consumer%20example%20or%20tutorial%3F%22&In-Reply-To=480C47D8.7020006%40evotex.ch">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017530.html">
   <LINK REL="Next"  HREF="017536.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;</H1>
    <B>Jean-Paul Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Question%20on%20push/pull%20producers%20inter-workings%2C%20%0A%09was%20%3A%20%22Is%20there%20a%20simple%20Producer/Consumer%20example%20or%20tutorial%3F%22&In-Reply-To=480C47D8.7020006%40evotex.ch"
       TITLE="[Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;">exarkun at divmod.com
       </A><BR>
    <I>Mon Apr 21 10:41:19 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="017530.html">[Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;
</A></li>
        <LI>Next message: <A HREF="017536.html">[Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17532">[ date ]</a>
              <a href="thread.html#17532">[ thread ]</a>
              <a href="subject.html#17532">[ subject ]</a>
              <a href="author.html#17532">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 21 Apr 2008 09:52:56 +0200, Gabriel Rossetti &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing_lists at evotex.ch</A>&gt; wrote:
&gt;<i>Jean-Paul Calderone wrote:
</I>&gt;&gt;<i>On Fri, 18 Apr 2008 09:57:35 +0200, Gabriel Rossetti 
</I>&gt;<i> [snip]
</I>&gt;<i>What exactly do you mean by :
</I>&gt;<i>
</I>&gt;<i>&quot;there's no events which will signal that you can send some more of the 
</I>&gt;<i>string *except* for
</I>&gt;<i>the reactor deciding that it is ready for some more&quot;?
</I>&gt;<i>
</I>&gt;<i>When I looked at Twisted's code, the difference that I saw was that if a 
</I>&gt;<i>push producer is used, and if the data to be sent is bigger than a certain 
</I>&gt;<i>length, it calls producer.pauseProducing()
</I>
This is true.  Let's back up for a moment, though.

A pull producer is one which only produces data when it is asked for data.
The ask-for-data API is resumeProducing.  This means that a consumer which
is given a pull producer must ask it for data repeatedly until there is
none left.  The consumer is free to do this in its own pace, and a typical
efficient way to do this is to ask for more data each time the application
buffer is empty.

A push producer produces data all the time, until it is asked to stop.  It
does this at whatever pace it wishes; it might produce a byte each second
or it might produce a chunk of bytes each time a user interacts with a UI
somehow or it might produce whatever it reads out of some socket whenever
it happens to do that.  The consumer is free to ask it to stop at any time
though.  The API for that is pauseProducing, and in this circumstance,
resumeProducing delivers the opposite message: it tells the producer that
it can go back to whatever it was doing.

Does it make sense why only the push producer case has a pauseProducing
call in it?

&gt;&gt;<i>So that's how you
</I>&gt;&gt;<i>should decide which of these you want to write - if the consumer is the
</I>&gt;&gt;<i>only event source involved, as in the large string case, then you want a
</I>&gt;&gt;<i>pull producer (streaming = False);
</I>&gt;<i>
</I>&gt;<i>How can the consumer be an event source? The producer is the one sending the 
</I>&gt;<i>data, maybe I don't get what you mean by &quot;event source&quot;.
</I>
For example, if the consumer is a socket, then there are at least two events
which it can generate which are potentially interesting: application-level
buffer empty and application-level buffer full.  These are good indicators
that more data should be produced and that no more data should be produced
(for a while), respectively.

&gt;&gt;<i>if the producer itself is event-driven
</I>&gt;&gt;<i>in its ability to provide data, then you want a push producer.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I thought the push producer worked like this : if the data is too big, send 
</I>&gt;<i>part of it and pause the rest, let the reactor breath some, and repeat. I 
</I>&gt;<i>thought the pull producer was basically like if no producer was used, one 
</I>&gt;<i>has to take care of any data splitting and send small parts when the 
</I>&gt;<i>consumer is ready. Is this not correct?
</I>
It's often the case that a producer doesn't have all of the data it is going
to produce when it is first registered with the consumer.  In these cases,
it is less a matter if splitting up the data and more a matter of knowing
whether to keep trying to gather more data to give to the consumer.  If the
consumer has indicated that it wants no more data (via pauseProducing), then
the producer can chill out for a while.  Only when the consumer issues the
resumeProducing call does the producer need to start getting data again.  For
TCP connections, this is a pretty good reflection of what goes on at a lower
level.  If you stop reading from a TCP socket, the remote side has to stop
sending shortly afterwards.  This is more efficient than letting an unbounded
amount of data pile up in memory.

If you _do_ already have all of the data that is going to be produced (that
is, in-memory and as a Python string or other byte buffer object which can
be used with socket.send), then the only reasons to use a producer are that
some object that you want to give the data to only supports the producer/
consumer API so you have no choice but to use a producer, or that you want
to know when the data has been cleared out of the application-level buffer
(not necessarily sent over the network, and certainly not necessarily
received by the peer, but at least no longer buffered in your userspace
process).  If neither of these apply, you may as well just write the one
string to the transport all at once.  Since you already had all the data
in memory, you already payed the resource allocation penalty, so there's
not really much lost by ignoring P/C.

Hope this helps,

Jean-Paul


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017530.html">[Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;
</A></li>
	<LI>Next message: <A HREF="017536.html">[Twisted-Python] Question on push/pull producers inter-workings, 	was : &quot;Is there a simple Producer/Consumer example or tutorial?&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17532">[ date ]</a>
              <a href="thread.html#17532">[ thread ]</a>
              <a href="subject.html#17532">[ subject ]</a>
              <a href="author.html#17532">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
