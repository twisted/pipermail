<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: More on PB Copyable Errors
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20More%20on%20PB%20Copyable%20Errors&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009262.html">
   <LINK REL="Next"  HREF="009267.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: More on PB Copyable Errors</H1>
    <B>David Bolen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20More%20on%20PB%20Copyable%20Errors&In-Reply-To="
       TITLE="[Twisted-Python] Re: More on PB Copyable Errors">db3l at fitlinxx.com
       </A><BR>
    <I>Wed Dec 29 21:31:17 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009262.html">[Twisted-Python] Re: More on PB Copyable Errors
</A></li>
        <LI>Next message: <A HREF="009267.html">[Twisted-Python] Re: More on PB Copyable Errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9265">[ date ]</a>
              <a href="thread.html#9265">[ thread ]</a>
              <a href="subject.html#9265">[ subject ]</a>
              <a href="author.html#9265">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Justin Johnson &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">justinjohnson at gmail.com</A>&gt; writes:

&gt;<i> In my testing it seemed that I would get an InsecureJelly error on the
</I>&gt;<i> sending side if I tried to send back an object that I hadn't called
</I>&gt;<i> pb.setUnjellyableForClass on the sending side for.  In other words,
</I>&gt;<i> calling setUnjellyableForClass on the sending side was a way of saying
</I>&gt;<i> that it was okay to send over the wire, and also a way of registering
</I>&gt;<i> what class to use when unjellying it if it were received.
</I>&gt;<i> 
</I>&gt;<i> Is this not correct?
</I>
I believe the only purpose of setUnjellyableForClass is to establish
what to do for unjellying.  While it does also impact the global
security options (which do get checked during jellying) the way it
stores type information in there is only matched during unjellying, at
least in my experience (it adds permission for the type but not the
instance).

I believe the only (typical) requirement to support jellying an object
is that it be a class that is a jelly.Jellyable subclass (such as any
of the remoteable flavors like Copyable, Referenceable, etc...).  Nothing
else should be needed on the server side.

I just tried a quick tweak to your s/e/c.py modules so that s.py
returned an instance of a dummy class defined in e.py instead of an
error, and it seems to work fine even if the server side (s) hasn't
issued the setUnjellyableForClass call.  Without that call, the client
will raise the error after receiving the object.  And even if the
server does issue that call, if the dummy class isn't inheriting from
Copyable, the insecure error is generated on the transmitting side.

It is, however, possible to insert additional types/classes/modules
into the global security options independent of class inheritance from
Jellyable.  This is how all the basic Python types are handled, but it
can be extended to support your own classes (although I had a problem
with extension classes/types, since I originally tried to use this to
support mxDateTime objects without modifying jelly).

So for example, if I have my test class &quot;MyObject&quot; in e.py, and
instead of setUnjellyableForClass, I use something like
&quot;jelly.globalSecurity.allowInstancesOf(MyObject)&quot;, then the object
will still be successfully sent and received (providing the instance
data can also be jellied).

So after writing this, the fact that the security options could get
used to permit an instance (that isn't of a subclass of Jellyable) to
be encoded might mean that just verifying Jellyable (ala my last
response to Christopher) is insufficient, at least technically.

Perhaps the only true way to determine if something is jellyable is to
try to jelly it (heck, that's probably more Pythonic anyway), and just
handle an exception as a fallback to the string representation.

-- David



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009262.html">[Twisted-Python] Re: More on PB Copyable Errors
</A></li>
	<LI>Next message: <A HREF="009267.html">[Twisted-Python] Re: More on PB Copyable Errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9265">[ date ]</a>
              <a href="thread.html#9265">[ thread ]</a>
              <a href="subject.html#9265">[ subject ]</a>
              <a href="author.html#9265">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
