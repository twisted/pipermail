<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Bloody Twisted VFS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Bloody%20Twisted%20VFS&In-Reply-To=%3C74e109b70807091924w779a261chd4d4f7f61fde16a1%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="050586.html">
   <LINK REL="Next"  HREF="050545.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Bloody Twisted VFS</H1>
    <B>Andy Gayton</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Bloody%20Twisted%20VFS&In-Reply-To=%3C74e109b70807091924w779a261chd4d4f7f61fde16a1%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Bloody Twisted VFS">andy at thecablelounge.com
       </A><BR>
    <I>Wed Jul  9 20:24:38 MDT 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="050586.html">[Twisted-Python] Bloody Twisted VFS
</A></li>
        <LI>Next message (by thread): <A HREF="050545.html">[Twisted-Python] Weekly Bug Summary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50591">[ date ]</a>
              <a href="thread.html#50591">[ thread ]</a>
              <a href="subject.html#50591">[ subject ]</a>
              <a href="author.html#50591">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Jul 9, 2008 at 7:34 PM, Andrew Bennetts
&lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">andrew-twisted at puzzling.org</A>&gt; wrote:
&gt;<i> Andy Gayton wrote:
</I>&gt;<i> [...]
</I>&gt;&gt;<i> Its a general solution for re-decorating the return result of methods
</I>&gt;&gt;<i> on decorated objects, which return new instances of themselves.  Which
</I>&gt;&gt;<i> is particularly handy for decorating tree node like objects, which can
</I>&gt;&gt;<i> return new child instances.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For example:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> root = FilePathNode(FilePath('/tmp'))
</I>&gt;&gt;<i> root = ReadOnly(root)
</I>&gt;&gt;<i> root = ForceUser(root, 'nobody')
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> root.child('foo') # should return a read only node for /tmp/foo, which
</I>&gt;&gt;<i> creates new files as user nobody.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It'd be awesome to provide support for this in a simpler way.
</I>&gt;<i>
</I>&gt;<i> For what it's worth, bzrlib.transport.decorator provides a similar facility
</I>&gt;<i> for bzrlib.transport.  It's used to implement e.g. ReadonlyTransportDecorator.
</I>&gt;<i> There's also a ChrootTransport, which is essentially a decorator too (although
</I>&gt;<i> it doesn't use bzrlib.transport.decorator because the generic decorator facility
</I>&gt;<i> didn't provide a sane way to track what the root of the chroot should be).
</I>
I'm likely over looking a few things.  Just hacked this together after
reading over TransportDecorator for a couple of minutes.  It's
possible that TransportDecorator could be implemented with vfs's
Decorator helper, with something along the lines of:

class TransportDecorator(twisted.vfs._decorator.Decorator):
    def __init__(self, url, _decorated=None):
        prefix = self._get_url_prefix()
        if not url.startswith(prefix):
            raise ValueError(
                &quot;url %r doesn't start with decorator prefix %r&quot; % \
                (url, prefix))
        decorated_url = url[len(prefix):]
        if _decorated is None:
             _decorated = get_transport(decorated_url)
        super(TransportDecorator, self).__init__(
            _decorated, factoryMethods=['clone'])

    def abspath(self, relpath):
        return self._get_url_prefix() + self.target.abspath(relpath)

    def external_url(self):
        return self._get_url_prefix() + self.target.external_url()

    def _get_url_prefix(self):
        raise NotImplementedError(self._get_url_prefix)

A key difference to this compared to the verbose approach in bzrlib,
is that the above object isn't an instance of Transport.  So far I've
handled this with zope.interface's.  The above decorator could say
that it implements(ITransport).


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="050586.html">[Twisted-Python] Bloody Twisted VFS
</A></li>
	<LI>Next message (by thread): <A HREF="050545.html">[Twisted-Python] Weekly Bug Summary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50591">[ date ]</a>
              <a href="thread.html#50591">[ thread ]</a>
              <a href="subject.html#50591">[ subject ]</a>
              <a href="author.html#50591">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
