<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Bloody Twisted Tree (VFS)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Bloody%20Twisted%20Tree%20%28VFS%29&In-Reply-To=%3C20080706151209.25821.82528526.divmod.xquotient.12221%40joule.divmod.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="050547.html">
   <LINK REL="Next"  HREF="050552.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Bloody Twisted Tree (VFS)</H1>
    <B>glyph at divmod.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Bloody%20Twisted%20Tree%20%28VFS%29&In-Reply-To=%3C20080706151209.25821.82528526.divmod.xquotient.12221%40joule.divmod.com%3E"
       TITLE="[Twisted-Python] Bloody Twisted Tree (VFS)">glyph at divmod.com
       </A><BR>
    <I>Sun Jul  6 09:12:09 MDT 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="050547.html">[Twisted-Python] Bloody Twisted VFS
</A></li>
        <LI>Next message (by thread): <A HREF="050552.html">[Twisted-Python] Bloody Twisted Tree (VFS)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50549">[ date ]</a>
              <a href="thread.html#50549">[ thread ]</a>
              <a href="subject.html#50549">[ subject ]</a>
              <a href="author.html#50549">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On 07:32 am, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">jml at mumak.net</A> wrote:
&gt;<i>On Sat, Jul 5, 2008 at 3:27 AM, Andy Gayton &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">andy at thecablelounge.com</A>&gt; 
</I>&gt;<i>wrote:
</I>&gt;&gt;<i>On Mon, Jun 30, 2008 at 9:06 PM, Jonathan Lange &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">jml at mumak.net</A>&gt; wrote:
</I>
&gt;&gt;<i>  * The primitive interface for IO should be producer/consumers,
</I>&gt;&gt;<i>replacing readChunk, writeChunk.  This interface is primitive enough
</I>&gt;&gt;<i>to express all other interfaces, while still providing the opportunity
</I>&gt;&gt;<i>to optimize streaming performance.  The producer/consumer interface
</I>&gt;&gt;<i>will need to take an offset to allow readChunk and writeChunk to be
</I>&gt;&gt;<i>implemented.
</I>&gt;<i>
</I>&gt;<i>It would be nice to have things so that readChunks and writeChunks
</I>&gt;<i>(plural) could be implemented, to avoid potato programming.
</I>
I don't think this is actually going to be a practical consideration, if 
I correctly understand what you mean.  For one thing, the 
producer/consumer interface is going to be something (very vaguely) like 
this:

    remoteFile.writeFrom(producer[, offset, length])
    remoteFile.readInto(consumer[, offset, length])

This means that if you've got a really giant file, the implementation 
could pretty trivially optimize delivering it to you in the most 
efficient possible way, keeping all the relevant buffers full at every 
opportunity.  Given that stream-based I/O is somewhat inherently serial, 
it's difficult to get less potato-y than that.

writeChunks, if I understand it, would be pretty trivially implementable 
by saying

    remoteFile.writeFrom(MultiChunkProducer(chunks))

Mapping 'readChunks' and 'writeChunks' to readv and writev in my head, 
I'm not really sure what a 'readChunks' would actually do, since we copy 
memory every time we sneeze in Python anyway.  We're not going to have 
preallocated buffers to read into.
&gt;&gt;<i>  * we're still using getMetadata and setMetadata - its likely we want
</I>&gt;&gt;<i>a layer on top of using arbitrary key/value dicts for metadata, but
</I>&gt;&gt;<i>this can be introduced in a backwards compatible way.
</I>
Hmm.  I don't remember agreeing to layering anything on top of 
&quot;arbitrary key/value dicts&quot;; I'd really like to see a completely 
different layer that specifically separates out optional features 
(xattrs, symlinks, posix ACLs(?)) into separate interfaces with specific 
methods that don't necessarily need to retrieve all the metadata at 
once, which is sort of an inherent property of having a key/value dict.

I'm OK with &quot;still using getMetadata and setMetadata&quot;, though, since as 
you say, it can be introduced in a backwards-compatible way.  I do think 
that we should keep that discussion open (for later, after the rest of 
this work has been completed).
&gt;<i>This reminds me, it would be good for VFS to have an exception for
</I>&gt;<i>&quot;this operation isn't supported&quot; (say with symlinks on fat32) and
</I>&gt;<i>another exception for &quot;supportable, but not actually implemented yet&quot;.
</I>
I don't think it's useful to distinguish between these two types of 
exception at *runtime*.  The use-case I can see for distinguishing is 
letting a programmer know that they should figure out something that 
might be tricky to implement and write some wrappers or submit some 
patches.  Perhaps a separate error message, rather than a separate 
exception type?  Do you have a different use-case?

One related thing that we spoke about in person was pushing this 
negotiation of file-system features backwards to the initialization 
step, so that applications which needed unusual filesystem attributes 
could fail quickly with a clear error message if they weren't supported 
by the underlying platform. (&quot;WebDAV requires extended filesystem 
attributes, and your backend, SFTP, does not provide that feature.&quot;, 
&quot;txGnuStow requires symbolic links, and your backend, the Microsoft 
Windows filesystem, does not provide that feature.&quot;)

The nice thing about this is that the default interface to the backend 
would be the one that masked everything but the most common subset of 
filesystem features, so that you couldn't *accidentally* depend on a 
feature that wasn't present everywhere, without specifically requesting 
it.  In order to get more obscure features you'd have to specify a 
longer list of interfaces.
&gt;&gt;<i>  * we still need to decide whether path resolution should be moved to
</I>&gt;&gt;<i>a separate interface, instead of being part of the node's interface.
</I>
&gt;<i>I'm not 100% sure what this means? Does this relate to possibly
</I>&gt;<i>combining with FilePath?
</I>
The tongue-in-cheek name that radix gave to this interface was 
'filepath.pathdelta'.  It's related to filepath in the sense that 
FilePath, ZipPath, et. al. could benefit from using the same interface 
to talk about relative pathnames rather than manipulating lists of 
strings.  One can, after all, abstractly do operations like &quot;child()&quot; 
and &quot;parent()&quot; without knowing a lot about the base implementation of 
the filesystem in question.
&gt;&gt;<i>  * there's concern over the package name.  twisted.tree has
</I>&gt;&gt;<i>considerable support :)
</I>
&gt;<i>I kind of like that. I'm not sure what the concern is with 'vfs' 
</I>&gt;<i>though.
</I>
&quot;twisted.vfs&quot; sounds incredibly boring and unpronounceable.  It would be 
the first twisted.&lt;acronym&gt; package, and it's not really related to any 
other technology ambiguously named &quot;vfs&quot;.

However, this reminds me about another concern which I did not remember 
to raise while Andy was here.  Should this really be twisted.&lt;anything&gt; 
at all?  I'd like twisted &lt;x&gt; &quot;dot products&quot; to generally be an 
application which does something &lt;x&gt;-ish.  I'm aware that not every 
package follows this rule, but the ones that don't are either (A) 
unmaintained and slated for removal, or (B) part of the core, not 
independent subprojects, as &quot;vfs&quot; seems slated to be.

Put a different way: what should 'twistd tree' do?  My suggestion would 
be a simple multi-protocol file server: HTTP, FTP (although probably 
disable that by default), SFTP, maybe a &quot;native&quot; protocol for providing 
a generalized backend for any Twisted application that uses the 'tree' 
API, so that we can write a proxy that exposes every arbitrary 
combination of features from the protocols it's talking to.

If everyone agrees with this, then great.  However, if we never intend 
for this to go beyond providing an API that other systems hook into, 
maybe it should go somewhere subordinate to another project; 
twisted.internet.files perhaps?

To be clear: I don't mind doing a release that does not include this 
tool; I don't think anything should block on it.  I just want it to be 
in the cards eventually if this is the way we're going to release it.
&gt;&gt;<i>I'll try and make these changes in the next week or so.  If you are
</I>&gt;&gt;<i>interested in shaping how this goes, you can track what's going on in
</I>&gt;&gt;<i><A HREF="http://twistedmatrix.com/trac/ticket/2815">http://twistedmatrix.com/trac/ticket/2815</A> - just weigh in once the
</I>&gt;&gt;<i>ticket goes back to review.
</I>
&gt;<i>Here's some random stuff that I wanted to at least mention:
</I>&gt;<i>
</I>&gt;<i>- Error translation. This should translate the exception types, but it
</I>&gt;<i>should also translate values, so the error contains the virtual path.
</I>
This sounds like a specific enough thing that you could file a ticket 
that described the exact behavior that you wanted.  It doesn't sound 
contentious at all to me, so unless you think there's some hidden 
confusion there... go ahead?
&gt;<i>- Deferreds. You don't mention them at all, but the lack of
</I>&gt;<i>asynchronous interfaces was one of the biggest problems we had with
</I>&gt;<i>twisted.vfs.
</I>
I believe that the consensus on asynchronicity is that all of the 
synchronous stuff should be FilePath's job.  In the glorious future of 
twisted.tree, everything will be async.  As discussed above, this 
doesn't always mean Deferreds, it also means producers and consumers.

One thing we didn't talk about in person: handling extremely large 
directories.  We had spoken about children() returning a Deferred of a 
list; I think it would be nice if it actually had a producer/consumer 
API of its own.  Maybe this is too much of a corner case to worry about 
in average applications (i.e. we could provide a give-me-a-deferred 
convenience API) but it would be nice if it were *possible* to implement 
things that were efficient against really big networked directories.
&gt;<i>- URL Escaping. I got bitten by this recently. It's obviously not a
</I>&gt;<i>general VFS problem, but it's an issue with enough of them that it
</I>&gt;<i>should be considered when defining interfaces.
</I>
I *think* that this should be pretty easily dealt with in a pretty 
generic way by having a clearly-defined set of string escaping rules 
depending on which protocol you're using.  It's a general VFS issue in 
the sense that there are escaping issues with &quot;/&quot; on regular 
filesystems, after all.  Or at least, there are error-reporting issues 
with characters like &quot;/&quot;, &quot;;&quot;, and &quot;:&quot; on certain FSes.
&gt;<i>- &quot;Decorators&quot; like &quot;read-only&quot; and &quot;chroot&quot; could prove useful. Is
</I>&gt;<i>there room in the design for such things?
</I>
We did discuss having things like this.  Specifically we talked a lot 
during the metadata discussion about the possibility for 'decorators' 
like &quot;provide-xattrs-with-dotfiles&quot; and &quot;provide-atime-by-pretending- 
its-zero&quot;.  However, we didn't spend too long on it because every 
alternative that got brought up sounded like it was a pretty amenable to 
a simple delegation approach; there just wasn't a lot of meat there. 
We'll have to check to make sure that is true in the review process, of 
course, but this is probably the thing I'm least worried about :).


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="050547.html">[Twisted-Python] Bloody Twisted VFS
</A></li>
	<LI>Next message (by thread): <A HREF="050552.html">[Twisted-Python] Bloody Twisted Tree (VFS)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50549">[ date ]</a>
              <a href="thread.html#50549">[ thread ]</a>
              <a href="subject.html#50549">[ subject ]</a>
              <a href="author.html#50549">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
