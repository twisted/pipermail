<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] freeing the reactor to do other jobs
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20freeing%20the%20reactor%20to%20do%20other%20jobs&In-Reply-To=%3C20081107152617.GA17614%40vidar.dreamhost.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="051166.html">
   <LINK REL="Next"  HREF="051171.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] freeing the reactor to do other jobs</H1>
    <B>David Ripton</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20freeing%20the%20reactor%20to%20do%20other%20jobs&In-Reply-To=%3C20081107152617.GA17614%40vidar.dreamhost.com%3E"
       TITLE="[Twisted-Python] freeing the reactor to do other jobs">dripton at ripton.net
       </A><BR>
    <I>Fri Nov  7 08:26:17 MST 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="051166.html">[Twisted-Python] freeing the reactor to do other jobs
</A></li>
        <LI>Next message (by thread): <A HREF="051171.html">[Twisted-Python] freeing the reactor to do other jobs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#51168">[ date ]</a>
              <a href="thread.html#51168">[ thread ]</a>
              <a href="subject.html#51168">[ subject ]</a>
              <a href="author.html#51168">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 2008.11.07 08:29:50 -0500, Jeff Dyke wrote:
&gt;<i> I'm using the XMLRPC server in twisted and a few methods call other,
</I>&gt;<i> sometimes long running, functions/methods.  I'm trying to get my brain
</I>&gt;<i> around how to free the reactor to respond to other requests while this
</I>&gt;<i> is happening.
</I>
There are two ways:

1. Instead, write functions that don't block for long, but instead do a
little bit of work, schedule a call to do the rest of the work, and then
return, so the reactor can have the CPU back.

2. Farm out big chunks of work that you can't or don't want to split up
to a subprocess or thread.

&gt;<i> A scenario.  A call is made to the server, which selects say 10K rows
</I>&gt;<i> from a db and needs to check each row against a table and if they do
</I>&gt;<i> not exist, insert them.
</I>&gt;<i> 
</I>&gt;<i> &quot;&quot;&quot; Oversimplified version of the process &quot;&quot;&quot;
</I>&gt;<i> def getData(self,user_id):
</I>&gt;<i>     rows = self.getUserData(user_id)
</I>&gt;<i>     for row in rows:
</I>&gt;<i>         if self.existsInQueue(row['some_id']):
</I>&gt;<i>             continue
</I>&gt;<i>         else:
</I>&gt;<i>              self.insertQueue(row)
</I>
If the long-running work is in a blocking database call, and the
database does not support a less-blocking version and you can't change
the database, then you probably want to use deferToThread for that part.

And then move the rest of getData into a separate function, that gets
called in a callback after getUserData finishes.

def getData(self,user_id):
    deferred1 = reactor.deferToThread(self.getUserData, user_id)
    deferred1.addCallback(self._addRowsToQueue)
    deferred1.addErrback(self._getUserDataFailed)

If adding the rows to the queue is fast, then you're done.  Just move
everything after getUserData into _addRowsToQueue.

def _addRowsToQueue(self, rows):
    for row in rows:
        if not self.existsInQueue(row['some_id']):
            self.insertQueue(row)

But if adding all the rows to the queue in one function call is too
slow, then you need to split it up.  It's a loop, so splitting it up is
easy.  Here's the simple scheduling-only version:

def _addSomeRowsToQueue(self, rows):
    if rows:
        row = rows.pop(0)
        if not self.existsInQueue(row['some_id']):
            self.insertQueue(row)
        reactor.callLater(0, self._addSomeRowsToQueue, rows)

Adding deferreds to the mix so that a callback function is called when
all the rows are added to the queue is the next step, after you
understand how this much works.

&gt;<i> I want the caller to wait on a result from this process, but I also
</I>&gt;<i> want the reactor to be able to handle other requests as they come in.
</I>
I hope you can live with &quot;I want something to happen using the results
from this process&quot;, rather than &quot;I want the caller to wait on a result
from this process.&quot;

You can simulate blocking flow somewhat with deferredGenerator or
inlineCallbacks, but I recommend sticking to the old way at first.
It's simpler and less magical.

-- 
David Ripton    <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">dripton at ripton.net</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="051166.html">[Twisted-Python] freeing the reactor to do other jobs
</A></li>
	<LI>Next message (by thread): <A HREF="051171.html">[Twisted-Python] freeing the reactor to do other jobs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#51168">[ date ]</a>
              <a href="thread.html#51168">[ thread ]</a>
              <a href="subject.html#51168">[ subject ]</a>
              <a href="author.html#51168">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
