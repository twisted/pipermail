<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Unjelly - recursion limit reached
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Unjelly%20-%20recursion%20limit%20reached&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011922.html">
   <LINK REL="Next"  HREF="011930.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Unjelly - recursion limit reached</H1>
    <B>Brian Warner</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Unjelly%20-%20recursion%20limit%20reached&In-Reply-To="
       TITLE="[Twisted-Python] Unjelly - recursion limit reached">warner at lothar.com
       </A><BR>
    <I>Sat Nov  5 21:34:05 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011922.html">[Twisted-Python] does twisted.* support mobile code?
</A></li>
        <LI>Next message: <A HREF="011930.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11919">[ date ]</a>
              <a href="thread.html#11919">[ thread ]</a>
              <a href="subject.html#11919">[ subject ]</a>
              <a href="author.html#11919">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> When a view_ method is called in a cacheable and the return value is a
</I>&gt;<i> graph of interconnected cacheables, is the return value completely
</I>&gt;<i> serialized at that point?
</I>
Do you mean that some view_ method is being invoked on a pb.Referenceable (or
pb.ViewPoint, I suppose) ? And that method is returning an instance that
inherits from pb.Cacheable? And this pb.Cacheable instance holds references
to other pb.Cacheables? Which may or may not have been transmitted across
this wire once already?

The general answer is yes, the return value is completely serialized right
then. The serialized form of the return value is transmitted in pieces as
jelly recurses down the retval object graph, each new node visited causes a
little bit more data to be sent. However, it does not stop for anything, and
there is no way for an object being serialized to indicate that it wants to
put off serialization for a while[1]. On the receiving end, the
callRemote()'s Deferred will not be fired until the retval has completely
finished deserialization. Intermediate objects may be constructed while
deserialization is taking place, but that ought to be invisible to the
caller.

I'm not sure what would happen if, say, your getStateToCacheAndObserveFor
method did a callRemote though the same wire. newpb has a queue to handle
this sort of thing (the callRemote doesn't get transmitted until at least
after the current operation has finished), but I don't know what oldpb does.
If it isn't clever enough to be reentrant, the receiving end will get
interleaved object state from the two operations and the results will be very
very messy.

getStateToCacheAndObserveFor and getStateToCopy are called from PB internals,
and as a result it may not be safe to make other PB calls from there. view_*
is called when the wire is in a stable state (i.e. remote methods calls are
top-level objects on the wire), so I think it should be safe to make
arbitrary PB calls from it.

&gt;<i> I'm concerned that my hierarchy of cacheables received by the client  
</I>&gt;<i> is inconsistent because it is being modified by another client view_  
</I>&gt;<i> call into the server before the previous hierarchy has been fully  
</I>&gt;<i> serialized to the first client.
</I>
Note that each callRemote is more-or-less atomic, and the creation of a whole
object graph is more-or-less atomic, but it is entirely possible that other
method calls will happen during the middle of a huge slew of RemoteCache
updates. So if object A modifies a dozen Cacheables at once, and object B has
a RemoteCache that is watching them, object C might sneak in a callRemote
while only half of the updates have been processed. The same thing will
happen if your Cacheable update method does multiple callRemotes to do its
job.


hope that helps somehow,
 -Brian



[1]: in newpb, if you enable it, Slicers can return a Deferred to indicate
     that they want to stall serialization for a while. This raises concerns
     about knowing when, if ever, serialization will resume, and increases
     uncertainty about state coherency, because all sorts of stuff could
     happen by the time serialization is resumed.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011922.html">[Twisted-Python] does twisted.* support mobile code?
</A></li>
	<LI>Next message: <A HREF="011930.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11919">[ date ]</a>
              <a href="thread.html#11919">[ thread ]</a>
              <a href="subject.html#11919">[ subject ]</a>
              <a href="author.html#11919">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
