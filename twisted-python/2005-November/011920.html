<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] pb.Cacheable vs. offline queuing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Cacheable%20vs.%20offline%20queuing&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011930.html">
   <LINK REL="Next"  HREF="011921.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] pb.Cacheable vs. offline queuing</H1>
    <B>Brian Warner</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Cacheable%20vs.%20offline%20queuing&In-Reply-To="
       TITLE="[Twisted-Python] pb.Cacheable vs. offline queuing">warner at lothar.com
       </A><BR>
    <I>Sat Nov  5 21:55:53 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011930.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
        <LI>Next message: <A HREF="011921.html">[Twisted-Python] pb.Cacheable vs. offline queuing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11920">[ date ]</a>
              <a href="thread.html#11920">[ thread ]</a>
              <a href="subject.html#11920">[ subject ]</a>
              <a href="author.html#11920">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> I've been looking at Cacheable, as the live updates between servers
</I>&gt;<i> would be useful, but I have a few questions:
</I>&gt;<i>
</I>&gt;<i> How does it avoid collisions, if an attribute is changed on both ends
</I>&gt;<i> at once?  Is any kind of 2PC involved, or similar?  I read that some
</I>&gt;<i> part of reading/observing is atomic, but is modifying atomic as well?
</I>
Luckily (well, for us at least :), there is no concept of &quot;simultaneous&quot;
here. PB offers two distinct classes for cacheable use: pb.Cacheable on the
&quot;sending&quot; side, and pb.RemoteCache on the &quot;receiving&quot; side. Modification
messages flow in one direction only. As long as you don't trigger some kind
of reentrancy problem, each update message is basically atomic, but there is
no mechanism in place to send changes back in the other direction.

So if you want to allow both sides to change things, you will have to build
some sort of layer on top of pb.Cacheable, which is where you'd put in your
synchronization logic. You have to figure out when the &quot;other&quot; object is
created, find a way to wire it back to its partner, and make sure that
changes don't travel in endless loops between the two paired objects.

&gt;<i> the two servers (public and office) must both keep serving users, even if
</I>&gt;<i> the connection between them is severed.
</I>
Be aware that trying to accomodate disconnected operation is like planting
kudzu in your flowerbed with a promise that you'll &quot;keep an eye on it&quot;. Each
time you think you've figured out everything there is to know about
distributed synchronization, you discover a new academic paper explaining a
new horrible failure method that you're vulnerable to. The depths awaiting to
be plumbed know no bound. (the problem is basically equivalent to merging in
a distributed version control system, and look at how many of *those* we've
got running around :).

Worse yet, the same problems actually exist in always-connected operation,
it's just that you can trick yourself into thinking you can ignore them more
often. Unidirectional dataflow is at least four orders of magnitude easier to
deal with.

&gt;<i> any collisions would be dealt with manually by the office staff once the
</I>&gt;<i> connection came back up.
</I>
Good. You might still have a chance to retain your sanity :). 

Yeah, Cacheable won't be enough for you. My hunch is that you'll be
implementing enough new code that you might as well not bother building it on
top of pb.Cacheable: start with a pb.Referenceable and a remote_acceptUpdate
method, an outboundUpdates() queue, and some setter methods to trigger
outbound update messages.

good luck,
 -Brian


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011930.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
	<LI>Next message: <A HREF="011921.html">[Twisted-Python] pb.Cacheable vs. offline queuing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11920">[ date ]</a>
              <a href="thread.html#11920">[ thread ]</a>
              <a href="subject.html#11920">[ subject ]</a>
              <a href="author.html#11920">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
