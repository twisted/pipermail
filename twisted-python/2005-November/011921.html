<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] pb.Cacheable vs. offline queuing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Cacheable%20vs.%20offline%20queuing&In-Reply-To=20051105.185553.33436059.warner%40lothar.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011920.html">
   <LINK REL="Next"  HREF="011923.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] pb.Cacheable vs. offline queuing</H1>
    <B>Jordan Krushen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20pb.Cacheable%20vs.%20offline%20queuing&In-Reply-To=20051105.185553.33436059.warner%40lothar.com"
       TITLE="[Twisted-Python] pb.Cacheable vs. offline queuing">jkrushen at gmail.com
       </A><BR>
    <I>Sat Nov  5 22:29:41 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011920.html">[Twisted-Python] pb.Cacheable vs. offline queuing
</A></li>
        <LI>Next message: <A HREF="011923.html">[Twisted-Python] Win32 installers of Twisted 2.1?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11921">[ date ]</a>
              <a href="thread.html#11921">[ thread ]</a>
              <a href="subject.html#11921">[ subject ]</a>
              <a href="author.html#11921">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/5/05, Brian Warner &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">warner at lothar.com</A>&gt; wrote:

&gt;<i> &gt; the two servers (public and office) must both keep serving users, even if
</I>&gt;<i> &gt; the connection between them is severed.
</I>&gt;<i>
</I>&gt;<i> Be aware that trying to accomodate disconnected operation is like planting
</I>&gt;<i> kudzu in your flowerbed with a promise that you'll &quot;keep an eye on it&quot;. Each
</I>&gt;<i> time you think you've figured out everything there is to know about
</I>&gt;<i> distributed synchronization, you discover a new academic paper explaining a
</I>&gt;<i> new horrible failure method that you're vulnerable to. The depths awaiting to
</I>&gt;<i> be plumbed know no bound. (the problem is basically equivalent to merging in
</I>&gt;<i> a distributed version control system, and look at how many of *those* we've
</I>&gt;<i> got running around :).
</I>
Been there, ran away from that :)  In this case, all data and business
logic (relevant to the syncing) are narrowly defined, and I plan to
treat any data collisions the same way as any sane merging system --
let the user figure it out (with an iSync-esque conflict resolver
interface).  I don't want to spend x amount of time building the
system, and 3-4x writing syncing logic.

&gt;<i> Worse yet, the same problems actually exist in always-connected operation,
</I>&gt;<i> it's just that you can trick yourself into thinking you can ignore them more
</I>&gt;<i> often. Unidirectional dataflow is at least four orders of magnitude easier to
</I>&gt;<i> deal with.
</I>
This system isn't symmetric, thankfully, and only certain types of
data will be updatable on both ends.  While connected, both systems
won't be doing quite the same thing (for the most part) so the window
for collisions while connected is incredibly small.  The same objects
would be edited, but not the same attributes on each end.

&gt;<i> &gt; any collisions would be dealt with manually by the office staff once the
</I>&gt;<i> &gt; connection came back up.
</I>&gt;<i>
</I>&gt;<i> Good. You might still have a chance to retain your sanity :).
</I>
Sanity is overrated :)

I don't plan to spend a lot of time writing code to deal with
synchronization, though, 'cause it's both tedious and complex at once.

Offline operation is *not* going to be nominal operation, thanks to
their relatively good connectivity to each other.  This is mostly to
ensure that the office doesn't shut down if their hosted server's
connection dies, and so that end users are still able to do things if
their office connection goes out, like attach media to jobs, complete
forms, check status, modify miscellaneous info, etc.

&gt;<i> Yeah, Cacheable won't be enough for you. My hunch is that you'll be
</I>&gt;<i> implementing enough new code that you might as well not bother building it on
</I>&gt;<i> top of pb.Cacheable: start with a pb.Referenceable and a remote_acceptUpdate
</I>&gt;<i> method, an outboundUpdates() queue, and some setter methods to trigger
</I>&gt;<i> outbound update messages.
</I>
That sounds fine, actually.  I'm not trying to build a general-purpose
diff engine here, just some specific things, so I'm probably better
off ignoring Cacheable and focusing on the logic instead.

Thanks for the advice :)

J.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011920.html">[Twisted-Python] pb.Cacheable vs. offline queuing
</A></li>
	<LI>Next message: <A HREF="011923.html">[Twisted-Python] Win32 installers of Twisted 2.1?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11921">[ date ]</a>
              <a href="thread.html#11921">[ thread ]</a>
              <a href="subject.html#11921">[ subject ]</a>
              <a href="author.html#11921">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
