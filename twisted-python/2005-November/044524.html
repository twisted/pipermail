<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Unjelly - recursion limit reached
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Unjelly%20-%20recursion%20limit%20reached&In-Reply-To=%3C20051120.230254.21604291.warner%40lothar.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="044479.html">
   <LINK REL="Next"  HREF="044533.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Unjelly - recursion limit reached</H1>
    <B>Brian Warner</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Unjelly%20-%20recursion%20limit%20reached&In-Reply-To=%3C20051120.230254.21604291.warner%40lothar.com%3E"
       TITLE="[Twisted-Python] Unjelly - recursion limit reached">warner at lothar.com
       </A><BR>
    <I>Mon Nov 21 00:02:54 MST 2005</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="044479.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
        <LI>Next message (by thread): <A HREF="044533.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44524">[ date ]</a>
              <a href="thread.html#44524">[ thread ]</a>
              <a href="subject.html#44524">[ subject ]</a>
              <a href="author.html#44524">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;&gt;<i> This is a pretty scary limitation. Is anybody working on a non-
</I>&gt;&gt;&gt;<i> recursion based version of jelly? Am I going to have to move to
</I>&gt;&gt;&gt;<i> Stackless Python?
</I>
Sorry to respond to this so late.. my Twisted time has been awfully bursty
this month.

FWIW, newpb does not suffer from this sort of stack-frame limitation. Rather
than using the C/Python runtime stack to keep track of its current place in
the object graph, it maintains a &quot;Slicer Stack&quot; (and corresponding Unslicer
Stack on the receiving end), which is really just a list of Slicer/Unslicer
instances. Each edge of the object graph path (from the top-most
one-per-connection Root object down to the thing currently being serialized
or unserialized) gets a Slicer/Unslicer on this list. Ridiculously deep
object graphs (like the linked-list structure you describe) will consume heap
memory for this list, but not stack frames.

The maximum number of stack frames consumed is a constant, not affected by
the shape or complexity of the data being serialized. (I haven't measured it
but I'd guess it's less than a dozen frames). The runtime memory footprint is
roughly linear with the depth of the object graph. Each Slicer contains a
generator.. I don't know how much memory is consumed to maintain the state of
a typical Slicer, but I'm not sure I'd want a million of them.

&gt;<i> My object graph is a natural and clean data structure. I don't want  
</I>&gt;<i> to lose that just because of limitations in my tools.
</I>
PB is all about transferring your existing object graph cleanly and
accurately. newpb just does it better than oldpb. Some of the limitations of
oldpb (well, really just that 640k string limit) are there to minimize the
damage if something goes really wrong (like you connect an HTTP client to the
PB socket, and it tries to interpret &quot;GET HTTP/1.1 index.html&quot; as a
bajillion-byte STRING token). newpb provides better ways to specify these
restrictions (the whole 'schema' approach), so there ought to be fewer
non-user-specified arbitrary limits.

That said, some graphs are more efficient to transfer than others. A linked
list of small integers will take about three times as many bytes to serialize
as a flat list, and will consume a far greater amount of memory while doing
so. The newpb Slicers are not clever enough to do tail-recursion.

&gt;<i> Is this currently being addressed or in a road map? Am I unknowingly  
</I>&gt;<i> volunteering for it? :-o
</I>
Well, it sounds like you might be a great candidate for beta-testing newpb
:<i>). Keep tuned to this channel for an alpha release announcement sometime
</I>soon.

cheers,
 -Brian


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="044479.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
	<LI>Next message (by thread): <A HREF="044533.html">[Twisted-Python] Unjelly - recursion limit reached
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44524">[ date ]</a>
              <a href="thread.html#44524">[ thread ]</a>
              <a href="subject.html#44524">[ subject ]</a>
              <a href="author.html#44524">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
