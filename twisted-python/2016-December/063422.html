<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] ITransport.write after	IProtocol.connectionLost -- no failure/exception?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20ITransport.write%20after%0A%09IProtocol.connectionLost%20--%20no%20failure/exception%3F&In-Reply-To=%3C8ED9DD0C-0490-4209-9096-256334DFEF27%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="063417.html">
   <LINK REL="Next"  HREF="063423.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] ITransport.write after	IProtocol.connectionLost -- no failure/exception?</H1>
    <B>ex vito</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20ITransport.write%20after%0A%09IProtocol.connectionLost%20--%20no%20failure/exception%3F&In-Reply-To=%3C8ED9DD0C-0490-4209-9096-256334DFEF27%40gmail.com%3E"
       TITLE="[Twisted-Python] ITransport.write after	IProtocol.connectionLost -- no failure/exception?">ex.vitorino at gmail.com
       </A><BR>
    <I>Mon Dec 19 06:13:18 MST 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="063417.html">[Twisted-Python] ITransport.write after IProtocol.connectionLost -- no failure/exception?
</A></li>
        <LI>Next message (by thread): <A HREF="063423.html">[Twisted-Python] ITransport.write after IProtocol.connectionLost -- no failure/exception?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#63422">[ date ]</a>
              <a href="thread.html#63422">[ thread ]</a>
              <a href="subject.html#63422">[ subject ]</a>
              <a href="author.html#63422">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 2016-12-17, at 23:18, Glyph Lefkowitz &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at twistedmatrix.com</A>&gt; wrote:

&gt;<i> On Dec 17, 2016, at 6:11 AM, exvito here &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ex.vitorino at gmail.com</A>&gt; wrote:
</I>
[...]

&gt;&gt;<i> Thanks for your input Cory and Glyph.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I do agree that a well written protocol should not
</I>&gt;&gt;<i> self.transport.write after connectionLost -- it does not make any kind
</I>&gt;&gt;<i> of sense to do that. It's just that the one I was debugging was doing
</I>&gt;&gt;<i> it in its app-level keep alive messages triggered by
</I>&gt;&gt;<i> IReactorTime.callLater which wasn't properly cancelled on
</I>&gt;&gt;<i> connectionLost. This, in turn, lead to unpexpected app-level keep
</I>&gt;&gt;<i> alive timeouts after disconnection which, while acceptable (depending
</I>&gt;&gt;<i> on app/protocol design), were having a negative impact on the overall
</I>&gt;&gt;<i> connection/protocol teardown and cleanup.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Having said this, the fact that self.transport.write does not complain
</I>&gt;&gt;<i> after connectionLost just made my analysis and debugging more
</I>&gt;&gt;<i> difficult (yes, I was aware that it is non-blocking -- thanks Cory --
</I>&gt;&gt;<i> and that when talking to the network the only confirmation of delivery
</I>&gt;&gt;<i> must be obtained from a received message stating that fact).
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> All in all, I was just looking for confirmation from a conceptual /
</I>&gt;&gt;<i> design standpoint. That was my purpose and it is now clear. Thanks.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Going a little bit further, in this context, I wonder if my
</I>&gt;&gt;<i> understanding of the Protocol / Transport objects lifecycle is 100%
</I>&gt;&gt;<i> clear. I think there is a one to one relationship in the sense that,
</I>&gt;&gt;<i> simply put, on an incoming connection the underlying machinery
</I>&gt;&gt;<i> instantiates a Protocol via the Factory's buildProtocol method,
</I>&gt;&gt;<i> instantiates a Transport object and then calls Protocol.makeConnection
</I>&gt;&gt;<i> to &quot;attach&quot; the transport to the protocol; when the connection is
</I>&gt;&gt;<i> closed, the Transport calls connectionLost on the Protocol and, at
</I>&gt;&gt;<i> some point, those two objects are no longer &quot;usable&quot; -- they've done
</I>&gt;&gt;<i> their job and will be destroyed if no app level references are kept to
</I>&gt;&gt;<i> them.
</I>&gt;<i> 
</I>&gt;<i> They're not &quot;destroyed&quot;, exactly.
</I>&gt;<i> 
</I>&gt;<i> The way to think about this is that the reactor, while running, is always on the stack.  The stack is the root of what's currently 'active' in the garbage collector.  The reactor then has references to various things - in this case, TCP transports and timed DelayedCall objects.  The transport has a reference to the protocol, which is what keeps both of them &quot;usable&quot;.  The DelayedCall has a reference to your function, and your function to anything it needs to do its work.
</I>&gt;<i> 
</I>&gt;<i> Things can be removed from and added back to the reactor at any time - for example, a transport may be removed without being closed by calling .stopReading() and .stopWriting() on it.  If it gets garbage collected, its socket will be closed, but because the reactor didn't close it, you won't get a normal connectionLost notification.
</I>
Sure, I had that clear in my understanding, thanks for the additional details on the stopReading/stopWriting -- I'm not familiar with low lever reactor details and, maybe, who knows, one day I'll put myself to the interesting exercise/challenge of playing around writing a reactor. Just to improve my understanding of these details.


&gt;<i> So rather than thinking of a Transport as having a precisely-defined lifecycle - although it does have certain states it goes through; connecting/connected/disconnecting/disconnected - the best way to think about it is as a graph of objects that the reactor is doing stuff to.
</I>
The bottom line (in my mind) is: is it correct or not to assume that, by design, once a Transport instance has been disconnected that same instance will never be connected again, regardless of when exactly that object is destroyed or garbage collected?


&gt;&gt;<i> If this is correct, in particular the fact that a given Transport
</I>&gt;&gt;<i> instance is not reusable after disconnection (if it is, could you
</I>&gt;&gt;<i> please point out such a case?), wouldn't it be valuable to log a
</I>&gt;&gt;<i> warning when write after disconnect is called? (agreed, raising an
</I>&gt;&gt;<i> Exception would be too much and break compatiblity). I find two
</I>&gt;&gt;<i> reasons for that: on one hand, given that it would have made my
</I>&gt;&gt;<i> debugging easier, it may help other developers pin point such cases;
</I>&gt;&gt;<i> on the other, the fact that Twisted itself logs messages on several
</I>&gt;&gt;<i> occasions, such as, for example, the default noisy Factory on doStart
</I>&gt;&gt;<i> / doStop. Adding to that, the fact that, if I'm reading the code
</I>&gt;&gt;<i> correctly, ITransport.write just throws away the data for TCP
</I>&gt;&gt;<i> transports since it falls back to FileDescriptor.write that simply
</I>&gt;&gt;<i> returns if &quot;not self.connected or self._writeDisconnected&quot; in
</I>&gt;&gt;<i> src/twisted/internet/abstract.py.
</I>&gt;<i> 
</I>&gt;<i> If you start logging a warning when write is called on a closed transport, then that means any code that wants to be warnings-clean needs to check to see if the transport is writable before writing to it.  This adds a lot of complexity to that sort of message-formatting code, and potentially makes it less efficient. After all, if you have to check each write() call, that will strongly encourage you to make your message-formatting happen entirely in memory, so you always have a big string that represents the whole message, just in case a transport.write() in the middle would encounter an error.
</I>
I understand that and find it perfectly acceptable. I just tend to err on the extra-cautious side when facing data-loss / data-integrity possibilities and, in the many scenarios I've used Twisted in, performance was never an issue while semantic correctness and implementation resiliency tend to need fixes and improvements. :)

One could argue, though, that someone looking for warnings-clean code (who doesn't, even if the real world and interfacing with it most often prevents it?) might like to know that their &quot;perfect&quot; (lots of quotes here!) warnings-clean code writes won't go anywhere after connectionLost which, in some cases, may help pinpoint an underlying design / implementation issue.

I'd like to underline, though, that I'm not insisting on the &quot;log warning&quot; aspect I raised before. Like I said, the status quo is very good, thank you. Just sharing a few thoughts.


&gt;<i> More importantly, when users start seeing a warning like this, they often develop an incorrect intuition about what's going on with the bytes; one of the _most_ frequently asked questions about how to write Twisted protocols is &quot;how do I tell if my bytes got to the other end without sending an application-level acknowledgement&quot;.  The answer, of course, is &quot;that's impossible&quot; but if users see that sometimes it warns them when the connection's closed, it reinforces the idea that there must be a way.
</I>&gt;<i> 
</I>&gt;<i> If you call .write, there is always the possibility that the connection _looks_ open to Twisted, but in fact is closed on the wire, and those bytes will be lost.  So it's important to me that we behave the same way in both cases.
</I>
Yes, I can relate to that common misconception regarding delivery confirmation, throughout the years, working with other people. Networking is non-trivival and there are lots of parts out of application control that can behave in unexpected ways and/or go wrong.


&gt;<i> That said, it's not like there's no room for improvement here!  The solution _I'd_ really like to see for this problem is improved visualization of what the reactor is doing.  Something that drew a graph of the reactor, and open connections, and pending timed calls would allow you to instantly see that your timed call was not connected to an active connection, and correct your code.
</I>
Well, trial already does that in part, doesn't it? It complains loudly about unclean reactor state after each test. It just doesn't relate timed calls to connections, which sounds like a very non-obvious challenge to handle at the reactor level: how could the reactor know that a given timed call callback will make use of a particular connection?

That does sound like a very interesting capability, though.


&gt;&gt;<i> Thoughts? (or corrections, of course?)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Again, thanks for your time and input.
</I>&gt;&gt;<i> Regards,
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> PS: I don't mean to start a huge discussion on the topic or question
</I>&gt;&gt;<i> the current design. It is very nice as it is, thank you! I'm just
</I>&gt;&gt;<i> looking for improving my understanding and, humbly, contributing back.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Don't worry, the design is pretty fixed - and if you managed to provoke such a discussion, then maybe it does need to change!  But I doubt it :)
</I>
I'm glad it is pretty fixed. That has always given me the confidence to work with it throughout the years. Thanks and congratulations for a very solid piece of code!

Having said this, again very humbly, who knows what the future may bring! ;)


Thanks for taking the time to respond.
Regards,
--
exvito


-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20161219/ebb9c33d/attachment-0002.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="063417.html">[Twisted-Python] ITransport.write after IProtocol.connectionLost -- no failure/exception?
</A></li>
	<LI>Next message (by thread): <A HREF="063423.html">[Twisted-Python] ITransport.write after IProtocol.connectionLost -- no failure/exception?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#63422">[ date ]</a>
              <a href="thread.html#63422">[ thread ]</a>
              <a href="subject.html#63422">[ subject ]</a>
              <a href="author.html#63422">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
