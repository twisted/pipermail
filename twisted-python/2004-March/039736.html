<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] RE: tracking spawned jobs in a twisted application (code review request)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20RE%3A%20tracking%20spawned%20jobs%20in%20a%20twisted%20application%20%28code%20review%20request%29&In-Reply-To=%3C49199579A2BB32438A7572AF3DBB2FB501FEEFA3%40uscimplm001.net.plm.eds.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="039735.html">
   <LINK REL="Next"  HREF="039738.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] RE: tracking spawned jobs in a twisted application (code review request)</H1>
    <B>Schneider, Michael</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20RE%3A%20tracking%20spawned%20jobs%20in%20a%20twisted%20application%20%28code%20review%20request%29&In-Reply-To=%3C49199579A2BB32438A7572AF3DBB2FB501FEEFA3%40uscimplm001.net.plm.eds.com%3E"
       TITLE="[Twisted-Python] RE: tracking spawned jobs in a twisted application (code review request)">michael.l.schneider at ugsplm.com
       </A><BR>
    <I>Mon Mar  1 09:32:02 MST 2004</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="039735.html">[Twisted-Python] tracking spawned jobs in a twisted application (code review request)
</A></li>
        <LI>Next message (by thread): <A HREF="039738.html">[Twisted-Python] Help about  adbapi and sqlreflector
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39736">[ date ]</a>
              <a href="thread.html#39736">[ thread ]</a>
              <a href="subject.html#39736">[ subject ]</a>
              <a href="author.html#39736">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry,

I hit the send button too soon,
Mike


 
----------------------------------------------------------------
Michael Schneider
Senior Software Engineering Consultant
UGS PLM Solutions - an EDS Company
 
&quot;The Greatest Performance Improvement Is the transitioning from a non-working state to the working state&quot;


&gt;<i> -----Original Message-----
</I>&gt;<i> From: Schneider, Michael 
</I>&gt;<i> Sent: Monday, March 01, 2004 11:28 AM
</I>&gt;<i> To: '<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">twisted-python at twistedmatrix.com</A>'
</I>&gt;<i> Subject: tracking spawned jobs in a twisted application (code review
</I>&gt;<i> request)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hello All,
</I>&gt;<i> 
</I>&gt;<i> I have been pushing some code around.
</I>&gt;<i> 
</I>&gt;<i> My problem is that I need to execute OS command line
</I>&gt;<i> jobs with twisted.
</I>&gt;<i> 
</I>&gt;<i> I started by morphing the twisted tutorial app into a
</I>&gt;<i> job runner.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> My first path (It was wrong!!) was to morph the database connection
</I>&gt;<i> pool to a compute pool using popen2.
</I>&gt;<i> 
</I>&gt;<i> This group, suggested that I use reactor.spawn instead of popen2 .
</I>&gt;<i> 
</I>&gt;<i> Attached is the resulting code.  
</I>&gt;<i> 
</I>&gt;<i> Basic Approach for Command protocol.processProtocol:
</I>&gt;<i> 
</I>&gt;<i> 1) crate a JobPool Object to manage list of running jobs
</I>&gt;<i> 2) Create Job Runner Object to wrap individual process info,
</I>&gt;<i>    and capture process output.
</I>&gt;<i>    (start time, stop time ...)
</I>&gt;<i> 3) Create CmdProcProtcol  to manage interaction with the reactor
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I morphed the twisted application: (Coded in comment section below)
</I>&gt;<i> 	1) Create JobPoolService
</I>&gt;<i> 	2) Create JobRunnerProtocol
</I>&gt;<i> 	3) Create XmlRpc Job Runner Interface that dispatches 
</I>&gt;<i> to job runner service.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> My questions are:
</I>&gt;<i> 	- Is the the twisted way?
</I>&gt;<i>       - What are some alternative approaches?
</I>&gt;<i> 	- Is there a better way?
</I>&gt;<i> 
</I>&gt;<i> Thank you very much,
</I>&gt;<i> Mike
</I>&gt;<i>  
</I>&gt;<i> ----------------------------------------------------------------
</I>&gt;<i> Michael Schneider
</I>&gt;<i> Senior Software Engineering Consultant
</I>&gt;<i> UGS PLM Solutions - an EDS Company
</I>&gt;<i>  
</I>&gt;<i> &quot;The Greatest Performance Improvement Is the transitioning 
</I>&gt;<i> from a non-working state to the working state&quot;
</I>&gt;<i> 
</I>
# Twisted, the Framework of Your Internet

&quot;&quot;&quot;
Manage execution of multiple processes\

Usage Model:
1)Create Job runner Service in App
2)Create Job Runner Protocol in App
3) Create Xmlrpc to call

    ----- from service code in twisted app
    m = RunTaskPool()
    cmdLine=&quot;dir d:\&quot;
    def = m.runJob(cmdLine)


class JobRunnerService(service.Service):

    __implements__ = service.Service.__implements__, IJobRunnerService

    def __init__(self):
        self.taskPool = None


    def runJob(self, command):
        print &quot;In Twisted runJob, command = &quot; + command
        self.verifyRunTaskPool()
        return self.taskPool.runJob(command)

    def verifyRunTaskPool(self):
        if(self.taskPool == None):
            self.taskPool = RunTaskPool()

class JobRunnerProtocol(basic.LineReceiver):

    def lineReceived(self, command):
        d = self.factory.runJob(command)
        d.addErrback(catchError)
        def writeValue(value):
            self.transport.write(value)
            self.transport.write('\n\n')
            self.transport.loseConnection()
        d.addCallback(writeValue)


class JobStatusXR(xmlrpc.XMLRPC):

    def __init__(self, service):
        xmlrpc.XMLRPC.__init__(self)
        self.service = service

    def xmlrpc_runJob(self, command):
        return self.service.runJob(command)


    def xmlrpc_isAlive(self):
        return 1


   
&quot;&quot;&quot;


from twisted.internet import protocol
from twisted.internet import reactor
from twisted.spread import pb
from twisted.python import reflect, log
from twisted.internet import  defer

from time import sleep
from time import time
import os



class CmdProcProtocol(protocol.ProcessProtocol):
    &quot;&quot;&quot;Twisted Protocol Class to run command line in a sub process &quot;&quot;&quot;
    def __init__(self, parentJobRunner):
        self._exitStatus = 0
        self.parentJobRunner = parentJobRunner
        self.data = &quot;&quot;
        
    def connectionMade(self):
        &quot;&quot;&quot;Called at the start of the execution&quot;&quot;&quot;
        #print &quot;connectionMade!&quot;
        pass
 
    def outReceived(self, data):
        &quot;&quot;&quot;Called when process writes output&quot;&quot;&quot;
        #print &quot;outReceived! with %d bytes!&quot; % len(data)
        self.data = self.data + data
        #print self.data
        
    def errReceived(self, data):
        #print &quot;errReceived! with %d bytes!&quot; % len(data)
        pass
    
    def inConnectionLost(self):
        #print &quot;inConnectionLost! stdin is closed! (we probably did it)&quot;
        pass
    def outConnectionLost(self):
        &quot;&quot;&quot;Program has closed stdout (program terminated)&quot;&quot;&quot;
        #print &quot;outConnectionLost! The child closed their stdout!&quot;
        #print &quot;# now is the time to examine what they wrote&quot;
        #print &quot;dir:&quot;, self.data
        pass

    def errConnectionLost(self):
        &quot;&quot;&quot;Program has closed stderr (program terminated)&quot;&quot;&quot;
        #print &quot;errConnectionLost! The child closed their stderr.&quot;
        pass
    def processEnded(self, status_object):
        &quot;&quot;&quot;Child process exited&quot;&quot;&quot;
        self._exitStatus =  status_object.value.exitCode
        print &quot;processEnded, status %d&quot; % self._exitStatus
        print &quot;quitting&quot;
        print self.data
        #notify parent with data returned , and exit status
        self.parentJobRunner.signalRunComplete(self._exitStatus, self.data)

    def kill(self):
        &quot;&quot;&quot;Kill this process&quot;&quot;&quot;
        #os.kill(self.transport.pid, signal.SIGKILL) 
        
class JobRunner:
    &quot;&quot;&quot;
    I am a lightweight wrapper for run job.
    &quot;&quot;&quot;
  

    def __init__(self, parentJobRunnerPool,  jobRunDeferred):

        #command to execute in Command Proc Protocol 
        self.command = &quot;&quot;

        #set 
        self.parentJobRunnerPool = parentJobRunnerPool
        self._startTime = -1
        self._endTime = -1
        self._timeLimit = -1
        self._exitcode = None
        self._log = &quot;job not yet started&quot;
        self._jobRunDeferred = jobRunDeferred
        
    def getLogCallback(self,*args, **kw):
        &quot;&quot;&quot;Called by Process Run Protocol when child process execution is complete &quot;&quot;&quot;

        #Notify JobRunner Pool That this job has completed execution
        self.parentJobRunnerPool.jobCompleteCallback(self)

        #return output of job
        return self._log

    def getExitCode(self):
        return self._exitcode
        
    def getStartTime(self):
        &quot;&quot;&quot;Get Time Job Started Executing &quot;&quot;&quot;
        return self._startTime
    
    def getEndTime(self):
        &quot;&quot;&quot;Get Time Job Stopped Executing &quot;&quot;&quot;
        return self._endTime
    
    def getRunTime(self):
        &quot;&quot;&quot; get time executing&quot;&quot;&quot;
        if(self._startTime &lt; 0):
            #job has not started yet, return -1
            return -1
        
        if(self._endTime &lt; 0):
            #job is running, but not yet finished, return time spent so far
            return (time() - self._startTime)
        
        #job is complete, return run time
        return (self._endTime - self._startTime)
        

    
    def runJob(self, *args, **kw):
        &quot;&quot;&quot;Execute Job:  NOTE: this function executes in its own thread &quot;&quot;&quot;
        
        #set execution start time
        
        self.command = (args[0])[0]
        

        print &quot;In Run Job daemon command : &quot; + self.command
     
        self._startTime = time()
        
        print &quot;Start Running Command : &quot; +  str(self.command) + &quot;  &quot; + str(self.getStartTime())
        self._log = &quot;Job is Running: &quot;

        #setup reactor to run job
        self.runCommand(self.command)
   


    def runCommand(self, commandStr):
        &quot;&quot;&quot;Create Command Line Protocol, and call spawnProcess&quot;&quot;&quot;
        commandStr = 'cmd.exe /c ' + commandStr


        pp= CmdProcProtocol(self)
        reactor.spawnProcess(pp,
                             commandStr ,
                             env=os.environ)
        
        
    def signalRunComplete(self, exitCode, stdoutString):
        # Pass Control back to caller to self.runJob(..)
        # by triggering defered callback,
        # this callback will return this object

        self._exitCode = exitCode
        self._log = stdoutString
             
        # set execution time
        self._endTime = time()
      
        print &quot;Done Running Job &quot;  + self.command
        
        reactor.callFromThread(self._jobRunDeferred.callback, self)
        
        
    

class RunTaskPool(pb.Referenceable):
 
    running = 0 # true when the pool is operating
    


    def __init__(self,  *args, **kw ):
        &quot;&quot;&quot;See RunTaskPool.__doc__
        &quot;&quot;&quot;
 
    
        self.args = args
        self.kw = kw
        self._jobRunnerJobs = []

        self.jobs = {}  # running Jobs, hashed on thread id


    
 
        self.startID = reactor.callWhenRunning(self.start)

    def start(self):
        &quot;&quot;&quot;Start of execution
        &quot;&quot;&quot;
        
        if not self.running:
            
            self.shutdownID = reactor.addSystemEventTrigger('during',
                                                            'shutdown',
                                                            self.finalClose)
            self.running = 1

    def jobCompleteCallback(self, jobRunner):
        &quot;&quot;&quot;Callback triggered by JobRunner when execution of job is complete &quot;&quot;&quot;
        print &quot;Deleting Job Object from running queue&quot;
        if jobRunner in self._jobRunnerJobs:
            self._jobRunnerJobs.remove(jobRunner)

        

    def runJob(self, *args, **kw ):
        &quot;&quot;&quot;run job and return the result as a defered object
        &quot;&quot;&quot;

        print &quot;MLS: runJob - setting up to run in thread &quot;
    
   
        d = defer.Deferred()  
        jobRunner = JobRunner(self,d)
        
        #Add to list of JobRunnerJobs  managed
        self._jobRunnerJobs.append(jobRunner)

        
        print &quot;MLS: in _runJobRunner &quot;
        
        # run Job in thread pool thread
        jobRunner.runJob(args, kw)
            
        # return defered used by jobRunner

        
        d.addCallback(jobRunner.getLogCallback)
        return d

  

    def close(self):
        &quot;&quot;&quot;Close all pool connections and shutdown the pool.&quot;&quot;&quot;

        from twisted.internet import reactor
        if self.shutdownID:
            reactor.removeSystemEventTrigger(self.shutdownID)
            self.shutdownID = None
        if self.startID:
            reactor.removeSystemEventTrigger(self.startID)
            self.startID = None
        self.finalClose()

    def finalClose(self):
        &quot;&quot;&quot;This should only be called by the shutdown trigger.&quot;&quot;&quot;

        self.running = 0
        for job in self.jobs.values():
            if self.noisy:
                log.msg(' closing: %s%s' % (
                                                     self.kw or ''))
            job.close()
        self.jobs.clear()

    def __getstate__(self):
        return {'noisy': self.noisy,
                'min': self.min,
                'max': self.max,
                'kw': self.kw}

    def __setstate__(self, state):
        self.__dict__ = state
        apply(self.__init__, self.kw)

def startup():
         for x in range(1,14):
            d = m.runJob()
            d.addCallback(printSelf)
            
    
def printSelf(jobRunner):
        print &quot;Job Runner Done&quot;

    


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="039735.html">[Twisted-Python] tracking spawned jobs in a twisted application (code review request)
</A></li>
	<LI>Next message (by thread): <A HREF="039738.html">[Twisted-Python] Help about  adbapi and sqlreflector
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39736">[ date ]</a>
              <a href="thread.html#39736">[ thread ]</a>
              <a href="subject.html#39736">[ subject ]</a>
              <a href="author.html#39736">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
