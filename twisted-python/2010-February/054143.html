<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] debugging a memory leak
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20debugging%20a%20memory%20leak&In-Reply-To=%3C007601cab42a%24d4c755e0%247e5601a0%24%40com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="054116.html">
   <LINK REL="Next"  HREF="054144.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] debugging a memory leak</H1>
    <B>Alec Matusis</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20debugging%20a%20memory%20leak&In-Reply-To=%3C007601cab42a%24d4c755e0%247e5601a0%24%40com%3E"
       TITLE="[Twisted-Python] debugging a memory leak">matusis at yahoo.com
       </A><BR>
    <I>Mon Feb 22 18:52:17 MST 2010</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="054116.html">[Twisted-Python] debugging a memory leak
</A></li>
        <LI>Next message (by thread): <A HREF="054144.html">[Twisted-Python] debugging a memory leak
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#54143">[ date ]</a>
              <a href="thread.html#54143">[ thread ]</a>
              <a href="subject.html#54143">[ subject ]</a>
              <a href="author.html#54143">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Werner

I am using your code, and it shows essentially the same thing as Heapy:
the counts of all common objects more or less agree.
The 'Total size' shown in Heapy

When I start the process, both python object sizes and their counts rise
proportionally to the numbers of reconnected clients, and then they
stabilize after all clients have reconnected.
At that moment, the &quot;external&quot; RSS process size is about 260MB. The
&quot;internal size&quot; of all python objects reported by Heapy is about 150MB.
After two days, the internal sizes/counts stay the same, but the external
size grows to 1500MB.

Python object counts/total sizes are measured from the manhole.
Is this sufficient to conclude that this is a C memory leak in one of the
external modules or in the Python interpreter itself?

&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">twisted-python-bounces at twistedmatrix.com</A> [mailto:twisted-python-
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">bounces at twistedmatrix.com</A>] On Behalf Of Werner Thie
</I>&gt;<i> Sent: Friday, February 19, 2010 4:10 PM
</I>&gt;<i> To: Twisted general discussion
</I>&gt;<i> Subject: Re: [Twisted-Python] debugging a memory leak
</I>&gt;<i> 
</I>&gt;<i> Hi Alec
</I>&gt;<i> 
</I>&gt;<i> ...and they promised you that with a gc'ed language there will never be
</I>&gt;<i> a memory problem again, you just plain forget about it.
</I>&gt;<i> 
</I>&gt;<i> I was stuck in the same position as you and after lots of probing the
</I>&gt;<i> following attempt helped a lot to correct what was later proofed to be
</I>&gt;<i> overly optimistic coding by holding on to objects for
</I>&gt;<i> performance/practical reasons in other objects. Producing non collect
</I>&gt;<i> able cycles in twisted is probably as easy as to forget about memory
</I>&gt;<i> when you have Alzheimer.
</I>&gt;<i> 
</I>&gt;<i> Proofing and working on the problem was only possible on the production
</I>&gt;<i> machine under real load situations. I went ahead and created a manhole
</I>&gt;<i> service on the production server, allowing me to peek at the python
</I>&gt;<i> object space without disturbing it too much. What I used as a tool was
</I>&gt;<i> the code you find later on included.
</I>&gt;<i> 
</I>&gt;<i> After cleaning all the self produced cycles out our servers processes
</I>&gt;<i> stabilized at roughly 280 to 320 MB per process and are now running
</I>&gt;<i> stable for months with more than 20k logins per day and a usual time of
</I>&gt;<i> connect per user on the average of 25 minutes playing games delivered by
</I>&gt;<i> nevow/athena LivePages.
</I>&gt;<i> 
</I>&gt;<i> As I said before, all cycles I found in our SW were introduced by
</I>&gt;<i> patterns like
</I>&gt;<i> 
</I>&gt;<i> def beforeRender(self, ctx):
</I>&gt;<i>      self.session = inevow.ISession(ctx)
</I>&gt;<i> 
</I>&gt;<i> The included code helps to identify the amount of objects being around.
</I>&gt;<i> Although it's a primitive tool it shines the light where its needed and
</I>&gt;<i> if you see certain object counts run away then you have at least
</I>&gt;<i> identified the surrounding where the non collect able cycles are built.
</I>&gt;<i> 
</I>&gt;<i> Why didn't I use heapy/guppy and found out that way? I wasn't able to
</I>&gt;<i> find the evidence for what I was suspecting with all the tools I tried
</I>&gt;<i> (and boy I tried for WEEKS). Avid users of heapy will most probably
</I>&gt;<i> disagree and tell me it would have been easy. But in a situation as this
</I>&gt;<i> everything that works to move you out of that pothole you're in is the
</I>&gt;<i> right thing to do.
</I>&gt;<i> 
</I>&gt;<i> HTH, Werner
</I>&gt;<i> 
</I>&gt;<i> exc = [
</I>&gt;<i>    &quot;function&quot;,
</I>&gt;<i>    &quot;type&quot;,
</I>&gt;<i>    &quot;list&quot;,
</I>&gt;<i>    &quot;dict&quot;,
</I>&gt;<i>    &quot;tuple&quot;,
</I>&gt;<i>    &quot;wrapper_descriptor&quot;,
</I>&gt;<i>    &quot;module&quot;,
</I>&gt;<i>    &quot;method_descriptor&quot;,
</I>&gt;<i>    &quot;member_descriptor&quot;,
</I>&gt;<i>    &quot;instancemethod&quot;,
</I>&gt;<i>    &quot;builtin_function_or_method&quot;,
</I>&gt;<i>    &quot;frame&quot;,
</I>&gt;<i>    &quot;classmethod&quot;,
</I>&gt;<i>    &quot;classmethod_descriptor&quot;,
</I>&gt;<i>    &quot;_Environ&quot;,
</I>&gt;<i>    &quot;MemoryError&quot;,
</I>&gt;<i>    &quot;_Printer&quot;,
</I>&gt;<i>    &quot;_Helper&quot;,
</I>&gt;<i>    &quot;getset_descriptor&quot;,
</I>&gt;<i>    &quot;weakreaf&quot;
</I>&gt;<i> ]
</I>&gt;<i> 
</I>&gt;<i> inc = [
</I>&gt;<i>    'myFirstSuspect',
</I>&gt;<i>    'mySecondSuspect'
</I>&gt;<i> ]
</I>&gt;<i> 
</I>&gt;<i> prev = {}
</I>&gt;<i> 
</I>&gt;<i> def dumpObjects(delta=True, limit=0, include=inc, exclude=[]):
</I>&gt;<i>    global prev
</I>&gt;<i>    if include != [] and exclude != []:
</I>&gt;<i>      print 'cannot use include and exclude at the same time'
</I>&gt;<i>      return
</I>&gt;<i>    print 'working with:'
</I>&gt;<i>    print '   delta: ', delta
</I>&gt;<i>    print '   limit: ', limit
</I>&gt;<i>    print ' include: ', include
</I>&gt;<i>    print ' exclude: ', exclude
</I>&gt;<i>    objects = {}
</I>&gt;<i>    gc.collect()
</I>&gt;<i>    oo = gc.get_objects()
</I>&gt;<i>    for o in oo:
</I>&gt;<i>      if getattr(o, &quot;__class__&quot;, None):
</I>&gt;<i>        name = o.__class__.__name__
</I>&gt;<i>        if ((exclude == [] and include == [])       or \
</I>&gt;<i>            (exclude != [] and name not in exclude) or \
</I>&gt;<i>            (include != [] and name in include)):
</I>&gt;<i>          objects[name] = objects.get(name, 0) + 1
</I>&gt;<i> ##    if more:
</I>&gt;<i> ##      print o
</I>&gt;<i>    pk = prev.keys()
</I>&gt;<i>    pk.sort()
</I>&gt;<i>    names = objects.keys()
</I>&gt;<i>    names.sort()
</I>&gt;<i>    for name in names:
</I>&gt;<i>      if limit == 0 or objects[name] &gt; limit:
</I>&gt;<i>        if not prev.has_key(name):
</I>&gt;<i>          prev[name] = objects[name]
</I>&gt;<i>        dt = objects[name] - prev[name]
</I>&gt;<i>        if delta or dt != 0:
</I>&gt;<i>          print '%0.6d -- %0.6d -- ' % (dt, objects[name]),  name
</I>&gt;<i>        prev[name] = objects[name]
</I>&gt;<i> 
</I>&gt;<i> def getObjects(oname):
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    gets an object list with all the named objects out of the sea of
</I>&gt;<i>    gc'ed objects
</I>&gt;<i>    &quot;&quot;&quot;
</I>&gt;<i>    olist = []
</I>&gt;<i>    objects = {}
</I>&gt;<i>    gc.collect()
</I>&gt;<i>    oo = gc.get_objects()
</I>&gt;<i>    for o in oo:
</I>&gt;<i>      if getattr(o, &quot;__class__&quot;, None):
</I>&gt;<i>        name = o.__class__.__name__
</I>&gt;<i>        if (name == oname):
</I>&gt;<i>          olist.append(o)
</I>&gt;<i>    return olist
</I>&gt;<i> 
</I>&gt;<i> dumpObject = dumpobj.dumpObj
</I>&gt;<i> 
</I>&gt;<i> Alec Matusis wrote:
</I>&gt;<i> &gt; I modified a tolerably leaking (about 40MB/day) Twisted server: when the
</I>&gt;<i> new
</I>&gt;<i> &gt; code was pushed, the memory leak  became catastrophic (about
</I>&gt;<i> 100MB/hr).
</I>&gt;<i> &gt; We could tolerate 40MB/day, but the new code needs to be debugged.
</I>&gt;<i> &gt; First, I reverted to the old version, that is leaking 40MB/day (The leak
</I>&gt;<i> &gt; rate is actually proportional to the number of new connections per
</I>second,
&gt;<i> &gt; (which correlates with the CPU utilization of the process): if CPU as
</I>&gt;<i> &gt; measured by $top jumps to &gt;90%, the leak can accelerate to 50MB/hr)
</I>&gt;<i> &gt; I took two steps to debug the leak:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1) Using guppy/heapy via manhole:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; hp = hpy()
</I>&gt;<i> &gt;&gt;&gt;&gt; h = hp.heap()
</I>&gt;<i> &gt;&gt;&gt;&gt; h
</I>&gt;<i> &gt; Partition of a set of 1157084 objects. Total size = 140911144 bytes.
</I>&gt;<i> &gt;  Index  Count   %     Size   % Cumulative  % Kind (class / dict of
</I>class)
&gt;<i> &gt;      0 785798  68 48463680  34  48463680  34 str
</I>&gt;<i> &gt;      1   7357   1 24660664  18  73124344  52 dict of service.TagSession
</I>&gt;<i> &gt;      2  11735   1 12298280   9  85422624  61 dict of
</I>&gt;<i> &gt; twisted.internet.base.DelayedCall
</I>&gt;<i> &gt;      3   7377   1  7731096   5  93153720  66 dict of
</I>&gt;<i> &gt; twisted.internet.tcp.Server
</I>&gt;<i> &gt;      4   7375   1  7729000   5 100882720  72 dict of
</I>protocols.TagProtocol
&gt;<i> &gt;      5  30925   3  7174600   5 108057320  77 __builtin__.set
</I>&gt;<i> &gt;      6   9193   1  6373336   5 114430656  81 dict (no owner)
</I>&gt;<i> &gt;      7  15557   1  3396904   2 117827560  84 list
</I>&gt;<i> &gt;      8  44833   4  3227976   2 121055536  86 types.BuiltinFunctionType
</I>&gt;<i> &gt;      9  38142   3  3051360   2 124106896  88 types.MethodType
</I>&gt;<i> &gt; &lt;328 more rows. Type e.g. '_.more' to view.&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Note that the total size of all objects is 140911144 bytes
</I>&gt;<i> &gt; The 1st, 3d and 4th items in this list show the actual number of
</I>connected
&gt;<i> &gt; clients. I wait for about 48 hrs, and then execute the same command, and
</I>I
&gt;<i> &gt; see approximately the same Total size, of 130MB.
</I>&gt;<i> &gt; So the total size that Heapy sees via the manhole is stable, fluctuating
</I>&gt;<i> &gt; around 140MB.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The problem is that the total RSS size of the process visible by the OS
</I>is
&gt;<i> &gt; much larger, it is  871680KB = 851MB:
</I>&gt;<i> &gt; $ps -o pid,vsz,rss,sz,size -p 11236
</I>&gt;<i> &gt;   PID     VSZ           RSS       SZ           SZ
</I>&gt;<i> &gt; 11236 1303180 871680 325795 1174388
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It is this total RSS size that keeps leaking at 40MB per day.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As far as I understand, this means that this is not the problem with
</I>purely
&gt;<i> &gt; Python code, since Heapy shows that the total size of all Python objects
</I>is
&gt;<i> &gt; more or less constant.
</I>&gt;<i> &gt; Is this a correct assumption?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 2) So now I turn to valgrind. I am no expert in using valgrind, so what
</I>I
&gt;<i> &gt; did was based only on general logic/rough guesses.
</I>&gt;<i> &gt; Since I cannot run this under valgrind on a production machine due to
</I>&gt;<i> &gt; performance reasons, I recompile python on the staging machine:
</I>&gt;<i> &gt; ./configure --enable-shared --without-pymalloc
</I>&gt;<i> &gt; --prefix=/nail/encap/python-2.6.4-valgrind
</I>&gt;<i> &gt; I then follow the instructions in
</I>&gt;<i> &gt; <A HREF="http://svn.python.org/projects/python/trunk/Misc/README.valgrind">http://svn.python.org/projects/python/trunk/Misc/README.valgrind</A>
</I>&gt;<i> &gt; Then I run twistd process like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; valgrind  --tool=memcheck
</I>&gt;<i> &gt; --suppressions=/nail/sys/src/Python-2.6.4/Misc/valgrind-python.supp
</I>&gt;<i> &gt; --leak-check=full --log-file=/tmp/valgrind.log  /usr/local/bin/twistd
</I>&gt;<i> &gt; --no_save --reactor=epoll --pidfile=logs/tagserv.pid
</I>&gt;<i> &gt; --logfile=logs/tagserv.log --python=tagserv.py
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The memory for the process shown by the OS is now 5x normal, and the
</I>&gt;<i> &gt; performance is about 5x worse, since it's running inside valgrind's
</I>&gt;<i> &gt; synthetic CPU.
</I>&gt;<i> &gt; Because this is done on the staging box where I cannot accurately
</I>&gt;<i> reproduce
</I>&gt;<i> &gt; the real load, the memory leaks from simulated load seen by $ps -o rss
</I>are
&gt;<i> &gt; pretty small, about 1 to 10MB.
</I>&gt;<i> &gt; Still, I am interested in finding out what they are.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Now I encounter the problems with my understanding of how to use
</I>&gt;<i> valgrind.
</I>&gt;<i> &gt; This may not be the appropriate list for this, but perhaps someone could
</I>&gt;<i> &gt; recognize the problem.
</I>&gt;<i> &gt; When I start the server, about 240 lines is written to valgrind log
</I>file,
&gt;<i> &gt; --log-file=/tmp/valgrind.log
</I>&gt;<i> &gt; When I shut it down, it adds another 100 lines.
</I>&gt;<i> &gt; No matter what I do in between, it always results in the log file with
</I>&gt;<i> &gt; exactly 343 lines.
</I>&gt;<i> &gt; I can have server runs with a leak of 1MB, or with 10MB, but in the end,
</I>I
&gt;<i> &gt; get pretty much the same log file. Moreover, when look for all lost
</I>memory
&gt;<i> &gt; reports:
</I>&gt;<i> &gt; $grep lost valgrind.log.1
</I>&gt;<i> &gt;  17,352 bytes in 31 blocks are possibly lost in loss record 49 of 62
</I>&gt;<i> &gt;  203,312 bytes in 478 blocks are possibly lost in loss record 57 of 62
</I>&gt;<i> &gt;     definitely lost: 0 bytes in 0 blocks.
</I>&gt;<i> &gt;       possibly lost: 220,664 bytes in 509 blocks.
</I>&gt;<i> &gt;  64 bytes in 2 blocks are definitely lost in loss record 12 of 63
</I>&gt;<i> &gt;  17,352 bytes in 31 blocks are possibly lost in loss record 50 of 63
</I>&gt;<i> &gt;  203,824 bytes in 479 blocks are possibly lost in loss record 58 of 63
</I>&gt;<i> &gt;     definitely lost: 64 bytes in 2 blocks.
</I>&gt;<i> &gt;       possibly lost: 221,176 bytes in 510 blocks.
</I>&gt;<i> &gt;  47 bytes in 1 blocks are definitely lost in loss record 8 of 63
</I>&gt;<i> &gt;  128 bytes in 4 blocks are definitely lost in loss record 16 of 63
</I>&gt;<i> &gt;  584 (104 direct, 480 indirect) bytes in 2 blocks are definitely lost in
</I>&gt;<i> &gt; loss record 26 of 63
</I>&gt;<i> &gt;  1,008 bytes in 6 blocks are definitely lost in loss record 31 of 63
</I>&gt;<i> &gt;  22,296 bytes in 41 blocks are possibly lost in loss record 50 of 63
</I>&gt;<i> &gt;  183,368 bytes in 381 blocks are possibly lost in loss record 59 of 63
</I>&gt;<i> &gt;     definitely lost: 1,287 bytes in 13 blocks.
</I>&gt;<i> &gt;     indirectly lost: 480 bytes in 20 blocks.
</I>&gt;<i> &gt;       possibly lost: 205,664 bytes in 422 blocks.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If I add up all those numbers, I get less than 1MB. How do I track down
</I>the
&gt;<i> &gt; 10MB leak?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Are there any alternative strategies in finding this leak?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Twisted-Python mailing list
</I>&gt;<i> &gt; <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> &gt; <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="054116.html">[Twisted-Python] debugging a memory leak
</A></li>
	<LI>Next message (by thread): <A HREF="054144.html">[Twisted-Python] debugging a memory leak
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#54143">[ date ]</a>
              <a href="thread.html#54143">[ thread ]</a>
              <a href="subject.html#54143">[ subject ]</a>
              <a href="author.html#54143">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
