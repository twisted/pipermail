<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Streaming File Transfer Protocol?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Streaming%20File%20Transfer%20Protocol%3F&In-Reply-To=%3C1266579203.2532.124.camel%40kratos%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="054056.html">
   <LINK REL="Next"  HREF="054109.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Streaming File Transfer Protocol?</H1>
    <B>Darren Govoni</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Streaming%20File%20Transfer%20Protocol%3F&In-Reply-To=%3C1266579203.2532.124.camel%40kratos%3E"
       TITLE="[Twisted-Python] Streaming File Transfer Protocol?">darren at ontrenet.com
       </A><BR>
    <I>Fri Feb 19 04:33:22 MST 2010</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="054056.html">[Twisted-Python] Streaming File Transfer Protocol?
</A></li>
        <LI>Next message (by thread): <A HREF="054109.html">[Twisted-Python] Streaming File Transfer Protocol?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#54108">[ date ]</a>
              <a href="thread.html#54108">[ thread ]</a>
              <a href="subject.html#54108">[ subject ]</a>
              <a href="author.html#54108">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi again,
   Ok, so now it seems the Int32StringReceiver does not receive
&quot;stringReceived&quot; events if the sent bytes
exceed a certain amount. If I send from the client, say 5000 bytes. It
receives it.

But when i send 7376896 bytes at a time, the client indicates it wrote
the bytes, but there is not one
stringReceived callback on the server side of the protocol. No error or
exception. nothing. 
Is this normal behavior?

thanks,
Darren

On Sat, 2010-02-13 at 20:22 -0500, David Bolen wrote:

&gt;<i> Darren Govoni &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">darren at ontrenet.com</A>&gt; writes:
</I>&gt;<i> 
</I>&gt;<i> &gt; I spoke too fast. But pardon my noobiness.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Ok, so I am using a simple protocol that is listening on a TCP port.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; One the client side, I write 4096 bytes using
</I>&gt;<i> &gt; self.transport.write(bytes)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; on dataReceived side, I get only 1448. 
</I>&gt;<i> 
</I>&gt;<i> Quite possible, and even likely with a chunk of 4096, given likely
</I>&gt;<i> network latencies and the physical packet sizes at each network hop
</I>&gt;<i> along the way.
</I>&gt;<i> 
</I>&gt;<i> However, dataReceived will eventually be called additional times until
</I>&gt;<i> all of the 4096 bytes that was transmitted and received over the
</I>&gt;<i> socket connection have been handed off to your protocol.  That's just
</I>&gt;<i> the nature of a stream protocol - it's a constant stream of data being
</I>&gt;<i> fed by one end and drained on the other, without any natural
</I>&gt;<i> boundaries or structures within (other than, I suppose, the boundary
</I>&gt;<i> of an octet since you can't receive a partial octet).
</I>&gt;<i> 
</I>&gt;<i> The alternative is to use a datagram protocol like UDP, but then you
</I>&gt;<i> have all the negatives of no guaranteed delivery, out of order
</I>&gt;<i> delivery, completely impossible delivery (when trying a datagram
</I>&gt;<i> larger than the UDP limit), etc...
</I>&gt;<i> 
</I>&gt;<i> Far easier to just handle the TCP stream properly.
</I>&gt;<i> 
</I>&gt;<i> &gt; Now, what I &quot;want&quot; to happen is when I issue a write of a known
</I>&gt;<i> &gt; number of bytes. I &quot;want&quot; those bytes to arrive in total because
</I>&gt;<i> &gt; they represent a pickled object.  The server has no idea if the
</I>&gt;<i> &gt; bytes are split and scattered (again, I want the control protocol to
</I>&gt;<i> &gt; take affect).
</I>&gt;<i> 
</I>&gt;<i> I suspect it may just be a difference in phrasing, but note that I
</I>&gt;<i> consider &quot;arrive in total&quot; to be different from &quot;arrive in the same
</I>&gt;<i> number of I/O operations&quot;.  TCP guarantees the former (sans dropped
</I>&gt;<i> connections) but not the latter.  It's a trade-off that you make in
</I>&gt;<i> order to get the other benefits of guaranteed delivery with TCP,
</I>&gt;<i> regardless of network disruptions, latency, etc...
</I>&gt;<i> 
</I>&gt;<i> You're fine as long as you just accept up front that you can't make
</I>&gt;<i> any assumptions as to how the data will arrive at the receiving end.
</I>&gt;<i> So combine the data in whatever sizes it is received (and any number
</I>&gt;<i> of received chunks) until you have it all.  You can then de-pickle it
</I>&gt;<i> or do anything else with it.  As a comparison, that's really all PB is
</I>&gt;<i> doing, although it's banana-encoding the object on the wire rather
</I>&gt;<i> than pickling.
</I>&gt;<i> 
</I>&gt;<i> Depending on the client/server interaction, you may also have the
</I>&gt;<i> opposite problem - the final chunk of data received may cover more
</I>&gt;<i> than one client transmission, and you'll have to split it up
</I>&gt;<i> appropriately.
</I>&gt;<i> 
</I>&gt;<i> That's why if you will be transmitting multiple sets of data over a
</I>&gt;<i> single connection, you'll want some structure (unique boundary codes,
</I>&gt;<i> encoded length information, parseable data like XML, etc...) in the wire
</I>&gt;<i> protocol so your server knows when it is done.
</I>&gt;<i> 
</I>&gt;<i> &gt; 1) Am I doing something wrong here?
</I>&gt;<i> 
</I>&gt;<i> Not so much wrong, as perhaps a little misguided in terms of trying to
</I>&gt;<i> have a stream protocol work less as a stream than it does.
</I>&gt;<i> 
</I>&gt;<i> I suspect you may also be over-estimating a little the complexity of
</I>&gt;<i> handling this aspect of TCP in your own code.
</I>&gt;<i> 
</I>&gt;<i> &gt; 2) Can I force twisted to send ALL the bytes I issue in the write
</I>&gt;<i> &gt; without re-thinking TCP or forcing me to re-implement TCP?
</I>&gt;<i> 
</I>&gt;<i> Again, distinguish between &quot;send ALL the bytes&quot; which *does* in fact
</I>&gt;<i> happen, versus &quot;receive bytes in identically sized chunks&quot; which will
</I>&gt;<i> not happen.  Though I seriously doubt that your demands are such that
</I>&gt;<i> it requires &quot;re-thinking&quot; or &quot;re-implement[ing]&quot; TCP.
</I>&gt;<i> 
</I>&gt;<i> Much easier to stick with the TCP base (loads of benefits), and just
</I>&gt;<i> encode enough structure into your stream to permit the server to
</I>&gt;<i> identify the boundaries of the requests.  Then, code the server to
</I>&gt;<i> look for such boundaries while accepting data in any size chunks, and
</I>&gt;<i> you're done.  It's pretty much what every other TCP protocol that has
</I>&gt;<i> structure to its data does, whether that's length counted, flag bytes,
</I>&gt;<i> specific textual content (such as the final empty line in an HTTP
</I>&gt;<i> request), etc...
</I>&gt;<i> 
</I>&gt;<i> As has been posted in another response, you may find some of the
</I>&gt;<i> existing protocols in twisted.protocol.basic to be helpful for this.
</I>&gt;<i> The older posting of mine that you referenced used a subclass of
</I>&gt;<i> LineReceiver to encode the length in ASCII as part of an initial
</I>&gt;<i> header, for example, though it closed the connection when done.  And,
</I>&gt;<i> for example, Netstring or the Int##String classes takes care of the
</I>&gt;<i> counting on your behalf, and even give subclasses a nice single entry
</I>&gt;<i> point (stringReceived) to use instead of dataReceived, so your server
</I>&gt;<i> need not think about the aggregation or splitting of chunks.
</I>&gt;<i> 
</I>&gt;<i> If nothing else, reading the source to one of those receiver classes
</I>&gt;<i> might help provide a concrete example of the aggregation (or
</I>&gt;<i> splitting) of the stream data that I mention above.
</I>&gt;<i> 
</I>&gt;<i> -- David
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20100219/dd2d5f0f/attachment.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="054056.html">[Twisted-Python] Streaming File Transfer Protocol?
</A></li>
	<LI>Next message (by thread): <A HREF="054109.html">[Twisted-Python] Streaming File Transfer Protocol?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#54108">[ date ]</a>
              <a href="thread.html#54108">[ thread ]</a>
              <a href="subject.html#54108">[ subject ]</a>
              <a href="author.html#54108">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
