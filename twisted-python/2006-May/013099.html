<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: cred and stateless protocols
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20cred%20and%20stateless%20protocols&In-Reply-To=445FA923.6090703%40libero.it">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013088.html">
   <LINK REL="Next"  HREF="013100.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: cred and stateless protocols</H1>
    <B>Phil Mayers</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20cred%20and%20stateless%20protocols&In-Reply-To=445FA923.6090703%40libero.it"
       TITLE="[Twisted-Python] Re: cred and stateless protocols">p.mayers at imperial.ac.uk
       </A><BR>
    <I>Wed May 10 06:42:32 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="013088.html">[Twisted-Python] Re: cred and stateless protocols
</A></li>
        <LI>Next message: <A HREF="013100.html">[Twisted-Python] Re: cred and stateless protocols
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13099">[ date ]</a>
              <a href="thread.html#13099">[ thread ]</a>
              <a href="subject.html#13099">[ subject ]</a>
              <a href="author.html#13099">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Manlio Perillo wrote:
&gt;&gt;<i> The only sensible solution to HTTP authentication for important
</I>&gt;&gt;<i> applications is to use an HTTPS link, signed server certs and ideally
</I>&gt;&gt;<i> client certs as well, 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Yes, but how many people knows how to set up a private certificate?
</I>&gt;<i> And how many sites uses certs verification?
</I>
Lots. I honestly don't think it's that hard but we might have to agree 
to disagree on this. If it has a fault, it's the difficulty virtual 
hosting without burning IPs.

&gt;<i> 
</I>&gt;<i> It would be nice to store a certificate on a smart card and authenticate
</I>&gt;<i> to a web server using only that certificate.
</I>
You can do that now if you want. But the hardware is expensive. Frankly, 
I think a local software store with key is fine.

But the important thing is to use SSL and server certs. The client certs 
are just a nice-to-have.

&gt;&gt;<i> an &quot;Authorization: GoogleAuth THETOKEN&quot; header. 
</I>&gt;<i> 
</I>&gt;<i> And this header should be supplied for every successive requests (like
</I>&gt;<i> cookies)?
</I>
Yes, avoiding the need for an extra round-trip per request.

&gt;<i> 
</I>&gt;&gt;<i> This provides much
</I>&gt;&gt;<i> greater scalability and is similar to MS Passport (which itself is
</I>&gt;&gt;<i> similar to Kerberos).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Presumably the token expires. You should note however that the token is
</I>&gt;&gt;<i> NOT used for sessioning. HTTP 302 redirects and URL parameters are used
</I>&gt;&gt;<i> for that. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I'm not sure to understand this.
</I>
GET /resource

401 unauth

GET /resouce
Authorization: GoogleAuth=foobarbaz

302 Moved
Location: /resource?sessionid=id

GET /resource?sessionid=id
Authorization: GoogleAuth=foobarbaz

200 OK
CONTENT

...then on subsequence requests, you can do:

GET /another_resource?sessionid=id
Authorization: GoogleAuth=foobazbaz

200 OK
CONENT

...which is a single round-trip with authentication and sessioning

&gt;<i> 
</I>&gt;&gt;<i> You might ponder that Google separated out auth and sessions
</I>&gt;&gt;<i> even in their engineering compromise.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Note that the above refers to the non-browser API. Presumably the
</I>&gt;&gt;<i> browser API will use a passport-alike 302+cookie.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For open source examples, see PubCookie.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Thanks for the link.
</I>&gt;<i> I have not read the source, but the &quot;granting cookie&quot; what type of
</I>&gt;<i> informations contains to be sure that the UA is the &quot;right&quot; one?
</I>
I haven't used it, I just know it's generally well thought of.

&gt;<i> 
</I>&gt;&gt;&gt;<i> By the way:
</I>&gt;&gt;&gt;<i> for user tracking in UDP, why not just use the peer address?
</I>&gt;&gt;<i> Pardon? Are you serious?
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Well, let me explain this better.
</I>&gt;<i> Unfortunately there are not examples of UDP servers in twisted.
</I>&gt;<i> 
</I>&gt;<i> Since UDP is connection-less, the first thing that come to my mind is:
</I>&gt;<i> 
</I>&gt;<i> class MyProtocol(DatagramProtocol):
</I>&gt;<i>     def __init__(self):
</I>&gt;<i>        self.users = {}
</I>&gt;<i> 
</I>&gt;<i>     def datagramReceived(self, data, (host, port)):
</I>&gt;<i>         context = self.users.setdefault(host, Context())
</I>&gt;<i>         response = context.handle(data)
</I>&gt;<i>         self.transport.write(data, (host, port))
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Where the Context class keep an internal state, like IMAP.
</I>
That is phenomenally insecure

  1. You're using just the IP and not the IP+port, which means 2 users 
behind the same NAT will be unable to simultaneously use your service, 
or will see each others data.

  2. Since it's UDP it's trivially forged, so unless your context.handle 
FURTHER authenticates the data (via e.g. HMAC and key agreement) it's 
basically open to the world

  3. You're creating a new context for the 1st packet from each IP, so I 
can trivially send hundreds of thousands of packets to your service with 
forged source addresses and exhaust the CPU and memory resources of your 
server.

At ABSOLUTE MINIMUM a UDP protocol must force the client to round-trip 
the first packet using minimal CPU resources possible to at least ensure 
it's not a source-spoofing DDoS.

# WARNING WARNING WARNING DO NOT USE INSECURE IN MANY WAYS
# I strongly suggest the use of TCP or existing secure UDP
# protocols such as Q2Q
class proto(DatagramProtocol):
   MAGIC = 'MYPT'
   ECHO = open('/dev/random').read(16)

   # PDU format: MAGIC(4 bytes)+FLAGS(1 bytes)+PAYLOAD

   def datagramReceived(self, data, (host, port)):
     if len(data)&lt;28:
       # too short
       return
     if data[:4]!=self.MAGIC:
       # not our protocol
       return
     flags = ord(data[4])

     # 1st packet in connection has flags=0
     if flags==0:
         # note: no state and minimal CPU consumed here
         self.transport.write(self.MAGIC+'\0'+self.ECHO, (host, port))
         return

     # 2nd packet must have flags==1 and payload==ECHO
     elif flags==1:
         if data[5:]!=self.ECHO:
             return
         # ok, we've verified there's something on the other
         # end, now start e.g. secure diffie-hellman
         context = startContext(host, port, self.transport)

     else flags==2:
         feedContext(host, port, data)

The above is NOT SECURE and would need sequence numbers, authentication 
and integrity protection adding. But it should hopefully convince you 
that the naive approach is just that - and in fact actively dangerous in 
a modern, hostile internet environment.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013088.html">[Twisted-Python] Re: cred and stateless protocols
</A></li>
	<LI>Next message: <A HREF="013100.html">[Twisted-Python] Re: cred and stateless protocols
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13099">[ date ]</a>
              <a href="thread.html#13099">[ thread ]</a>
              <a href="subject.html#13099">[ subject ]</a>
              <a href="author.html#13099">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
