<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Flow, generators, coroutines etc.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Flow%2C%20generators%2C%20coroutines%20etc.&In-Reply-To=%3C44799A1A.3080204%40imperial.ac.uk%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="045744.html">
   <LINK REL="Next"  HREF="045748.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Flow, generators, coroutines etc.</H1>
    <B>Phil Mayers</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Flow%2C%20generators%2C%20coroutines%20etc.&In-Reply-To=%3C44799A1A.3080204%40imperial.ac.uk%3E"
       TITLE="[Twisted-Python] Flow, generators, coroutines etc.">p.mayers at imperial.ac.uk
       </A><BR>
    <I>Sun May 28 06:39:54 MDT 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="045744.html">[Twisted-Python] Flow, generators, coroutines etc.
</A></li>
        <LI>Next message (by thread): <A HREF="045748.html">[Twisted-Python] Flow, generators, coroutines etc.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45745">[ date ]</a>
              <a href="thread.html#45745">[ thread ]</a>
              <a href="subject.html#45745">[ subject ]</a>
              <a href="author.html#45745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dominic Fox wrote:
&gt;<i> I understand that twisted.flow is no longer maintained, and is not
</I>&gt;<i> widely considered to represent a good way of writing twisted code.
</I>&gt;<i> However, I haven't been able to find any explanation of why this
</I>&gt;<i> approach (using generators to simulate co-operative multitasking)
</I>&gt;<i> seems to have been abandoned.
</I>
Well, flow in particular had a very funny model. It did not seem 
straightforward to me at all.

&gt;<i> 
</I>&gt;<i> Is it simply the case  that most people writing twisted code didn't
</I>&gt;<i> find it very useful? Or are there more specific arguments against
</I>&gt;<i> doing things that way?
</I>
I believe the general consensus with regards generator-based 
microthreads is that attempting to hide the fact you are doing 
asynchronous work behind a language trick is a Bad Thing(tm) in much the 
same way that RESTians believe layering RPC semantics over HTTP (or any 
WAN technology) is a bad thing, and for many of the same reasons.

In addition, though the concurrency issues are VASTLY reduced compared 
to pre-emptive threading, they do still exist. I've got caught out by them.

Pre python2.5 getting the data back into the generator either requires a 
global or a magic stack-traversing function which is of course nasty.

Finally, you have to work very hard pre-python2.5 to make the uthreads 
correctly handle all error cases.

&gt;<i> 
</I>&gt;<i> I'm trying to make the case at work for using twisted for networking
</I>&gt;<i> things (in spite of my preference for lightweight threads plus
</I>&gt;<i> sensible concurrency primitives, if Python is the target platform then
</I>&gt;<i> twisted is probably the best way to go).
</I>
I tend to think that lightweight threads really require first-class 
support from the VM, such as exists in Erlang, in order for them to be 
truly useful.

Were Erlang not such an ugly language I'd seriously consider switching 
to it. The more restricted model leads to all kinds of magic VM scaling 
goodness and the &quot;right&quot; (in my at least current opinion) way of writing 
such code is enshrined in the very architecture.

Had Stackless not been shot down (and for no particularly good reasons - 
&quot;we'd have to port it to each platform&quot; seems to have been the gist of 
it, plus some people rather disappointing and recurrent fear of the new) 
then I suspect Twisted would not exist in its current form.

w.r.t. &quot;sensible&quot; concurrency primitives, I've heard an Erlang expert 
relate: &quot;Oh, we have two concurrency primitives. 'read' and 'write'&quot;, a 
position I support wholeheartedly.

All that said, the BBC Kamaelia project uses a generator-based 
consumer/producer pipeline as its underlying primitive, and seems to get 
along fine with it. But a consumer/producer component is not the same as 
a lightweight thread of course - broadly a c/p will only ever interact 
with its input, local variables, output and library calls. A thread 
might be expected to interact with other threads and shared data, from 
whence all difficulty springs.

It's also worth pointing out that Google uses a massively distributed 
c/p implementation called map-reduce to do much of their big work. A 
well-isolated generator-based c/p would be trivially parallel in much 
the same way.

&gt;<i> 
</I>&gt;<i> If I can show some full-threaded code next to some co-operative
</I>&gt;<i> multitasking code that a) has much the same sort of control flow, but
</I>&gt;<i> b) scales much better, and doesn't have to worry about subtle
</I>&gt;<i> concurrency issues, then I think it should go fairly well. If I have
</I>&gt;<i> to explain about how the event-driven programming model works at the
</I>&gt;<i> same time, it might not go *so* well...
</I>
I wrote a generator-based uthread thing over the top of twisted ages 
ago, on more or less the same rationale - other people would eventually 
be expected to write code for the system, and they would balk at or be 
unable to handle writing &quot;true&quot; async code.

This has not in fact been the case. Several of my colleagues have picked 
up the deferred/callback programming model with little difficulty.

Given that a similar system appears in MochiKit and web programmers 
appear to be able to pick it up and run with it in a *JavaScript* VM, 
perhaps we're underestimating people.

I will say three things:

  1. The name &quot;Deferred&quot; is tremendously unfortunate. I cannot begin to 
imagine why they weren't just called &quot;Callback&quot;. The name seems to 
confuse people into thinking it does something it does not.

  2. The generator/uthread trick makes for tidier code because you can 
keep state in local variables. Using callbacks require you to pass a 
state object around and then prefix everything with a &quot;state.varname&quot; or 
worse &quot;state['varname']&quot; and the (frankly annoying) extra typing 
obviously leads to more scope for bugs as well as lower performance 
since local variable access is much faster.
  Sadly the &quot;with&quot; keyword just got used for something else (something 
else the language already had in fact. Oh well)

  3. I believe Deferreds as they currently exist are not very fast, and 
that's on top of the high cost of python function calls. Frequently we 
are told most processes are IO bound. That is very definitely not the 
case in my setup - I am SNMP polling 1200 devices every 5 minutes, 
sending an average of ~300-500 PDUs to each. With a bit of tuning, the 
CPU spins at about 90% usermode and 10% io/system.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="045744.html">[Twisted-Python] Flow, generators, coroutines etc.
</A></li>
	<LI>Next message (by thread): <A HREF="045748.html">[Twisted-Python] Flow, generators, coroutines etc.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45745">[ date ]</a>
              <a href="thread.html#45745">[ thread ]</a>
              <a href="subject.html#45745">[ subject ]</a>
              <a href="author.html#45745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
