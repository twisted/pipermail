<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Where to start: log reader/analysis
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Where%20to%20start%3A%20log%20reader/analysis&In-Reply-To=%3C4adac7a30708131450g7879608fh49d26074d323512e%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="048330.html">
   <LINK REL="Next"  HREF="048328.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Where to start: log reader/analysis</H1>
    <B>Nathaniel Haggard</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Where%20to%20start%3A%20log%20reader/analysis&In-Reply-To=%3C4adac7a30708131450g7879608fh49d26074d323512e%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Where to start: log reader/analysis">natester at gmail.com
       </A><BR>
    <I>Mon Aug 13 15:50:04 MDT 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="048330.html">[Twisted-Python] Where to start: log reader/analysis
</A></li>
        <LI>Next message (by thread): <A HREF="048328.html">[Twisted-Python] TDDing an ssh client - mocking the server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#48376">[ date ]</a>
              <a href="thread.html#48376">[ thread ]</a>
              <a href="subject.html#48376">[ subject ]</a>
              <a href="author.html#48376">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Like this?

from twisted.internet import task,reactor,abstract
from twisted.protocols import basic
import os

class FileFollowerTransport(object):
    &quot;&quot;&quot;Iterate through a file while it is updated.

    &quot;&quot;&quot;

    interval = 1

    def __init__(self, filename, interval=None):
        self.filename = filename
        self.interval = interval or self.interval
        self.stat = None
        self.offset = 0
        self.lines = []
        self.lc = task.LoopingCall(self.follow)

    #
    # File following

    def run(self):
        self.lc.start(self.interval)

    def follow(self):
        if self.hasChanged():
            data = self.readChange()
            if data:
                self.protocol.dataReceived(data)

    def hasChanged(self):
        stat = os.stat(self.filename)
        if stat != self.stat:
            self.stat = stat
            return True
        return False

    def readChange(self):
        file = open(self.filename)
        file.seek(self.offset)
        data = file.read()
        self.offset = file.tell()
        file.close()
        return data

class stuby(basic.LineReceiver):

    def dataReceived(self, data):
        print data


if __name__ == '__main__':
    l = stuby()
    f = FileFollowerTransport('test')
    f.protocol = l
    f.run()
    l.makeConnection(f)
    reactor.run()



On 8/6/07, Jean-Paul Calderone &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">exarkun at divmod.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> On Mon, 6 Aug 2007 10:57:19 +0200, Yoann Aubineau &lt;
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">yoann.aubineau at wengo.com</A>&gt; wrote:
</I>&gt;<i> &gt;Hi Andrew,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;I wrote a class that follows a file (eg. log file) and provides an
</I>&gt;<i> iterator
</I>&gt;<i> &gt;to walk through it. Don't know if it may be of any use for you (or
</I>&gt;<i> others).
</I>&gt;<i>
</I>&gt;<i> Hi Yoann, thanks for sharing.
</I>&gt;<i>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;class FileFollower(object):
</I>&gt;<i> &gt;    &quot;&quot;&quot;Iterate through a file while it is updated.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    &gt;&gt;&gt; file = FileFollower(&quot;/tmp/testfile&quot;)
</I>&gt;<i> &gt;    &gt;&gt;&gt; file.interval = 5
</I>&gt;<i> &gt;    &gt;&gt;&gt; for line in file:
</I>&gt;<i> &gt;    ...     print line
</I>&gt;<i> &gt;    &quot;&quot;&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    interval = 1
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def __init__(self, filename, interval=None):
</I>&gt;<i> &gt;        self.filename = filename
</I>&gt;<i> &gt;        self.interval = interval or self.interval
</I>&gt;<i> &gt;        self.stat = None
</I>&gt;<i> &gt;        self.offset = 0
</I>&gt;<i> &gt;        self.lines = []
</I>&gt;<i> &gt;        self.running = True
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    #
</I>&gt;<i> &gt;    # File following
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def follow(self):
</I>&gt;<i> &gt;        while self.running:
</I>&gt;<i> &gt;            if self.hasChanged():
</I>&gt;<i> &gt;                data = self.readChange()
</I>&gt;<i> &gt;                if data:
</I>&gt;<i> &gt;                    self.dataReceived(data)
</I>&gt;<i> &gt;                    break
</I>&gt;<i> &gt;            time.sleep(self.interval)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def hasChanged(self):
</I>&gt;<i> &gt;        stat = os.stat(self.filename)
</I>&gt;<i> &gt;        if stat != self.stat:
</I>&gt;<i> &gt;            self.stat = stat
</I>&gt;<i> &gt;            return True
</I>&gt;<i> &gt;        return False
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def readChange(self):
</I>&gt;<i> &gt;        file = open(self.filename)
</I>&gt;<i> &gt;        file.seek(self.offset)
</I>&gt;<i> &gt;        data = file.read()
</I>&gt;<i> &gt;        self.offset = file.tell()
</I>&gt;<i> &gt;        file.close()
</I>&gt;<i> &gt;        return data
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    #
</I>&gt;<i> &gt;    # Data buffering
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def dataReceived(self, data):
</I>&gt;<i> &gt;        lines = data.split(os.linesep)
</I>&gt;<i> &gt;        lines = lines[:-1]
</I>&gt;<i> &gt;        for line in lines:
</I>&gt;<i> &gt;            self.lineReceived(line)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def lineReceived(self, line):
</I>&gt;<i> &gt;        self.lines.append(line)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    #
</I>&gt;<i> &gt;    # Iterator implementation
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def __iter__(self):
</I>&gt;<i> &gt;        return self
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    def next(self):
</I>&gt;<i> &gt;        if not self.lines:
</I>&gt;<i> &gt;            self.follow()
</I>&gt;<i> &gt;        line = self.lines.pop(0)
</I>&gt;<i> &gt;        return line
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> In order to make this class more usable within a Twisted application, I'd
</I>&gt;<i> make a few suggestions:
</I>&gt;<i>
</I>&gt;<i> Separate the transport from the protocol.  All of the methods in the area
</I>&gt;<i> commented &quot;file following&quot; are basically transport methods: they know how
</I>&gt;<i> to get the underlying bytes (by polling and eventually reading).  The
</I>&gt;<i> protocol implementation is basically the dataReceived and lineReceived
</I>&gt;<i> methods.  With separation between the transport and the protocol, you
</I>&gt;<i> don't even need to implement these, since you can just use LineReceiver
</I>&gt;<i> from twisted.protocols.basic.
</I>&gt;<i>
</I>&gt;<i> Do the polling in a cooperative way.  Using an infinite for loop and a
</I>&gt;<i> time.sleep call has the consequence of tying up an entire thread.  This
</I>&gt;<i> means nothing else can happen unless you run the follow method of this
</I>&gt;<i> class in a new, dedicated thread.  If you use the reactor to schedule
</I>&gt;<i> the checks instead, then this can be used alongside other Twisted code
</I>&gt;<i> without having to deal with threading.  twisted.internet.task.LoopingCall
</I>&gt;<i> might be of particular interest.
</I>&gt;<i>
</I>&gt;<i> Jean-Paul
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20070813/6c74965c/attachment.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="048330.html">[Twisted-Python] Where to start: log reader/analysis
</A></li>
	<LI>Next message (by thread): <A HREF="048328.html">[Twisted-Python] TDDing an ssh client - mocking the server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#48376">[ date ]</a>
              <a href="thread.html#48376">[ thread ]</a>
              <a href="subject.html#48376">[ subject ]</a>
              <a href="author.html#48376">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
