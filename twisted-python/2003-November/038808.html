<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Scaling problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Scaling%20problem&In-Reply-To=%3C20031105151449.GA20167%40intarweb.us%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="038806.html">
   <LINK REL="Next"  HREF="038810.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Scaling problem</H1>
    <B>Jp Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Scaling%20problem&In-Reply-To=%3C20031105151449.GA20167%40intarweb.us%3E"
       TITLE="[Twisted-Python] Scaling problem">exarkun at intarweb.us
       </A><BR>
    <I>Wed Nov  5 08:14:49 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="038806.html">[Twisted-Python] Scaling problem
</A></li>
        <LI>Next message (by thread): <A HREF="038810.html">[Twisted-Python] Scaling problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38808">[ date ]</a>
              <a href="thread.html#38808">[ thread ]</a>
              <a href="subject.html#38808">[ subject ]</a>
              <a href="author.html#38808">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Nov 05, 2003 at 02:48:07AM -0800, Uwe C. Schroeder wrote:
&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> Hash: SHA1
</I>&gt;<i> 
</I>&gt;<i> On Tuesday 04 November 2003 12:20 pm, Glyph Lefkowitz wrote:
</I>&gt;<i> &gt; Uwe C. Schroeder wrote:
</I>&gt;<i> &gt; &gt; Is there a way to have twisted do something like apache or postgres and
</I>&gt;<i> &gt; &gt; split the incoming connection to several processes ? It's not a web
</I>&gt;<i> &gt; &gt; application, I'm solely using pb.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This is possible, although not as easy as I'd like it to be.  In
</I>&gt;<i> &gt; principle, on most UNIX-based OSes, it's possible to listen() and
</I>&gt;<i> &gt; accept() in one process, pass the returned file descriptor to a
</I>&gt;<i> &gt; subprocess and do communication there.  I'd like to make this automatic
</I>&gt;<i> &gt; at some point, but won't have the time to do it for at least another few
</I>&gt;<i> &gt; months.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The fact that it's not as graceful or automatic as I like doesn't mean
</I>&gt;<i> &gt; it's impossible though.  If you want to just have one &quot;control&quot; process
</I>&gt;<i> &gt; that shuttles around I/O and N worker processes that do the actual work,
</I>&gt;<i> &gt; you can still use spawnProcess and communicate over stdin/stdout to the
</I>&gt;<i> &gt; subprocesses about new connections using a simple protocol which
</I>&gt;<i> &gt; multiplexes multiple socket connections down to the one pipe connection
</I>&gt;<i> &gt; and back.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Also, if database latency is your main problem, or you can move a little
</I>&gt;<i> &gt; bit of performance-sensitive code into C and relinquish the GIL while
</I>&gt;<i> &gt; they're happening, you can just use callInThread to run your
</I>&gt;<i> &gt; transactions in threads instead of having the reactor waiting on them.
</I>&gt;<i> 
</I>&gt;<i> I figured that the impact of callInThread is much higher to the rest of the 
</I>&gt;<i> system than I like. I'm already using deferToThread a lot, however there are 
</I>&gt;<i> limits to the usefulness of threads.  For example I use it to do page 
</I>&gt;<i> formatting (printjobs). Each of the printjobs is about 120 pages to format. 
</I>&gt;<i> If I start 20 to 30 such formatting jobs with deferToThread twisted virtually 
</I>&gt;<i> becomes unresponsive. If I limit to a max of 3 or so it works. I admit I 
</I>&gt;<i> don't understand this, since IMHO defering to a thread should make it 
</I>&gt;<i> independant from the parent.
</I>
  But it doesn't, not in Python.  Each thread adds new contention for the
GIL, which makes every thread less responsive.  If the print jobs were
managed by a C extension which could release the GIL before doing its work,
then they would be mostly independant.

&gt;<i> I didn't dig into this problem since It's not a big deal to limit to a few
</I>&gt;<i> such jobs at any given time and use a spooler type interface to suspend
</I>&gt;<i> requests for later.
</I>
  Yea.  If you only have 4 CPUs, it doesn't make sense to be running 400
CPU-bound threads :)

&gt;<i> 
</I>&gt;<i> I think I suffer from database latency in general and with the expensive 
</I>&gt;<i> function in particular. The expensive function could be moved to a thread and 
</I>&gt;<i> maybe I'll give it a try. However if I do this for every method that writes 
</I>&gt;<i> more than 10 or 15 records to the database I'll most likely end up with 
</I>&gt;<i> thousands of threads. Currently the system is used by up to 15 people, but 
</I>&gt;<i> projection goes to 400+ people at any given time. I don't have a problem with 
</I>&gt;<i> having people wait for a result, I have a problem with the other people that 
</I>&gt;<i> don't get a result because the framework stops responding for a couple of 
</I>&gt;<i> functions that just take more than a millisecond to execute. 
</I>&gt;<i> I'd rather have 500 processes like with apache and have the OS do the 
</I>&gt;<i> scheduling - which is way more efficient than having the framework schedule.
</I>&gt;<i> The most expensive function I have (besides the printing mentioned above) 
</I>&gt;<i> executes in about 3 seconds. This is not &quot;blocking&quot; in my understanding, 
</I>&gt;<i> since the function never waits for something to happen, it just calculates 
</I>&gt;<i> and stores stuff.
</I>
  It is blocking.  While the term usually refers to a function that waits
for some I/O to finish, it applies equally well to any functions that run
for a non-trivial amount of time and, while doing so, prevent the rest of
the application from proceeding.

&gt;<i> Twisted is unresponsive for those 3 seconds. Multiply that by 10 users and
</I>&gt;<i> one user might end up with a delay of more than 30 seconds before his &quot;3
</I>&gt;<i> seconds&quot; are evaluated. If I had a lot of processes the OS would schedule
</I>&gt;<i> that more efficiently since then the function might take 5 seconds to
</I>&gt;<i> complete, but it would be interrupted by the OS scheduler to hand
</I>&gt;<i> processing time to one of the other processes.
</I>&gt;<i> 
</I>&gt;<i> Maybe I'll look into splitting into n worker processes. Since this would 
</I>&gt;<i> involve going into twisted code, where would I start looking ?
</I>&gt;<i> 
</I>
  Before doing that, you might consider just spawning a handful of worker
threads and giving them queues.  This keeps the application responsive by
not forcing an insane number of context switches but also still allowing all
the expensive functions to run independently of the I/O thread.  

  There is even a ThreadPool class in Twisted already (though I have never
used it myself ;), so giving this approach a try should be pretty quick, and
if it is still not good enough, you haven't lost much time.

  This is not to say that multiple processes would not also be a good
solution, just that it might be a harder one to implement.  If you do end up
looking at multiple processes, reactor.spawnProcess() (as glyph alluded to
earlier) is one way to go about it.  This is basically the equivalent of
popen2() (though with a lot more flexibility).

  On a related, but not necessarily useful note, I've recently begun
investigating ways of moving the state associated with a user request,
including the associated socket object, between processes.  My use case is
not load-balancing, but the code should apply equally well to this as to
what I intend to use it for.  It requires C extensions (which are currently
-just- good enough to play around with higher-level stuff in Python with). 
The code is very short, and lives mostly in sandbox/exarkun/copyover/fdpass.py
in CVS HEAD.

  Jp
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Digital signature
URL: &lt;/pipermail/twisted-python/attachments/20031105/3c284807/attachment.sig&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="038806.html">[Twisted-Python] Scaling problem
</A></li>
	<LI>Next message (by thread): <A HREF="038810.html">[Twisted-Python] Scaling problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38808">[ date ]</a>
              <a href="thread.html#38808">[ thread ]</a>
              <a href="subject.html#38808">[ subject ]</a>
              <a href="author.html#38808">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
