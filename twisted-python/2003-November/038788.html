<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Adapting RemoteReferences
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Adapting%20RemoteReferences&In-Reply-To=%3C20031104015904.GA10300%40twistedmatrix.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="038787.html">
   <LINK REL="Next"  HREF="038789.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Adapting RemoteReferences</H1>
    <B>Sam Jordan</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Adapting%20RemoteReferences&In-Reply-To=%3C20031104015904.GA10300%40twistedmatrix.com%3E"
       TITLE="[Twisted-Python] Adapting RemoteReferences">sam at twistedmatrix.com
       </A><BR>
    <I>Mon Nov  3 18:59:04 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="038787.html">[Twisted-Python] Adapting RemoteReferences
</A></li>
        <LI>Next message (by thread): <A HREF="038789.html">[Twisted-Python] Adapting RemoteReferences
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38788">[ date ]</a>
              <a href="thread.html#38788">[ thread ]</a>
              <a href="subject.html#38788">[ subject ]</a>
              <a href="author.html#38788">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

Thanks for the response Jp ...

On Mon, Nov 03, 2003 at 07:43:10AM -0500, Jp Calderone wrote:
&gt;<i>   I think the preferred approach is the opposite.  Instead of taking remote
</I>&gt;<i> references and trying to treat them as local, take local references and
</I>&gt;<i> treat them as remote (this makes sense from an interface enforcement
</I>&gt;<i> consistency point of view, too -- it's easier to throw away some information
</I>&gt;<i> than you have than to pull information you don't have out of thin air).
</I>
Indeed, this does make more sense, I don't know why I didn't think of it in this
way. The way you have described also takes care of emulating the Deferred result
instead of having to specify it as part of the interface as well.

On the other hand, you still end up with basically the same level of interface
enforcement; that is, you can guarantee the interface characteristics of local
objects but not remote objects. This is unlikely to change however, without either
the protocol changing (unlikely - &quot;did somebody mention IDL? :-)&quot;) or people obeying
their own interface definition conventions. Still, I can certainly see your point that
publishing an object as implementing an interface when it possibly doesn't is worse
than wrapping a local object with a single string-based dispatching method. 

Other small differences I can think of are that in cases where a system has already
been written and a remote interface is being provided, it may be easier to make
chanes to the effect of:

    # part of remote system wrapper class
    def remote_addObserver(self, observer):
        underlyingSystem.addObserver(observer.adaptTo(IUserInterface))

    # part of the underlying system
    # (code that was written prior to considering a remote interface)
    def addObserver(self, observer): self.observers.append(observer)

So if the underlying system was built without a remote interface in mind
it may be easier to just adapt the remote refs than to change every instance
of calls to the local objects.

If it _was_ written with the knowledge that a remote interface will be placed
on top in the future, I assume the code would look something like:

    # part of remote system wraper class
    def remote_addObserver(self, observer):
        underlyingSystem.addObserver(observer)

    # part of underlying system
    def addObserver(self, observer):
        if not isinstance(observer, RemoteReference):
            observer = LocalAsyncForwarder(observer, IUserInterface)
        # rest of method ...

And then all subsequent calls would use callRemote.

I guess which one you prefer is purely a matter of style and I can
see no real disadvantages from the later approach unless of course,
the system has already been written.

&gt;<i>   See twisted.spread.util.LocalAsyncForwarder.
</I>
Thanks for pointing this out.

Cheers,

Sam.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="038787.html">[Twisted-Python] Adapting RemoteReferences
</A></li>
	<LI>Next message (by thread): <A HREF="038789.html">[Twisted-Python] Adapting RemoteReferences
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38788">[ date ]</a>
              <a href="thread.html#38788">[ thread ]</a>
              <a href="subject.html#38788">[ subject ]</a>
              <a href="author.html#38788">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
