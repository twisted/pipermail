<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Scaling problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Scaling%20problem&In-Reply-To=20031105151449.GA20167%40intarweb.us">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006302.html">
   <LINK REL="Next"  HREF="006305.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Scaling problem</H1>
    <B>Uwe C. Schroeder</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Scaling%20problem&In-Reply-To=20031105151449.GA20167%40intarweb.us"
       TITLE="[Twisted-Python] Scaling problem">uwe at oss4u.com
       </A><BR>
    <I>Wed Nov  5 13:00:23 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="006302.html">[Twisted-Python] Scaling problem
</A></li>
        <LI>Next message: <A HREF="006305.html">[Twisted-Python] rpm package for twisted?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6304">[ date ]</a>
              <a href="thread.html#6304">[ thread ]</a>
              <a href="subject.html#6304">[ subject ]</a>
              <a href="author.html#6304">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Wednesday 05 November 2003 07:14 am, Jp Calderone wrote:
&gt;<i> On Wed, Nov 05, 2003 at 02:48:07AM -0800, Uwe C. Schroeder wrote:
</I>&gt;<i> &gt; -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> &gt; Hash: SHA1
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Tuesday 04 November 2003 12:20 pm, Glyph Lefkowitz wrote:
</I>&gt;<i> &gt; &gt; Uwe C. Schroeder wrote:
</I>&gt;<i> &gt; &gt; &gt; Is there a way to have twisted do something like apache or postgres
</I>&gt;<i> &gt; &gt; &gt; and split the incoming connection to several processes ? It's not a
</I>&gt;<i> &gt; &gt; &gt; web application, I'm solely using pb.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; This is possible, although not as easy as I'd like it to be.  In
</I>&gt;<i> &gt; &gt; principle, on most UNIX-based OSes, it's possible to listen() and
</I>&gt;<i> &gt; &gt; accept() in one process, pass the returned file descriptor to a
</I>&gt;<i> &gt; &gt; subprocess and do communication there.  I'd like to make this automatic
</I>&gt;<i> &gt; &gt; at some point, but won't have the time to do it for at least another
</I>&gt;<i> &gt; &gt; few months.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The fact that it's not as graceful or automatic as I like doesn't mean
</I>&gt;<i> &gt; &gt; it's impossible though.  If you want to just have one &quot;control&quot; process
</I>&gt;<i> &gt; &gt; that shuttles around I/O and N worker processes that do the actual
</I>&gt;<i> &gt; &gt; work, you can still use spawnProcess and communicate over stdin/stdout
</I>&gt;<i> &gt; &gt; to the subprocesses about new connections using a simple protocol which
</I>&gt;<i> &gt; &gt; multiplexes multiple socket connections down to the one pipe connection
</I>&gt;<i> &gt; &gt; and back.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Also, if database latency is your main problem, or you can move a
</I>&gt;<i> &gt; &gt; little bit of performance-sensitive code into C and relinquish the GIL
</I>&gt;<i> &gt; &gt; while they're happening, you can just use callInThread to run your
</I>&gt;<i> &gt; &gt; transactions in threads instead of having the reactor waiting on them.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I figured that the impact of callInThread is much higher to the rest of
</I>&gt;<i> &gt; the system than I like. I'm already using deferToThread a lot, however
</I>&gt;<i> &gt; there are limits to the usefulness of threads.  For example I use it to
</I>&gt;<i> &gt; do page formatting (printjobs). Each of the printjobs is about 120 pages
</I>&gt;<i> &gt; to format. If I start 20 to 30 such formatting jobs with deferToThread
</I>&gt;<i> &gt; twisted virtually becomes unresponsive. If I limit to a max of 3 or so it
</I>&gt;<i> &gt; works. I admit I don't understand this, since IMHO defering to a thread
</I>&gt;<i> &gt; should make it independant from the parent.
</I>&gt;<i>
</I>&gt;<i>   But it doesn't, not in Python.  Each thread adds new contention for the
</I>&gt;<i> GIL, which makes every thread less responsive.  If the print jobs were
</I>&gt;<i> managed by a C extension which could release the GIL before doing its work,
</I>&gt;<i> then they would be mostly independant.
</I>
That explains it. Maybe I'll go ahead and create a separate &quot;print&quot; server 
process that just produces paper. I'm using reportlab and I even had to turn 
off the c extensions used in reportlab, because they are not threadsafe. 
Printing isn't a big deal at this time, simply because I gave them a &quot;print 
later&quot; checkbox which will suspend formatting and printing for the night. At 
night I then just process all the printjobs sequentially.


&gt;<i> &gt; I didn't dig into this problem since It's not a big deal to limit to a
</I>&gt;<i> &gt; few such jobs at any given time and use a spooler type interface to
</I>&gt;<i> &gt; suspend requests for later.
</I>&gt;<i>
</I>&gt;<i>   Yea.  If you only have 4 CPUs, it doesn't make sense to be running 400
</I>&gt;<i> CPU-bound threads :)
</I>
Exactly :-)

&gt;<i>
</I>&gt;<i> &gt; I think I suffer from database latency in general and with the expensive
</I>&gt;<i> &gt; function in particular. The expensive function could be moved to a thread
</I>&gt;<i> &gt; and maybe I'll give it a try. However if I do this for every method that
</I>&gt;<i> &gt; writes more than 10 or 15 records to the database I'll most likely end up
</I>&gt;<i> &gt; with thousands of threads. Currently the system is used by up to 15
</I>&gt;<i> &gt; people, but projection goes to 400+ people at any given time. I don't
</I>&gt;<i> &gt; have a problem with having people wait for a result, I have a problem
</I>&gt;<i> &gt; with the other people that don't get a result because the framework stops
</I>&gt;<i> &gt; responding for a couple of functions that just take more than a
</I>&gt;<i> &gt; millisecond to execute.
</I>&gt;<i> &gt; I'd rather have 500 processes like with apache and have the OS do the
</I>&gt;<i> &gt; scheduling - which is way more efficient than having the framework
</I>&gt;<i> &gt; schedule. The most expensive function I have (besides the printing
</I>&gt;<i> &gt; mentioned above) executes in about 3 seconds. This is not &quot;blocking&quot; in
</I>&gt;<i> &gt; my understanding, since the function never waits for something to happen,
</I>&gt;<i> &gt; it just calculates and stores stuff.
</I>&gt;<i>
</I>&gt;<i>   It is blocking.  While the term usually refers to a function that waits
</I>&gt;<i> for some I/O to finish, it applies equally well to any functions that run
</I>&gt;<i> for a non-trivial amount of time and, while doing so, prevent the rest of
</I>&gt;<i> the application from proceeding.
</I>&gt;<i>
</I>&gt;<i> &gt; Twisted is unresponsive for those 3 seconds. Multiply that by 10 users
</I>&gt;<i> &gt; and one user might end up with a delay of more than 30 seconds before his
</I>&gt;<i> &gt; &quot;3 seconds&quot; are evaluated. If I had a lot of processes the OS would
</I>&gt;<i> &gt; schedule that more efficiently since then the function might take 5
</I>&gt;<i> &gt; seconds to complete, but it would be interrupted by the OS scheduler to
</I>&gt;<i> &gt; hand processing time to one of the other processes.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Maybe I'll look into splitting into n worker processes. Since this would
</I>&gt;<i> &gt; involve going into twisted code, where would I start looking ?
</I>&gt;<i>
</I>&gt;<i>   Before doing that, you might consider just spawning a handful of worker
</I>&gt;<i> threads and giving them queues.  This keeps the application responsive by
</I>&gt;<i> not forcing an insane number of context switches but also still allowing
</I>&gt;<i> all the expensive functions to run independently of the I/O thread.
</I>&gt;<i>
</I>&gt;<i>   There is even a ThreadPool class in Twisted already (though I have never
</I>&gt;<i> used it myself ;), so giving this approach a try should be pretty quick,
</I>&gt;<i> and if it is still not good enough, you haven't lost much time.
</I>&gt;<i>
</I>&gt;<i>   This is not to say that multiple processes would not also be a good
</I>&gt;<i> solution, just that it might be a harder one to implement.  If you do end
</I>&gt;<i> up looking at multiple processes, reactor.spawnProcess() (as glyph alluded
</I>&gt;<i> to earlier) is one way to go about it.  This is basically the equivalent of
</I>&gt;<i> popen2() (though with a lot more flexibility).
</I>
I think a mixture of both might be the best approach. Having several processes 
would be great for MP machines, so one has the ability to scale on a hardware 
basis. Making more intelligent use of threads could increase responsiveness. 
One user is fine wating  for something to happen, but all the others 
shouldn't have to wait for the one user too.

&gt;<i>   On a related, but not necessarily useful note, I've recently begun
</I>&gt;<i> investigating ways of moving the state associated with a user request,
</I>&gt;<i> including the associated socket object, between processes.  My use case is
</I>&gt;<i> not load-balancing, but the code should apply equally well to this as to
</I>&gt;<i> what I intend to use it for.  It requires C extensions (which are currently
</I>&gt;<i> -just- good enough to play around with higher-level stuff in Python with).
</I>&gt;<i> The code is very short, and lives mostly in
</I>&gt;<i> sandbox/exarkun/copyover/fdpass.py in CVS HEAD.
</I>
I'll check that out. I wouldn't name it load-balancing. Would be interesting 
though to check if one could have a single &quot;socket server&quot; that distributes 
to several processes on several machines :-) For an application like mine 
load balancing might be much easier, since I could make the clients reconnect 
to a different server/port.

	UC

- --
Open Source Solutions 4U, LLC	2570 Fleetwood Drive
Phone:  +1 650 872 2425		San Bruno, CA 94066
Cell:   +1 650 302 2405		United States
Fax:    +1 650 872 2417
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.1 (GNU/Linux)

iD8DBQE/qTq3jqGXBvRToM4RAsd8AJ9Xme37KfYCxT+ls4SNOAQrzZTi8gCeK42C
Lwf/hmo+TRp/ulHAA49I3Ck=
=W66T
-----END PGP SIGNATURE-----



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006302.html">[Twisted-Python] Scaling problem
</A></li>
	<LI>Next message: <A HREF="006305.html">[Twisted-Python] rpm package for twisted?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6304">[ date ]</a>
              <a href="thread.html#6304">[ thread ]</a>
              <a href="subject.html#6304">[ subject ]</a>
              <a href="author.html#6304">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
