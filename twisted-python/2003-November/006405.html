<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] adbapi.Augmention
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20adbapi.Augmention&In-Reply-To=200311132238.26796.jon%40totient.demon.co.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006404.html">
   <LINK REL="Next"  HREF="006406.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] adbapi.Augmention</H1>
    <B>Stephen C. Waterbury</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20adbapi.Augmention&In-Reply-To=200311132238.26796.jon%40totient.demon.co.uk"
       TITLE="[Twisted-Python] adbapi.Augmention">golux at comcast.net
       </A><BR>
    <I>Thu Nov 13 17:47:42 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="006404.html">[Twisted-Python] adbapi.Augmention
</A></li>
        <LI>Next message: <A HREF="006406.html">[Twisted-Python] adbapi.Augmention
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6405">[ date ]</a>
              <a href="thread.html#6405">[ thread ]</a>
              <a href="subject.html#6405">[ subject ]</a>
              <a href="author.html#6405">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jon Dyte wrote:

&gt;<i> the doc string of adbapi.Augmentation mentions just using the ConnectionPool 
</I>&gt;<i> directly.
</I>&gt;<i> 
</I>&gt;<i> &quot;A class which augments a database connector with some functionality.
</I>&gt;<i> This class is now deprecated. Just use the ConnectionPool directly.
</I>&gt;<i> Conventional usage of me is to write methods that look like...&quot;
</I>&gt;<i> 
</I>&gt;<i> Presumbably this means DONT inherit from ConnectionPool like you
</I>&gt;<i> used to inherit from Augmentation( or am I reading that incorrectly)
</I>&gt;<i> and just create a ConnectionPool instance and run the queries through that.
</I>
Christopher Armstrong wrote:

&gt;<i> right.
</I>
But I think it works okay to subclass ConnectionPool ...
at least, it works for me.  Is there a better way to
do something like the following (which is working fine)?
(Admittedly you need to see my other modules for the full
picture, but you can infer what they would do ... as
you can probably guess, I don't use t.e.row.RowObject.)

----------------------------------------------------------------

# Twisted imports ...
from twisted.enterprise import adbapi
from twisted.internet import defer
from twisted.python import log, reflect
# Pan Galactic imports ...
from pangalactic.utils import sql, utils

class PgerDb(adbapi.ConnectionPool):
     &quot;&quot;&quot;
     I am PGERDB, implemented using the Twisted Enterprise adbapi
     and pyPgSQL on top of the PGERDB Master Schema.
     &quot;&quot;&quot;

     def __init__(self, dbapiname='pyPgSQL.PgSQL', database='pgerdb'):
         adbapi.ConnectionPool.__init__(self,
                                        dbapiname,
                                        database=database)
         self.dbname = database

     def doPgerdbQuery(self, table, subtypes, *args, **kw):
         &quot;&quot;&quot;
         Run a query submitted as a list of args against a
         specified table.

         @type table:  string
         @param table: name of the table to search

         @type subtypes:  boolean
         @param subtypes: whether to search only the specified
                          table (False) or to include all subtype
                          tables (True)

         @type args:   list of tuples
         @param args:  a list of tuples, in which each tuple has the
                       tuple has the form:
                         - element[0] = column name
                         - element[1] = search value
                         - element[2] = operator
                       where I{operator} can be any SQL binary
                       operator.

         @param kw:    (optional kw arg)

                       B{sort}: column(s) to be sorted on -- this
                       can be either a string (a single column
                       name) or a list or tuple of column names
         &quot;&quot;&quot;
         if args:
             sqlargs = sql.buildSelect(table, subtypes, *args, **kw)
             return self.runQuery(*sqlargs)
         else:
             raise TypeError, 'I need at least one search parameter'

     def getByRowKey(self, rowkey):
         &quot;&quot;&quot;
         Get the resultset for this rowkey.

         @type rowkey:  list
         @param rowkey: a rowkey (for more about rowkeys, see
                        L{pangalactic.repo.factory.record2RowKey})

         @rtype:   a PgResultSet
         @return:  the result set that matches this rowkey.
         &quot;&quot;&quot;
         sqlargs = sql.buildSelectFromRowKey(rowkey)
         return self.runQuery(*sqlargs)

     def addRow(self, table, *args, **kw):
         &quot;&quot;&quot;
         Add a row to the specified table.

         @type table:  string
         @param table: name of the table to search

         @type args:   list
         @param args:  a list of 2-tuples:
                       [(colname, value), ...]

         @type kw:     dictionary
         @param kw:    {colname : value, ...}
         &quot;&quot;&quot;
         parmdict = kw or dict(args)
         sqlcmd, parms = sql.buildInsert(table, parmdict)
         d = self.runOperation(sqlcmd, *parms)
         logmsg = 'addRow:  1 row added to %s table.' % table
         d.addCallback(lambda x: self._addRowDone(x, logmsg))
         d.addErrback(self.operationError)
         return d

     def _addRowDone(self, d, logmsg):
         &quot;&quot;&quot;Callback for addRow success.
         &quot;&quot;&quot;
         log.msg(&quot;%s operation %s&quot; % (reflect.qual(self.__class__), logmsg))
         return d

     def addRows(self, records):
         &quot;&quot;&quot;
         Add a series of rows, in a single transaction, from a
         list of records (for a description of &quot;records&quot;, see
         L{pangalactic.repo.factory.extract2Record}).

         @type records:  list
         @param records: a list of records -- see
                         L{pangalactic.utils.factory} for the
                         definition of an extract
         &quot;&quot;&quot;
         tables = utils.unique([rec[0] for rec in records])
         sqlstmt, parms = sql.buildTransactionalInsert(records)
         d = self.runOperation(sqlstmt, *parms)
         logmsg = 'addRows: rows added to tables %s.' % str(tables)
         d.addCallback(lambda x: self._addRowsConfirm(x, logmsg))
         d.addErrback(self.interactionError)
         return d

     def _addRowsConfirm(self, d, logmsg):
         &quot;&quot;&quot;
         Callback for addRows success.
         &quot;&quot;&quot;
         log.msg(&quot;%s %s&quot; % (reflect.qual(self.__class__), logmsg))
         return d

     def operationDone(self, done):
         &quot;&quot;&quot;
         Callback for database operation success.
         &quot;&quot;&quot;
         log.msg(&quot;%s Operation done: %s&quot; % (reflect.qual(self.__class__), done))

     def operationError(self, error):
         &quot;&quot;&quot;
         Callback for database operation failure.
         &quot;&quot;&quot;
         log.msg(&quot;%s Operation failed: %s&quot; % (reflect.qual(self.__class__), error))
         log.err(error)

     def interactionDone(self, done):
         &quot;&quot;&quot;
         Callback for database interaction success.
         &quot;&quot;&quot;
         log.msg(&quot;%s Interaction done: %s&quot; % (reflect.qual(self.__class__), done))

     def interactionError(self, error):
         &quot;&quot;&quot;
         Callback for database interaction failure.
         &quot;&quot;&quot;
         log.msg(&quot;%s Interaction failed: %s&quot; % (reflect.qual(self.__class__), error))
         log.err(error)

----------------------------------------------------------------




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006404.html">[Twisted-Python] adbapi.Augmention
</A></li>
	<LI>Next message: <A HREF="006406.html">[Twisted-Python] adbapi.Augmention
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6405">[ date ]</a>
              <a href="thread.html#6405">[ thread ]</a>
              <a href="subject.html#6405">[ subject ]</a>
              <a href="author.html#6405">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
