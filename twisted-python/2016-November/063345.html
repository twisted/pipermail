<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Twisted%2016.6.0rc1%20Release%20Candidate%0A%09Announcement&In-Reply-To=%3CD4F374FF-8869-47D6-8206-A09FE28126E4%40twistedmatrix.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="063344.html">
   <LINK REL="Next"  HREF="063347.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Twisted%2016.6.0rc1%20Release%20Candidate%0A%09Announcement&In-Reply-To=%3CD4F374FF-8869-47D6-8206-A09FE28126E4%40twistedmatrix.com%3E"
       TITLE="[Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement">glyph at twistedmatrix.com
       </A><BR>
    <I>Fri Nov 18 18:36:16 MST 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="063344.html">[Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement
</A></li>
        <LI>Next message (by thread): <A HREF="063347.html">[Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#63345">[ date ]</a>
              <a href="thread.html#63345">[ thread ]</a>
              <a href="subject.html#63345">[ subject ]</a>
              <a href="author.html#63345">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
&gt;<i> On Nov 18, 2016, at 12:13 AM, Mark Williams &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">markrwilliams at gmail.com</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i> On Thu, Nov 17, 2016 at 11:00:13AM -0800, Glyph Lefkowitz wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> This doesn't appear to be an answer to the &quot;is it a regression&quot; question though ;-).  I'm still curious what you think there.
</I>&gt;<i> 
</I>&gt;<i> It's not a shipped feature so it can't be a regression.  But if the
</I>&gt;<i> feature doesn't work it shouldn't be shipped.
</I>
&quot;doesn't work&quot; is a pretty black-and-white assessment.  Are you anticipating a problem with the way the interface is specified that it can't be easily changed?

I should say up front here that I think I was being too emphatic in my support for UTF-8.  We absolutely must support the ability to decode other encodings.  I don't think that means we need support for access to raw bytes.

&gt;<i> I did consult the policy manual before opening revert PR.  Here's what
</I>&gt;<i> seemed most relevant:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="https://twistedmatrix.com/trac/wiki/ReviewProcess#Revertingachange">https://twistedmatrix.com/trac/wiki/ReviewProcess#Revertingachange</A>
</I>&gt;<i> 
</I>&gt;<i> This, and the other revert documents, focus on test regressions.  But
</I>&gt;<i> I opened the PR because of the above link's mention of &quot;undesirable.&quot;
</I>&gt;<i> Is there a better resource that explains when a revert is appropriate?
</I>
Test regressions are listed because they're unambiguously cause for a revert; &quot;undesirable&quot; is intentionally vague because we might decide to revert a thing for no reason.  I guess opening a PR for a discussion like this is reasonable.

This could be considered an incompatible interface change; I'm honestly not sure about the exact type signatures of various methods to say whether it is or not.

&gt;&gt;<i> The _general_ issue is unfixable, except to use chardet upon encoding errors.  As far as I'm aware, IRC simply doesn't have the ability to specify an encoding.
</I>&gt;<i> 
</I>&gt;<i> IRCv3 (<A HREF="http://ircv3.net/">http://ircv3.net/</A>) is attempting to mandate utf-8 for certain
</I>&gt;<i> protocol elements (usernames and metadata).  But it needs to be
</I>&gt;<i> backwards compatible, so it can't mandate it for all messages.  And it
</I>&gt;<i> is not IRC as specified by RFC1459.  So no, no defined encoding.
</I>
Not only &quot;no defined encoding&quot; but also no mechanism like HTTP headers to say what the encoding is.

&gt;&gt;<i> More importantly, IRC doesn't specify an encoding and it is also responsible for transmitting textual data intended to be input and consumed by humans.  If you can't decode it, faithfully replicating the on-the-wire encoding is of limited utility.  You can't write any code to process the data.
</I>&gt;<i> 
</I>&gt;<i> I can write code that uses the encoding that makes sense for my use
</I>&gt;<i> case.  I can't if we mandate utf-8, even when I receive perfectly
</I>&gt;<i> valid IRC messages.
</I>
Sorry, I haven't been separating out my lines of reasoning clearly enough here.

My points are, separately:

IRC is text. It's nonsensical to process it as bytes, because you can't process it as bytes.  This is separate from the question of &quot;what encoding is IRC&quot;.
UTF-8 is good. There should be gradual social pressure to use UTF-8 everywhere (I'm a fan of <A HREF="http://utf8everywhere.org">http://utf8everywhere.org</A> &lt;<A HREF="http://utf8everywhere.org/">http://utf8everywhere.org/</A>&gt;).  This is especially true in protocols like IRC and filenames where there's no mechanism to specify an encoding so that it can be correctly decoded.  Therefore:
an initial release which features UTF-8 only is fine; therefore there's no need to do a revert.
defaulting to UTF-8 is reasonable for the forseeable future; users should only change this if they know that they want something unusual.
IRC is an incompatible and broken wasteland; thanks to your quantitative research we know exactly how broken.  Therefore:
&quot;support alternate encodings&quot; is a valuable feature.  Supporting point 2.1, this feature can be added on at any later point, making a revert of the present implementation unnecessary.
We can, and should, just go ahead and add support for alternate (per-server, per-channel, per-user) default and fallback encodings.
We should always have a fallback encoding, since blowing up on &quot;invalid&quot; data on a protocol where there's no standard to say what is or isn't valid doesn't seem very helpful.

&gt;&gt;<i> If chardet is installed, can it be specified as an encoding itself?  Like, b&quot;garbage garbage&quot;.decode(&quot;chardet&quot;)?  This would make it possible to use without binding to the library; you just specify an encoding.  (The library is LGPL2.1 which makes it a problematic dependency for Twisted, even optionally.)
</I>&gt;<i> 
</I>&gt;<i> It does not, but if that makes it more generally usable you've given a
</I>&gt;<i> great idea for my next PyPI package :)
</I>
Let me know :).

&gt;&gt;<i> POSIX has an internally inconsistent model of how encodings work; they cannot possibly function correctly.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> First off, let me put to rest the lie that paths are &quot;really&quot; bytes.  Paths are text.  They must be text because they have to transit through text-processing systems, such pas windowing systems and and terminal programs.  Users must be able to visually identify and select them, as text.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> This is significant because certain operations on paths-as-bytes will inevitably fail.  You can't type an invalidly-encoded pathname in your shell.  If two paths differ by an incorrectly-encoded character you won't be able to visually distinguish between them without inspecting their contents.  This is why OS X forces all paths to be UTF-8, and why paths are &quot;really&quot; unicode (UCS-2, precisely) on Windows.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> There's POSIX metadata which allows you to select an encoding; locale.  But, locale is per-process state, and, due to the fact that you can have multiple filesystems mounted simultaneously, it's impossible for this metadata to fully describe the state of any arbitrary path.  The standard metadata is insufficient.  This is why UI toolkits like GTK+ have adopted the policy of &quot;ignore the locale, paths are UTF-8, deal with it ðŸ•¶&quot;.  As far back as GTK2, non-utf-8 path selection has been deprecated: &lt;<A HREF="https://developer.gnome.org/gtk2/stable/GtkFileSelection.html#gtk-file-selection-set-filename">https://developer.gnome.org/gtk2/stable/GtkFileSelection.html#gtk-file-selection-set-filename</A> &lt;<A HREF="https://developer.gnome.org/gtk2/stable/GtkFileSelection.html#gtk-file-selection-set-filename">https://developer.gnome.org/gtk2/stable/GtkFileSelection.html#gtk-file-selection-set-filename</A>&gt;&gt;.
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> When I received Arabic PDFs on a FAT16 USB drive with filenames in
</I>&gt;<i> CP1256, I had to switch mlterm to that particular code page to read
</I>&gt;<i> the directory listings so I could use convmv to convert them to UTF-8.
</I>
There is no question that your life has been hard, and that a wide array of people have made bad decisions that contribute to your difficulties. :-)

&gt;<i> I'll note that this was impossible to do with a GTK-based tool.
</I>
&gt;<i> 
</I>&gt;<i> Opinionated software is fine when it operates at the point of user
</I>&gt;<i> interpretation.
</I>&gt;<i> 
</I>&gt;<i> mlterm had to decode the stuff as unicode so X could display the
</I>&gt;<i> graphemes.  But if Linux's FAT16 implementation decided that we should
</I>&gt;<i> all quit whining and use UTF-8, even though no other FAT16
</I>&gt;<i> implementation requires this, it wouldn't have mattered what mlterm
</I>&gt;<i> could or couldn't do and I would have lost those files.  And it would
</I>&gt;<i> have been incredibly confounding to me, because everything would have
</I>&gt;<i> agreed that I had a FAT16 partition, but only Linux would have
</I>&gt;<i> mysteriously failed to read it.
</I>
But, Linux's FAT16 driver has decided that.

The correct way to solve your problem with current Linux (I don't know if this was possible at the time) would be to address it with mount, not special user-space software.  Specifically, I think it would be something like:

mount -t fat -o fat=16,iocharset=utf-8,codepage=1256 /dev/disk/by-label/arabic.msdos /media/arabic.msdos

Now all your GTK+ software works, too, because you're not trying to reconcile your legacy format support at the application level.

In other words, the thing those pathnames are encoding is text; the way they're being encoded is codepage 1256 on the platter.  However, the interface between the OS and the application can still be &quot;text&quot; (i.e. UTF-8) without breaking the on-disk &quot;bytes&quot; (cp1256).

&gt;<i> Similarly, Twisted provides an IRC *library*.  It's a Python API, not
</I>&gt;<i> irssi or Textual.  The ultimate consumer of what passes through it may
</I>&gt;<i> be a human, but the next consumer might not be.  What if I want to
</I>&gt;<i> write write a bot that bridges two IRC networks?  What if I want to
</I>&gt;<i> dump the raw IRC data to a file so I can train a tensorflow version of
</I>&gt;<i> chardet?  There's nothing in the IRC specification that prevents me
</I>&gt;<i> from doing this, but there will be something in Twisted's
</I>&gt;<i> implementation that does.
</I>
In the current release, yes.  But in a future release: no, you can't just bridge arbitrary bytes between two networks and expect them to work.  Those networks (or channels, or users) might have different implicit encoding rules; which, by default and only by default, should be utf-8.  In a multi-encoding world, you may need to transcode between them to properly bridge; this is a consequence of the fact that eventually you're presenting this data as text to human eyeballs.

&gt;&gt;<i> While a mis-encoded path is a failure, there are ways to treat paths as a data structure to allow for only partial failure.  They're a data structure because they must be in an encoding with no NULLs, which encode SOLIDUS as the octet 0x2F, and so you can fail on each individual path component; if you're lucky you don't need to present all the components in the path to manipulate it.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> We don't do this in Twisted right now (as I was somewhat disappointed to discover while writing this), but we should, and more importantly we could; FilePath(b&quot;\xff&quot;).child(&quot;valid&quot;).asTextMode().basename() could return u&quot;valid&quot; rather than returning an encoding error.
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> <A HREF="https://twistedmatrix.com/trac/ticket/8908">https://twistedmatrix.com/trac/ticket/8908</A> &lt;<A HREF="https://twistedmatrix.com/trac/ticket/8908">https://twistedmatrix.com/trac/ticket/8908</A>&gt;
</I>
Thanks for filing that!

&gt;&gt;<i> To bring all this back to IRC though:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Mis-encoded IRC messages are not data structures; they're just strings.  There's no opportunity for partial recovery beyond chardet and mojibake.  In most cases, partial recovery requires configuration.  Per-channel encodings, for example, or per-user, which have to be agreed upon out of band, in ways that IRC does not expose as metadata.
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It would also have to be per server, since any two channels might
</I>&gt;<i> disagree on the encoding of their topics.  And the welcome message
</I>&gt;<i> might be in its own encoding. And, and, and...
</I>
Right.  Per-server default, and then per-channel and per-(privmsg)-user is about as precise as you can get though.  In principle, it's possible that different segments of the same topic could be in different encodings, different words in the same sentence!  In practice though that just means somebody screwed up and the topic is now unreadable garbage in all clients.

&gt;<i> But none of this is actually true.  What seems to be true is that
</I>&gt;<i> non-utf-8 encodings are rarely if ever seen on Freenode, and sometimes
</I>&gt;<i> to regularly seen on many other IRC servers.  These encodings are
</I>&gt;<i> certainly used.
</I>
I can't really parse you here - are you saying that each network more or less sticks to one encoding?

&gt;&gt;<i> Given this situation, the only reasonable way forward as a community is to tell users that using anything other than UTF-8 is a misconfiguration and we need to be getting all those out-of-band agreements to switch to it.
</I>&gt;<i> 
</I>&gt;<i> Doing this ensures Twisted's IRC implementation will be unable to
</I>&gt;<i> communicate with a significant minority of users, and will be a less
</I>&gt;<i> useful programming tool.
</I>
Sorry, my statement you were responding to here was way too strong.  What I meant to say here is that long term there is no way to get a &quot;right&quot; answer in this ecosystem, so &quot;UTF-8 is the only correct answer&quot; is the only direction we can push in to actually make things work reasonably by default an increasing proportion of the time.  For the forseeable future, adding the ability to cope with other encodings (encoding a fallback to latin-1 so that you can at least do demojibakefication manually after copy/pasting) is something a general-purpose IRC library absolutely needs.  This is why every client has an &quot;encoding&quot; selection menu, too.

&gt;<i> It makes more sense to have an implementation that parses protocol
</I>&gt;<i> elements as bytes and provides a bytes API.  It's fine to also provide
</I>&gt;<i> a decoded text API, but not to the exclusion of bytes.
</I>
This is the point where I think we diverge.  I don't think adding a bytes API actually adds any value.  Trying to process the contents of IRC as bytes as any way leads to inevitable failures (&quot;line&quot; truncation midway through a UTF-8 escape sequence for example).

So, the thing IRC is transmitting is text.  The way it's transmitting it is poorly specified and will need manual configurability hooks to specify encoding information, probably forever, and perhaps even to guess it (although &quot;encoding=chardet&quot; would be nice).  I agree that just saying &quot;UTF-8 or GTFO&quot; is not a sustainable approach at all.  &quot;UTF-8 or have a bad time with this fiddly customization API and config file&quot; is fine, because anyone wanting something else is probably already having a bad time.

If you are engaging in a real abuse of the IRC protocol and you're treating it as an 8-bit clean stream to send some escaped binary data through (like a video stream, something like that), well, that's what the 'charmap' alias of 'latin-1' is for :-).

So... have I sold you?

-glyph

-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20161118/e4a639cb/attachment-0002.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="063344.html">[Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement
</A></li>
	<LI>Next message (by thread): <A HREF="063347.html">[Twisted-Python] Twisted 16.6.0rc1 Release Candidate	Announcement
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#63345">[ date ]</a>
              <a href="thread.html#63345">[ thread ]</a>
              <a href="subject.html#63345">[ subject ]</a>
              <a href="author.html#63345">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
