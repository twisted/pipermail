<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re-Occuring Operations
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re-Occuring%20Operations&In-Reply-To=20030317064217.GA9305%40doublegemini.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003289.html">
   <LINK REL="Next"  HREF="003291.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re-Occuring Operations</H1>
    <B>Andrew Bennetts</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re-Occuring%20Operations&In-Reply-To=20030317064217.GA9305%40doublegemini.com"
       TITLE="[Twisted-Python] Re-Occuring Operations">andrew-twisted at puzzling.org
       </A><BR>
    <I>Mon Mar 17 07:46:45 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="003289.html">[Twisted-Python] Re-Occuring Operations
</A></li>
        <LI>Next message: <A HREF="003291.html">[Twisted-Python] Re-Occuring Operations
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3290">[ date ]</a>
              <a href="thread.html#3290">[ thread ]</a>
              <a href="subject.html#3290">[ subject ]</a>
              <a href="author.html#3290">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, Mar 17, 2003 at 06:42:17AM +0000, Clark C. Evans wrote:
&gt;<i> Hello.   I was wondering if there is anything which handles 
</I>&gt;<i> re-occuring functions; that is, an auto-rescheduler or
</I>&gt;<i> something of that nature.   Here is what I came up with,
</I>&gt;<i> I'm sure there is a shorter 'lambda' form, but I was
</I>&gt;<i> going for clarity here.
</I>
There is.  This is copied straight from doc/howto/time.html:

&quot;&quot;&quot;
    If we want a task to run every X seconds repeatedly, we can
    just re-add it every time it's run:

        from twisted.internet import reactor
        
        def runEverySecond():
            print &quot;a second has passed&quot;
            reactor.callLater(1, runEverySecond)
        
        reactor.callLater(1, runEverySecond)
&quot;&quot;&quot;


&gt;<i>   class MultiRun:
</I>&gt;<i>       &quot;&quot;&quot; apply a callable while it returns true &quot;&quot;&quot;
</I>&gt;<i>       def __init__(self, callable, waitInterval = 0):
</I>&gt;<i>           self.callable = callable
</I>&gt;<i>           self.waitInterval = waitInterval
</I>&gt;<i>           self.iterate(starting = 1)
</I>&gt;<i>       def iterate(self, starting = 0):
</I>&gt;<i>           if starting or self.callable():
</I>&gt;<i>               from twisted.internet import reactor
</I>&gt;<i>               reactor.callLater(self.waitInterval, self.iterate)
</I>
Or:

    from __future__ import nested_scopes  # For you retro Python 2.1 hippies
    
    def multiRun(interval, func):
        from twisted.internet import reactor
        def iterate():
            if func():
                reactor.callLater(interval, iterate)
        iterate()

Except to fit in with the Twisted naming scheme, you'd have to call it
'mindlessReruns' ;)

On the other hand, being a fairly straightforward six-line function, it
probably doesn't need to be in Twisted.

&gt;<i> Something like this would be useful, it's already emerged in
</I>&gt;<i> two different contexts in my code:
</I>&gt;<i> 
</I>&gt;<i>    (a) a background operation (which never returns true)
</I>&gt;<i>        that runs every 5 minutes, 
</I>
That's amply catered for by the first example, possibly with a try/finally
thrown in.

&gt;<i>    (b) an operation which keeps pooling a resource, if 
</I>&gt;<i>        the resource is busy it returns true, otherwise 
</I>&gt;<i>        it processes the resource and returns false to
</I>&gt;<i>        signal that it is done
</I>
I don't quite understand your terminology.  I think you mean there's a queue
of operations that can only be processed if there's some sort of resource
available to process them, and you wish to occasionally poll the resource
pool to see if there's one free.  If so, it's probably better to arrange
your code to avoid polling, i.e. make the resource pool check the queue
automatically when a resource is freed.  This reduces latency and is usually
simpler.

Regardless, I'm not sure this deserves or requires special support in
Twisted.  Merely documenting the necessary idioms is probably better.  After
all there are lots of possible small variations (e.g. dynamically varying
the interval based on the function's return value) that would be tedious to
build into a generic class or function, but are dead simple to build into
your own six-line implementation. 

Or perhaps I'm wrong, and there's a nice class with lots of use-cases just
waiting to be implemented :)

-Andrew.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003289.html">[Twisted-Python] Re-Occuring Operations
</A></li>
	<LI>Next message: <A HREF="003291.html">[Twisted-Python] Re-Occuring Operations
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3290">[ date ]</a>
              <a href="thread.html#3290">[ thread ]</a>
              <a href="subject.html#3290">[ subject ]</a>
              <a href="author.html#3290">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
