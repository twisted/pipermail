<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] more thoughts on resumable async data flows
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20more%20thoughts%20on%20resumable%20async%20data%20flows&In-Reply-To=%3C20030314065003.GA99373%40doublegemini.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="035780.html">
   <LINK REL="Next"  HREF="035829.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] more thoughts on resumable async data flows</H1>
    <B>Clark C. Evans</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20more%20thoughts%20on%20resumable%20async%20data%20flows&In-Reply-To=%3C20030314065003.GA99373%40doublegemini.com%3E"
       TITLE="[Twisted-Python] more thoughts on resumable async data flows">cce at clarkevans.com
       </A><BR>
    <I>Thu Mar 13 23:50:03 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="035780.html">[Twisted-Python] greetings!
</A></li>
        <LI>Next message (by thread): <A HREF="035829.html">[Twisted-Python] more thoughts on resumable async data flows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35783">[ date ]</a>
              <a href="thread.html#35783">[ thread ]</a>
              <a href="subject.html#35783">[ subject ]</a>
              <a href="author.html#35783">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Howdy.   I've made quite a few changes to flow.py and it's 
quickly approaching maturity.   To summarize, flow.py is a
way to express sequential, streaming data flows that are 
interruptable as a collection of small, atomic operations.
This is needed since sometimes an operation must block,
flow.py takes care of resuming your flow at a later time.

It's trivial, but here is an example...

    def printResult(data): print data
    def addOne(data): return  data+1
    def finished(): print &quot;finished&quot;
    def dataSource(data):  return [1, 1+data, 1+data*2]

    a = Flow()
    a.addBranch(dataSource, finished)
    a.addCallable(addOne)
    a.addCallable(printResult)
    a.execute(2)
    a.execute(8)

The above code constructs a flow, starting with a
'branch' operation that generates a series of events,
in this case, the lists [1,3,5] and then in a 
second execution, [1,9,17].  For each one of these 
events, a function addOne is called on them, and 
then the output of that function is directed to be printed. 

This mechanism works with generators...

    def simpleGenerator(data):
        for x in range(data):
            yield x

    b = Flow()
    b.addBranch(simpleGenerator)
    b.addCallable(printResult)
    b.execute(5)

While this may not be all that useful, what Flow brings
to the table is the ability to PauseFlow within a 
processing stage, for example

    class simpleIterator:
        def __init__(self, data):
            self.data = data
        def __iter__(self):
            return self
        def next(self):
            print &quot;.&quot;
            if self.data &lt; 0: raise StopIteration
            ret = self.data
            self.data -= 1
            #
            # imagine a blocking operation here... sometime
            if ret % 2:
                raise PauseFlow   # &lt;= Goes to main event loop
            return ret

    c = Flow()
    c.addBranch(simpleIterator)
    c.addCallable(printResult)
    c.execute(5)

The above code produces 4, 2, 0 ; while this may not
be all that interesting, if there were N stages above
this code, they would all be resumed properly.  By 
tossing PauseFlow, the entire Flow event loop is 
stopped, and a reactor.callLater(0, loop-again) is
called; giving other events in the queue to work.

Thus, the flow construct provides a way to not only manage
a bunch of useful code snippets into a process; but more
importantly gives a way that the entire flow can be 
interruped and then resumed later when data arrives.

Anyway, it's in the sandbox if anyone wants to play...

Clark

P.S.  Unfortunately, it looks like PauseFlow doesn't
work in the context of a generator... pity.  Hopefully
I'm doing something wrong.




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="035780.html">[Twisted-Python] greetings!
</A></li>
	<LI>Next message (by thread): <A HREF="035829.html">[Twisted-Python] more thoughts on resumable async data flows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35783">[ date ]</a>
              <a href="thread.html#35783">[ thread ]</a>
              <a href="subject.html#35783">[ subject ]</a>
              <a href="author.html#35783">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
