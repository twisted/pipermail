<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] patch implementing deferIterationToThread
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20patch%20implementing%20deferIterationToThread&In-Reply-To=%3C20030304054648.GA51485%40doublegemini.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="035656.html">
   <LINK REL="Next"  HREF="035638.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] patch implementing deferIterationToThread</H1>
    <B>Clark C. Evans</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20patch%20implementing%20deferIterationToThread&In-Reply-To=%3C20030304054648.GA51485%40doublegemini.com%3E"
       TITLE="[Twisted-Python] patch implementing deferIterationToThread">cce at clarkevans.com
       </A><BR>
    <I>Mon Mar  3 22:46:48 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="035656.html">[Twisted-Python] fetchmany and deferreds which call back more than once
</A></li>
        <LI>Next message (by thread): <A HREF="035638.html">[Twisted-Python] coding standard: column width?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35637">[ date ]</a>
              <a href="thread.html#35637">[ thread ]</a>
              <a href="subject.html#35637">[ subject ]</a>
              <a href="author.html#35637">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please find a patch to internet/defer.py and iternet/threads.py
which enables an &quot;iterator&quot; to be deferred to a thread.  This is
useful since often you have a long running process (a database
query for example) which you'd like to return results every
once and a while rather than delivering all of the output 
at the end of the process.  This patch adds to the given
files (it doesn't change any code).

The remainder of the message is hereby public domain.

#
# code to append to defer.py
#
class MultiCallDeferred(Deferred):
    &quot;&quot;&quot;This is a verision of Deferred which can be invoked more
       than once.  This is accomplished by cloning the current
       deferred object and carrying out the callbacks on the clone.
    &quot;&quot;&quot;
    def _startRunCallbacks(self, result, isError):
        clone = Deferred()
        clone.default = self.default
        for x in self.callbacks:
            clone.callbacks.append(x)
        clone._startRunCallbacks(result, isError)

#
# code to be added to threads.py
#
def _putIterationInDeferred(deferred, f, args, kwargs):
    &quot;&quot;&quot;Send the results of an iteration to a deferred.
       The function called should return an object
       with a next() operator.  This is the ideal mechanism
       to defer a generator.
    &quot;&quot;&quot;
    from twisted.internet import reactor
    try:
        itr = apply(f, args, kwargs)
        while 1:
            reactor.callFromThread(deferred.callback, itr.next())
    except StopIteration: pass
    except:
        f = failure.Failure()
        reactor.callFromThread(deferred.errback, f)
def deferIterationToThread(f, *args, **kwargs):
    &quot;&quot;&quot;Run the results of an iterator in a thread.&quot;&quot;&quot;
    d = defer.MultiCallDeferred()
    reactor.callInThread(_putIterationInDeferred, d, f, args, kwargs)
    return d

#
# usage using iterators (or generators for simpler syntax)
# 
from twisted.internet.threads import deferIterationToThread
from twisted.internet import reactor
class producer:
    def __init__(self):
        self.val = 9
    def next(self):
        val = self.val
        if val &lt; 1: raise StopIteration
        self.val -= 1
        return val
def bldr(): return producer()
def printResult(x): print x
d = deferIterationToThread(bldr)
d.addCallback(printResult)
try: # if you have generators
    from __future__ import generators
    def gene(start=99):
        while(start &gt; 90):
            yield start
            start -= 1
    d = deferIterationToThread(gene)
    d.addCallback(printResult)
except: pass
reactor.run()



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="035656.html">[Twisted-Python] fetchmany and deferreds which call back more than once
</A></li>
	<LI>Next message (by thread): <A HREF="035638.html">[Twisted-Python] coding standard: column width?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35637">[ date ]</a>
              <a href="thread.html#35637">[ thread ]</a>
              <a href="subject.html#35637">[ subject ]</a>
              <a href="author.html#35637">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
