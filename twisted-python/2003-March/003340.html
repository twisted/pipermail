<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Problems with PB and Jelly...
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Problems%20with%20PB%20and%20Jelly...&In-Reply-To=20030322.233426.61636994.warner%40lothar.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003339.html">
   <LINK REL="Next"  HREF="003345.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Problems with PB and Jelly...</H1>
    <B>Jasper Phillips</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Problems%20with%20PB%20and%20Jelly...&In-Reply-To=20030322.233426.61636994.warner%40lothar.com"
       TITLE="[Twisted-Python] Problems with PB and Jelly...">jasper at peak.org
       </A><BR>
    <I>Sun Mar 23 06:59:15 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="003339.html">[Twisted-Python] Problems with PB and Jelly...
</A></li>
        <LI>Next message: <A HREF="003345.html">[Twisted-Python] Problems with PB and Jelly...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3340">[ date ]</a>
              <a href="thread.html#3340">[ thread ]</a>
              <a href="subject.html#3340">[ subject ]</a>
              <a href="author.html#3340">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Sat, 22 Mar 2003, Brian Warner wrote:

&gt;<i> &gt; I have a Perspective &lt;-&gt; Referenceable server/client setup, and am trying
</I>&gt;<i> &gt; to pass objects between them.  Following the online docs I've set all the
</I>&gt;<i> &gt; relavent classes to inherit from pb.Copyable + pb.RemoteCopy, and passed
</I>&gt;<i> &gt; them all to pb.setUnjellyableForClass.
</I>&gt;<i> 
</I>&gt;<i> I'll take responsibility for that one (I wrote those docs :). If the classes
</I>&gt;<i> behave the same way on both ends, then it can make sense to inherit from both
</I>&gt;<i> Copyable and RemoteCopy. If objects are supposed to behave differently
</I>&gt;<i> depending upon whether they are the &quot;home&quot; or the &quot;away&quot; form, then you'll
</I>&gt;<i> want two classes, where the &quot;home&quot; form is pb.Copyable and the receiving
</I>&gt;<i> &quot;away&quot; form is pb.RemoteCopy.
</I>
The way you wrote it in the docs made sense to me!  As my objects are treated
the same on either side, I chose to use multiple inheritence to avoid
tripling the number of classes I needed.

&gt;<i> Often this depends upon whether the object really has a home: if it is just
</I>&gt;<i> a container for some chunk of state, and doesn't hold any references to
</I>&gt;<i> other objects, then it doesn't really have a home and you can use the
</I>&gt;<i> dual-inheritance trick to cut down on some typing.
</I>[snip]

Hmmmm.  You're implying that the state can't hold references to other
objects?  That might explain an exception I'm getting, which I'll describe
below.  If this is true, is there some easy way around this, or do I need
a custom setCopyableState()?

&gt;<i> &gt; I'm also unsure what to make of the last bullet under &quot;Things To Watch Out
</I>&gt;<i> &gt; For&quot; on the above webpage.  It seems unsure whether using __init__ to
</I>&gt;<i> &gt; initialize transferable objects is ok...  Must I truly go and hack all
</I>&gt;<i> &gt; my objects to not use __init__, and instead use setCopyableState()?
</I>&gt;<i> 
</I>&gt;<i> To be precise, the received objects are created with a hack that creates an
</I>&gt;<i> object of a dummy class, then transforms it into the correct class, then runs
</I>&gt;<i> setCopyableState to populate the attributes. By doing this, it avoids running
</I>&gt;<i> the new class' __init__ method altogether. When the object is created by you
</I>&gt;<i> (by using the class name as a callable), it will run __init__. When it is
</I>&gt;<i> created in response to a received serialized instance, it will not run
</I>&gt;<i> __init__ but will run setCopyableState instead. This lets you set up objects
</I>&gt;<i> differently in the two different situations.
</I>
I've since gone and investigated more close what's going on.  I've used this
hack before, and it was exactly what I was hoping to see.

However, I'm sometimes getting an exception when the actual dictionary
copying is done, as something other than a dict is being copied into
__dict__.  At this point the &quot;jelType&quot; is &quot;dereference&quot;...

Suddenly, I wonder if this is because I'm using a circular reference?
I have a &quot;map&quot; which contains &quot;cells&quot;, which contain &quot;links&quot; having
a reference to &quot;map&quot;...


Damn, it looks like this might be the cuplrit.  &quot;reference&quot; jelyTypes are
recursively descended into before they are stored, and if a dereference is
found before it's stored... some sort of _Dereference object is created?
An attempt is then made to copy this into __dict__, and boom.

I can think of two ways to avoid this problem: 2 passes, or creating
instances and storing a ref to them before recursing to determine their their
state.  Perhaps this _Dereference is intended to be replaced with a real
reference in some sort of 2nd pass?

I'll have to look into this more closely latter.  At first glance it appears
to be something best fixed in twisted itself rather than a local
setCopyableState()... at least to this twisted newbie. ;-)

&gt;<i> &gt; The &quot;module not allowed&quot; exception is misleading, and stems from what
</I>&gt;<i> &gt; appears to be an obsolete branch &quot;else&quot; branch of
</I>&gt;<i> &gt; jelly._Unjellier.unjelly(), judging by the fact that it uses the temp
</I>&gt;<i> &gt; variable jelType for something different than the &quot;if&quot; branch.
</I>&gt;<i> 
</I>&gt;<i> I think you might be right. We have a review of PB scheduled for the PyCon
</I>&gt;<i> sprint next tuesday.. I've added that code to the list of stuff to be
</I>&gt;<i> examined. We'll try to clear out all the dead code on that day.
</I>
I've since looked at this code more closely as well.  The &quot;else&quot; branch in
question is most definitely _not_ dead code, but it is confusing.  ;-)

jelly._Unjellier.unjelly() is used in two manners, which you can see fairly
easily by printing out the local variable &quot;jelType&quot;.  Sometimes this is a
&quot;type&quot; name that gets munged into a _unjelly_&quot;type&quot; method call (ie the final
&quot;if&quot; branch), and other times &quot;jelType&quot; is a class's local import name, which
is parsed into recursive unjelly commands (the &quot;else&quot; branch).

Then again, that's what I think is going on.  Hard to say, since I'm still
getting exceptions out of it I don't quite grasp. ;-(

- -Jasper

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.0.6 (GNU/Linux)
Comment: For info see <A HREF="http://www.gnupg.org">http://www.gnupg.org</A>

iD8DBQE+faGY8EpjZ7/X9bIRAq3bAKDOyRV9oB98xDlTlUdx9rgEz1eItgCgx4Yu
7S3uLjnNpZ1JLDNEmMhWT9Y=
=+Ilk
-----END PGP SIGNATURE-----



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003339.html">[Twisted-Python] Problems with PB and Jelly...
</A></li>
	<LI>Next message: <A HREF="003345.html">[Twisted-Python] Problems with PB and Jelly...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3340">[ date ]</a>
              <a href="thread.html#3340">[ thread ]</a>
              <a href="subject.html#3340">[ subject ]</a>
              <a href="author.html#3340">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
