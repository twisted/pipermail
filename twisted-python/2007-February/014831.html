<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Question about Foolscap Slicers and Unslicers.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Question%20about%20Foolscap%20Slicers%20and%20Unslicers.&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014827.html">
   <LINK REL="Next"  HREF="014835.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Question about Foolscap Slicers and Unslicers.</H1>
    <B>kgi</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Question%20about%20Foolscap%20Slicers%20and%20Unslicers.&In-Reply-To="
       TITLE="[Twisted-Python] Question about Foolscap Slicers and Unslicers.">iacovou at gmail.com
       </A><BR>
    <I>Fri Feb  9 13:05:29 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="014827.html">[Twisted-Python] Re: [Twisted-commits] r19594 - Initial observer
</A></li>
        <LI>Next message: <A HREF="014835.html">[Twisted-Python] wxReactor and twisted question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14831">[ date ]</a>
              <a href="thread.html#14831">[ thread ]</a>
              <a href="subject.html#14831">[ subject ]</a>
              <a href="author.html#14831">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Hi all (and Brian in particular);

I've got a few questions about Foolscap Slicers and Unslicers. The 
documentation I'm reading is at:

  <A HREF="http://twistedmatrix.com/~warner/Foolscap/using-pb.html">http://twistedmatrix.com/~warner/Foolscap/using-pb.html</A>

In it, a code fragment of custom slicing is given:

    class ListSlicer(BaseSlicer):
        opentype = (&quot;list&quot;,)
        slices = list

The docs then say in the next paragraph:

&quot;&quot;&quot;
Slicer registration can be either explicit or implicit. In this example, an 
implicit registration is used: by setting the slices attribute to the list 
type, the BaseSlicer's metaclass automatically registers the mapping from 
list to ListSlicer.

To explicitly register a slicer, just leave opentype set to None (to disable 
auto-registration), and then register the slicer manually.
&quot;&quot;&quot;

... and then quote an example of this:

    class TupleSlicer(BaseSlicer):
        opentype = (&quot;tuple&quot;,)
        slices = None
        ...
    registerAdapter(TupleSlicer, tuple, pb.ISlicer)

The problem is that the code sets *slices* to None, but the text talks about 
setting *opentype* to None. I'd be inclined to think the code is right, 
except the text says the same sort of thing happens later on when talking 
about Unslicers:

&quot;&quot;&quot;
If the Unslicer has a non-None class attribute named opentype, then it is 
automatically registered. If it does not have this attribute (or if it is set 
to None), then no registration is performed, and the Unslicer must be 
manually registered:
&quot;&quot;&quot;

Which is it?

Actually, my real question is: what are the exact uses of &quot;opentype&quot; 
and &quot;slices&quot; respectively? I suspect that &quot;slices&quot; refers to the type being 
sliced, and &quot;opentype&quot; is something low-level to do with the slicing process 
(maybe the symbol inserted in the output stream?). Why is is (seemingly 
always) a 1-tuple?

Lastly (secondly?) there is some text in the document:

  <A HREF="http://twistedmatrix.com/~warner/Foolscap/specifications/pb.html">http://twistedmatrix.com/~warner/Foolscap/specifications/pb.html</A>

under the paragraph heading, &quot;Arbitrary Instances are NOT serialized&quot; that 
says:

&quot;&quot;&quot;
Both ends must be willing to transport the object. The sending side expresses 
this by marking the class (subclassing Copyable, or registering an ISlicer 
adapter).
&quot;&quot;&quot;

To me this appears to imply that each of the various ways of transporting a 
non-fundamental type is as good as any other: if I have a subclassed Copyable 
then I wouldn't need an ISlicer adapter, and vice versa.

Is this true? Does this mutual relationship hold true for ISlicer-registered 
types and types making use of foolscap.registerRemoteCopyFactory()? I'm 
asking because I have some types for which I have called 
registerRemoteCopyFactory() yet for which I get an exception saying that the 
object is not sliceable (implying that I need to take the ISlicer approach 
and that the registerRemoteCopyFactory() approach is no longer good enough).

I'm using Python 2.4, Twisted 2.5.0 and head-of-SVN Foolscap.

Cheers,

Ricky


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014827.html">[Twisted-Python] Re: [Twisted-commits] r19594 - Initial observer
</A></li>
	<LI>Next message: <A HREF="014835.html">[Twisted-Python] wxReactor and twisted question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14831">[ date ]</a>
              <a href="thread.html#14831">[ thread ]</a>
              <a href="subject.html#14831">[ subject ]</a>
              <a href="author.html#14831">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
