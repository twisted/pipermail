<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20What%20is%20the%20minimum%20effort%20solution%20to%0A%09make%09inetd-managed%20twisted-based%20application%3F&In-Reply-To=20100713165252.GG14318%40ruber.office.udmvt.ru">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022556.html">
   <LINK REL="Next"  HREF="022565.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?</H1>
    <B>exarkun at twistedmatrix.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20What%20is%20the%20minimum%20effort%20solution%20to%0A%09make%09inetd-managed%20twisted-based%20application%3F&In-Reply-To=20100713165252.GG14318%40ruber.office.udmvt.ru"
       TITLE="[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?">exarkun at twistedmatrix.com
       </A><BR>
    <I>Tue Jul 13 22:31:46 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="022556.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
        <LI>Next message: <A HREF="022565.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22559">[ date ]</a>
              <a href="thread.html#22559">[ thread ]</a>
              <a href="subject.html#22559">[ subject ]</a>
              <a href="author.html#22559">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 13 Jul, 04:52 pm, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">twisted-web at udmvt.ru</A> wrote:
&gt;<i>On Tue, Jul 13, 2010 at 02:37:08PM -0000, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">exarkun at twistedmatrix.com</A> 
</I>&gt;<i>wrote:
</I>&gt;&gt;<i>On 12:57 pm, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">twisted-web at udmvt.ru</A> wrote:
</I>&gt;&gt;<i> &gt;What is the minimal effort method for building protocol instance 
</I>&gt;&gt;<i>(maybe
</I>&gt;&gt;<i> &gt;out of
</I>&gt;&gt;<i> &gt;already implemented protocol factory) using a transport, that uses
</I>&gt;&gt;<i> &gt;parent-inherited sockets (or any other already connected sockets) ?
</I>&gt;&gt;<i> &gt;I haven't yet found any single-line solution for that.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>This isn't supported, but we'd like to support it.
</I>&gt;<i>
</I>&gt;<i>Oops, the Bad news.
</I>&gt;&gt;<i>  There's a ticket in
</I>&gt;&gt;<i>the issue tracker, &lt;<A HREF="http://twistedmatrix.com/trac/ticket/4387">http://twistedmatrix.com/trac/ticket/4387</A>&gt;, 
</I>&gt;&gt;<i>related
</I>&gt;&gt;<i>to this (but with a somewhat wider scope).
</I>&gt;<i>
</I>&gt;<i>Well, that feature will benefit from the feature I need. By the way, 
</I>&gt;<i>twisted
</I>&gt;<i>architecture and abstractions allow one (for a limited number of 
</I>&gt;<i>protocols)
</I>&gt;<i>to transfer the state along with the FD of the opened connection.
</I>&gt;<i>Say, one may want to read HTTP headers and then send
</I>&gt;<i>the connection FD to another process along with the read headers, so it 
</I>&gt;<i>will
</I>&gt;<i>receive and &quot;re-read&quot; them with dataReceived(). Modification of HTTP 
</I>&gt;<i>protocol
</I>&gt;<i>code will not be required here. But we need a modified transport 
</I>&gt;<i>constructor.
</I>&gt;&gt;<i> &gt;Right now I am looking at t.i.unix.Connector and t.i.unix.Port to
</I>&gt;&gt;<i> &gt;understand
</I>&gt;&gt;<i> &gt;how do transports get constructed by them, but well, that is too
</I>&gt;&gt;<i> &gt;complex for a single evening.
</I>&gt;&gt;<i> &gt;Should I really get into the details of implementing my own transport
</I>&gt;&gt;<i> &gt;(or their constructors)
</I>&gt;&gt;<i> &gt;to do what I need? I'm sure there should be something, that I missed 
</I>&gt;&gt;<i>in
</I>&gt;&gt;<i> &gt;the documentation
</I>&gt;&gt;<i> &gt;(or in the code?).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Despite not appearing to be private, things like t.i.unix.Connector 
</I>&gt;&gt;<i>and
</I>&gt;&gt;<i>t.i.unix.Port aren't really intended for use by applications.
</I>&gt;<i>
</I>&gt;<i>No, no, I'm only using them as a documentation about what transport 
</I>&gt;<i>looks like
</I>&gt;<i>from the inside of the twisted, to other parts of the framework.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>This is the right part of Twisted to be looking at if you want to
</I>&gt;&gt;<i>contribute a patch which adds this feature, though.  And I encourage 
</I>&gt;&gt;<i>you
</I>&gt;&gt;<i>to do that. :)
</I>&gt;<i>
</I>&gt;<i>Well, I was trying to get into it during last evening, but it turned 
</I>&gt;<i>out to be
</I>&gt;<i>more appropriate to spend a week or two on that process. It looks, like
</I>&gt;<i>transport abstraction is not documented as a whole, only the user 
</I>&gt;<i>visible
</I>&gt;<i>parts, or better say, protocol visible parts. I am still not sure 
</I>&gt;<i>whether
</I>&gt;<i>it is advisable to subclass a base.BaseConnector or we can simply
</I>&gt;<i>create a transport instance without that &quot;complications&quot;. It looks like
</I>&gt;<i>BaseConnector contain some portion of code, that should be reused.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The implementation should be fairly straight-forward.  Most things 
</I>&gt;&gt;<i>like
</I>&gt;&gt;<i>Port and Client and Server have a &quot;createInternetSocket&quot; method.  All
</I>&gt;&gt;<i>that's really necessary to use an externally created file descriptor 
</I>&gt;&gt;<i>is
</I>&gt;&gt;<i>get &quot;createInternetSocket&quot; to return that descriptor instead of 
</I>&gt;&gt;<i>creating
</I>&gt;&gt;<i>a new one (or skip the call to the method entirely and just use the
</I>&gt;&gt;<i>descriptor you have already).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The biggest question I have is what the API should look like.  Somehow
</I>&gt;&gt;<i>the file descriptor needs to get from your application code (which 
</I>&gt;&gt;<i>knows
</I>&gt;&gt;<i>that inetd put an open TCP connection on fd 0) to the
</I>&gt;&gt;<i>Port/Client/Server.
</I>&gt;<i>
</I>&gt;<i>That depends. Are we going to limit that feature to socket FDs only, or
</I>&gt;<i>should we provide more specific interfaces for different type of files?
</I>
Ultimately it would be nice to support it for each transport type 
Twisted supports.  That doesn't mean we have to do it all at once 
though. :)
&gt;<i>
</I>&gt;<i>Two (pipe) FDs may be used to construct full-duplex half-closeable 
</I>&gt;<i>transport too.
</I>&gt;<i>Or may someone be interested also in master pty based transport? That 
</I>&gt;<i>would indeed require some
</I>&gt;<i>terminal-specific support to be present in the transport instance, 
</I>&gt;<i>wouldn't it?
</I>&gt;<i>Like transport.sendBreak()
</I>&gt;<i>Perhaps one may use a full-duplex transport constructed from a tty 
</I>&gt;<i>/slave-pty FD?
</I>&gt;<i>It may be useful to provide analogous interface for half-duplex 
</I>&gt;<i>connections too, IMHO.
</I>
Actually, in twisted/internet/process.py (&quot;Do NOT use this module 
directly&quot;), you'll see ProcessReader and ProcessWriter which are 
transports for pipes/ptys.  The normal way to access these is via 
reactor.spawnProcess.  But you'll notice that they even accept a fileno 
as an __init__ argument, unlike most other transports in Twisted.

Mirroring this on the opposite side is twisted/internet/_posixstdio.py, 
which is a standard io transport, and also accepts filenos to its 
__init__.
&gt;<i>I think it may look like
</I>&gt;<i>  connection = somenewmodulename.socketConnection(fd, protocolFactory, 
</I>&gt;<i>addrFamily, sockType, reactor=None)
</I>&gt;<i>or
</I>&gt;<i>  import socket
</I>&gt;<i>  connection = somenewmodulename.socketConnection(socket.fromfd(fd, 
</I>&gt;<i>addrFamily, sockType), protocolFactory, reactor=None)
</I>&gt;<i>
</I>&gt;<i>Create a transport object and associate/build a new protocol instance 
</I>&gt;<i>with/on it.
</I>&gt;<i>For other FD types there should be different functions, returning 
</I>&gt;<i>instances
</I>&gt;<i>of other types.
</I>&gt;<i>
</I>&gt;<i>Would you comment on that?
</I>
Something to keep in mind here is that it may be desirable to support 
Windows at some point.  This is one reason why it may make sense to have 
these APIs as methods on the reactor: the reactor can already easily be 
replaced by alternate implementations to cater to different platforms.
&gt;&gt;<i>
</I>&gt;&gt;<i>The obvious options, adding another argument to
</I>&gt;&gt;<i>listen/connectTCP/UNIX/etc, would work, but is somewhat ugly (you have
</I>&gt;&gt;<i>the issue that existing mandatory arguments would just be ignored).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Another idea would be adding new methods entirely.  I don't know if
</I>&gt;&gt;<i>that's much better, though.
</I>&gt;<i>
</I>&gt;<i>Adding new methods to reactor? I thought it can live completely 
</I>&gt;<i>separate
</I>&gt;<i>from the reactor code and do not pollute reactor interface. Reactor is 
</I>&gt;<i>only
</I>&gt;<i>used in the process of attaching a FD to a transport when new transport
</I>&gt;<i>registers it's FDs in the reactor, so it can be an (optional?) argument
</I>&gt;<i>to a constructor. However, yes, API consistency may suffer from that.
</I>
If it's possible to do this, it's probably a good idea.  Just keep in 
mind that Windows doesn't use FDs for lots of things.  StandardIO shows 
that the API inconsistency is annoying but not fatal.  Plus, we're 
working on an API which can be a layer on top of this to make it all 
consistent again (twisted.internet.endpoints).
&gt;&gt;<i>
</I>&gt;&gt;<i>So, if we can come up with a nice API, I think this will be a pretty
</I>&gt;&gt;<i>quick feature to implement.
</I>&gt;<i>
</I>&gt;<i>I think it could be a set of functions inside a platform-dependent 
</I>&gt;<i>module
</I>&gt;<i>if that functions will be FD-type dependent.
</I>&gt;&gt;<i> &gt;And by the way, I haven't found any socketpair(2) usage in the 
</I>&gt;&gt;<i>twisted
</I>&gt;&gt;<i> &gt;framework (except for tests),
</I>&gt;&gt;<i> &gt;how can that be? Transport based on socketpair sockets will have the
</I>&gt;&gt;<i> &gt;same
</I>&gt;&gt;<i> &gt;implementation, as I need. Is it true, that nobody in twisted 
</I>&gt;&gt;<i>community
</I>&gt;&gt;<i> &gt;uses
</I>&gt;&gt;<i> &gt;anonymous preconnected sockets in real life?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Apparently. :)
</I>&gt;<i>
</I>&gt;<i>Oops, surprise!..
</I>&gt;<i>BTW creating a socketpair and forking and then communicating via PB 
</I>&gt;<i>seems
</I>&gt;<i>like an elegant and convenient feature to me. Perhaps non-portable?
</I>
Windows doesn't have fork, so yea, you'll run into problems there. :) 
There are also problems with the way fork interacts with kqueue and 
epoll.  The usual approach is reactor.spawnProcess to create an entirely 
new Python process, and then either connect to it over TCP or just use 
stdin/stdout to talk to it.
&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;PS: I need socket-based transport, that is, full-duplex, half-
</I>&gt;&gt;<i> &gt;closeable, with support
</I>&gt;&gt;<i> &gt;of getting the remote endpoint address and with ability to start TLS 
</I>&gt;&gt;<i>on
</I>&gt;&gt;<i> &gt;top of it
</I>&gt;&gt;<i> &gt;and without implementing every that feature myself :)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Hopefully if we can figure out how to create a Twisted transport 
</I>&gt;&gt;<i>object
</I>&gt;&gt;<i>from an existing file descriptor, you should have no trouble with the
</I>&gt;&gt;<i>rest of these.
</I>&gt;<i>
</I>&gt;<i>That's what I need, and I really hoped, that it is already implemented. 
</I>&gt;<i>What a surprise.
</I>&gt;<i>Surely, I would not mind contibuting to such a great project, but first 
</I>&gt;<i>I
</I>&gt;<i>would have to get more understanding of it's abstractions.
</I>
I'll answer whatever questions I can. :)

Jean-Paul

</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022556.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
	<LI>Next message: <A HREF="022565.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22559">[ date ]</a>
              <a href="thread.html#22559">[ thread ]</a>
              <a href="subject.html#22559">[ subject ]</a>
              <a href="author.html#22559">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
