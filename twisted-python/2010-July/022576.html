<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20What%20is%20the%20minimum%20effort%20solution%20to%0A%09make%09inetd-managed%20twisted-based%20application%3F&In-Reply-To=20100714160000.GM14318%40ruber.office.udmvt.ru">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022565.html">
   <LINK REL="Next"  HREF="022612.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?</H1>
    <B>exarkun at twistedmatrix.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20What%20is%20the%20minimum%20effort%20solution%20to%0A%09make%09inetd-managed%20twisted-based%20application%3F&In-Reply-To=20100714160000.GM14318%40ruber.office.udmvt.ru"
       TITLE="[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?">exarkun at twistedmatrix.com
       </A><BR>
    <I>Thu Jul 15 12:15:43 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="022565.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
        <LI>Next message: <A HREF="022612.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22576">[ date ]</a>
              <a href="thread.html#22576">[ thread ]</a>
              <a href="subject.html#22576">[ subject ]</a>
              <a href="author.html#22576">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 14 Jul, 04:00 pm, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">twisted-web at udmvt.ru</A> wrote:
&gt;<i>On Wed, Jul 14, 2010 at 02:31:46AM -0000, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">exarkun at twistedmatrix.com</A> 
</I>&gt;<i>wrote:
</I>&gt;&gt;<i>I'll answer whatever questions I can. :)
</I>&gt;<i>
</I>&gt;<i>Oh, I have some questions...
</I>&gt;<i>I asked some questions in the form of suggestions, well, don't take 
</I>&gt;<i>them seriously,
</I>&gt;<i>I only ask, not really propose anything. However I'm ready to hear you
</I>&gt;<i>about what I'm wrong with.
</I>&gt;<i>
</I>&gt;<i>Here, what I have discovered so far:
</I>&gt;<i>There are transport factories in twisted, not defined as such, but 
</I>&gt;<i>really they are,
</I>&gt;<i>like tcp.Port and tcp.Connector.
</I>&gt;<i>
</I>&gt;<i>They interface with protocol factories. That interface is asymmetric 
</I>&gt;<i>between
</I>&gt;<i>server protocol factory and client protocol factory. Well, the 
</I>&gt;<i>implementation
</I>&gt;<i>of client's side protocol factory and server's side should differ, but 
</I>&gt;<i>why should interfaces?
</I>
startedConnecting, clientConnectionFailed, and clientConnectionLost only 
exist to facilitate client reconnection.  See the end of the email for 
more about that.
&gt;<i>That is okay, while you only have different and asymmetric transport 
</I>&gt;<i>factories
</I>&gt;<i>the ones for client transports and the others for server transports.
</I>&gt;<i>But is there really something in created and connected transport,
</I>&gt;<i>that makes it server's or client's ? I guess nothing, except protocol 
</I>&gt;<i>instance attached.
</I>
That's probably true.  And there could probably be a little less 
duplication of code between the Client and Server transports (although 
there's not a *lot* now).
&gt;<i>
</I>&gt;<i>Q: Why should protocol factory interface &quot;bother&quot; about client/server 
</I>&gt;<i>dichotomy?
</I>&gt;<i>For example, why should I be limited to only using PBClientFactory with 
</I>&gt;<i>connectXXX()
</I>&gt;<i>variants of transport factories?
</I>&gt;<i>Why should I do not want (under some crazy circumstances) to use 
</I>&gt;<i>reverse-connects
</I>&gt;<i>and run PBServerFactory with connectXXX()?
</I>&gt;<i>Well, maybe not PB, but what about other protocols?
</I>&gt;<i>Should it work? Well, I suppose, it would break if you try now, but is
</I>&gt;<i>is supposed to be that asymmetric?
</I>
You can certainly implement protocols that don't care about which side 
of the underlying transport is the client and which side is the server. 
It probably wouldn't be much work to get PB to be such an 
implementation.  But apparently no one really cares about this, 
otherwise it might have come up before. ;)
&gt;<i>And after all, there is absolute symmetry in UDP-based transports.
</I>
Okay.  But SOCK_DGRAM is completely different from SOCK_STREAM, so I 
don't know if this comparison really means anything.
&gt;<i>Q: Consider socketpair() variant - a pair of completely symmetric 
</I>&gt;<i>mutually
</I>&gt;<i>connected sockets.
</I>&gt;<i>Should I provide transport factory for use with server protocol 
</I>&gt;<i>factories
</I>&gt;<i>and another transport factory for use with client protocol factories?
</I>&gt;<i>
</I>&gt;<i>That idea sounds stupid to me, there can be no difference in the 
</I>&gt;<i>implementation,
</I>&gt;<i>except in the interfaces to protocol factories.
</I>
I'd probably start off with a low-level interface that's completely 
symmetric and doesn't involve factories.  After all, it's not like 
socketpairs can spontaneously spring into existing (like client 
connections on a server can).  On top of that, if you want, construct an 
API using factories to support multiple connections.
&gt;<i>
</I>&gt;<i>I see there are some code, that can be moved from tcp.Port and 
</I>&gt;<i>tcp.Connector
</I>&gt;<i>to some common base class of an abstract transport factory. That class 
</I>&gt;<i>could
</I>&gt;<i>interfere with protocol factory without knowing whether it is server or 
</I>&gt;<i>client.
</I>&gt;<i>Protocol factory already knows about it's own asymmetry.
</I>&gt;<i>
</I>&gt;<i>I do identify the events, that protocol factory receives from transport 
</I>&gt;<i>factory as these,
</I>&gt;<i>please correct me if I'm wrong:
</I>&gt;<i>
</I>&gt;<i>global (factory-context) events:
</I>&gt;<i>- start factory                         doStart
</I>&gt;<i>- entering transport creation phase     startedConnecting 
</I>&gt;<i>&lt;server: when bind&amp;listen succeeds why does anybody
</I>&gt;<i>                                                                 not 
</I>&gt;<i>invoke something like startedListenig ?&gt;
</I>&gt;<i>- stop factory                          doStop
</I>
Make sure you don't get confused when you use &quot;start factory&quot; and &quot;stop 
factory&quot; as labels for doStart and doStop.  The base implementation of 
doStart calls startFactory and the base implementation of doStop calls 
stopFactory.

There's no startedListening because no one imagined there might be a 
kind of port that could only be created asynchronously.  listenTCP, 
listenSSL, listenUNIX, listenUDP, listenMulticast can all complete 
immediately, so they all return an IPort provider.  So if you wanted the 
startedListening callback, you can just call it yourself immediately 
after you call the listenXXX method.

This may be an oversight for the general case.  Vertex, for example, 
certainly wants to expose an asynchronous listen API.  Other similar 
use-cases might be a listen API that uses UPnP to request a hole in a 
firewall.

Still, listening is a one-off event.  So if you can at least return a 
Deferred from your listen API, then when the Deferred fires, you have 
your &quot;started listening&quot; notification.
&gt;<i>
</I>&gt;<i>per transport connection events:
</I>&gt;<i>- on transport creation                 &lt;none exists?why?&gt;      &lt;after 
</I>&gt;<i>connect() or listen() returns result, at this point
</I>&gt;<i>                                                                 we may 
</I>&gt;<i>decide to prevent further transport instantiation,
</I>&gt;<i>especially if we are server-side protocol factory&gt;
</I>
The factory can choose to do this in buildProtocol.
&gt;<i>- transport creation failed             clientConnectionFailed 
</I>&gt;<i>&lt;server: direct analogy - accept() may return an error,
</I>&gt;<i>                                                                 but 
</I>&gt;<i>that event not exists for server. why?&gt;
</I>
I don't think accept() failing is really analogous to 
clientConnectionFailed.  Nevertheless, exposing accept() failures to 
application code is definitely a good idea.  There's currently a ticket 
open for adding that feature.
&gt;<i>- transport created succesfully         buildProtocol           &lt;a 
</I>&gt;<i>request to build a protocol instance implies, that
</I>&gt;<i>transport instance have been succesfully created. or not?&gt;
</I>&gt;<i>- build protocol                        buildProtocol
</I>
In general, no such implication exists.  It just means someone wants a 
new protocol instance to do something with.  Usually that's because 
there's a new transport to connect it to, but maybe it's just a unit 
test calling the method.
&gt;<i>- after transport and protocol creation clientConnectionMade    &lt;in 
</I>&gt;<i>t.s.pb.PBXXXXFactory, event sent by protocol instance,
</I>&gt;<i>                                                                 name 
</I>&gt;<i>not defined in any Interface, why not?&gt;
</I>

PB wanted to put some logic on the factory when a new connection was 
first established.  I'm not sure why it does this instead of putting the 
logic in Protocol.connectionMade.
&gt;<i>- transport closed                      clientConnectionLost    &lt;why 
</I>&gt;<i>not define this for server too to be consistent?&gt;
</I>
Consistency is alright, but sometimes it's not a sufficient 
justification.  Over the years, I think the *existence* of 
ClientFactory.clientConnectionLost has caused more confusion and 
questions than the *lack* of ServerFactory.clientConnectionLost.  In 
both cases, the information is available from Protocol.connectionLost.
&gt;<i>They are not client/servers asymmetric as I see them, but have 
</I>&gt;<i>asymmetric names in twisted
</I>&gt;<i>and sometimes when server variants exists, they have no fixed names 
</I>&gt;<i>defined in Interface classes :(
</I>&gt;<i>
</I>&gt;<i>What is the difference between doStart and startedConnecting (together 
</I>&gt;<i>with imaginary startedListening)?
</I>
doStart is called when a factory is hooked up to a network event source. 
That means there'll probably be just one call to doStart.  For a 
reconnecting client factory, startedConnecting may be called many times.

But really, doStart/startFactory/doStop/stopFactory are pretty obscure 
and rarely used.  I wouldn't be surprised if we could come up with a 
better way to present this information pretty easily.
&gt;<i>And who is responsible for sending which events? That is not defined in 
</I>&gt;<i>documentation.
</I>
The reactor implementation.  There's no &quot;how to implement a reactor&quot; 
document because people don't do that very often.
&gt;<i>What do you think about these names:
</I>&gt;<i>doStart()
</I>&gt;<i>transportFactoryStarted()
</I>&gt;<i>onBeforeTransportCreate()
</I>&gt;<i>connectionFailed()
</I>&gt;<i>buildProtocol()
</I>&gt;<i>connectionMade()
</I>&gt;<i>connectionLost()
</I>&gt;<i>doStop()
</I>&gt;<i>Well, I understand, you will veto them arguing by lot of code using old 
</I>&gt;<i>names,
</I>&gt;<i>but I am interested to know will they break the abstraction of protocol 
</I>&gt;<i>factory?
</I>
What are they methods on?  What are the precise semantics of each?
&gt;<i>Can please anyone explain the asymmetry of the interfaces of protocol 
</I>&gt;<i>factories
</I>&gt;<i>and tell how can it be useful for me.
</I>
There's a lot of noise amongst the long-time Twisted developers about 
how client factories are no good and we should just dump them, leaving 
only server factories.  That doesn't exactly make things symmetric, but 
it gets rid of the asymmetric factory interfaces. :)
&gt;<i>Thanks for your time.
</I>&gt;<i>
</I>&gt;<i>Alexey.
</I>&gt;<i>
</I>&gt;<i>--
</I>&gt;<i>D1 D3C2C0C6C5CDC8C5CC,
</I>&gt;<i>A0CBC5CAD1C5C9 B8CFC0C3C8CD
</I>&gt;<i>D1C8D1D2C5CCCDDBC9 C0C4CCC8CDC8D1D2D0C0D2CED0
</I>&gt;<i>D6C5D5C0 CFC5D0C5C4C0D7C8 C4C0CDCDDBD5
</I>&gt;<i>D2C5D5CDC8D7C5D1CACEC3CE D6C5CDD2D0C0 D2C5CBC5CACECCCCD3CDC8CAC0D6C8C9
</I>&gt;<i>AEA0AE &quot;A2CECBC3C0B2C5CBC5CACECC&quot;
</I>&gt;<i>D4C8CBC8C0CB C2 B3C4CCD3D0D2D1CACEC9 D0C5D1CFD3C1CBC8CAC5.
</I>&gt;<i>
</I>&gt;<i>_______________________________________________
</I>&gt;<i>Twisted-Python mailing list
</I>&gt;<i><A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i><A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022565.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
	<LI>Next message: <A HREF="022612.html">[Twisted-Python] What is the minimum effort solution to	make	inetd-managed twisted-based application?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22576">[ date ]</a>
              <a href="thread.html#22576">[ thread ]</a>
              <a href="subject.html#22576">[ subject ]</a>
              <a href="author.html#22576">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
