<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re-entrancy policy for the reactor
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re-entrancy%20policy%20for%20the%20reactor&In-Reply-To=AFF5D96D-5C94-4F68-8CAB-B8B3AA9BF374%40twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024343.html">
   <LINK REL="Next"  HREF="024345.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re-entrancy policy for the reactor</H1>
    <B>exarkun at twistedmatrix.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re-entrancy%20policy%20for%20the%20reactor&In-Reply-To=AFF5D96D-5C94-4F68-8CAB-B8B3AA9BF374%40twistedmatrix.com"
       TITLE="[Twisted-Python] Re-entrancy policy for the reactor">exarkun at twistedmatrix.com
       </A><BR>
    <I>Wed Jul 27 17:41:58 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="024343.html">[Twisted-Python] Re-entrancy policy for the reactor
</A></li>
        <LI>Next message: <A HREF="024345.html">[Twisted-Python] Re-entrancy policy for the reactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24344">[ date ]</a>
              <a href="thread.html#24344">[ thread ]</a>
              <a href="subject.html#24344">[ subject ]</a>
              <a href="author.html#24344">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09:10 pm, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at twistedmatrix.com</A> wrote:
&gt;<i>
</I>&gt;<i>On Jul 24, 2011, at 10:51 PM, Itamar Turner-Trauring wrote:
</I>&gt;&gt;<i>I'm going to merge #5063 next time I have a few minutes when I'm more
</I>&gt;&gt;<i>awake, which will mean my yak stack[1] is empty and I can go back to
</I>&gt;&gt;<i>working on abortConnection(). As explained in
</I>&gt;&gt;<i><A HREF="http://twistedmatrix.com/trac/ticket/78,">http://twistedmatrix.com/trac/ticket/78,</A>  abortConnection() is like
</I>&gt;&gt;<i>loseConnection(), except it doesn't wait until buffers are written 
</I>&gt;&gt;<i>out,
</I>&gt;&gt;<i>it closes the connection immediately. The question is, how 
</I>&gt;&gt;<i>immediately?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>My current implementation, a bit like one of the half-close code 
</I>&gt;&gt;<i>paths,
</I>&gt;&gt;<i>ends up calling connectionLost directly. That means you can have a 
</I>&gt;&gt;<i>call
</I>&gt;&gt;<i>stack that looks like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>MyProtocol.dataReceived
</I>&gt;&gt;<i>TCPConnection.abortConnection
</I>&gt;&gt;<i>...
</I>&gt;&gt;<i>MyProtocol.connectionLost
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>This can lead to re-entrancy bugs. I am tempted to suggest a policy of
</I>&gt;&gt;<i>No Reactor Reentrancy, but that is currently violated by one of the 
</I>&gt;&gt;<i>TCP
</I>&gt;&gt;<i>half-close code paths, and producers if I'm not mistaken.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Some options:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>(a) Leave abortConnection() reentrant.
</I>&gt;&gt;<i>(b) Make abortConnection() non-reentrant, don't change any current 
</I>&gt;&gt;<i>APIs.
</I>&gt;&gt;<i>(c) Make all reactor APIs non-reentrant.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>(Since there's a ticket for documenting the reentrancy policy, you 
</I>&gt;&gt;<i>will
</I>&gt;&gt;<i>notice I've added another yak to my stack. I'll finish #78 someday!)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Thoughts?
</I>&gt;<i>
</I>&gt;<i>My main thought here is that protocol reentrancy is bad, and nobody 
</I>&gt;<i>really expects it even if they think it should be fine.
</I>&gt;<i>
</I>&gt;<i>However, I do believe it would be best (easier to test, in particular) 
</I>&gt;<i>to immediately call connectionLost within doRead (or doWrite) after 
</I>&gt;<i>dataReceived exits, rather than callLater(0)-ing it or otherwise 
</I>&gt;<i>placing it into a global call queue.
</I>
Probably not easier to test, nor easier to get right.  A single 
generalized solution to avoid re-entrancy is probably the only way to 
avoid a perpetual sequence of accidental re-entrant calls in obscure 
untested cases in each different reactor implementation.

Perhaps the solution doesn't need to be `reactor.callLater(0, ...)`, but 
I think various implementations will be better if they put tasks into 
some kind of queue, perhaps checked at the end of the iteration instead 
of in the next iteration, rather than special casing each possible re- 
entrant event in each possible event dispatcher.

Jean-Paul

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024343.html">[Twisted-Python] Re-entrancy policy for the reactor
</A></li>
	<LI>Next message: <A HREF="024345.html">[Twisted-Python] Re-entrancy policy for the reactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24344">[ date ]</a>
              <a href="thread.html#24344">[ thread ]</a>
              <a href="subject.html#24344">[ subject ]</a>
              <a href="author.html#24344">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
