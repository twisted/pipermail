From trac at twistedmatrix.com  Sun Dec  3 00:05:23 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 03 Dec 2017 07:05:23 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1512284723.81.8978984448037618722@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171203/9a8334bf/attachment.html>

From trac at twistedmatrix.com  Sun Dec 10 00:05:20 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 10 Dec 2017 07:05:20 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1512889520.75.2302632024752270828@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171210/47b337bf/attachment.html>

From glyph at twistedmatrix.com  Sun Dec 10 09:17:25 2017
From: glyph at twistedmatrix.com (Glyph)
Date: Sun, 10 Dec 2017 08:17:25 -0800
Subject: [Twisted-Python] ampoul3
Message-ID: <B7026B9C-4C01-41B9-A01A-C1FCC748DA9E@twistedmatrix.com>

I often refer to Ampoule as a way to get simple process pooling with Twisted.  However, it's been somewhat moribund (no maintenance, no py3 support) for the better part of a decade, despite more or less doing what it needs to do.

As such, I've created a friendly fork (hopefully only until Valentino checks his email and officially retires as the maintainer :)), at https://github.com/glyph/ampoule <https://github.com/glyph/ampoule>, and released it as https://pypi.python.org/pypi/ampoul3.

If you've wanted to use Ampoule, or something like it, with Python 3, check it out.

-glyph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171210/8bfb3d9b/attachment.html>

From glyph at twistedmatrix.com  Sun Dec 10 23:02:23 2017
From: glyph at twistedmatrix.com (Glyph)
Date: Sun, 10 Dec 2017 22:02:23 -0800
Subject: [Twisted-Python] ampoul3
In-Reply-To: <B7026B9C-4C01-41B9-A01A-C1FCC748DA9E@twistedmatrix.com>
References: <B7026B9C-4C01-41B9-A01A-C1FCC748DA9E@twistedmatrix.com>
Message-ID: <5EE56CDE-4A08-4E34-98DF-3C86A6D4FE37@twistedmatrix.com>

On Dec 10, 2017, at 8:17 AM, Glyph <glyph at twistedmatrix.com> wrote:
> 
> I often refer to Ampoule as a way to get simple process pooling with Twisted.  However, it's been somewhat moribund (no maintenance, no py3 support) for the better part of a decade, despite more or less doing what it needs to do.
> 
> As such, I've created a friendly fork (hopefully only until Valentino checks his email and officially retires as the maintainer :)), at https://github.com/glyph/ampoule <https://github.com/glyph/ampoule>, and released it as https://pypi.python.org/pypi/ampoul3 <https://pypi.python.org/pypi/ampoul3>.

Valentino was more responsive than I expected!  https://pypi.python.org/pypi/ampoule now features a universal wheel supporting both py2 & py3.

I'd like some help maintaining this, since I certainly don't have a ton of bandwidth to take on new projects.  Anyone else interested in making parallel execution with Twisted easy?

On that note I also plan to move it into the Twisted org at some point.

-g

> 
> If you've wanted to use Ampoule, or something like it, with Python 3, check it out.
> 
> -glyph
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python

-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171210/cb435512/attachment.html>

From trac at twistedmatrix.com  Sun Dec 17 00:05:21 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 17 Dec 2017 07:05:21 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1513494321.36.8771361763853580539@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171217/0b1b6cbe/attachment.html>

From rodrigc at crodrigues.org  Sun Dec 17 18:18:24 2017
From: rodrigc at crodrigues.org (Craig Rodrigues)
Date: Sun, 17 Dec 2017 17:18:24 -0800
Subject: [Twisted-Python] Drop support for Python 3.3
Message-ID: <CAG=rPVc2eFB2PLrscNnbf0Mg=wOs=PooK5ouWWuJqiKi9Vf6FA@mail.gmail.com>

I submitted this patch to drop support for Python 3.3:

https://github.com/twisted/twisted/pull/943


1.  Python 3.3 was declared EOL on Sep. 29, 2017
2.  In terms of major Linux distributions, Python 3.4 came with Python 3.4
is in Debian 8, Ubuntu 14.04, Fedora 21

So after this patch, Twisted would run on:

Python 2.7 and Python 3.4+

Thoughts?
--
Craig
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171217/f99f838b/attachment.html>

From trac at twistedmatrix.com  Sun Dec 24 00:05:21 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 24 Dec 2017 07:05:21 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1514099121.84.1376524570532654573@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171224/08d7bc42/attachment.html>

From glyph at twistedmatrix.com  Tue Dec 26 19:27:44 2017
From: glyph at twistedmatrix.com (Glyph)
Date: Tue, 26 Dec 2017 18:27:44 -0800
Subject: [Twisted-Python] github process automation shortcut
Message-ID: <8EFD1305-B173-4696-A187-F0BA9F1AE387@twistedmatrix.com>

With more and more ecosystem projects on Github, more or less maintained by the same team that maintains Twisted proper, our "review keyword in trac" workflow is increasingly awkward.

Github itself has an individualized "review queue" of sorts - https://github.com/pulls/review-requested <https://github.com/pulls/review-requested> - where you can see open pull requests where your review has been requested.  What makes this particularly interesting is that you can request review from a team, rather than from an individual.

Of course, like everything interesting (ahem, labels), you need repo:write permission to do this, so we'd still need a bot.

But!

It appears that the CODEOWNERS file - https://help.github.com/articles/about-codeowners/ <https://help.github.com/articles/about-codeowners/> - can automatically request code reviews when pull requests touch relevant code - so we could add "* @twisted/$PROJECT-reviewers" to each project on that file and, I believe, have a fairly orderly review queue that can be seen in a nice unified view by each org member, and by using -reviewers teams, we could allow for folks to join or leave any individual repo review responsibility that they want.

Actually setting up all the stuff needed to test this requires more time than I have on my hands at the moment.  Does anyone else know for sure if this works as I imagine it would - specifically, that third party contributors would get an automatic review request opened, at least initially?

We might still need a bot to re-request reviews, but this seems like a much less ad-hoc way of doing this process migration than labels.

-g
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171226/e255ee52/attachment.html>

From adi at roiban.ro  Wed Dec 27 11:02:52 2017
From: adi at roiban.ro (Adi Roiban)
Date: Wed, 27 Dec 2017 18:02:52 +0000
Subject: [Twisted-Python] Drop support for Python 3.3
In-Reply-To: <CAG=rPVc2eFB2PLrscNnbf0Mg=wOs=PooK5ouWWuJqiKi9Vf6FA@mail.gmail.com>
References: <CAG=rPVc2eFB2PLrscNnbf0Mg=wOs=PooK5ouWWuJqiKi9Vf6FA@mail.gmail.com>
Message-ID: <CAFycZ9fekC4VV-0OSab=n=ihgdqVkZCMAj-tz7u-CL0-tmQ3uw@mail.gmail.com>

On 18 December 2017 at 01:18, Craig Rodrigues <rodrigc at crodrigues.org> wrote:
> I submitted this patch to drop support for Python 3.3:
>
> https://github.com/twisted/twisted/pull/943
>
>
> 1.  Python 3.3 was declared EOL on Sep. 29, 2017
> 2.  In terms of major Linux distributions, Python 3.4 came with Python 3.4
> is in Debian 8, Ubuntu 14.04, Fedora 21
>
> So after this patch, Twisted would run on:
>
> Python 2.7 and Python 3.4+

+1  for removing python 3.3

But as commented in the PR, I would like to see this removed after the
next release, so that we don't have to change the release notes for
17.9.0
That is 18.X.X should be the last release to support 3.4

-- 
Adi Roiban


From adi at roiban.ro  Wed Dec 27 11:03:55 2017
From: adi at roiban.ro (Adi Roiban)
Date: Wed, 27 Dec 2017 18:03:55 +0000
Subject: [Twisted-Python] github process automation shortcut
In-Reply-To: <8EFD1305-B173-4696-A187-F0BA9F1AE387@twistedmatrix.com>
References: <8EFD1305-B173-4696-A187-F0BA9F1AE387@twistedmatrix.com>
Message-ID: <CAFycZ9cq6WqQ787NANtCVT_JR8YiLckg2hDe80+5PfTwz1F1+w@mail.gmail.com>

On 27 December 2017 at 02:27, Glyph <glyph at twistedmatrix.com> wrote:
> With more and more ecosystem projects on Github, more or less maintained by
> the same team that maintains Twisted proper, our "review keyword in trac"
> workflow is increasingly awkward.
>
> Github itself has an individualized "review queue" of sorts -
> https://github.com/pulls/review-requested - where you can see open pull
> requests where your review has been requested.  What makes this particularly
> interesting is that you can request review from a team, rather than from an
> individual.
>
> Of course, like everything interesting (ahem, labels), you need repo:write
> permission to do this, so we'd still need a bot.
>
> But!
>
> It appears that the CODEOWNERS file -
> https://help.github.com/articles/about-codeowners/ - can automatically
> request code reviews when pull requests touch relevant code - so we could
> add "* @twisted/$PROJECT-reviewers" to each project on that file and, I
> believe, have a fairly orderly review queue that can be seen in a nice
> unified view by each org member, and by using -reviewers teams, we could
> allow for folks to join or leave any individual repo review responsibility
> that they want.
>
> Actually setting up all the stuff needed to test this requires more time
> than I have on my hands at the moment.  Does anyone else know for sure if
> this works as I imagine it would - specifically, that third party
> contributors would get an automatic review request opened, at least
> initially?
>
> We might still need a bot to re-request reviews, but this seems like a much
> less ad-hoc way of doing this process migration than labels.

I think that we can give it a try as is easy to implement.

----------

I tried CODEOWNERS and for my project (which is multi platforms) and
it does not work for me.

The main reason is that GitHub is "simple" and a soon as you create
the review it will think that you want someone to review it.

Most of the time, the review should be requested after all the tests
are green... and you create the PR to trigger the tests.
With many platforms and with lots of tests, it is probable that a dev
will not run all the test before the push.
The tests might fail, and then you might need another day of work
before requesting the review.

...or you create the PR at end of the day, and you want to do a self
review in the morning.

--------

And then you need the bot anyway for 're-review' ... so why not use
the same bot for explicitly requesting when the review is ready.

-------

You might have a team member just leaving a comment, without any
intention to provide a reject/approve review in the future.
With this action, the team is removed from "Reviewers", hence removed
from the review queue.. and the PR might be lost.
This can be solved by asking team members to just leave simple
comments, and not review comments, but review comments are a nice way
to organize multi-chuck comments.

--------

I am +1 for moving all the tickets from Trac to GitHub so that we will
get rid of the "review" keyword and the tentative ticket flow in Trac.

It will be painful, but I think that it will make it easier to
implement a dev process / workflow.

In an ideal world, we would have plenty of time to document the
workflow, and contributors would have plenty of time to read the dev
documentation,
but I think that we should recognize that everyone is short on time,
so in order to make it easier for everybody to contribute

I don't like that we depend that much on GitHub, but I don't see how
there will be time to keep custom infrastructure.
There is little time to do review, and at this stage I think that is
more important for people to do reviews and work on patches rather
than working on infrastructure.


-- 
Adi Roiban


From exarkun at twistedmatrix.com  Wed Dec 27 17:27:56 2017
From: exarkun at twistedmatrix.com (Jean-Paul Calderone)
Date: Wed, 27 Dec 2017 19:27:56 -0500
Subject: [Twisted-Python] [ANN] txaws 0.5.0
Message-ID: <CAEeXt4PL1F+hJqQq-93035WpUN76n9fQuc7i6oYGph81mqCwig@mail.gmail.com>

Hello all,

I'm pleased to announce the release of txAWS 0.5.0.  txAWS is a library for
interacting with Amazon Web Services (AWS) using Twisted.

You can download the release from PyPI <https://pypi.python.org/pypi/txAWS>.

Since the last release, the following enhancements have been made:

Features
> --------
> - txaws.s3.client.S3Client.get_bucket now accepts a ``prefix`` parameter
> for
>   selecting a subset of S3 objects. (#78)
> - txaws.ec2.client.EC2Client now has a ``get_console_output`` method
> binding
>   the ``GetConsoleOutput`` API. (#82)


Thanks to everyone who contributed and to Least Authority TFA GmbH
<https://leastauthority.com/> for sponsoring my work on this release.

Jean-Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171227/8f737bcf/attachment.html>

From sveinse at seldal.com  Wed Dec 27 21:18:32 2017
From: sveinse at seldal.com (Svein Seldal)
Date: Thu, 28 Dec 2017 05:18:32 +0100
Subject: [Twisted-Python] Unhandled exceptions and observability
Message-ID: <16e53039-da37-e7ab-234b-3cecacbc6a29@seldal.com>

Hi


I'm not sure how to write this email, but please let me try. I'd like to 
address something that I see as a limitation in Twisted. It might be 
that my use case is odd or that I'm outside the scope of Twisted, but 
non the less, I'd hope this could be a relevant topic.

Problem:

Unhandled exceptions can leave the application in a half-working state, 
and the in-app observability for them is difficult to obtain. Instead of 
terminating the whole application, the rest of the app can still keep 
running, and can be completely unaware of the failure.

This applies to unhandled errbacks in Deferred and principally to any 
other reactor callbacks. E.g. it can occur in Deferreds being used 
internally in Twisted, where direct access to the object isn't available 
to the caller.

As a user of Twisted, I would like to have the option to catch or fail 
my application completely when these unhandled exceptions occur, as 
would be expected in a sequential program.


Background:

I have a larger application using many simultaneous TCP, UDP and UNIX 
connections. As with Twisted, the app is grouped in functions, where 
most of the heavy lifting are done in black-box-ish modules. There is of 
course, no guarantee for everything to work smoothly and if something 
fails, the entire application stops as a clear indication of the 
failure. However, there have been some occasions where this application 
is found to be half-dead, due to a failure occurring in a reactor-based 
callback that can only be seen by reading the logs. The main application 
is unfortunately unaware of its own failure.

AFAIK Twisted has no direct mechanism for handling errors that might 
occur when user code is called from the reactor. Or even worse, the 
caller does not know about the occurred failure unless the caller has 
direct access to the failing object. I believe this is more dangerous to 
reliability than the plain failing applications is, due to lower 
observability.

Lets say the following code is used in a running application:

    from twisted.internet.task import LoopingCall
    class Foo:
      def __init__(self):
        self.loop = LoopingCall(self.cb)
        self.loop.start(2, False)
      def cb(self):
        self.count += 1

    # Main app does this:
    try:
      foo = Foo()
    except:
      print "Won't happen"
      raise

The code will fail due to the programmical error in cb, but the calling 
application won't fail and thinks everything is fine. The methodology in 
debugging errors like this is by looking through the logs.


The 0-solution:

Everywhere a function is being called from the reactor, the user is 
responsible to handling all exceptions. As is the current case.

However, this is not completely straight forward. try-expect are great 
to catch expected errors, but it's easy to forget and ignore the 
unexpected ones. Like in the example above. The safeguard for this would 
be something like:

    def cb(self):
      try:
         self.count += 1
      except:
         print "Whoops. Unexpected"
         signal_main_app()

And in a large application, there are many entrypoints (e.g. methods in 
a protcol handler), so the code becomes very cluttered. Plus it puts the 
responsibility for the user to implement the signal_main_app() framework.


Proposal:

The ideal solution would be if there were a way to configure Twisted to 
inform about unhandled exceptions. It can be a addSystemEventTrigger(), 
or a SW signal, or a process signal, or perhaps a global 
execute-last-errback function. Possibly in a debug-context.

With this one could inform the application that one deferred object has 
not handled its errbacks. Then the main application is given a choice to 
respond appropriately, like shutting down.


Is my concern about the non-observability of unhandled exceptions at all 
warranted? Is the thinking wrong? Are there any other types of solutions 
to this problem? (I would like to avoid having to patch Twisted to do it.)


Best regards,
Svein


From exarkun at twistedmatrix.com  Thu Dec 28 06:29:15 2017
From: exarkun at twistedmatrix.com (Jean-Paul Calderone)
Date: Thu, 28 Dec 2017 08:29:15 -0500
Subject: [Twisted-Python] Unhandled exceptions and observability
In-Reply-To: <16e53039-da37-e7ab-234b-3cecacbc6a29@seldal.com>
References: <16e53039-da37-e7ab-234b-3cecacbc6a29@seldal.com>
Message-ID: <CAEeXt4M+U50okr9rh0ZsAByYpwr1Lt9L03iHPfiKy4EVewWmHQ@mail.gmail.com>

On Wed, Dec 27, 2017 at 11:18 PM, Svein Seldal <sveinse at seldal.com> wrote:

> Hi
>
>
> I'm not sure how to write this email, but please let me try. I'd like to
> address something that I see as a limitation in Twisted. It might be that
> my use case is odd or that I'm outside the scope of Twisted, but non the
> less, I'd hope this could be a relevant topic.
>
> Problem:
>
> Unhandled exceptions can leave the application in a half-working state,
> and the in-app observability for them is difficult to obtain. Instead of
> terminating the whole application, the rest of the app can still keep
> running, and can be completely unaware of the failure.
>
> This applies to unhandled errbacks in Deferred and principally to any
> other reactor callbacks. E.g. it can occur in Deferreds being used
> internally in Twisted, where direct access to the object isn't available to
> the caller.
>
> As a user of Twisted, I would like to have the option to catch or fail my
> application completely when these unhandled exceptions occur, as would be
> expected in a sequential program.
>
>
I'm not sure I agree with the problem statement or your idea (below) for
solving it.  However, it's straightforward to implement your idea with
current and all recent versions of Twisted.  This program will exit rapidly:


from twisted.internet import reactor
> from twisted.python.log import addObserver
> def stop_on_errors(event):
>     if event['isError']:
>         reactor.stop()
> addObserver(stop_on_errors)
> def fail():
>     1/0
> reactor.callLater(0, fail)
> reactor.run()


Someone else can probably demonstrate how to do the same thing using
twisted.logger instead.


>
> Background:
>
> I have a larger application using many simultaneous TCP, UDP and UNIX
> connections. As with Twisted, the app is grouped in functions, where most
> of the heavy lifting are done in black-box-ish modules. There is of course,
> no guarantee for everything to work smoothly and if something fails, the
> entire application stops as a clear indication of the failure. However,
> there have been some occasions where this application is found to be
> half-dead, due to a failure occurring in a reactor-based callback that can
> only be seen by reading the logs. The main application is unfortunately
> unaware of its own failure.
>

The black boxes should probably not be so black that they hide whether they
are working or broken from the calling code.  What if they are broken in a
way that doesn't raise an exception?  What if they are broken in a way that
doesn't signal whatever ad hoc channel you invent or discover for
determining if they are broken?  The only real solution is for error
signaling to be a guaranteed part of the interface to the black box.


>
> AFAIK Twisted has no direct mechanism for handling errors that might occur
> when user code is called from the reactor. Or even worse, the caller does
> not know about the occurred failure unless the caller has direct access to
> the failing object. I believe this is more dangerous to reliability than
> the plain failing applications is, due to lower observability.
>

Correct.  No *direct* mechanism.  Various indirect mechanisms exist,
though, such as the logging example given above.


>
> Lets say the following code is used in a running application:
>
>    from twisted.internet.task import LoopingCall
>    class Foo:
>      def __init__(self):
>        self.loop = LoopingCall(self.cb)
>        self.loop.start(2, False)
>      def cb(self):
>        self.count += 1
>
>    # Main app does this:
>    try:
>      foo = Foo()
>    except:
>      print "Won't happen"
>      raise
>
> The code will fail due to the programmical error in cb, but the calling
> application won't fail and thinks everything is fine. The methodology in
> debugging errors like this is by looking through the logs.
>

Foo is broken.  It uses the global reactor.  It creates side-effects in
__init__.  It creates a Deferred (LoopingCall.start) without attaching
callbacks or errbacks.


>
>
> The 0-solution:
>
> Everywhere a function is being called from the reactor, the user is
> responsible to handling all exceptions. As is the current case.
>
> However, this is not completely straight forward. try-expect are great to
> catch expected errors, but it's easy to forget and ignore the unexpected
> ones. Like in the example above. The safeguard for this would be something
> like:
>
>    def cb(self):
>      try:
>         self.count += 1
>      except:
>         print "Whoops. Unexpected"
>         signal_main_app()
>
> And in a large application, there are many entrypoints (e.g. methods in a
> protcol handler), so the code becomes very cluttered. Plus it puts the
> responsibility for the user to implement the signal_main_app() framework.
>

You say "cluttered".  Someone else might say "has correct error handling
code".  You also don't need to modify every piece of application code this
way.  You can compose this error handling into just about anything.  For
example:

def  handle_errors_for_broken_app_code(f):
>     @decorator
>     def g(...):
>         try:
>             f(...)
>         except:
>             signal_main_app()
>     return g


Or whatever variation of function composition strikes your fancy.

An entirely different approach, if you don't want to have to rely on your
black boxes having a reliable error signal is to create a monitoring system
instead.  Flip everything around and check the system for working-ness
instead of broken-ness.  If you ever can't confirm workingn-ess, it's a
good bet something has gone wrong and action should be taken.


>
>
> Proposal:
>
> The ideal solution would be if there were a way to configure Twisted to
> inform about unhandled exceptions. It can be a addSystemEventTrigger(), or
> a SW signal, or a process signal, or perhaps a global execute-last-errback
> function. Possibly in a debug-context.
>
>
Basically, there is a way now.  The logging system - since "unhandled
exceptions" are actually always handled by the reactor and logged.  The
logging-based approach has some properties I would identify as "problems"
but it may work for you.

The idea of a "last errback" is flawed in various ways and has been
discussed and discarded many times in the past (I would love to provide a
link to such discussion and apologize for not doing so; perhaps someone
else can do the necessary digging to find one).



> With this one could inform the application that one deferred object has
> not handled its errbacks. Then the main application is given a choice to
> respond appropriately, like shutting down.
>
>
> Is my concern about the non-observability of unhandled exceptions at all
> warranted? Is the thinking wrong? Are there any other types of solutions to
> this problem? (I would like to avoid having to patch Twisted to do it.)
>
>
Hopefully the above gives you some ideas for alternate solutions.  If
they're not workable, discussion about the particulars of why not might be
interesting and could generate some other ideas.

Thanks,
Jean-Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171228/f22a53b6/attachment-0001.html>

From trac at twistedmatrix.com  Sun Dec 31 00:05:21 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 31 Dec 2017 07:05:21 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1514703921.68.4801835178097463285@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171231/c8bddfd7/attachment.html>

From trac at twistedmatrix.com  Sun Dec  3 00:05:23 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 03 Dec 2017 07:05:23 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1512284723.81.8978984448037618722@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171203/9a8334bf/attachment-0002.html>

From trac at twistedmatrix.com  Sun Dec 10 00:05:20 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 10 Dec 2017 07:05:20 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1512889520.75.2302632024752270828@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171210/47b337bf/attachment-0002.html>

From glyph at twistedmatrix.com  Sun Dec 10 09:17:25 2017
From: glyph at twistedmatrix.com (Glyph)
Date: Sun, 10 Dec 2017 08:17:25 -0800
Subject: [Twisted-Python] ampoul3
Message-ID: <B7026B9C-4C01-41B9-A01A-C1FCC748DA9E@twistedmatrix.com>

I often refer to Ampoule as a way to get simple process pooling with Twisted.  However, it's been somewhat moribund (no maintenance, no py3 support) for the better part of a decade, despite more or less doing what it needs to do.

As such, I've created a friendly fork (hopefully only until Valentino checks his email and officially retires as the maintainer :)), at https://github.com/glyph/ampoule <https://github.com/glyph/ampoule>, and released it as https://pypi.python.org/pypi/ampoul3.

If you've wanted to use Ampoule, or something like it, with Python 3, check it out.

-glyph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171210/8bfb3d9b/attachment-0002.html>

From glyph at twistedmatrix.com  Sun Dec 10 23:02:23 2017
From: glyph at twistedmatrix.com (Glyph)
Date: Sun, 10 Dec 2017 22:02:23 -0800
Subject: [Twisted-Python] ampoul3
In-Reply-To: <B7026B9C-4C01-41B9-A01A-C1FCC748DA9E@twistedmatrix.com>
References: <B7026B9C-4C01-41B9-A01A-C1FCC748DA9E@twistedmatrix.com>
Message-ID: <5EE56CDE-4A08-4E34-98DF-3C86A6D4FE37@twistedmatrix.com>

On Dec 10, 2017, at 8:17 AM, Glyph <glyph at twistedmatrix.com> wrote:
> 
> I often refer to Ampoule as a way to get simple process pooling with Twisted.  However, it's been somewhat moribund (no maintenance, no py3 support) for the better part of a decade, despite more or less doing what it needs to do.
> 
> As such, I've created a friendly fork (hopefully only until Valentino checks his email and officially retires as the maintainer :)), at https://github.com/glyph/ampoule <https://github.com/glyph/ampoule>, and released it as https://pypi.python.org/pypi/ampoul3 <https://pypi.python.org/pypi/ampoul3>.

Valentino was more responsive than I expected!  https://pypi.python.org/pypi/ampoule now features a universal wheel supporting both py2 & py3.

I'd like some help maintaining this, since I certainly don't have a ton of bandwidth to take on new projects.  Anyone else interested in making parallel execution with Twisted easy?

On that note I also plan to move it into the Twisted org at some point.

-g

> 
> If you've wanted to use Ampoule, or something like it, with Python 3, check it out.
> 
> -glyph
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python

-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171210/cb435512/attachment-0002.html>

From trac at twistedmatrix.com  Sun Dec 17 00:05:21 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 17 Dec 2017 07:05:21 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1513494321.36.8771361763853580539@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171217/0b1b6cbe/attachment-0002.html>

From rodrigc at crodrigues.org  Sun Dec 17 18:18:24 2017
From: rodrigc at crodrigues.org (Craig Rodrigues)
Date: Sun, 17 Dec 2017 17:18:24 -0800
Subject: [Twisted-Python] Drop support for Python 3.3
Message-ID: <CAG=rPVc2eFB2PLrscNnbf0Mg=wOs=PooK5ouWWuJqiKi9Vf6FA@mail.gmail.com>

I submitted this patch to drop support for Python 3.3:

https://github.com/twisted/twisted/pull/943


1.  Python 3.3 was declared EOL on Sep. 29, 2017
2.  In terms of major Linux distributions, Python 3.4 came with Python 3.4
is in Debian 8, Ubuntu 14.04, Fedora 21

So after this patch, Twisted would run on:

Python 2.7 and Python 3.4+

Thoughts?
--
Craig
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171217/f99f838b/attachment-0002.html>

From trac at twistedmatrix.com  Sun Dec 24 00:05:21 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 24 Dec 2017 07:05:21 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1514099121.84.1376524570532654573@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171224/08d7bc42/attachment-0002.html>

From glyph at twistedmatrix.com  Tue Dec 26 19:27:44 2017
From: glyph at twistedmatrix.com (Glyph)
Date: Tue, 26 Dec 2017 18:27:44 -0800
Subject: [Twisted-Python] github process automation shortcut
Message-ID: <8EFD1305-B173-4696-A187-F0BA9F1AE387@twistedmatrix.com>

With more and more ecosystem projects on Github, more or less maintained by the same team that maintains Twisted proper, our "review keyword in trac" workflow is increasingly awkward.

Github itself has an individualized "review queue" of sorts - https://github.com/pulls/review-requested <https://github.com/pulls/review-requested> - where you can see open pull requests where your review has been requested.  What makes this particularly interesting is that you can request review from a team, rather than from an individual.

Of course, like everything interesting (ahem, labels), you need repo:write permission to do this, so we'd still need a bot.

But!

It appears that the CODEOWNERS file - https://help.github.com/articles/about-codeowners/ <https://help.github.com/articles/about-codeowners/> - can automatically request code reviews when pull requests touch relevant code - so we could add "* @twisted/$PROJECT-reviewers" to each project on that file and, I believe, have a fairly orderly review queue that can be seen in a nice unified view by each org member, and by using -reviewers teams, we could allow for folks to join or leave any individual repo review responsibility that they want.

Actually setting up all the stuff needed to test this requires more time than I have on my hands at the moment.  Does anyone else know for sure if this works as I imagine it would - specifically, that third party contributors would get an automatic review request opened, at least initially?

We might still need a bot to re-request reviews, but this seems like a much less ad-hoc way of doing this process migration than labels.

-g
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171226/e255ee52/attachment-0002.html>

From adi at roiban.ro  Wed Dec 27 11:02:52 2017
From: adi at roiban.ro (Adi Roiban)
Date: Wed, 27 Dec 2017 18:02:52 +0000
Subject: [Twisted-Python] Drop support for Python 3.3
In-Reply-To: <CAG=rPVc2eFB2PLrscNnbf0Mg=wOs=PooK5ouWWuJqiKi9Vf6FA@mail.gmail.com>
References: <CAG=rPVc2eFB2PLrscNnbf0Mg=wOs=PooK5ouWWuJqiKi9Vf6FA@mail.gmail.com>
Message-ID: <CAFycZ9fekC4VV-0OSab=n=ihgdqVkZCMAj-tz7u-CL0-tmQ3uw@mail.gmail.com>

On 18 December 2017 at 01:18, Craig Rodrigues <rodrigc at crodrigues.org> wrote:
> I submitted this patch to drop support for Python 3.3:
>
> https://github.com/twisted/twisted/pull/943
>
>
> 1.  Python 3.3 was declared EOL on Sep. 29, 2017
> 2.  In terms of major Linux distributions, Python 3.4 came with Python 3.4
> is in Debian 8, Ubuntu 14.04, Fedora 21
>
> So after this patch, Twisted would run on:
>
> Python 2.7 and Python 3.4+

+1  for removing python 3.3

But as commented in the PR, I would like to see this removed after the
next release, so that we don't have to change the release notes for
17.9.0
That is 18.X.X should be the last release to support 3.4

-- 
Adi Roiban



From adi at roiban.ro  Wed Dec 27 11:03:55 2017
From: adi at roiban.ro (Adi Roiban)
Date: Wed, 27 Dec 2017 18:03:55 +0000
Subject: [Twisted-Python] github process automation shortcut
In-Reply-To: <8EFD1305-B173-4696-A187-F0BA9F1AE387@twistedmatrix.com>
References: <8EFD1305-B173-4696-A187-F0BA9F1AE387@twistedmatrix.com>
Message-ID: <CAFycZ9cq6WqQ787NANtCVT_JR8YiLckg2hDe80+5PfTwz1F1+w@mail.gmail.com>

On 27 December 2017 at 02:27, Glyph <glyph at twistedmatrix.com> wrote:
> With more and more ecosystem projects on Github, more or less maintained by
> the same team that maintains Twisted proper, our "review keyword in trac"
> workflow is increasingly awkward.
>
> Github itself has an individualized "review queue" of sorts -
> https://github.com/pulls/review-requested - where you can see open pull
> requests where your review has been requested.  What makes this particularly
> interesting is that you can request review from a team, rather than from an
> individual.
>
> Of course, like everything interesting (ahem, labels), you need repo:write
> permission to do this, so we'd still need a bot.
>
> But!
>
> It appears that the CODEOWNERS file -
> https://help.github.com/articles/about-codeowners/ - can automatically
> request code reviews when pull requests touch relevant code - so we could
> add "* @twisted/$PROJECT-reviewers" to each project on that file and, I
> believe, have a fairly orderly review queue that can be seen in a nice
> unified view by each org member, and by using -reviewers teams, we could
> allow for folks to join or leave any individual repo review responsibility
> that they want.
>
> Actually setting up all the stuff needed to test this requires more time
> than I have on my hands at the moment.  Does anyone else know for sure if
> this works as I imagine it would - specifically, that third party
> contributors would get an automatic review request opened, at least
> initially?
>
> We might still need a bot to re-request reviews, but this seems like a much
> less ad-hoc way of doing this process migration than labels.

I think that we can give it a try as is easy to implement.

----------

I tried CODEOWNERS and for my project (which is multi platforms) and
it does not work for me.

The main reason is that GitHub is "simple" and a soon as you create
the review it will think that you want someone to review it.

Most of the time, the review should be requested after all the tests
are green... and you create the PR to trigger the tests.
With many platforms and with lots of tests, it is probable that a dev
will not run all the test before the push.
The tests might fail, and then you might need another day of work
before requesting the review.

...or you create the PR at end of the day, and you want to do a self
review in the morning.

--------

And then you need the bot anyway for 're-review' ... so why not use
the same bot for explicitly requesting when the review is ready.

-------

You might have a team member just leaving a comment, without any
intention to provide a reject/approve review in the future.
With this action, the team is removed from "Reviewers", hence removed
from the review queue.. and the PR might be lost.
This can be solved by asking team members to just leave simple
comments, and not review comments, but review comments are a nice way
to organize multi-chuck comments.

--------

I am +1 for moving all the tickets from Trac to GitHub so that we will
get rid of the "review" keyword and the tentative ticket flow in Trac.

It will be painful, but I think that it will make it easier to
implement a dev process / workflow.

In an ideal world, we would have plenty of time to document the
workflow, and contributors would have plenty of time to read the dev
documentation,
but I think that we should recognize that everyone is short on time,
so in order to make it easier for everybody to contribute

I don't like that we depend that much on GitHub, but I don't see how
there will be time to keep custom infrastructure.
There is little time to do review, and at this stage I think that is
more important for people to do reviews and work on patches rather
than working on infrastructure.


-- 
Adi Roiban



From exarkun at twistedmatrix.com  Wed Dec 27 17:27:56 2017
From: exarkun at twistedmatrix.com (Jean-Paul Calderone)
Date: Wed, 27 Dec 2017 19:27:56 -0500
Subject: [Twisted-Python] [ANN] txaws 0.5.0
Message-ID: <CAEeXt4PL1F+hJqQq-93035WpUN76n9fQuc7i6oYGph81mqCwig@mail.gmail.com>

Hello all,

I'm pleased to announce the release of txAWS 0.5.0.  txAWS is a library for
interacting with Amazon Web Services (AWS) using Twisted.

You can download the release from PyPI <https://pypi.python.org/pypi/txAWS>.

Since the last release, the following enhancements have been made:

Features
> --------
> - txaws.s3.client.S3Client.get_bucket now accepts a ``prefix`` parameter
> for
>   selecting a subset of S3 objects. (#78)
> - txaws.ec2.client.EC2Client now has a ``get_console_output`` method
> binding
>   the ``GetConsoleOutput`` API. (#82)


Thanks to everyone who contributed and to Least Authority TFA GmbH
<https://leastauthority.com/> for sponsoring my work on this release.

Jean-Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171227/8f737bcf/attachment-0002.html>

From sveinse at seldal.com  Wed Dec 27 21:18:32 2017
From: sveinse at seldal.com (Svein Seldal)
Date: Thu, 28 Dec 2017 05:18:32 +0100
Subject: [Twisted-Python] Unhandled exceptions and observability
Message-ID: <16e53039-da37-e7ab-234b-3cecacbc6a29@seldal.com>

Hi


I'm not sure how to write this email, but please let me try. I'd like to 
address something that I see as a limitation in Twisted. It might be 
that my use case is odd or that I'm outside the scope of Twisted, but 
non the less, I'd hope this could be a relevant topic.

Problem:

Unhandled exceptions can leave the application in a half-working state, 
and the in-app observability for them is difficult to obtain. Instead of 
terminating the whole application, the rest of the app can still keep 
running, and can be completely unaware of the failure.

This applies to unhandled errbacks in Deferred and principally to any 
other reactor callbacks. E.g. it can occur in Deferreds being used 
internally in Twisted, where direct access to the object isn't available 
to the caller.

As a user of Twisted, I would like to have the option to catch or fail 
my application completely when these unhandled exceptions occur, as 
would be expected in a sequential program.


Background:

I have a larger application using many simultaneous TCP, UDP and UNIX 
connections. As with Twisted, the app is grouped in functions, where 
most of the heavy lifting are done in black-box-ish modules. There is of 
course, no guarantee for everything to work smoothly and if something 
fails, the entire application stops as a clear indication of the 
failure. However, there have been some occasions where this application 
is found to be half-dead, due to a failure occurring in a reactor-based 
callback that can only be seen by reading the logs. The main application 
is unfortunately unaware of its own failure.

AFAIK Twisted has no direct mechanism for handling errors that might 
occur when user code is called from the reactor. Or even worse, the 
caller does not know about the occurred failure unless the caller has 
direct access to the failing object. I believe this is more dangerous to 
reliability than the plain failing applications is, due to lower 
observability.

Lets say the following code is used in a running application:

    from twisted.internet.task import LoopingCall
    class Foo:
      def __init__(self):
        self.loop = LoopingCall(self.cb)
        self.loop.start(2, False)
      def cb(self):
        self.count += 1

    # Main app does this:
    try:
      foo = Foo()
    except:
      print "Won't happen"
      raise

The code will fail due to the programmical error in cb, but the calling 
application won't fail and thinks everything is fine. The methodology in 
debugging errors like this is by looking through the logs.


The 0-solution:

Everywhere a function is being called from the reactor, the user is 
responsible to handling all exceptions. As is the current case.

However, this is not completely straight forward. try-expect are great 
to catch expected errors, but it's easy to forget and ignore the 
unexpected ones. Like in the example above. The safeguard for this would 
be something like:

    def cb(self):
      try:
         self.count += 1
      except:
         print "Whoops. Unexpected"
         signal_main_app()

And in a large application, there are many entrypoints (e.g. methods in 
a protcol handler), so the code becomes very cluttered. Plus it puts the 
responsibility for the user to implement the signal_main_app() framework.


Proposal:

The ideal solution would be if there were a way to configure Twisted to 
inform about unhandled exceptions. It can be a addSystemEventTrigger(), 
or a SW signal, or a process signal, or perhaps a global 
execute-last-errback function. Possibly in a debug-context.

With this one could inform the application that one deferred object has 
not handled its errbacks. Then the main application is given a choice to 
respond appropriately, like shutting down.


Is my concern about the non-observability of unhandled exceptions at all 
warranted? Is the thinking wrong? Are there any other types of solutions 
to this problem? (I would like to avoid having to patch Twisted to do it.)


Best regards,
Svein



From exarkun at twistedmatrix.com  Thu Dec 28 06:29:15 2017
From: exarkun at twistedmatrix.com (Jean-Paul Calderone)
Date: Thu, 28 Dec 2017 08:29:15 -0500
Subject: [Twisted-Python] Unhandled exceptions and observability
In-Reply-To: <16e53039-da37-e7ab-234b-3cecacbc6a29@seldal.com>
References: <16e53039-da37-e7ab-234b-3cecacbc6a29@seldal.com>
Message-ID: <CAEeXt4M+U50okr9rh0ZsAByYpwr1Lt9L03iHPfiKy4EVewWmHQ@mail.gmail.com>

On Wed, Dec 27, 2017 at 11:18 PM, Svein Seldal <sveinse at seldal.com> wrote:

> Hi
>
>
> I'm not sure how to write this email, but please let me try. I'd like to
> address something that I see as a limitation in Twisted. It might be that
> my use case is odd or that I'm outside the scope of Twisted, but non the
> less, I'd hope this could be a relevant topic.
>
> Problem:
>
> Unhandled exceptions can leave the application in a half-working state,
> and the in-app observability for them is difficult to obtain. Instead of
> terminating the whole application, the rest of the app can still keep
> running, and can be completely unaware of the failure.
>
> This applies to unhandled errbacks in Deferred and principally to any
> other reactor callbacks. E.g. it can occur in Deferreds being used
> internally in Twisted, where direct access to the object isn't available to
> the caller.
>
> As a user of Twisted, I would like to have the option to catch or fail my
> application completely when these unhandled exceptions occur, as would be
> expected in a sequential program.
>
>
I'm not sure I agree with the problem statement or your idea (below) for
solving it.  However, it's straightforward to implement your idea with
current and all recent versions of Twisted.  This program will exit rapidly:


from twisted.internet import reactor
> from twisted.python.log import addObserver
> def stop_on_errors(event):
>     if event['isError']:
>         reactor.stop()
> addObserver(stop_on_errors)
> def fail():
>     1/0
> reactor.callLater(0, fail)
> reactor.run()


Someone else can probably demonstrate how to do the same thing using
twisted.logger instead.


>
> Background:
>
> I have a larger application using many simultaneous TCP, UDP and UNIX
> connections. As with Twisted, the app is grouped in functions, where most
> of the heavy lifting are done in black-box-ish modules. There is of course,
> no guarantee for everything to work smoothly and if something fails, the
> entire application stops as a clear indication of the failure. However,
> there have been some occasions where this application is found to be
> half-dead, due to a failure occurring in a reactor-based callback that can
> only be seen by reading the logs. The main application is unfortunately
> unaware of its own failure.
>

The black boxes should probably not be so black that they hide whether they
are working or broken from the calling code.  What if they are broken in a
way that doesn't raise an exception?  What if they are broken in a way that
doesn't signal whatever ad hoc channel you invent or discover for
determining if they are broken?  The only real solution is for error
signaling to be a guaranteed part of the interface to the black box.


>
> AFAIK Twisted has no direct mechanism for handling errors that might occur
> when user code is called from the reactor. Or even worse, the caller does
> not know about the occurred failure unless the caller has direct access to
> the failing object. I believe this is more dangerous to reliability than
> the plain failing applications is, due to lower observability.
>

Correct.  No *direct* mechanism.  Various indirect mechanisms exist,
though, such as the logging example given above.


>
> Lets say the following code is used in a running application:
>
>    from twisted.internet.task import LoopingCall
>    class Foo:
>      def __init__(self):
>        self.loop = LoopingCall(self.cb)
>        self.loop.start(2, False)
>      def cb(self):
>        self.count += 1
>
>    # Main app does this:
>    try:
>      foo = Foo()
>    except:
>      print "Won't happen"
>      raise
>
> The code will fail due to the programmical error in cb, but the calling
> application won't fail and thinks everything is fine. The methodology in
> debugging errors like this is by looking through the logs.
>

Foo is broken.  It uses the global reactor.  It creates side-effects in
__init__.  It creates a Deferred (LoopingCall.start) without attaching
callbacks or errbacks.


>
>
> The 0-solution:
>
> Everywhere a function is being called from the reactor, the user is
> responsible to handling all exceptions. As is the current case.
>
> However, this is not completely straight forward. try-expect are great to
> catch expected errors, but it's easy to forget and ignore the unexpected
> ones. Like in the example above. The safeguard for this would be something
> like:
>
>    def cb(self):
>      try:
>         self.count += 1
>      except:
>         print "Whoops. Unexpected"
>         signal_main_app()
>
> And in a large application, there are many entrypoints (e.g. methods in a
> protcol handler), so the code becomes very cluttered. Plus it puts the
> responsibility for the user to implement the signal_main_app() framework.
>

You say "cluttered".  Someone else might say "has correct error handling
code".  You also don't need to modify every piece of application code this
way.  You can compose this error handling into just about anything.  For
example:

def  handle_errors_for_broken_app_code(f):
>     @decorator
>     def g(...):
>         try:
>             f(...)
>         except:
>             signal_main_app()
>     return g


Or whatever variation of function composition strikes your fancy.

An entirely different approach, if you don't want to have to rely on your
black boxes having a reliable error signal is to create a monitoring system
instead.  Flip everything around and check the system for working-ness
instead of broken-ness.  If you ever can't confirm workingn-ess, it's a
good bet something has gone wrong and action should be taken.


>
>
> Proposal:
>
> The ideal solution would be if there were a way to configure Twisted to
> inform about unhandled exceptions. It can be a addSystemEventTrigger(), or
> a SW signal, or a process signal, or perhaps a global execute-last-errback
> function. Possibly in a debug-context.
>
>
Basically, there is a way now.  The logging system - since "unhandled
exceptions" are actually always handled by the reactor and logged.  The
logging-based approach has some properties I would identify as "problems"
but it may work for you.

The idea of a "last errback" is flawed in various ways and has been
discussed and discarded many times in the past (I would love to provide a
link to such discussion and apologize for not doing so; perhaps someone
else can do the necessary digging to find one).



> With this one could inform the application that one deferred object has
> not handled its errbacks. Then the main application is given a choice to
> respond appropriately, like shutting down.
>
>
> Is my concern about the non-observability of unhandled exceptions at all
> warranted? Is the thinking wrong? Are there any other types of solutions to
> this problem? (I would like to avoid having to patch Twisted to do it.)
>
>
Hopefully the above gives you some ideas for alternate solutions.  If
they're not workable, discussion about the particulars of why not might be
interesting and could generate some other ideas.

Thanks,
Jean-Paul
-------------- next part --------------
An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171228/f22a53b6/attachment-0002.html>

From trac at twistedmatrix.com  Sun Dec 31 00:05:21 2017
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 31 Dec 2017 07:05:21 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1514703921.68.4801835178097463285@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20171231/c8bddfd7/attachment-0002.html>

