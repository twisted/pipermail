<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Twisted Plugins - Implementation Discussion
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Twisted%20Plugins%20-%20Implementation%20Discussion&In-Reply-To=1302178445.1686.8.camel%40blake">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023875.html">
   <LINK REL="Next"  HREF="023892.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Twisted Plugins - Implementation Discussion</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Twisted%20Plugins%20-%20Implementation%20Discussion&In-Reply-To=1302178445.1686.8.camel%40blake"
       TITLE="[Twisted-Python] Twisted Plugins - Implementation Discussion">glyph at twistedmatrix.com
       </A><BR>
    <I>Thu Apr  7 14:20:32 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="023875.html">[Twisted-Python] Twisted Plugins - Implementation Discussion
</A></li>
        <LI>Next message: <A HREF="023892.html">[Twisted-Python] Twisted Plugins - Implementation Discussion
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23873">[ date ]</a>
              <a href="thread.html#23873">[ thread ]</a>
              <a href="subject.html#23873">[ subject ]</a>
              <a href="author.html#23873">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Apr 7, 2011, at 8:14 AM, Itamar Turner-Trauring wrote:

&gt;<i> On Thu, 2011-04-07 at 02:08 -0400, Glyph Lefkowitz wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> My idea for exposing it is that if you then do 'getPlugins(IPlugin2)',
</I>&gt;&gt;<i> you will get back an iterable of IPlugin2 providers, but not
</I>&gt;&gt;<i> necessarily instances of your classes: they could be cached plugins,
</I>&gt;&gt;<i> with cached results for metadata() and willProvide() - the latter
</I>&gt;&gt;<i> based on the list currently saved as the 'provided' attribute.  So a
</I>&gt;&gt;<i> loop like this to load a twistd plugin by name:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>        def twistdPluginByTapname(name):
</I>&gt;&gt;<i>            for p2 in getPlugins(IPlugin2):
</I>&gt;&gt;<i>                if p2.willProvide(IServiceMaker) and
</I>&gt;&gt;<i>        p2.metadata()['tapname'] == name:
</I>&gt;&gt;<i>                    return p2.load()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> ... would not actually load any plugins, but work entirely from the
</I>&gt;&gt;<i> cached metadata.
</I>&gt;<i> 
</I>&gt;<i> That's where the whole idea falls down for me. Evidence suggests (and
</I>&gt;<i> you note this earlier) that caching doesn't work anywhere in the real
</I>&gt;<i> world. My current Ubuntu install complains about a read-only cache every
</I>&gt;<i> time I run lore (and I'm pretty sure there's nothing added to my
</I>&gt;<i> PYTHONPATH other than installed system packages). Any design which
</I>&gt;<i> assumes caching works appears to be useless in the real world.
</I>&gt;<i> 
</I>&gt;<i> So, the design has to *not* rely on caching working.
</I>
Here's an idea: let's make caching actually work :).  Prior experience indicates that with some small amount of dedication, it's possible to make a module in Twisted not be broken all the time.


As you observed that I already mentioned earlier in the thread, caching never works because post-installation hooks are such a pain, and you have to have special permissions to access the cache file.  So, separately from this, we could attempt a secondary cache read/write to a location much more likely to be writable by the user (something like ~/.local/var/cache/usr_lib_python2.6_site-packages.dropin.cache) read if the first one is out of date and written if writing the first one fails.

Also: we already rely on this behavior, so things are just as broken now for you.  For example, you'll end up loading the code for all twistd plugins and trial reporters when what you want are lore plugins.  This could also be fixed independently.

(To fix your particular installation right now, 'sudo twistd --help' or 'sudo lore' once.)

And, finally, as a separate consideration, we could make &quot;cached metadata&quot; mean &quot;explicitly specified metadata&quot; instead.  The important thing that I'm talking about doing first is making the system work exactly the same way that it does now, with one additional feature in the API which would allow us to make use of metadata that lives outside the Python code, using the existing mechanism for storing metadata that is currently not used.  For a first cut, we wouldn't even remove the ServiceMaker hack, just add the new feature to it so that we could do slightly less importing at startup.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20110407/85b0c50f/attachment.htm">http://twistedmatrix.com/pipermail/twisted-python/attachments/20110407/85b0c50f/attachment.htm</A> 
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023875.html">[Twisted-Python] Twisted Plugins - Implementation Discussion
</A></li>
	<LI>Next message: <A HREF="023892.html">[Twisted-Python] Twisted Plugins - Implementation Discussion
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23873">[ date ]</a>
              <a href="thread.html#23873">[ thread ]</a>
              <a href="subject.html#23873">[ subject ]</a>
              <a href="author.html#23873">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
