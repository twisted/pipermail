<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Supporting a two-part client protocol.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Supporting%20a%20two-part%20client%20protocol.&In-Reply-To=%3C3723792.iddL89eHtP%40fpbarry%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="065011.html">
   <LINK REL="Next"  HREF="065013.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Supporting a two-part client protocol.</H1>
    <B>Barry Scott</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Supporting%20a%20two-part%20client%20protocol.&In-Reply-To=%3C3723792.iddL89eHtP%40fpbarry%3E"
       TITLE="[Twisted-Python] Supporting a two-part client protocol.">barry.scott at forcepoint.com
       </A><BR>
    <I>Thu Feb  6 11:29:41 MST 2020</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="065011.html">[Twisted-Python] Supporting a two-part client protocol.
</A></li>
        <LI>Next message (by thread): <A HREF="065013.html">[Twisted-Python] Inheriting DatagramProtocol, which is an old-style class
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65012">[ date ]</a>
              <a href="thread.html#65012">[ thread ]</a>
              <a href="subject.html#65012">[ subject ]</a>
              <a href="author.html#65012">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thursday, 6 February 2020 16:02:40 GMT Go Luhng wrote:
&gt;<i> Thanks for the detailed responses, Colin and Barry. I have a followup
</I>&gt;<i> 
</I>&gt;<i> question about sans-io. From the document:
</I>&gt;<i> &gt; For input (that is, receiving data from the network), the
</I>&gt;<i> 
</I>&gt;<i> calling code is responsible for delivering code to the
</I>&gt;<i> implementation via a single input (often via a method called
</I>&gt;<i> receive_bytes, or something similar).
</I>&gt;<i> 
</I>&gt;<i> This sounds very nice, however with certain protocols, you canonly
</I>&gt;<i> decode serialized events based on context.
</I>
That's not a protocol problem its an implementation problem surely?

&gt;<i> For example, the parser needs to know if we're at the handshake stage,
</I>&gt;<i> or the regular communication stage, or the shutdown stage, because
</I>&gt;<i> different formats of messages are sent by the server at each stage.
</I>&gt;<i> 
</I>&gt;<i> How does this elegantly fit into the scheme of sans-io?
</I>
The sans-io (as I remember it) says don't put IO details into your
protocol code, abstract it/have clean API boundaries. (Makes it
easy to write unit tests as you do not need to have a network stack.
Just make the API calls: dataReceived, connectionLost, timeout etc).

Its the job of your protocol code to have a state machine and
know where is at any point in time. What you are calling &quot;stage&quot;
sounds like a &quot;state&quot; of the state machine.

The pattern in very crude outline is:
Define all the events that the protocol must handle.
Define all the states the protocol needs. When each event is
received do the state specific action and change state.

You can see this in the chunked encoding code, with one
way to implement the state machine.

Also note that its usual for there is be more then one state machine
in most protocols. Using HTTP as an example it needs to handle the
command, headers then the body
handling the command and headers means splitting the byte stream into lines.
Once you have the headers you can figure out how to process the body.

1. State machine for overall HTTP status, headers, body
2. State machine to split bytes received into header lines
3. State machine for chunked body encoding
4. State machine for Content-Length body encoding.

Barry


&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>



</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="065011.html">[Twisted-Python] Supporting a two-part client protocol.
</A></li>
	<LI>Next message (by thread): <A HREF="065013.html">[Twisted-Python] Inheriting DatagramProtocol, which is an old-style class
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65012">[ date ]</a>
              <a href="thread.html#65012">[ thread ]</a>
              <a href="subject.html#65012">[ subject ]</a>
              <a href="author.html#65012">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
