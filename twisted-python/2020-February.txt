From trac at twistedmatrix.com  Sun Feb  2 00:05:36 2020
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 02 Feb 2020 07:05:36 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1580627136.36.4127522971257222004@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20200202/de492c59/attachment.htm>

From goluhng at gmail.com  Mon Feb  3 12:06:23 2020
From: goluhng at gmail.com (Go Luhng)
Date: Mon, 3 Feb 2020 14:06:23 -0500
Subject: [Twisted-Python] Supporting a two-part client protocol.
Message-ID: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>

Hi there,

I'm planning to use Twisted to write a client for the following protocol:

Each messages is composed of two separate messages:

1. A header, which is a serialized C struct, containing multiple
fields, among them a `length` field.
2. A Protocol Buffer payload, which length is specified by the
aforementioned `length` field on the header.

While the initial implementation is focused on TCP, I do hope to
support this same protocol over UDP eventually.

What's the best way for me to implement such a client with Twisted?
Specifically, to implement support for sending/receiving messages in
the above format to/from a server?

Thanks, Go


From colin.dunklau at gmail.com  Mon Feb  3 16:58:26 2020
From: colin.dunklau at gmail.com (Colin Dunklau)
Date: Tue, 4 Feb 2020 00:58:26 +0100
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
Message-ID: <CAMTx_3D+OsmMu7qLOdenXThYkSVvymVWm0r7ESBoFjE5FiYWqQ@mail.gmail.com>

On Mon, Feb 3, 2020 at 8:06 PM Go Luhng <goluhng at gmail.com> wrote:
>
> Hi there,
>
> I'm planning to use Twisted to write a client for the following protocol:
>
> Each messages is composed of two separate messages:
>
> 1. A header, which is a serialized C struct, containing multiple
> fields, among them a `length` field.
> 2. A Protocol Buffer payload, which length is specified by the
> aforementioned `length` field on the header.
>
> While the initial implementation is focused on TCP, I do hope to
> support this same protocol over UDP eventually.
>
> What's the best way for me to implement such a client with Twisted?
> Specifically, to implement support for sending/receiving messages in
> the above format to/from a server?
>
> Thanks, Go

Assuming the header has a fixed length,
https://twistedmatrix.com/documents/current/api/twisted.protocols.basic.IntNStringReceiver.html
and its more-concrete subclasses are a decent source of inspiration.
OTOH, that's for stream protocols, so if you want to eventually handle
UDP, it's probably nicer to do the full sans-io thing
(https://sans-io.readthedocs.io/) and wire it up with a more-basic
Twisted protocol. Well, that's probably the better approach in any
case.


From goluhng at gmail.com  Mon Feb  3 17:18:26 2020
From: goluhng at gmail.com (Go Luhng)
Date: Mon, 3 Feb 2020 19:18:26 -0500
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAMTx_3D+OsmMu7qLOdenXThYkSVvymVWm0r7ESBoFjE5FiYWqQ@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAMTx_3D+OsmMu7qLOdenXThYkSVvymVWm0r7ESBoFjE5FiYWqQ@mail.gmail.com>
Message-ID: <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>

> Colin Dunklau wrote:
>
> Assuming the header has a fixed length,

It does. The header is just a serialized C struct, so it's
fully-specified for length and offset of each field.

> OTOH, that's for stream protocols, so if you want to eventually handle
> UDP, it's probably nicer to do the full sans-io thing
> (https://sans-io.readthedocs.io/) and wire it up with a more-basic
> Twisted protocol.

Could you elaborate on this?  I'm new to Twisted, and also unfamiliar
with sans-io.

Specifically, I'm wondering what type of "more-basic" Twisted protocol you mean.


From colin.dunklau at gmail.com  Tue Feb  4 00:39:11 2020
From: colin.dunklau at gmail.com (Colin Dunklau)
Date: Tue, 4 Feb 2020 08:39:11 +0100
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAMTx_3D+OsmMu7qLOdenXThYkSVvymVWm0r7ESBoFjE5FiYWqQ@mail.gmail.com>
 <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>
Message-ID: <CAMTx_3B7rtg8LNEfz8fd8fob24Ug+N5mMcEd0p63LpTgWn-Djg@mail.gmail.com>

On Tue, Feb 4, 2020 at 1:18 AM Go Luhng <goluhng at gmail.com> wrote:
>
> > Colin Dunklau wrote:
> >
> > Assuming the header has a fixed length,
>
> It does. The header is just a serialized C struct, so it's
> fully-specified for length and offset of each field.
>
> > OTOH, that's for stream protocols, so if you want to eventually handle
> > UDP, it's probably nicer to do the full sans-io thing
> > (https://sans-io.readthedocs.io/) and wire it up with a more-basic
> > Twisted protocol.
>
> Could you elaborate on this?  I'm new to Twisted, and also unfamiliar
> with sans-io.
>
> Specifically, I'm wondering what type of "more-basic" Twisted protocol you mean.

The sans-io pattern is described well at that site, including a link
to Cory Benfield's great talk
(https://www.youtube.com/watch?v=7cC3_jGwl_U). The idea is to keep
your protocol logic strictly separate from anything that does IO (like
a Twisted Protocol's `dataReceived` and its transport's `write`
method, or an asyncio thing, or blocking socket operations, etc), to
make it easier to test and reuse.

By "more-basic" I mean twisted.internet.protocol.Protocol and
twisted.internet.protocol.DatagramProtocol.

If you don't go full sans-io, I'd still strongly recommend splitting
up you protocol implementation into distinct pieces. Twisted protocols
can become hard to reason about when they become implicit state
machines... avoid it by making a separate, explicit state machine and
use that in the Protocol, instead of dumping the bits on the protocol
instance itself. This way you at least still get the testability.


From barry.scott at forcepoint.com  Tue Feb  4 03:40:35 2020
From: barry.scott at forcepoint.com (Barry Scott)
Date: Tue, 04 Feb 2020 10:40:35 +0000
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAMTx_3B7rtg8LNEfz8fd8fob24Ug+N5mMcEd0p63LpTgWn-Djg@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>
 <CAMTx_3B7rtg8LNEfz8fd8fob24Ug+N5mMcEd0p63LpTgWn-Djg@mail.gmail.com>
Message-ID: <32937360.kCLCYxncz1@fpbarry>

On Tuesday, 4 February 2020 07:39:11 GMT Colin Dunklau wrote:
> On Tue, Feb 4, 2020 at 1:18 AM Go Luhng <goluhng at gmail.com> wrote:
> > > Colin Dunklau wrote:
> > > 
> > > Assuming the header has a fixed length,
> > 
> > It does. The header is just a serialized C struct, so it's
> > fully-specified for length and offset of each field.
> > 
> > > OTOH, that's for stream protocols, so if you want to eventually handle
> > > UDP, it's probably nicer to do the full sans-io thing
> > > (https://sans-io.readthedocs.io/) and wire it up with a more-basic
> > > Twisted protocol.
> > 
> > Could you elaborate on this?  I'm new to Twisted, and also unfamiliar
> > with sans-io.
> > 
> > Specifically, I'm wondering what type of "more-basic" Twisted protocol you
> > mean.
> The sans-io pattern is described well at that site, including a link
> to Cory Benfield's great talk
> (https://www.youtube.com/watch?v=7cC3_jGwl_U). The idea is to keep
> your protocol logic strictly separate from anything that does IO (like
> a Twisted Protocol's `dataReceived` and its transport's `write`
> method, or an asyncio thing, or blocking socket operations, etc), to
> make it easier to test and reuse.
> 
> By "more-basic" I mean twisted.internet.protocol.Protocol and
> twisted.internet.protocol.DatagramProtocol.
> 
> If you don't go full sans-io, I'd still strongly recommend splitting
> up you protocol implementation into distinct pieces. Twisted protocols
> can become hard to reason about when they become implicit state
> machines... avoid it by making a separate, explicit state machine and
> use that in the Protocol, instead of dumping the bits on the protocol
> instance itself. This way you at least still get the testability.

The sans-io is a worth considering.

The advice to use explicit state machines I fully endorse.

I'm maintaining some code that uses an implicit state machine
and its a pain to reason about and avoid bugs with.

Barry

> 
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python





From goluhng at gmail.com  Tue Feb  4 10:11:45 2020
From: goluhng at gmail.com (Go Luhng)
Date: Tue, 4 Feb 2020 12:11:45 -0500
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <32937360.kCLCYxncz1@fpbarry>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>
 <CAMTx_3B7rtg8LNEfz8fd8fob24Ug+N5mMcEd0p63LpTgWn-Djg@mail.gmail.com>
 <32937360.kCLCYxncz1@fpbarry>
Message-ID: <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>

Thanks Colin and Barry for the reply. I read the sans-io docs and it
is an attractive approach.

I believe I have a plan going forward, but I'm not sure what you mean
by explicit vs implicit state machine, if you care to elaborate.


From colin.dunklau at gmail.com  Tue Feb  4 15:49:50 2020
From: colin.dunklau at gmail.com (Colin Dunklau)
Date: Tue, 4 Feb 2020 23:49:50 +0100
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>
 <CAMTx_3B7rtg8LNEfz8fd8fob24Ug+N5mMcEd0p63LpTgWn-Djg@mail.gmail.com>
 <32937360.kCLCYxncz1@fpbarry>
 <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>
Message-ID: <CAMTx_3AydBjqcfHo3_tUuuDKMR938e8qvB=FuH_zZoNVQnXB5w@mail.gmail.com>

On Tue, Feb 4, 2020 at 6:12 PM Go Luhng <goluhng at gmail.com> wrote:
>
> Thanks Colin and Barry for the reply. I read the sans-io docs and it
> is an attractive approach.
>
> I believe I have a plan going forward, but I'm not sure what you mean
> by explicit vs implicit state machine, if you care to elaborate.

IntNStringReceiver has a state machine, but it's embedded in the
protocol implementation, so it's implicit:
https://github.com/twisted/twisted/blob/twisted-19.10.0/src/twisted/protocols/basic.py#L682
It's not that easy to tell what's going on there, at first glance. The
dataReceived method has _most_ of the state machine implementation,
but it fiddles with instance attributes, and that length check in
sendString could be considered a parser detail, rather than part of
the protocol itself.

The situation with LineOnlyReceiver is similar:
https://github.com/twisted/twisted/blob/twisted-19.10.0/src/twisted/protocols/basic.py#L421
Now that one is simple enough that it's reasonably clear what's going
on... but it's a good candidate for a simple example (analysis first,
code after).

This is clearly more code, but the benefit from its clearer separation
of concerns is a boon... especially given that this is a reeeeal
simple example dealing with one of the simplest possible protocols.
Your protocol will undoubtedly be much more complex, so the benefit
should be a lot clearer.

In the original, the parsing details are mixed in with the
higher-level semantics of the protocol, especially with respect to the
max line length handling. In the "composed" version (admittedly not
the best name), the parser is explicit, and entirely divorced from the
protocol. It's easier to understand, simpler (even trivial) to test in
isolation, and winds up being reusable outside of a Twisted Protocol.
Hey, this is starting to sound like that sans-io thingie!

To map LineParser's semantics to sans-io terminology, readData is for
getting "input", and iterLines (actually the generator iterator it
makes) produces "events": a "line event", or a "line too darn long"
event (via the exception).

Link for easier viewing
(https://gist.github.com/cdunklau/4f8c72222295680ca20e3d4401f385b1),
reproduced here for list archive posterity:

    import collections

    from twisted.internet import protocol


    class LineParser(object):
        def __init__(self, delimiter, max_length):
            self.delimiter = delimiter
            self.max_length = max_length
            self._buffer = b''
            self._lines = collections.deque()

        def readData(self, data):
            lines = (self._buffer + data).split(self.delimiter)
            self._buffer = lines.pop()
            self._lines.extend(lines)

        def iterLines(self):
            while self._lines:
                line = self._lines.popleft()
                if len(line) > self.max_length:
                    raise LineLengthExceeded(line)
                yield line
            if len(self._buffer) > self.max_length:
                raise LineLengthExceeded(self._buffer)


    class LineLengthExceeded(Exception):
        def __init__(self, culprit):
            super().__init__(culprit)
            self.culprit = culprit


    class ComposedLineOnlyReceiver(protocol.Protocol):
        delimiter = b'\r\n'
        MAX_LENGTH = 16384
        _parser = None

        def dataReceived(self, data):
            """
            Translates bytes into lines, and calls lineReceived.
            """
            if self._parser is None:
                self._parser = LineParser(self.delimiter, self.MAX_LENGTH)

            self._parser.readData(data)
            try:
                for line in self._parser.iterLines():
                    if self.transport.disconnecting:
                        # this is necessary because the transport may
be told to lose
                        # the connection by a line within a larger
packet, and it is
                        # important to disregard all the lines in that
packet following
                        # the one that told it to close.
                        return
                    self.lineReceived(line)
            except LineLengthExceeded as e:
                return self.lineLengthExceeded(e.culprit)

        def lineReceived(self, line):
            """
            Override this for when each line is received.
            @param line: The line which was received with the delimiter removed.
            @type line: C{bytes}
            """
            raise NotImplementedError

        def sendLine(self, line):
            return self.transport.writeSequence((line, self.delimiter))

        def lineLengthExceeded(self, line):
            return self.transport.loseConnection()


From colin.dunklau at gmail.com  Wed Feb  5 01:48:41 2020
From: colin.dunklau at gmail.com (Colin Dunklau)
Date: Wed, 5 Feb 2020 09:48:41 +0100
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAO-tw_jFLfRBvfcoQvtdJsbfxHsSZYussvaFupRWxJMquiCXDw@mail.gmail.com>
 <CAMTx_3B7rtg8LNEfz8fd8fob24Ug+N5mMcEd0p63LpTgWn-Djg@mail.gmail.com>
 <32937360.kCLCYxncz1@fpbarry>
 <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>
Message-ID: <CAMTx_3BUrpw9rLG42VRVWg3NnMqvCM6_bGDSM3sTivZDNbpYEQ@mail.gmail.com>

On Tue, Feb 4, 2020 at 6:12 PM Go Luhng <goluhng at gmail.com> wrote:
>
> Thanks Colin and Barry for the reply. I read the sans-io docs and it
> is an attractive approach.
>
> I believe I have a plan going forward, but I'm not sure what you mean
> by explicit vs implicit state machine, if you care to elaborate.

I realize now that in my previous reply I conflated state machine with
parser state. Sorry about that!

Neither IntNStringReceiver nor LineOnlyReceiver has much in the way of
state. LineReceiver does, but it's a simple flag (line or raw mode).
conch.ssh's SSHTransportBase has more:
https://github.com/twisted/twisted/blob/twisted-19.10.0/src/twisted/conch/ssh/transport.py#L456-L471
This is reasonably explicit. It's still mixed in with the protocol
methods, but the states are at least explicitly declared.

I wasn't able to find an example in Twisted of an implicit state
machine. Maybe someone else has a concrete example somewhere?


From barry.scott at forcepoint.com  Wed Feb  5 08:09:28 2020
From: barry.scott at forcepoint.com (Barry Scott)
Date: Wed, 05 Feb 2020 15:09:28 +0000
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAMTx_3BUrpw9rLG42VRVWg3NnMqvCM6_bGDSM3sTivZDNbpYEQ@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>
 <CAMTx_3BUrpw9rLG42VRVWg3NnMqvCM6_bGDSM3sTivZDNbpYEQ@mail.gmail.com>
Message-ID: <2048928.Wt0HEHJxYC@fpbarry>

On Wednesday, 5 February 2020 08:48:41 GMT Colin Dunklau wrote:
> I wasn't able to find an example in Twisted of an implicit state
> machine. Maybe someone else has a concrete example somewhere?

There is an example of an explicit state machine in the twisted code
for http chunked transfer encoding.

Its in https://github.com/twisted/twisted/blob/trunk/src/twisted/web/
http.py#L1779

If there is code that assumes that it can react directly off of the events 
from a framework like twisted. When events happen in an unexpected
sequence you can end with errors. For example you can get a connectionLost
event at any time.

If you have a state machine it is easy to know what the clean actions will be.
But if there is no explicit state the code may not have the information it
needs to handle the connectionLost in an appropriate ways.

The situation with states and events only gets more complex when there
are deferred's that run after a connectionLost event and assume a connect
is still live. If such a deferred can check an explicit state it is far easier
to make the code work appropriately.

Barry




From goluhng at gmail.com  Thu Feb  6 09:02:40 2020
From: goluhng at gmail.com (Go Luhng)
Date: Thu, 6 Feb 2020 11:02:40 -0500
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <2048928.Wt0HEHJxYC@fpbarry>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <CAO-tw_gt7hQgu3tC20FW=HnzEhDM4Vzid6jWj=QZu4FYGpqCTw@mail.gmail.com>
 <CAMTx_3BUrpw9rLG42VRVWg3NnMqvCM6_bGDSM3sTivZDNbpYEQ@mail.gmail.com>
 <2048928.Wt0HEHJxYC@fpbarry>
Message-ID: <CAO-tw_isxNmXBz30im0t9vtae1yvK5pKSWH+JdUvpsZRwaxawg@mail.gmail.com>

Thanks for the detailed responses, Colin and Barry. I have a followup
question about sans-io. From the document:

> For input (that is, receiving data from the network), the
calling code is responsible for delivering code to the
implementation via a single input (often via a method called
receive_bytes, or something similar).

This sounds very nice, however with certain protocols, you canonly
decode serialized events based on context.

For example, the parser needs to know if we're at the handshake stage,
or the regular communication stage, or the shutdown stage, because
different formats of messages are sent by the server at each stage.

How does this elegantly fit into the scheme of sans-io?


From barry.scott at forcepoint.com  Thu Feb  6 11:29:41 2020
From: barry.scott at forcepoint.com (Barry Scott)
Date: Thu, 06 Feb 2020 18:29:41 +0000
Subject: [Twisted-Python] Supporting a two-part client protocol.
In-Reply-To: <CAO-tw_isxNmXBz30im0t9vtae1yvK5pKSWH+JdUvpsZRwaxawg@mail.gmail.com>
References: <CAO-tw_gt3z+5g8yB93zw=GTWMerBdWf__S=PAC9u4=cS9f-39Q@mail.gmail.com>
 <2048928.Wt0HEHJxYC@fpbarry>
 <CAO-tw_isxNmXBz30im0t9vtae1yvK5pKSWH+JdUvpsZRwaxawg@mail.gmail.com>
Message-ID: <3723792.iddL89eHtP@fpbarry>

On Thursday, 6 February 2020 16:02:40 GMT Go Luhng wrote:
> Thanks for the detailed responses, Colin and Barry. I have a followup
> 
> question about sans-io. From the document:
> > For input (that is, receiving data from the network), the
> 
> calling code is responsible for delivering code to the
> implementation via a single input (often via a method called
> receive_bytes, or something similar).
> 
> This sounds very nice, however with certain protocols, you canonly
> decode serialized events based on context.

That's not a protocol problem its an implementation problem surely?

> For example, the parser needs to know if we're at the handshake stage,
> or the regular communication stage, or the shutdown stage, because
> different formats of messages are sent by the server at each stage.
> 
> How does this elegantly fit into the scheme of sans-io?

The sans-io (as I remember it) says don't put IO details into your
protocol code, abstract it/have clean API boundaries. (Makes it
easy to write unit tests as you do not need to have a network stack.
Just make the API calls: dataReceived, connectionLost, timeout etc).

Its the job of your protocol code to have a state machine and
know where is at any point in time. What you are calling "stage"
sounds like a "state" of the state machine.

The pattern in very crude outline is:
Define all the events that the protocol must handle.
Define all the states the protocol needs. When each event is
received do the state specific action and change state.

You can see this in the chunked encoding code, with one
way to implement the state machine.

Also note that its usual for there is be more then one state machine
in most protocols. Using HTTP as an example it needs to handle the
command, headers then the body
handling the command and headers means splitting the byte stream into lines.
Once you have the headers you can figure out how to process the body.

1. State machine for overall HTTP status, headers, body
2. State machine to split bytes received into header lines
3. State machine for chunked body encoding
4. State machine for Content-Length body encoding.

Barry


> 
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python





From goluhng at gmail.com  Fri Feb  7 17:50:04 2020
From: goluhng at gmail.com (Go Luhng)
Date: Fri, 7 Feb 2020 19:50:04 -0500
Subject: [Twisted-Python] Inheriting DatagramProtocol,
 which is an old-style class
Message-ID: <CAO-tw_jJe2PfsWpdHgML+-fGpAimOGx7B+GdepAJ4Wg92Hke1g@mail.gmail.com>

I am creating a child class
`Child(twisted.internet.protocol.DatagramProtocol)` to implement a
custom UDP multicast protocol.

I need to add an `__init__()` to `Child`, but as part of that I need
to call `super()` which is impossible because `DatagramProtocol` is
old-style.

How should I proceed?

Also, why are there old-style classes in the latest release of Twisted?


From maarten at treewalker.org  Fri Feb  7 22:44:04 2020
From: maarten at treewalker.org (Maarten ter Huurne)
Date: Sat, 08 Feb 2020 06:44:04 +0100
Subject: [Twisted-Python] Inheriting DatagramProtocol,
 which is an old-style class
In-Reply-To: <CAO-tw_jJe2PfsWpdHgML+-fGpAimOGx7B+GdepAJ4Wg92Hke1g@mail.gmail.com>
References: <CAO-tw_jJe2PfsWpdHgML+-fGpAimOGx7B+GdepAJ4Wg92Hke1g@mail.gmail.com>
Message-ID: <7604975.74ho7zvVvB@hyperion>

On Saturday, 8 February 2020 01:50:04 CET Go Luhng wrote:
> I am creating a child class
> `Child(twisted.internet.protocol.DatagramProtocol)` to implement a
> custom UDP multicast protocol.
> 
> I need to add an `__init__()` to `Child`, but as part of that I need
> to call `super()` which is impossible because `DatagramProtocol` is
> old-style.
> 
> How should I proceed?

There is no __init__() in DatagramProtocol or in its superclass 
AbstractDatagramProtocol, so you can just skip the call.

> Also, why are there old-style classes in the latest release of
> Twisted?

I don't know the reason, but it seems to be deliberate, since 
AbstractDatagramProtocol is annotated with @_oldStyle in the source.

Bye,
		Maarten




From twm at freecog.net  Fri Feb  7 22:58:48 2020
From: twm at freecog.net (Tom Most)
Date: Fri, 07 Feb 2020 21:58:48 -0800
Subject: [Twisted-Python] 
 =?utf-8?q?Inheriting_DatagramProtocol=2C_which_?=
 =?utf-8?q?is_an_old-style_class?=
In-Reply-To: <7604975.74ho7zvVvB@hyperion>
References: <CAO-tw_jJe2PfsWpdHgML+-fGpAimOGx7B+GdepAJ4Wg92Hke1g@mail.gmail.com>
 <7604975.74ho7zvVvB@hyperion>
Message-ID: <7de7ff9d-6341-4ac0-8724-8931b5f0723a@www.fastmail.com>

Old-style classes remain old-style for compatibility reasons. You have some options, though:

1. Set the TWISTED_NEWSTYLE environment variable [1] to make all such old-style classes new-style.
2. When subclassing it, also subclass object, making the result new-style.
3. Switch to Python 3, where all-classes are new-style.

Option 3 is the best, since we will drop Python 2.7 support soon enough. Option 1 may be helpful when migrating a codebase.

---Tom

[1]: https://github.com/twisted/twisted/blob/c0a51509974e995537212efc5074140388585da6/src/twisted/python/compat.py#L61

On Fri, Feb 7, 2020, at 9:44 PM, Maarten ter Huurne wrote:
> On Saturday, 8 February 2020 01:50:04 CET Go Luhng wrote:
> > I am creating a child class
> > `Child(twisted.internet.protocol.DatagramProtocol)` to implement a
> > custom UDP multicast protocol.
> > 
> > I need to add an `__init__()` to `Child`, but as part of that I need
> > to call `super()` which is impossible because `DatagramProtocol` is
> > old-style.
> > 
> > How should I proceed?
> 
> There is no __init__() in DatagramProtocol or in its superclass 
> AbstractDatagramProtocol, so you can just skip the call.
> 
> > Also, why are there old-style classes in the latest release of
> > Twisted?
> 
> I don't know the reason, but it seems to be deliberate, since 
> AbstractDatagramProtocol is annotated with @_oldStyle in the source.
> 
> Bye,
> 		Maarten


From goluhng at gmail.com  Sun Feb  9 06:19:13 2020
From: goluhng at gmail.com (Go Luhng)
Date: Sun, 9 Feb 2020 08:19:13 -0500
Subject: [Twisted-Python] Inheriting DatagramProtocol,
 which is an old-style class
In-Reply-To: <7de7ff9d-6341-4ac0-8724-8931b5f0723a@www.fastmail.com>
References: <CAO-tw_jJe2PfsWpdHgML+-fGpAimOGx7B+GdepAJ4Wg92Hke1g@mail.gmail.com>
 <7604975.74ho7zvVvB@hyperion>
 <7de7ff9d-6341-4ac0-8724-8931b5f0723a@www.fastmail.com>
Message-ID: <CAO-tw_jVQAvXO8mqE7WEhFMtf_2Nf8KVt9G0-w=eNry=Gh_wTw@mail.gmail.com>

Thanks!  I will likely choose option 2, since I'm stuck on a very
large legacy pile of Python 2 code that I can't port up just yet.

On Sat, Feb 8, 2020 at 12:59 AM Tom Most <twm at freecog.net> wrote:
>
> Old-style classes remain old-style for compatibility reasons. You have some options, though:
>
> 1. Set the TWISTED_NEWSTYLE environment variable [1] to make all such old-style classes new-style.
> 2. When subclassing it, also subclass object, making the result new-style.
> 3. Switch to Python 3, where all-classes are new-style.
>
> Option 3 is the best, since we will drop Python 2.7 support soon enough. Option 1 may be helpful when migrating a codebase.
>
> ---Tom
>
> [1]: https://github.com/twisted/twisted/blob/c0a51509974e995537212efc5074140388585da6/src/twisted/python/compat.py#L61
>
> On Fri, Feb 7, 2020, at 9:44 PM, Maarten ter Huurne wrote:
> > On Saturday, 8 February 2020 01:50:04 CET Go Luhng wrote:
> > > I am creating a child class
> > > `Child(twisted.internet.protocol.DatagramProtocol)` to implement a
> > > custom UDP multicast protocol.
> > >
> > > I need to add an `__init__()` to `Child`, but as part of that I need
> > > to call `super()` which is impossible because `DatagramProtocol` is
> > > old-style.
> > >
> > > How should I proceed?
> >
> > There is no __init__() in DatagramProtocol or in its superclass
> > AbstractDatagramProtocol, so you can just skip the call.
> >
> > > Also, why are there old-style classes in the latest release of
> > > Twisted?
> >
> > I don't know the reason, but it seems to be deliberate, since
> > AbstractDatagramProtocol is annotated with @_oldStyle in the source.
> >
> > Bye,
> >               Maarten
>
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python


From trac at twistedmatrix.com  Sun Feb 16 00:05:32 2020
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 16 Feb 2020 07:05:32 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1581836732.13.8007906971282956915@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20200216/4136e7c9/attachment.htm>

From trac at twistedmatrix.com  Sun Feb 23 00:05:29 2020
From: trac at twistedmatrix.com (trac at twistedmatrix.com)
Date: Sun, 23 Feb 2020 07:05:29 -0000
Subject: [Twisted-Python] Weekly Bug Summary
Message-ID: 1582441529.34.1451202394988667337@twistedmatrix.com

An HTML attachment was scrubbed...
URL: </pipermail/twisted-python/attachments/20200223/a3be7900/attachment.htm>

