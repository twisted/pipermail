From glyph at twistedmatrix.com  Mon Apr  2 00:58:51 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 1 Apr 2001 23:58:51 -0500 (CDT)
Subject: [Twisted-Python] upon further consideration...
Message-ID: <Pine.LNX.4.21.0104012357380.8876-100000@zaibach.twistedmatrix.com>

Nick, I think you're right.  I'm going to scrap the verb-oriented dispatch
system for something MUCH more like Inform's style.  I'm still working out
the design, but when I've got something substantial, I'll post again.

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph





From nick at zork.net  Mon Apr  2 03:31:04 2001
From: nick at zork.net (Nick Moffitt)
Date: Mon, 2 Apr 2001 00:31:04 -0700
Subject: [Twisted-Python] upon further consideration...
In-Reply-To: <Pine.LNX.4.21.0104012357380.8876-100000@zaibach.twistedmatrix.com>; from glyph@twistedmatrix.com on Sun, Apr 01, 2001 at 11:58:51PM -0500
References: <Pine.LNX.4.21.0104012357380.8876-100000@zaibach.twistedmatrix.com>
Message-ID: <20010402003103.N18346@zork.net>

begin  Glyph Lefkowitz quotation:
> Nick, I think you're right.  I'm going to scrap the verb-oriented
> dispatch system for something MUCH more like Inform's style.  I'm
> still working out the design, but when I've got something
> substantial, I'll post again.

	Good heavens.  Well I must admit that my earlier messages were
driven largely by naivete rather than pure technical prowess.

	I've been playing with twisted-python more and more lately,
and have been trying to build a smallish game.  As such, I think I'm
getting a feel for what you had in mind pre-0.8.x, so let me post what
I was thinking about the nasty verb problem (goddamn action-oriented
structures in an object-oriented world!).

	I had thought about your verb-based dispatch system, and
decided that before I'd sit down and read your code, I'd think about
how I would implement such a beast.

	I decided that all basic verbs would be implemented in the
direct object.  As such, that meant that the parser would identify the
DO rather than the verb, initially, and then go looking for the object
that represents the DO.

	The search pattern for a sentence with no DO ("Shoot at
dalek") would be actor, actor's contents, and the contents of actor's
location.  So you could have a player with laser-eyes, a handgun, and
a nearby trebuchet, all capable of "shoot"ing, but the laser-eyes
would win out unless a DO was specified.

	Indirect objects would have a special kind of verb form for
"catching" actions performed by direct objects.  They'd accept the
sentence's DO as the subject, as well as any prepositions (to know if
you're putting the coin IN the piggy bank or merely ON it).	

	Pre- and post- hooks are easily done by overloading and
putting code before or after you call your parent's version of a verb.

	Anyway, this is largely cafe musing, but I had diagrammed out
the traditional "throw rock at dalek" scenario and it seemed to make
sense. 

	I'm sure there are better ways to merge the handling of verbs
with python's object system.  It is kind of neat to just read through
an object and pull out functions that match a simple pattern.

	Left unadressed was the synonym problem (making "examine" and
"look at" synonymous in the general case), though I doubt it's that
complicated.

	

-- 
You are not entitled to your opinions.
 
	01234567 <- The amazing indent-o-meter!
        ^	    Matt McIrvin: the Nikola Tesla of tab damage.




From washort at iceman  Sat Apr  7 06:39:06 2001
From: washort at iceman (Allen Short)
Date: Sat, 07 Apr 2001 05:39:06 -0500
Subject: [Twisted-Python] The King of Spain never rushes
Message-ID: <20010407053906H.washort@iceman>

AUSTIN (AP) -- Work proceeds apace on the Twisted Reality Demo Center,
the long-awaited spectacular showcase from Twisted Matrix Labs. "Eat
your heart out Verant, Bioware, and Blizzard", chairman and Evil
Overlord Glyph Lefkowitz was overheard saying, "we have more internet
than you can possibly imagine. Heck, we've even gotten an endorsement
from John Romero."  When asked to comment, Mr Romero squeakily
responded "That tickles!".  Chief Reality Engineer Allen Short refused
to discuss specific technical advances over previous releases, saying
only "You know it's gonna rock. Where or when are minor details."


All seriousness aside, I've begun to port the Java code for the TR
demo to the current system. Right now, we have Mr Romero and the water
fountain; their code is in trdemo/trdemo.py, along with
trdemo/build_map, the mapfile.  I've added a Box class to
twisted.library; problem is, it doesn't work quite right. (Try putting
something in a box to see what i mean =) 


PS: glyph, have you added the verb-chaining stuff yet? i've a case or
two that wants it. 


-- 
Allen Short, CS Geek                  shortwa at auburn.edu
favorite toys: Lisp/Smalltalk/Python/Jabber/XEmacs/Linux
<demoncrat> I think nowadays sisyphus would have to reinstall windows
            all the time  




From carmstro at dynup.net  Sun Apr  8 21:04:02 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sun, 8 Apr 2001 21:04:02 -0400
Subject: [Twisted-Python] config interface
Message-ID: <20010408210402.A325@Fookidla.org>

I've been working a whole lot on the config interface, and I don't like 
how things are working right now. 

configurable objects are organized in a tree. Every object defines these
methods:

    #ContainableTypes should return a list of classes that
    #it can hold.
    def configContainableTypes(self): pass

    #Type should return the type of the current object
    def configType(self): pass
    
    #GetContents should return a dict of children of this object. {"name": obj}
    def configGetChildren(self): pass

    #AddItem should add a child to this object
    def configAddItem(self, id, item): pass

    #RemoveItem should remove a child from this object.
    def configRemoveItem(self, id): pass

I'd like to change this API somewhat to allow different paramaters to add and 
remove item methods. Not all objects need ids to add an object, and it's not
natural for some objects to represent their contents as a dict (selectors,
for instance). I was thinking about a solution similar to the improper-state
trick that glyph described to me, only it would just look at the arguments
that a method needs rather than a constructor of a class.

So, maybe there could be standardized names for paramaters of AddItem or
RemoveItem so that a front-end would know what exactly to get from the user
to add or remove an item. GetChildren could also just return either a list
or a dict, and the front-end would handle it appropriately.

This is not a developed idea at all, and I just wanna run it by anyone who
cares. Standardizing names of paramaters doesn't seem very clean to me, but
I can't think of much else..
-- 
Chris Armstrong   http://twistedmatrix.com/~carmstro     carmstro at dynup.net
There is a 90% chance that this message was written when the author's been
awake longer than he should have. Please disregard any senseless drivel.




From glyph at twistedmatrix.com  Wed Apr 11 07:31:32 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 11 Apr 2001 06:31:32 -0500
Subject: [Twisted-Python] config interface
In-Reply-To: <20010408210402.A325@Fookidla.org>
References: <20010408210402.A325@Fookidla.org>
Message-ID: <0104110528160H.26755@helix>

On Sunday 08 April 2001 20:04, you wrote:
> configurable objects are organized in a tree. Every object defines these
> methods:

>     #ContainableTypes should return a list of classes that
>     #it can hold.
>     def configContainableTypes(self): pass

This seems fine...

>     #Type should return the type of the current object
>     def configType(self): pass

I don't think this is necessary though.  Can't you just use the Python class?

>     #GetContents should return a dict of children of this object. {"name":
> obj} def configGetChildren(self): pass

Seems like a list of tuples (.items() style) might be more appropriate than a 
dict, considering that this really isn't mutable.

>     #AddItem should add a child to this object
>     def configAddItem(self, id, item): pass

Also fine...

>     #RemoveItem should remove a child from this object.
>     def configRemoveItem(self, id): pass

> I'd like to change this API somewhat to allow different paramaters to add
> and remove item methods. Not all objects need ids to add an object, and
> it's not natural for some objects to represent their contents as a dict
> (selectors, for instance). I was thinking about a solution similar to the
> improper-state trick that glyph described to me, only it would just look at
> the arguments that a method needs rather than a constructor of a class.

That trick is a necessary addition to the API in any case -- these functions 
aren't enough.  However, you might want to have ConfigurableDictionary, 
ConfigurableItem, and ConfigurableSequence types which have different ideas 
about how things get added to them.


In order for new configurable things to be instantiatable, you'll need API 
additions like:

def configGetRequiredInitArgs(self)

This returns a 2-tuple of a sequence and a hash.  The first sequence is a 
list of types/classes of the required arguments, in order, and the second is 
a hash of name:type/class of optional argument.

These arguments get filled in by your configuration interface code, and 
passed to:

def configCheckInitArgs(self, args, kw)

This to separate preconditions of the init from the init itself -- if this 
indicates there's something wrong with the arguments (for example, an integer 
is outside of its acceptable range) then this message can be displayed to the 
user for them to try again.

def configDoInit(self, args, kw)

This will most likely be a passthru to self.__init__, probably frequently 
enough to make that the default implementation, but since 
configGetRequiredInitArgs may want to do some pre-initialization, things 
could be different.


Note that if something returned by configGetRequiredInitArgs is a class, that 
class be configurable as well -- that, and your interface may need to be 
somewhat recursive in order to allow you to pass configurable elements to the 
initializers of other configurable elements... I'd recommend trying to get 
something work only supporting basic types at first.

Also, what are you planning on doing for configuring an object's attributes?  
It seems like that should behave differently from configuring the objects it 
contains.


-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Wed Apr 11 11:42:20 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 11 Apr 2001 11:42:20 -0400
Subject: [Twisted-Python] config interface
In-Reply-To: <0104110528160H.26755@helix>; from glyph@twistedmatrix.com on Wed, Apr 11, 2001 at 06:31:32AM -0500
References: <20010408210402.A325@Fookidla.org> <0104110528160H.26755@helix>
Message-ID: <20010411114220.A2931@Fookidla.org>

On Wed, Apr 11, 2001 at 06:31:32AM -0500, Glyph Lefkowitz wrote:
> >     #Type should return the type of the current object
> >     def configType(self): pass
> 
> I don't think this is necessary though.  Can't you just use the Python class?

You're right. I was switching to classes for the type system, anyway.

> >     #GetContents should return a dict of children of this object. {"name":
> > obj} def configGetChildren(self): pass
> 
> Seems like a list of tuples (.items() style) might be more appropriate than a 
> dict, considering that this really isn't mutable.

Ok, makes sense.

> > I'd like to change this API somewhat to allow different paramaters to add
> > and remove item methods. Not all objects need ids to add an object, and
> > it's not natural for some objects to represent their contents as a dict
> > (selectors, for instance). I was thinking about a solution similar to the
> > improper-state trick that glyph described to me, only it would just look at
> > the arguments that a method needs rather than a constructor of a class.
> 
> That trick is a necessary addition to the API in any case -- these functions 
> aren't enough.  However, you might want to have ConfigurableDictionary, 
> ConfigurableItem, and ConfigurableSequence types which have different ideas 
> about how things get added to them.

I don't understand what those methods should do. Could you explain a bit
more?

The main thing I was confused about was what exact paramaters might 
configAddItem and configRemoveItem need. Not all containers will have an
'id' for each of their children, but I suppose they could be somehow
generated. For instance, for Selector, I was starting to implement the ids
for each server as 'str(serverObj)', but this didn't seem very nice to me.
I guess now that I think of it again, it doesn't seem all that bad. I might
need to add id(Obj) onto that, though, in some cases.

The following you described to me on IRC, but I appreciate you organizing
it for my benefit. :)

> In order for new configurable things to be instantiatable, you'll need API 
> additions like:
> 
> def configGetRequiredInitArgs(self)
> 
> This returns a 2-tuple of a sequence and a hash.  The first sequence is a 
...
> Note that if something returned by configGetRequiredInitArgs is a class, that 
> class be configurable as well -- that, and your interface may need to be 
> somewhat recursive in order to allow you to pass configurable elements to the 
> initializers of other configurable elements... I'd recommend trying to get 
> something work only supporting basic types at first.

That sounds pretty neat. Recursion is such fun. :)

> Also, what are you planning on doing for configuring an object's attributes?  
> It seems like that should behave differently from configuring the objects it 
> contains.

I already have that implemented. Remember config_strings and config_callbacks?


Thanks for the reply
-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From glyph at twistedmatrix.com  Wed Apr 11 11:50:05 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 11 Apr 2001 10:50:05 -0500
Subject: [Twisted-Python] And Now I Eat humble.py
Message-ID: <0104111050060L.26755@helix>

Well, the "Super-Duper It-Can't-Break 
No-Really-It's-Not-Like-The-Java-Version-I-Swear" version of containment in 
Twisted Reality broke rather nastily after dash sent out his update email 
regarding the demo.  I *think* I've got it mostly fixed now... at least, a 
nastily contrived, pathological unit test passes, and it appears to do the 
correct thing interactively.  It doesn't try to keep track of nearly so much 
stuff now, so even if it does break, it's likely that the breakage will be in 
event updates and not the actual structure of the game.

Curiously enough, all this stuff broke when we introduced a certain 
mechanical cockroach into the demo world...

In other news, I've ported the old Java Faucet to Jython (only works on 
2.1a1, since previous versions of jython don't implement getattr properly!!), 
which means that the faucet is runnable with a nice gui on MacOS X now.  The 
other important note is that since Gloop now works on Jython, it is possible 
to hook arbitrary Java programs and libraries into a Gloop distributed 
network (this turned out to be very simple, actually).  The possibilities of 
this are left as an exercise for the reader.

Currently, I'm adding features to the demo -- testing guest login -- and 
taking some screenshots of various GUI things.  The way things are going at 
this point, I think the next release (after the demo is done) should be 
0.9.0; post that, (after carmstro's config interface is done, and hopefully 
Inheritance) we should move on to 0.99.0 and concentrate mainly on writing 
tests... once we've tested every module, 1.0.

This concludes this morning's State of the Matrix Address :)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Wed Apr 11 12:00:48 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 11 Apr 2001 12:00:48 -0400
Subject: [Twisted-Python] And Now I Eat humble.py
In-Reply-To: <0104111050060L.26755@helix>; from glyph@twistedmatrix.com on Wed, Apr 11, 2001 at 10:50:05AM -0500
References: <0104111050060L.26755@helix>
Message-ID: <20010411120048.A2985@Fookidla.org>

On Wed, Apr 11, 2001 at 10:50:05AM -0500, Glyph Lefkowitz wrote:
> Currently, I'm adding features to the demo -- testing guest login -- and 
> taking some screenshots of various GUI things.  The way things are going at 
> this point, I think the next release (after the demo is done) should be 
> 0.9.0; post that, (after carmstro's config interface is done, and hopefully 
> Inheritance) we should move on to 0.99.0 and concentrate mainly on writing 
> tests... once we've tested every module, 1.0.

I'd like to propose making web.py a package for the TODO for 1.0. :)

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From glyph at twistedmatrix.com  Wed Apr 11 12:31:12 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 11 Apr 2001 11:31:12 -0500
Subject: [Twisted-Python] config interface
In-Reply-To: <20010411114220.A2931@Fookidla.org>
References: <20010408210402.A325@Fookidla.org> <0104110528160H.26755@helix> <20010411114220.A2931@Fookidla.org>
Message-ID: <0104111131120M.26755@helix>

On Wednesday 11 April 2001 10:42, you wrote:

> > That trick is a necessary addition to the API in any case -- these
> > functions aren't enough.  However, you might want to have
> > ConfigurableDictionary, ConfigurableItem, and ConfigurableSequence types
> > which have different ideas about how things get added to them.
>
> I don't understand what those methods should do. Could you explain a bit
> more?

class Configurable
class ConfigurableDict(UserDict.UserDict, Configurable)
class ConfigurableSequence(UserList.UserList, Configurable)

Rather than adding a whole new interface (configAddItem etc) why not just use 
the built-in list/dictionary interfaces for the two kinds of collection you 
have?

> The main thing I was confused about was what exact paramaters might
> configAddItem and configRemoveItem need. Not all containers will have an
> 'id' for each of their children, but I suppose they could be somehow
> generated. For instance, for Selector, I was starting to implement the ids
> for each server as 'str(serverObj)', but this didn't seem very nice to me.
> I guess now that I think of it again, it doesn't seem all that bad. I might
> need to add id(Obj) onto that, though, in some cases.

I don't really understand why this is relevant; why would you need IDs for 
servers?  Aren't they just added in some order (a list)?

> > Also, what are you planning on doing for configuring an object's
> > attributes? It seems like that should behave differently from configuring
> > the objects it contains.
>
> I already have that implemented. Remember config_strings and
> config_callbacks?

I'm still not 100% comfortable with that implementation, but I suppose it can 
be refactored later.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Wed Apr 11 15:10:07 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 11 Apr 2001 15:10:07 -0400
Subject: [Twisted-Python] config interface
In-Reply-To: <0104111131120M.26755@helix>; from glyph@twistedmatrix.com on Wed, Apr 11, 2001 at 11:31:12AM -0500
References: <20010408210402.A325@Fookidla.org> <0104110528160H.26755@helix> <20010411114220.A2931@Fookidla.org> <0104111131120M.26755@helix>
Message-ID: <20010411151007.A3314@Fookidla.org>

On Wed, Apr 11, 2001 at 11:31:12AM -0500, Glyph Lefkowitz wrote:
> > I don't understand what those methods should do. Could you explain a bit
> > more?
> 
> class Configurable
> class ConfigurableDict(UserDict.UserDict, Configurable)
> class ConfigurableSequence(UserList.UserList, Configurable)
> 
> Rather than adding a whole new interface (configAddItem etc) why not just use 
> the built-in list/dictionary interfaces for the two kinds of collection you 
> have?

Ok, I get you know. Good idea. :)

> 
> > The main thing I was confused about was what exact paramaters might
> > configAddItem and configRemoveItem need. Not all containers will have an
> > 'id' for each of their children, but I suppose they could be somehow
> > generated. For instance, for Selector, I was starting to implement the ids
> > for each server as 'str(serverObj)', but this didn't seem very nice to me.
> > I guess now that I think of it again, it doesn't seem all that bad. I might
> > need to add id(Obj) onto that, though, in some cases.
> 
> I don't really understand why this is relevant; why would you need IDs for 
> servers?  Aren't they just added in some order (a list)?

Exactly, servers really don't have IDs. But other things do. That's why I was
confused in the first place. But it is useful to have them for the UI.
str(serverObj) may not be that user friendly, but it has to be unique.
Also the ID is needed for deleting things from the selector.

Now that I think of it, with your dict and list overriding ideas, I don't
think IDs would even be needed. Or maybe they would. I'll work on it. :)

> > I already have that implemented. Remember config_strings and
> > config_callbacks?
> 
> I'm still not 100% comfortable with that implementation, but I suppose it can 
> be refactored later.

Okie dokie.
-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From carmstro at dynup.net  Fri Apr 13 20:13:37 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Fri, 13 Apr 2001 20:13:37 -0400
Subject: [Twisted-Python] weird problem with subclassing library.door.Door
Message-ID: <20010413201337.A6302@Fookidla.org>

Ok, I made a subclass of Door called SecretDoor. The point of this door is
that it's opened with a remote button and is not visible unless it is open.
I tried implementing this by overriding _close() in my class.

class SecretDoor(door.Door):
    def verb_open(self, sentence):
            sentence.subject.hears("This door is opened elsewhere.")

    def _close(self, actor):
        self._undescribe()

Unfortunately, this did not work.
The _undescribe call was apparently being cancelled out by something that was
resetting the description in the current room. I looked for calls to 
_redescribe(), but couldn't find any that were being called after my 
_undescribe(). Eventually I just decided to hack it out and added:

    def _redescribe(self):
        if not self.isOpen:
            self._undescribe()
        else:
            door.Door._redescribe(self)

This is very bad, but I could not figure out any other way to do it. I still
have it this way, and I just wanted to notify glyph and anyone else who's
interested. Is there a better way to do this? Where is the description being
added back into the room?

Ahh well, thanks a bunch.

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Mon Apr 16 17:07:08 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 00:07:08 +0300
Subject: [Twisted-Python] twisted.net refactoring
Message-ID: <E14pGDE-0000nW-00@darjeeling>

Hi!
I've started to work on refactoring twisted.net for minimal dependancies.
Currently, in the vein of "research project", what interests me is how
layering of protocols in an event-oriented framework can be accomplished.
Please have a look at http://moshez.org/protocols.tgz
I've written tests for all the protocol handlers I wrote, and I'd
be happy to work with anyone who wants to write tests for the irc client
and telnet server.

Basically, the idea is to turn low-level events (basically just handleData)
into high level events (like handleRequest, for HTTP, at the other end
of the spectrum). The idea is to reflect the layering of protocols (and 
only the layering of protocols -- read on) in the classes. 

So, inheritance happens when the spec references another spec -- e.g.,
XML-RPC is defined to be over HTTP, so it would be correct to have

class XMLRPCHandler(HTTPHandler):

    def handleRequest(self, command, selector, version, request):
        ...parse request into Python tuple...
        result = self.handleMethod(params)
        ....return HTTP response...

But, on the other hand, HTTP does not say anything about TCP/IP, so
HTTP should *not* be layered above any transport. This allows us to
use SSL, SOCKS or files just as well.

One big advantage I'm interested in is testability -- see the examples
already there to get my point -- you can bombard your handler hard-coded
strings and watch for the answers.
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Tue Apr 17 04:15:42 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 17 Apr 2001 03:15:42 -0500
Subject: [Twisted-Python] twisted.net refactoring
In-Reply-To: <E14pGDE-0000nW-00@darjeeling>
References: <E14pGDE-0000nW-00@darjeeling>
Message-ID: <01041703154214.26755@helix>

This is definitely the direction I want twisted.net to be going in.  Thank 
you for implmenting it (as well as the additional protocols!).

Have you started making the requisite changes in net.py as well?

On Monday 16 April 2001 16:07, you wrote:
> Hi!
> I've started to work on refactoring twisted.net for minimal dependancies.
> Currently, in the vein of "research project", what interests me is how
> layering of protocols in an event-oriented framework can be accomplished.
> Please have a look at http://moshez.org/protocols.tgz
> I've written tests for all the protocol handlers I wrote, and I'd
> be happy to work with anyone who wants to write tests for the irc client
> and telnet server.
>
> Basically, the idea is to turn low-level events (basically just handleData)
> into high level events (like handleRequest, for HTTP, at the other end
> of the spectrum). The idea is to reflect the layering of protocols (and
> only the layering of protocols -- read on) in the classes.
>
> So, inheritance happens when the spec references another spec -- e.g.,
> XML-RPC is defined to be over HTTP, so it would be correct to have
>
> class XMLRPCHandler(HTTPHandler):
>
>     def handleRequest(self, command, selector, version, request):
>         ...parse request into Python tuple...
>         result = self.handleMethod(params)
>         ....return HTTP response...
>
> But, on the other hand, HTTP does not say anything about TCP/IP, so
> HTTP should *not* be layered above any transport. This allows us to
> use SSL, SOCKS or files just as well.
>
> One big advantage I'm interested in is testability -- see the examples
> already there to get my point -- you can bombard your handler hard-coded
> strings and watch for the answers.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Tue Apr 17 04:30:56 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 11:30:56 +0300
Subject: [Twisted-Python] twisted.net refactoring
In-Reply-To: <01041703154214.26755@helix>
References: <01041703154214.26755@helix>, <E14pGDE-0000nW-00@darjeeling>
Message-ID: <E14pQsy-0001s8-00@darjeeling>

On Tue, 17 Apr 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:

> This is definitely the direction I want twisted.net to be going in.  Thank 
> you for implmenting it (as well as the additional protocols!).
> 
> Have you started making the requisite changes in net.py as well?

Not yet. 
I'm not *exactly* sure of the design of net.py itself -- it's a bit
too big for me to digest it right now.
Twisted.net is not the only one that needs to be changed though --
.web, .irc and .telnet should also be modified to take advantage
of it. 

I'm starting to think I want to change my original direction a bit --
just have protocols as twisted.protocols package, think of it as
a library that bridges a level mismatch in event-based protocol
handling -- that is, transforms low-level events (got chunk of
data) into semantic events (got an e-mail message). Then we can
port .net and friends over one by one when we have the chance.

IOW .net should specialize in things that call .handleData and and supply
.write, and .protocols should specialize in providing mixins that supply
.handleData and .write -- and never the twain shall meet, except in high-level
things like twisted.web or twisted.irc which use .net *and* .protocols
to provide useful services. Well, actually, the interface should be
enhanced to .goodBye() -- this is a method .net's should provide and
.protocol's use to signal the remote end requested a shutdown. Oh, 
and .welcome() which the .net's should call 

.net and .protcols should be considered seperate packages that are not
allowed to have any dependancy on any part of twisted.

So here is a summary
- .protocol -- has .welcome() and .handleData method, will call .write()
  and .goodBye() methods.
- .net -- has .write() and .goodBye() methods, will call .welcome() on
  connecting and .handleData() when the transport layer has data.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Mon Apr 16 14:32:44 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: 16 Apr 2001 18:32:44 -0000
Subject: [Twisted-Python] First Port to twisted.protocols
Message-ID: <20010416183244.26197.qmail@stimpy.scso.com>

I'll check in the protocols stuff later today.
In the mean time, for you early adopters, http://moshez.org/protocls.tgz
has the latest and snazziest.
And....as a special surprise, I've ported twisted.web over to stop
knowing so much HTTP. HTTP knowledge used to be smeared all over
Request and HTTPHandler, and now neither of them knows much HTTP.





From moshez at zadka.site.co.il  Tue Apr 17 11:53:57 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 18:53:57 +0300
Subject: [Twisted-Python] First Port to twisted.protocols
In-Reply-To: <20010416183244.26197.qmail@stimpy.scso.com>
References: <20010416183244.26197.qmail@stimpy.scso.com>
Message-ID: <E14pXnh-0002x3-00@darjeeling>

On 16 Apr 2001 18:32:44 -0000, Moshe Zadka <moshez at zadka.site.co.il> wrote:

> I'll check in the protocols stuff later today.

As promised, I've check it in.

> And....as a special surprise, I've ported twisted.web over to stop
> knowing so much HTTP. HTTP knowledge used to be smeared all over
> Request and HTTPHandler, and now neither of them knows much HTTP.

I'm working on integrating and testing my web.py port.
I'll think of Resource testability later. 
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Tue Apr 17 14:58:38 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 21:58:38 +0300
Subject: [Twisted-Python] First Port to twisted.protocols
In-Reply-To: <E14pXnh-0002x3-00@darjeeling>
References: <E14pXnh-0002x3-00@darjeeling>, <20010416183244.26197.qmail@stimpy.scso.com>
Message-ID: <E14pagQ-0003Yp-00@darjeeling>

On Tue, 17 Apr 2001 18:53:57 +0300, Moshe Zadka <moshez at zadka.site.co.il> wrote:
 
> > I'll check in the protocols stuff later today.
> 
> As promised, I've check it in.

And now I've fixed a little bug in twisted.protocols.http
The HTTP server code now works fine.

> > And....as a special surprise, I've ported twisted.web over to stop
> > knowing so much HTTP. HTTP knowledge used to be smeared all over
> > Request and HTTPHandler, and now neither of them knows much HTTP.
> 
> I'm working on integrating and testing my web.py port.

Here's a first rough patch to do that:

Please do *not* apply it -- I've got some ideas about improving the
HTTP handlers to make it even smoother.

Stay tuned!

Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.81
diff -c -r1.81 web.py
*** twisted/web.py	2001/04/12 17:32:14	1.81
--- twisted/web.py	2001/04/17 18:59:16
***************
*** 29,34 ****
--- 29,36 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ import twisted.protocols.http
+ from twisted import protocols
  
  # Useful constants
  
***************
*** 238,280 ****
              else:
                  return name
  
!     def __init__(self, blob):
          # parse the blob
          # ...
          split = string.split
          find = string.find
          lower = string.lower
  
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
          received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         reqfields = split(reqstring, ' ')
! 
!         assert 2 <= len(reqfields) <=3, "Invalid request format."
! 
!         self.method, self.uri = reqfields[0], reqfields[1]
! 
!         if len(reqfields) == 2:
!             # we are dealing with HTTP/0.9
!             self.clientproto = "HTTP/0.9"
!         else:
!             self.clientproto = reqfields[2]
! 
!         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = urllib.unquote(self.uri)
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = urllib.unquote(x[0]), x[1]
              for kvp in split(argstring,'&'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
--- 240,270 ----
              else:
                  return name
  
!     def __init__(self, method, uri, version, blob):
          # parse the blob
          # ...
          split = string.split
          find = string.find
          lower = string.lower
  
!         blobf = StringIO.StringIO(blob)
          received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri, self.clientproto = method, uri, version
!         self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = self.uri
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = x[0], x[1]
              for kvp in split(argstring,'&'):
!                 keyval = split(kvp, '=')
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
***************
*** 282,304 ****
                      else:
                          args[key] = [value]
  
!         for header in blobs:
              x = find(header,":")
              if x != -1:
                  received[lower(header[:x])] = header[x+2:]
              else:
                  print 'Invalid HTTP/1.1 protocol message?'
                  print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
--- 272,292 ----
                      else:
                          args[key] = [value]
  
!         while 1:
!             header = blobf.readline()
!             if header == '\n':
!                 break
              x = find(header,":")
              if x != -1:
                  received[lower(header[:x])] = header[x+2:]
              else:
                  print 'Invalid HTTP/1.1 protocol message?'
                  print header
!         self.content = blobf.read()
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
***************
*** 370,387 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.write("%s %s %s\r\n" % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write("%s: %s\r\n" % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
--- 358,372 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.handler.sendStatus(self.code, message)
!                 for header, value in self.headers.items():
!                     self.handler.sendHeader(header, value)
!                 self.handler.endHeaders
!         self.handler.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
***************
*** 1386,1441 ****
              return page
  
  
! class HTTPHandler(net.GenericHandler):
!     contentLength = 0
!     request = None
!     recvd = ""
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def _process(self, request):
!         """ (private) """
!         request.handler = self
!         request.process(self.server)
! 
!     def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend < 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
-         if self.contentLength:
-             if len(self.recvd) >= self.contentLength:
-                 self.request.content = recvd[:self.contentLength]
-                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1371,1387 ----
              return page
  
  
! class HTTPHandler(net.GenericHandler, protocols.http.HTTPHandler):
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def handleRequest(self, command, selector, version, request):
!         self.request = Request(command, selector, version, request)
!         self.request.handler = self
!         self.request.process(self.server)
  
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
************************************************************




From moshez at zadka.site.co.il  Tue Apr 17 15:24:15 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 22:24:15 +0300
Subject: [Twisted-Python] First Port to twisted.protocols
In-Reply-To: <E14pagQ-0003Yp-00@darjeeling>
References: <E14pagQ-0003Yp-00@darjeeling>, <E14pXnh-0002x3-00@darjeeling>, <20010416183244.26197.qmail@stimpy.scso.com>
Message-ID: <E14pb5D-0003c0-00@darjeeling>

On Tue, 17 Apr 2001 21:58:38 +0300, Moshe Zadka <moshez at zadka.site.co.il> wrote:
 
> Here's a first rough patch to do that:
> 
> Please do *not* apply it -- I've got some ideas about improving the
> HTTP handlers to make it even smoother.
> 
> Stay tuned!

Thank you for your patience.
A new patch attached, which uses the most work-saving features of
HTTPHandler to make the actual code which handles HTTP short
and highlevel.
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org

Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.81
diff -c -r1.81 web.py
*** twisted/web.py	2001/04/12 17:32:14	1.81
--- twisted/web.py	2001/04/17 19:18:47
***************
*** 29,34 ****
--- 29,36 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ import twisted.protocols.http
+ from twisted import protocols
  
  # Useful constants
  
***************
*** 238,280 ****
              else:
                  return name
  
!     def __init__(self, blob):
!         # parse the blob
!         # ...
!         split = string.split
!         find = string.find
!         lower = string.lower
! 
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
!         received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
- 
-         reqfields = split(reqstring, ' ')
- 
-         assert 2 <= len(reqfields) <=3, "Invalid request format."
- 
-         self.method, self.uri = reqfields[0], reqfields[1]
  
!         if len(reqfields) == 2:
!             # we are dealing with HTTP/0.9
!             self.clientproto = "HTTP/0.9"
!         else:
!             self.clientproto = reqfields[2]
! 
!         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = urllib.unquote(self.uri)
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = urllib.unquote(x[0]), x[1]
              for kvp in split(argstring,'&'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
--- 240,265 ----
              else:
                  return name
  
!     def __init__(self, method, uri, version, request):
!         from string import split
! 
!         received = self.received = request
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri, self.clientproto = method, uri, version
!         self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = self.uri
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = x[0], x[1]
              for kvp in split(argstring,'&'):
!                 keyval = split(kvp, '=')
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
***************
*** 282,304 ****
                      else:
                          args[key] = [value]
  
!         for header in blobs:
!             x = find(header,":")
!             if x != -1:
!                 received[lower(header[:x])] = header[x+2:]
!             else:
!                 print 'Invalid HTTP/1.1 protocol message?'
!                 print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
--- 267,277 ----
                      else:
                          args[key] = [value]
  
!         self.content = request.fp.read()
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
***************
*** 370,387 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.write("%s %s %s\r\n" % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write("%s: %s\r\n" % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
--- 343,357 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.handler.sendStatus(self.code, message)
!                 for header, value in self.headers.items():
!                     self.handler.sendHeader(header, value)
!                 self.handler.endHeaders
!         self.handler.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
***************
*** 1386,1441 ****
              return page
  
  
! class HTTPHandler(net.GenericHandler):
!     contentLength = 0
!     request = None
!     recvd = ""
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
- 
-     def _process(self, request):
-         """ (private) """
-         request.handler = self
-         request.process(self.server)
  
!     def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend < 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
-         if self.contentLength:
-             if len(self.recvd) >= self.contentLength:
-                 self.request.content = recvd[:self.contentLength]
-                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1356,1372 ----
              return page
  
  
! class HTTPHandler(net.GenericHandler, protocols.http.HTTPHandler):
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def handleRFC822Request(self, command, selector, version, request):
!         self.request = Request(command, selector, version, request)
!         self.request.handler = self
!         self.request.process(self.server)
  
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler




From moshez at lerner.co.il  Wed Apr 18 03:04:00 2001
From: moshez at lerner.co.il (Moshe Zadka)
Date: Wed, 18 Apr 2001 10:04:00 +0300
Subject: [Twisted-Python] PIRP for Twisted Python
Message-ID: <200104180704.KAA15495@jabotinsky.lerner.co.il>

Hello, dear Twisted developers!

Attached is a twisted.protocol for PIRP, DJB's publishing protocol.
I think it would be interesting to write an interface for twisted.web
so Resources would be publishable both by the web and by PIRP (and
possibly, later, other protocols?)
 
The big point would probably to think up an interface to the request
which is portable enough.

I think something like:
  - request.components(): return the requested path as a list of components
  - request.received_headers(): return the headers
  - request.write(packet): write a packet to the user

I'm still not sure how to signal failure: while in PIRP there's a single
form of failure, HTTP defines millions of them.
Anyway, I'll go off an implement a PIRP client now.
-- 
Moshe Zadka <moshez at lerner.co.il>
Web Developer, Python Developer

import NetstringReceiver

class PIRPHandler(NetstringReceiver.NetstringReceiver):

    __buffer = None

    def handleString(self, s):
        if s:
            if self.__buffer is None:
                self.__buffer = []
            self.__buffer.append(s)
        else:
            buffer, self.__buffer = self.__buffer, None
            self.handlePIRP(buffer)

    def sendError(self):
        self.write('!')

    def sendPacket(self, packet):
        self.write('%d:%s,' % (len(packet), packet)))

    def endPackets(self):
        self.sendPacket('')

    def sendPackets(self, packets):
        for packet in packets:
             self.sendPacket(packet)
        self.endPackets()
-- 
Moshe Zadka <moshez at lerner.co.il>
Web Developer, Python Developer




From moshez at zadka.site.co.il  Wed Apr 18 07:02:32 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Wed, 18 Apr 2001 14:02:32 +0300
Subject: [Twisted-Python] twisted.protocols.http: RFC
Message-ID: <200104181102.OAA15816@jabotinsky.lerner.co.il>

Glyph and I talked and decided the HTTP handling should be more
flexible.
Here is a preliminary patch for the flexibility:

on finishing headers, the handler calls handleHeaders()
Presumably, that call causes .setCallback(some_callable) to be called
on the handler. Then, content chunks are passed back via some_callable(chunk)
when there is no more, some_callable('') is called.

I haven't checked it in yet.
Please loot at HTTPCallBackHandler and let me know what you think.
Of course, I can still read everything into memory if I'm using 
HTTPRequestHandler.

Please note that the handler is smart about content-length...

-- 
Moshe Zadka <moshez at lerner.co.il>
Web Developer, Python Developer

import string
from LineReceiver import LineReceiver

class HTTPClient(LineReceiver):

    __length = None
    __buffer = ''

    def sendCommand(self, command, selector):
        self.write('%s %s HTTP/1.0\r\n' % (command, selector))

    def sendHeader(self, name, value):
        self.write('%s: %s\r\n' % (name, value))

    def endHeaders(self):
        self.write('\r\n')

    def handleLine(self, line):
        if line:
            self.handleHeader(line)
        else:
            self.handleEndHeaders()
            self.setRawMode()

    def handleEndHeaders(self):
        self.__buffer = self.__buffer + '\n'

    def handleRawData(self, data):
        if not data:
            self.handleResponse(self.__buffer)
            self.__buffer = ''
            return
        if self.length is not None:
            data, rest = data[:self.length], data[self.length:]
            self.length = self.length - len(data)
        else:
            rest = ''
        self.__buffer = self.__buffer + data
        if self.length == 0:
            self.handleResponse(self.__buffer)
            self.__buffer = ''

    def handleHeader(self, line):
        __buffer = __buffer + line + '\n'
        if string.find(line, 'content-length: ') == 0:
            self.length = int(string.strip(string.split(line, ':', 1)[0]))


class HTTPHandler(LineReceiver):

    __length = 0
    __header = ''
    __first_line = 1

    def _parse_command(self, command):
        parts = string.split(command)
        if len(parts)<3:
            parts.append('HTTP/0.9') # isn't backwards compat great!
        if len(parts) != 3:
            self.sendError(405, 'Bad command')
            raise ValueError(str(parts))
        return parts

    def sendStatus(self, code, resp=''):
        self.write('HTTP/1.0 %s %s\r\n' % (code, resp))

    def sendHeader(self, name, value):
        self.write('%s: %s\r\n' % (name, value))

    def endHeaders(self):
        self.write('\r\n')

    def sendError(self, code, resp=''):
        self.sendStatus(code, resp)
        self.endHeaders()

    def handleLine(self, line):
        if self.__first_line:
            self.__first_line = 0
            command, request, version = self._parse_command(line)
            self.handleCommand(command, request, version)
            if version == 'HTTP/0.9':
                self.handleEndHeaders()
                self.callHandleEndContent()
        elif line == '':
            if self.__header:
                self.callHandleHeader(self.__header)
            self.__header = ''
            self.handleEndHeaders()
            if self.__length == 0:
                self.callHandleEndContent()
            else:
                self.setRawMode()
        elif line[0] in ' \t':
            self.__header = self.__header+'\n'+line
        else:
            if self.__header:
            	self.callHandleHeader(self.__header)
            self.__header = line

    def callHandleHeader(self, line):
        assert line
        if string.find(string.lower(line), 'content-length: ') == 0:
            self.__length = int(string.strip(string.split(line, ':', 1)[1]))
        self.handleHeader(line)

    def callHandleEndContent(self):
        self.__first_line = 1
        self.handleEndContent()

    def handleRawData(self, data):
        if not data:
            self.callHandleEndContent()
        if len(data) < self.__length:
            self.handleContentChunk(data)
            self.__length = self.__length - len(data)
        else:
            self.handleContentChunk(data[:self.__length])
            self.callHandleEndContent()
            self.setLineMode(data[self.__length:])

from cStringIO import StringIO
import rfc822

class HTTPHeadersHandler(HTTPHandler):

    def handleCommand(self, command, selector, version):
        self.__command = command
        self.__selector = selector
        self.__version = version
        self.__headers = StringIO()

    def handleHeader(self, line):
        self.__headers.write(line+'\n')

    def handleEndHeaders(self):
        self.__headers.write('\n')
        self.__headers.seek(0)
        headers = rfc822.Message(self.__headers)
        self.handleHeaders(self.__command, self.__selector, 
                           self.__version, headers)
        del self.__command, self.__selector, self.__version, self.__headers


class HTTPCallbackOnContentHandler(HTTPHeadersHandler):

    def setCallBack(self, call):
        self.__call = call

    def handleContentChunk(self, data):
        self.__call(data)

    def handleEndContent(self):
        self.__call('')


class HTTPRequestHandler(HTTPHeadersHandler):

    def handleHeaders(self, command, selector, version, headers):
        self.__command, self.__selector, self.__version, self.__headers = \
                                         command, selector, version, headers
        self.__content = StringIO()

    def handleContentChunk(self, data):
        self.__content.write(data)

    def handleEndContent(self):
        data = self.__content.getvalue()
        del self.__content
        self.handleRequest(self.__command, self.__selector, 
                           self.__version, self.__headers, data)


def _test():

    class DummyHTTPHandler(HTTPRequestHandler):

        def __init__(self):
            import StringIO
            self.output = StringIO.StringIO()
            self.write = self.output.write

        def handleRequest(self, command, selector, version, headers, data):
            request = "'''\n"+str(headers)+"\n"+data+"'''\n"
            self.sendStatus(200, "OK")
            self.sendHeader("Request", selector)
            self.sendHeader("Command", command)
            self.sendHeader("Version", version)
            self.sendHeader("Content-Length", len(request))
            self.endHeaders()
            self.write(request)

    requests = '''\
GET / HTTP/1.0

GET / HTTP/1.1
Accept: text/html

POST / HTTP/1.1
Content-Length: 10

0123456789HEAD /
'''
    requests = string.replace(requests, '\n', '\r\n')
    expected_response = "HTTP/1.0 200 OK\015\012Request: /\015\012Command: GET\015\012Version: HTTP/1.0\015\012Content-Length: 9\015\012\015\012'''\012\012'''\012HTTP/1.0 200 OK\015\012Request: /\015\012Command: GET\015\012Version: HTTP/1.1\015\012Content-Length: 27\015\012\015\012'''\012Accept: text/html\012\012'''\012HTTP/1.0 200 OK\015\012Request: /\015\012Command: POST\015\012Version: HTTP/1.1\015\012Content-Length: 38\015\012\015\012'''\012Content-Length: 10\012\0120123456789'''\012HTTP/1.0 200 OK\015\012Request: /\015\012Command: HEAD\015\012Version: HTTP/0.9\015\012Content-Length: 9\015\012\015\012'''\012\012'''\012"
    a = DummyHTTPHandler()
    a.handleData(requests)
    value = a.output.getvalue()
    if value != expected_response:
	for i in range(len(value)):
            if value[i] != expected_response[i]:
                print `value[i-5:i+10]`, `expected_response[i-5:i+10]`
                break
        raise AssertionError

if __name__ == '__main__':
    _test()




From glyph at twistedmatrix.com  Sat Apr 28 18:39:14 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sat, 28 Apr 2001 17:39:14 -0500
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
Message-ID: <01042817391401.10809@helix>

Looks like 0.9 has been quite a while in coming.  The Rt. Hon. Rev. Short and 
I have been discussing lots of interesting ideas for improvement of twisted 
reality; I quite some time looking at Squeak and considering strategies for 
adopting Smalltalk to improve the reliability of the core, but eventually 
gave up.

It looks like the strategy for insulating the game engine from unstable code 
is going to be server distribution; much like twisted web allows multiple 
users to run untrusted (except for the fact that gloop sends pickles, but 
this is an implementation deficiency not a design flaw) web servers on the 
same machine, I think that the central "reality reservoir" server on Zaibach 
will allow users to install doors to their areas.

I also think that there's going to be a small paradigm shift in TR's approach 
to game code; I think that twisted.reality was attempting to be 
unrealistically game-agnostic.  The core will start to make a few more 
assumptions about things like inventory, damage, and containment.  The 
supporting "bulky" code (containing big string and tuple constants et. al.) 
will continue to live in twisted/library/, but I don't think it's possible to 
elegantly encapsulate anything meaningful in such a bare-bones simulation 
that's currently twisted/reality.py.

I've written a draft "official twisted python coding standard", currently at

	http://www.twistedmatrix.com/users/glyph/standard.html

Comments, corrections, and pointers to inconsistencies in the existing code 
will be welcomed, but if anybody says anything about NerdyCaps, I'm going to 
break some teeth.

And finally, I'd like to see some discussion of a release strategy, as 
charming as "whenever we get around to it" has been :).  I recommend 
something like this (note that I don't put dates next to *anything*...

	0.8.5: the fixes which are currently in (CGI, refactorings to Twisted 
Reality, swing faucet, etc), preliminary demo code, segregation of 
Inheritance into a separate package, "dead" protocols directory.

	0.9.0: "live" protocols implementation, used by at least .web (hopefully 
.gloop too); full, publicly running TR demo (assuming also some more 
improvements to the TR core, some more library functionality).

	0.9.1: Simple distributed TR server.

	0.9.2: Distributed TR server + SSL certificates.

	0.9.3: Postgres protocol client, asynchronous DB API spec.

	0.9.4: Some sort of relational storage for TR objects (?)

	0.99.*: Writing tests and hammering the heck out of what we've got, adding 
minor features and polish to TR and the TR demo.

	1.0.0: unit tests for everything.  Media firestorm, we take radix's leash 
and dash and I run the mop-up operation in-character in the TR demo :)

Here, there's some speculation as to whether we should do a fork to "stable" 
and "unstable" versions of TPy.  Any thoughts?  Further #s here assume such a 
fork doesn't happen.  These are more of an overarching plan than specific 
functionality.

	1.1.0: Rudimentary relational storage of Things, Radix's config interface.  
Finished version of Inheritance, packaged separately.  Batteries not 
included.

	1.2.0: "dict" protocol client and server for TR.  More and better of the 
config interface.  Meatier back-end for mail handling, real mail server 
(perhaps integrated with PMS?)

	1.3.0: better Faucet, perhaps with PyGame.  Start of work on 
_Inheritance_II:Acquisition_, which has a "massively" multiplayer "mode" as 
well as the multi- and single-player modes.  (This will, in truth, be a 
different game, set in a similiar but much larger world.)  The game won't be 
a strict sequel, but more in the way that Beyond Zork was a Zork sequel.

	1.4.0: Fairly complete inet.d replacement: pop3, imap, telnet, talk, ident, 
IRC client-compatible server; all implemented with Moshe's protocols 
framework.

	1.5.0: 100% for-real relational storage of TR objects, finished version of 
the schema and extensibility mechanisms for that schema.

	1.6.0: Peer-to-peer TR additions; each client is a server too.  Finish 
_Acquisition_, beginnings of serious work on an even larger game.

	1.7.0: _Inheritance_III:Collection_, single-player only, but a testbed for 
features used in a larger game, mostly those which involve automatically 
generating large areas.  If we do spatiality, here's where it gets exercised.

	1.8.0: generalizations of peer-to-peer framework and trust web, to do 
something like mojo nation.

	1.9.0: Robustness improvements.  netcat from /dev/urandom to a gloop or 
twisted.web socket fails gracefully.  I go to jail for a year because of 
features released with 1.8.0.

	2.0.0: Full implementation of CORBA, NFS, XML-RPC, SMB, SSH, and NTP, all of 
which are TR-aware.  Javascript interpreter.  Enterprise.  Highly concurrent 
resource control for multi-user Python.  Moxie.  Green eggs.  Appleshare 
server and client.  Ham.  X font server.  Kerberos.  Zephyr.  CODA.  built-in 
remote debugging.  Completely transparent python-relational interface with 
syntax additions built using MobiusPython.  Kitchen sink.  Bathroom sink.  
Implement "corridors" before Lilo gets around to it, move OPN to 
twistedmatrix.com.  _Inheritance_IV:Subtype_Polymorphism_.

	2.0.1: Internet.

	2.0.2: Divunal.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Sat Apr 28 19:12:48 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sat, 28 Apr 2001 19:12:48 -0400
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <01042817391401.10809@helix>; from glyph@twistedmatrix.com on Sat, Apr 28, 2001 at 05:39:14PM -0500
References: <01042817391401.10809@helix>
Message-ID: <20010428191248.A1263@Fookidla.org>

Ok, 3 points.

1) I think 0.9.0 should be feature-complete with 1.0, and 0.9.* only be bug
fixes, and all your current 0.9.* releases be 0.8.* releases.

2) package-izing of web. I think this needs to be done (we have webconfig
and webutils in twisted, and these should be web.config and web.utils).
I've been bitching about this for a very long time. I think it should be 
done before 1.0. It makes sense to do it now, while the protocol handling
part of web is being factored out into protocols.http.

3) Maybe releases >1.0 should be a little more spread out numerically. Maybe
not. I donno.

On Sat, Apr 28, 2001 at 05:39:14PM -0500, Glyph Lefkowitz wrote:
> Looks like 0.9 has been quite a while in coming.  The Rt. Hon. Rev. Short and 
> I have been discussing lots of interesting ideas for improvement of twisted 
> reality; I quite some time looking at Squeak and considering strategies for 
> adopting Smalltalk to improve the reliability of the core, but eventually 
> gave up.
> 

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Sun Apr 29 01:33:33 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sun, 29 Apr 2001 08:33:33 +0300
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <01042817391401.10809@helix>
References: <01042817391401.10809@helix>
Message-ID: <E14tjpt-0005Wc-00@darjeeling>

On Sat, 28 Apr 2001matrix.com> wrote:

> I've written a draft "official twisted python coding standard", currently at
> 
> 	http://www.twistedmatrix.com/users/glyph/standard.html

Thanks.

> 	0.9.3: Postgres protocol client, asynchronous DB API spec.

Wow! Sounds heavy...

> Here, there's some speculation as to whether we should do a fork to "stable" 
> and "unstable" versions of TPy.  Any thoughts?

No need, until you've got 1000s of users, which won't happen until 2.0,
probably, if at all.

> 	1.4.0: Fairly complete inet.d replacement: pop3, imap, telnet, talk, ident, 
> IRC client-compatible server; all implemented with Moshe's protocols 
> framework.

And I'm still thinking of APX and SIMAP -- http://em.ca/~bruceg/

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From thyrr at bb3.betterbox.net  Sun Apr 29 03:55:19 2001
From: thyrr at bb3.betterbox.net (Thyrr)
Date: Sun, 29 Apr 2001 02:55:19 -0500 (CDT)
Subject: [Twisted-Python] Twisted.Web memory usage, and other things
Message-ID: <Pine.LNX.3.96.1010429023511.26828A-100000@bb3.betterbox.net>

I'm planning on setting up a web server and was wondering how much
memory TwistedPython uses up compared to Apache, especially since my
RAM is limited. I would also like to know is TwistedPython supports
virtual hosts at this time, and whether there's any way to have a
persistant interpreter like mod_perl and mod_php.

Oh, and while I'm asking questions, how does one create a multi-user
interactive fiction? Strikes me as an odd concept as I've never seen one,
but an interesting possibility. Python is in some ways similar to TADS
(text adventure development system)'s scripting language, but TADS is
geared towards a single user. Wouldn't a multiplayer IF game be like a
singleplayer IF game except there's only one set of objects for the
players to fight over? By the way, there's a MUD base derived from LPC
called MudOS that tried to accomplish some of the same goals as
TwistedPython, like network services including HTTP, FTP, Intermud Chat,
etc, and providing sort of an internal shell with programs.

And another quick question: What's the GTK stuff for?

Anyways:
  Thank you in advance for any help you can provide,

 - Thyrr at BB3.BetterBox.net





From glyph at twistedmatrix.com  Sun Apr 29 12:00:54 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 29 Apr 2001 11:00:54 -0500
Subject: [Twisted-Python] Twisted.Web memory usage, and other things
In-Reply-To: <Pine.LNX.3.96.1010429023511.26828A-100000@bb3.betterbox.net>
References: <Pine.LNX.3.96.1010429023511.26828A-100000@bb3.betterbox.net>
Message-ID: <01042911005403.10809@helix>

On Sunday 29 April 2001 02:55, you wrote:
> I'm planning on setting up a web server and was wondering how much
> memory TwistedPython uses up compared to Apache, especially since my
> RAM is limited.

RAM usage is hard to measure on UNIX, but if you can run Python on your 
limited-RAM machine (e.g. it's not an embedded system with sub-megabyte hard 
allocation requirements), you ought to be able to bring up a basic Twisted 
Web server; it doesn't have many requirements in excess of just a standard 
python interpreter.  As far as how it measures up to Apache; it depends on 
what you configure each of them to do :).  I would guess that in the average 
case, twisted web would be lighter, memory-wise, than apache, but that apache 
can be configured to take up much less RAM if you know what you're doing.

Here is some sample output of PS, indicating what a bunch of average users do 
with twisted web:

USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
jh       17110  0.0  1.8  6312 2372 ?        S    Mar10   3:38 python2.0 
shae     24700  0.0  1.4  3708 1796 ?        S    Mar15   0:02 python 
glyph    22519  0.0  2.1  5380 2804 ?        S    Mar27   0:44 python 
carmstro 19275  0.0  1.7  4568 2280 ?        S    Apr03   0:22 python 
matsaleh  8402  0.0  1.6  3804 2096 ?        S    Apr06   0:01 python
washort  27718  0.1  1.4  5052 1816 ?        S    Apr12  28:52 python
det       3675  0.0  1.9  4160 2464 ?        S    Apr20   0:01 python 
www-data 30020  0.0  3.7  5568 4760 ?        S    Apr26   0:39 python
rikyu    12063  0.0  2.8  4480 3676 ?        S    Apr27   0:01 python

By contrast, here's my single-user testing machine with a single instance of 
Apache running (debian's default config)

USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root       435  0.0  0.9  2840 1164 ?        S    Apr04   0:00 apache
www-data 14321  0.0  0.8  2900 1044 ?        S    07:35   0:00 apache
www-data 14322  0.0  0.8  2888 1076 ?        S    07:35   0:00 apache
www-data 14323  0.0  0.8  2888 1060 ?        S    07:35   0:00 apache
www-data 14324  0.0  0.8  2900 1064 ?        S    07:35   0:00 apache
www-data 14325  0.0  0.8  2900 1060 ?        S    07:35   0:00 apache
www-data 14733  0.0  0.5  2852  764 ?        S    10:17   0:00 apache
www-data 14738  0.0  0.6  2852  776 ?        S    10:17   0:00 apache
www-data 14739  0.0  0.9  2852 1212 ?        S    10:17   0:00 apache
www-data 14740  0.0  0.9  2852 1212 ?        S    10:17   0:00 apache
www-data 14741  0.0  0.9  2852 1212 ?        S    10:17   0:00 apache

(Note, also, that "root" is not one of the users in that first list! ^_^)

> I would also like to know is TwistedPython supports virtual hosts at this
> time,

While at the time that you sent the message that wasn't true, named virtual 
host is such a trivial feature that I added it: it took 7 minutes to add and 
5 minutes to test.  Also, the implementation is 29 lines, which includes 11 
lines of API documentation and 4 blank lines.  Other features are just as 
easy to add :)

> and whether there's any way to have a persistant interpreter like mod_perl
> and mod_php.

Twisted Python *is* a persistent interpreter.  There are a number of 
different ways to run code in it, depending on your preferred modality of 
thinking about web servers.  However, it only supports Python (obviously).

It wouldn't be too hard to implement a filtered process which talked to a 
persistent interpreter of some other language, but I don't see the point, 
since python is more than good enough for me :)

> Oh, and while I'm asking questions, how does one create a multi-user
> interactive fiction? Strikes me as an odd concept as I've never seen one,
> but an interesting possibility.

Good question!  I've been hacking away trying to solve it for years, and I'm 
still not sure it can be done :).  When we get something good done, I'll tell 
you... :)

> Python is in some ways similar to TADS
> (text adventure development system)'s scripting language, but TADS is
> geared towards a single user. Wouldn't a multiplayer IF game be like a
> singleplayer IF game except there's only one set of objects for the
> players to fight over?

Yes, and that's a tough nut to crack.  The idea being that you create LOTS of 
objects to fight over.  Then you make it hard to fight...

> By the way, there's a MUD base derived from LPC
> called MudOS that tried to accomplish some of the same goals as
> TwistedPython, like network services including HTTP, FTP, Intermud Chat,
> etc, and providing sort of an internal shell with programs.

I'm familiar with MudOS.  It's certainly older and more established than TPy, 
but I think you'll find the integration of services in TPy somewhat more ... 
streamlined.

> And another quick question: What's the GTK stuff for?

I am a very lazy person and I am highly resistant to change.  So I have these 
crazy ideas, like writing servers should be about the same as writing clients 
on the network level.  The GTK stuff allows me to do that, by integrating the 
network layer API (twisted net) with a GUI API (gtk).  This means, for 
example, you can run a webserver inside a PyGTK application with almost no 
extra work; the glue code will be on the order of 3 lines.  Not only that, 
but it'll be a relatively high-performance webserver, that you could handle a 
decent amount of traffic on, and one that won't hang your UI while doing 
stuff, rather than the standard "joke" blocking webserver included with 
Python.  If it still works, the map "editor" should demonstrate this :)

> Anyways:
>   Thank you in advance for any help you can provide,

And you're welcome.  Happy twisting.


-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Sun Apr 29 12:17:45 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 29 Apr 2001 11:17:45 -0500
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <20010428191248.A1263@Fookidla.org>
References: <01042817391401.10809@helix> <20010428191248.A1263@Fookidla.org>
Message-ID: <01042911174504.10809@helix>

On Saturday 28 April 2001 18:12, you wrote:
> Ok, 3 points.
>
> 1) I think 0.9.0 should be feature-complete with 1.0, and 0.9.* only be bug
> fixes, and all your current 0.9.* releases be 0.8.* releases.

The gimp-style versioning is intentional.  I think that 0.99.* indicates 
"slogging towards 1.0!!" whereas 0.9 seems like a decent release in its own 
right.  I'll vote (i.e. use my divine mandate to dictate) that we keep it 
that way :)

> 2) package-izing of web. I think this needs to be done (we have webconfig
> and webutils in twisted, and these should be web.config and web.utils).
> I've been bitching about this for a very long time. I think it should be
> done before 1.0. It makes sense to do it now, while the protocol handling
> part of web is being factored out into protocols.http.

The trouble is that webutils and webconfig are not logically "owned" by web.  
webutils could grow into a separate distribution; webconfig might just as 
logically be config.web.  I don't see a compelling reason for organizing them 
in a package yet.  (Something like twisted.reality may bear packagizing, 
since twisted.library *is* logically "owned" by reality).

Also, anything called "util" is basically crying out for refactoring.  
Perhaps web and reality should both be packages and both have a "library" 
subpackage?  I dunno.  Suggestions are welcome.

> 3) Maybe releases >1.0 should be a little more spread out numerically.
> Maybe not. I donno.

Well, there are 1.0.1, 1.0.2, 1.0.3 releases in between, etc, that were not 
detailed.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Sun Apr 29 12:26:33 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 29 Apr 2001 11:26:33 -0500
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <E14tjpt-0005Wc-00@darjeeling>
References: <01042817391401.10809@helix> <E14tjpt-0005Wc-00@darjeeling>
Message-ID: <01042911263305.10809@helix>

On Sunday 29 April 2001 00:33, you wrote:
> On Sat, 28 Apr 2001matrix.com> wrote:
> > I've written a draft "official twisted python coding standard", currently
> > at
> >
> > 	http://www.twistedmatrix.com/users/glyph/standard.html
>
> Thanks.

As you mentioned to me offline, I forgot about whitespace and docstring 
indentation.  I've updated it to include a blurb about those.

> > 	0.9.3: Postgres protocol client, asynchronous DB API spec.
>
> Wow! Sounds heavy...

Not that heavy (I hope)... there's a standard for the protocol, there is a 
reference implementation of it in libpq and a 3rd-party implementation using 
emacs.  The nastiest part, I think, will be in trying to design a database 
API that makes sense asynchronously.

> > Here, there's some speculation as to whether we should do a fork to
> > "stable" and "unstable" versions of TPy.  Any thoughts?
>
> No need, until you've got 1000s of users, which won't happen until 2.0,
> probably, if at all.

That's what I thought...

> > 	1.4.0: Fairly complete inet.d replacement: pop3, imap, telnet, talk,
> > ident, IRC client-compatible server; all implemented with Moshe's
> > protocols framework.
>
> And I'm still thinking of APX and SIMAP -- http://em.ca/~bruceg/

Good to hear :).  But first get web integrated with twisted.protocols.http! 
:))

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Sun Apr 29 13:53:37 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sun, 29 Apr 2001 13:53:37 -0400
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <01042911174504.10809@helix>; from glyph@twistedmatrix.com on Sun, Apr 29, 2001 at 11:17:45AM -0500
References: <01042817391401.10809@helix> <20010428191248.A1263@Fookidla.org> <01042911174504.10809@helix>
Message-ID: <20010429135336.A2424@Fookidla.org>

On Sun, Apr 29, 2001 at 11:17:45AM -0500, Glyph Lefkowitz wrote:
> > 1) I think 0.9.0 should be feature-complete with 1.0, and 0.9.* only be bug
> > fixes, and all your current 0.9.* releases be 0.8.* releases.
> 
> The gimp-style versioning is intentional.  I think that 0.99.* indicates 
> "slogging towards 1.0!!" whereas 0.9 seems like a decent release in its own 
> right.  I'll vote (i.e. use my divine mandate to dictate) that we keep it 
> that way :)

Sorry about that, I didn't notice 0.99.* before sending the last mail, and
dash straightened me out yesterday. :)

> > 2) package-izing of web. I think this needs to be done (we have webconfig
> > and webutils in twisted, and these should be web.config and web.utils).
> > I've been bitching about this for a very long time. I think it should be
> > done before 1.0. It makes sense to do it now, while the protocol handling
> > part of web is being factored out into protocols.http.
> 
> The trouble is that webutils and webconfig are not logically "owned" by web.  
> webutils could grow into a separate distribution; webconfig might just as 
> logically be config.web.  I don't see a compelling reason for organizing them 
> in a package yet.  (Something like twisted.reality may bear packagizing, 
> since twisted.library *is* logically "owned" by reality).
> 
> Also, anything called "util" is basically crying out for refactoring.  
> Perhaps web and reality should both be packages and both have a "library" 
> subpackage?  I dunno.  Suggestions are welcome.

Yeah, web.library sounds good. webutils is basically the same as library,
only all classes are in the same file. And where to put webconfig is a toughy,
since it's related to both config and web. Which is more important? The way
it's implemented, or what it does? I think config.web seems more logical.
Then there could also be config.reality, config.gloop, etc. (when we get
around to it).

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Mon Apr 30 00:57:45 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 30 Apr 2001 07:57:45 +0300
Subject: [Twisted-Python] twisted.web uses twisted.protocols
Message-ID: <E14u5kn-0000QE-00@darjeeling>

Well, not the official version, but here's a patch:


Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.82
diff -c -r1.82 web.py
*** twisted/web.py	2001/04/27 13:27:37	1.82
--- twisted/web.py	2001/04/30 04:56:59
***************
*** 29,34 ****
--- 29,35 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ from twisted.protocols import http
  
  # Useful constants
  
***************
*** 206,219 ****
  
  
  
! class Request:
!     """web.Request(blob)
  
-     This defines HTTP request.  'blob' is a list of lines that
-     represent the request to parse.
-     """
- 
-     content = None
      code = HTTP.OK
  
      # HTML generation helpers
--- 207,214 ----
  
  
  
! class Request(http.HTTPRequestHandler):
  
      code = HTTP.OK
  
      # HTML generation helpers
***************
*** 238,270 ****
              else:
                  return name
  
!     def __init__(self, blob):
!         # parse the blob
!         # ...
!         split = string.split
!         find = string.find
!         lower = string.lower
! 
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
!         received = self.received = {}
!         args = self.args = {}
          self.stack = []
          self.headers = {}
- 
-         reqfields = split(reqstring, ' ')
  
!         assert 2 <= len(reqfields) <=3, "Invalid request format."
  
-         self.method, self.uri = reqfields[0], reqfields[1]
- 
-         if len(reqfields) == 2:
-             # we are dealing with HTTP/0.9
-             self.clientproto = "HTTP/0.9"
-         else:
-             self.clientproto = reqfields[2]
- 
-         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
--- 233,257 ----
              else:
                  return name
  
!     def _parse_argstring(self, argstring, split=string.split):
!         for kvp in split(argstring, '&'):
!             keyval = map(urllib.unquote, split(kvp, '='))
!             if len(keyval) != 2:
!                 continue
!             arg = self.args[key] = self.args.get(key, [])
!             arg.append(value)
! 
!     def handleRequest(self, command, selector, version, headers, content):
!         from string import split
!         self.received = headers
!         self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri = command, selector
!         self.clientproto = version
!         self.content = content
  
          x = split(self.uri,'?')
  
          if len(x) == 1:
***************
*** 273,311 ****
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
              self.path, argstring = urllib.unquote(x[0]), x[1]
!             for kvp in split(argstring,'&'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
!                 if len(keyval)==2:
!                     key, value = keyval
!                     if args.has_key(key):
!                         args[key].append(value)
!                     else:
!                         args[key] = [value]
  
!         for header in blobs:
!             x = find(header,":")
!             if x != -1:
!                 received[lower(header[:x])] = header[x+2:]
!             else:
!                 print 'Invalid HTTP/1.1 protocol message?'
!                 print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
!     def process(self, server):
          "Process a request."
          # Log the request to a file.
          print self
!         self.setHeader('server', Server.version)
          self.setHeader('date', date_time_string())
          self.setHeader('content-type', "text/html")
          self.setHeader('connection', 'close')
--- 260,279 ----
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
              self.path, argstring = urllib.unquote(x[0]), x[1]
!             self._parse_args(argstring)
  
!         self.process()
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
!     def process(self):
          "Process a request."
          # Log the request to a file.
          print self
!         self.setHeader('server', self.server.version)
          self.setHeader('date', date_time_string())
          self.setHeader('content-type', "text/html")
          self.setHeader('connection', 'close')
***************
*** 327,336 ****
                      raise 'bad content-type'
  
              # Resource Identification
!             self.server = server
!             self.selector = server.selector
!             self.server_port = server.port
!             resource = server.resource(self)
              body = resource.render(self)
              if body == NOT_DONE_YET:
                  return
--- 295,303 ----
                      raise 'bad content-type'
  
              # Resource Identification
!             self.selector = self.handler.server.selector
!             self.server_port = self.handler.server.port
!             resource = self.handler.server.resource(self)
              body = resource.render(self)
              if body == NOT_DONE_YET:
                  return
***************
*** 371,392 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.write("%s %s %s\r\n" % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write("%s: %s\r\n" % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
!         self.handler.stopConsuming()
!         del self.handler
  
      def setHeader(self, k, v):
          self.headers[string.lower(k)] = v
--- 338,355 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.sendStatus(self.code, message)
!                 for name, value in self.headers.items():
!                     self.sendHeader(name, value)
!                 self.endHeaders()
!         self.handler.write(data)
  
      def finish(self):
!         self.handler.close()
  
      def setHeader(self, k, v):
          self.headers[string.lower(k)] = v
***************
*** 1393,1447 ****
  
  
  class HTTPHandler(net.GenericHandler):
!     contentLength = 0
      request = None
-     recvd = ""
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
-     def _process(self, request):
-         """ (private) """
-         request.handler = self
-         request.process(self.server)
- 
      def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend < 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
!         if self.contentLength:
!             if len(self.recvd) >= self.contentLength:
!                 self.request.content = recvd[:self.contentLength]
!                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1356,1376 ----
  
  
  class HTTPHandler(net.GenericHandler):
! 
      request = None
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
      def handleData(self, data):
!         if self.request is None:
!             self.request = Request(self)
!             self.request.server = self.server
!         self.request.handleData(data)
  
!     def close(self):
!         self.loseConnection()
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler




From moshez at zadka.site.co.il  Mon Apr 30 13:14:46 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 30 Apr 2001 20:14:46 +0300
Subject: [Twisted-Python] twisted.web split
Message-ID: <E14uHG2-0001DH-00@darjeeling>

Hello, all.
I talked a bit with glyph and radix about splitting twisted.web.
It's over 1500 lines now, and I think it's becoming unmanageable.
Here is how I propose it will be split:

- twisted/web/html.py -- HTML generation helpers
- twisted/web/protocol.py -- Web protocols (HTTP and Gloop, currently)
- twisted/web/resource.py -- Resources.

Specifically:

- twisted/web/resource.py

	class Data(Resource):
	class Interface(Resource):
	class FileTransfer:
	class DirectoryListing(Interface):
	class File(Resource):
	class CGIDirectory(Resource):
	class ErrorPage(Interface):
	class NoResource(ErrorPage):
        class ResourceIssue:
	class ResourceSubscription(Resource):
	class PythonScript(Resource):
	class CGIScript(Resource):
	class FilteredScript(CGIScript):
	class PHPScript(FilteredScript):
	class MethodDirectory(Interface):
	class UserDirectory(Interface):

- twisted/web/html.py

	def escape(text):
	def PRE(text):
	def output(func, *args, **kw):
	def date_time_string(msSinceEpoch=None):
	def d(**z):

- twisted/web/protocol.py

	class HTTP: (might move completely outside)
	class Request(http.HTTPRequestHandler):
	class CGIProcess(net.Process):
	class ResourcePublish(gloop.Handler):
	class ResourcePublisher(gloop.Server, authenticator.SessionManager):
	class HTTPHandler(net.GenericHandler):
	class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
	class HTTPClient(net.GenericClient, log.Logger):
	class HTTPCallback(HTTPClient):
	class ResourcePublisherClient(gloop.Client, log.Logger):

>From a simple grep I think I've covered everything.
Anything else that might have slipped should be easy to put somewhere.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Mon Apr 30 15:41:29 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 30 Apr 2001 22:41:29 +0300
Subject: [Twisted-Python] GLOOP2 -- No more Mr. Passive Resistance
Message-ID: <E14uJY1-0001PP-00@darjeeling>

Glyph and I talked a bit about revising Gloop. I don't have
yet a proposal for the high level protocol, but I did put together
a simple protocol for transferring objects. There's a super-pre-alpha
implementation already, though.
It's at http://moshez.org/gloop2

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From carmstro at dynup.net  Mon Apr 30 20:47:30 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Mon, 30 Apr 2001 20:47:30 -0400
Subject: [Twisted-Python] twisted.web split
In-Reply-To: <E14uHG2-0001DH-00@darjeeling>; from moshez@zadka.site.co.il on Mon, Apr 30, 2001 at 08:14:46PM +0300
References: <E14uHG2-0001DH-00@darjeeling>
Message-ID: <20010430204729.A3640@Fookidla.org>

One addition: twisted/web/library.py - same as twisted/webutils.py.

On Mon, Apr 30, 2001 at 08:14:46PM +0300, Moshe Zadka wrote:
> Hello, all.
> I talked a bit with glyph and radix about splitting twisted.web.
> It's over 1500 lines now, and I think it's becoming unmanageable.
> Here is how I propose it will be split:
> 
> - twisted/web/html.py -- HTML generation helpers
> - twisted/web/protocol.py -- Web protocols (HTTP and Gloop, currently)
> - twisted/web/resource.py -- Resources.

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From glyph at twistedmatrix.com  Sun Apr  1 22:58:51 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 1 Apr 2001 23:58:51 -0500 (CDT)
Subject: [Twisted-Python] upon further consideration...
Message-ID: <Pine.LNX.4.21.0104012357380.8876-100000@zaibach.twistedmatrix.com>

Nick, I think you're right.  I'm going to scrap the verb-oriented dispatch
system for something MUCH more like Inform's style.  I'm still working out
the design, but when I've got something substantial, I'll post again.

                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph





From nick at zork.net  Mon Apr  2 01:31:04 2001
From: nick at zork.net (Nick Moffitt)
Date: Mon, 2 Apr 2001 00:31:04 -0700
Subject: [Twisted-Python] upon further consideration...
In-Reply-To: <Pine.LNX.4.21.0104012357380.8876-100000@zaibach.twistedmatrix.com>; from glyph@twistedmatrix.com on Sun, Apr 01, 2001 at 11:58:51PM -0500
References: <Pine.LNX.4.21.0104012357380.8876-100000@zaibach.twistedmatrix.com>
Message-ID: <20010402003103.N18346@zork.net>

begin  Glyph Lefkowitz quotation:
> Nick, I think you're right.  I'm going to scrap the verb-oriented
> dispatch system for something MUCH more like Inform's style.  I'm
> still working out the design, but when I've got something
> substantial, I'll post again.

	Good heavens.  Well I must admit that my earlier messages were
driven largely by naivete rather than pure technical prowess.

	I've been playing with twisted-python more and more lately,
and have been trying to build a smallish game.  As such, I think I'm
getting a feel for what you had in mind pre-0.8.x, so let me post what
I was thinking about the nasty verb problem (goddamn action-oriented
structures in an object-oriented world!).

	I had thought about your verb-based dispatch system, and
decided that before I'd sit down and read your code, I'd think about
how I would implement such a beast.

	I decided that all basic verbs would be implemented in the
direct object.  As such, that meant that the parser would identify the
DO rather than the verb, initially, and then go looking for the object
that represents the DO.

	The search pattern for a sentence with no DO ("Shoot at
dalek") would be actor, actor's contents, and the contents of actor's
location.  So you could have a player with laser-eyes, a handgun, and
a nearby trebuchet, all capable of "shoot"ing, but the laser-eyes
would win out unless a DO was specified.

	Indirect objects would have a special kind of verb form for
"catching" actions performed by direct objects.  They'd accept the
sentence's DO as the subject, as well as any prepositions (to know if
you're putting the coin IN the piggy bank or merely ON it).	

	Pre- and post- hooks are easily done by overloading and
putting code before or after you call your parent's version of a verb.

	Anyway, this is largely cafe musing, but I had diagrammed out
the traditional "throw rock at dalek" scenario and it seemed to make
sense. 

	I'm sure there are better ways to merge the handling of verbs
with python's object system.  It is kind of neat to just read through
an object and pull out functions that match a simple pattern.

	Left unadressed was the synonym problem (making "examine" and
"look at" synonymous in the general case), though I doubt it's that
complicated.

	

-- 
You are not entitled to your opinions.
 
	01234567 <- The amazing indent-o-meter!
        ^	    Matt McIrvin: the Nikola Tesla of tab damage.




From washort at iceman  Sat Apr  7 04:39:06 2001
From: washort at iceman (Allen Short)
Date: Sat, 07 Apr 2001 05:39:06 -0500
Subject: [Twisted-Python] The King of Spain never rushes
Message-ID: <20010407053906H.washort@iceman>

AUSTIN (AP) -- Work proceeds apace on the Twisted Reality Demo Center,
the long-awaited spectacular showcase from Twisted Matrix Labs. "Eat
your heart out Verant, Bioware, and Blizzard", chairman and Evil
Overlord Glyph Lefkowitz was overheard saying, "we have more internet
than you can possibly imagine. Heck, we've even gotten an endorsement
from John Romero."  When asked to comment, Mr Romero squeakily
responded "That tickles!".  Chief Reality Engineer Allen Short refused
to discuss specific technical advances over previous releases, saying
only "You know it's gonna rock. Where or when are minor details."


All seriousness aside, I've begun to port the Java code for the TR
demo to the current system. Right now, we have Mr Romero and the water
fountain; their code is in trdemo/trdemo.py, along with
trdemo/build_map, the mapfile.  I've added a Box class to
twisted.library; problem is, it doesn't work quite right. (Try putting
something in a box to see what i mean =) 


PS: glyph, have you added the verb-chaining stuff yet? i've a case or
two that wants it. 


-- 
Allen Short, CS Geek                  shortwa at auburn.edu
favorite toys: Lisp/Smalltalk/Python/Jabber/XEmacs/Linux
<demoncrat> I think nowadays sisyphus would have to reinstall windows
            all the time  




From carmstro at dynup.net  Sun Apr  8 19:04:02 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sun, 8 Apr 2001 21:04:02 -0400
Subject: [Twisted-Python] config interface
Message-ID: <20010408210402.A325@Fookidla.org>

I've been working a whole lot on the config interface, and I don't like 
how things are working right now. 

configurable objects are organized in a tree. Every object defines these
methods:

    #ContainableTypes should return a list of classes that
    #it can hold.
    def configContainableTypes(self): pass

    #Type should return the type of the current object
    def configType(self): pass
    
    #GetContents should return a dict of children of this object. {"name": obj}
    def configGetChildren(self): pass

    #AddItem should add a child to this object
    def configAddItem(self, id, item): pass

    #RemoveItem should remove a child from this object.
    def configRemoveItem(self, id): pass

I'd like to change this API somewhat to allow different paramaters to add and 
remove item methods. Not all objects need ids to add an object, and it's not
natural for some objects to represent their contents as a dict (selectors,
for instance). I was thinking about a solution similar to the improper-state
trick that glyph described to me, only it would just look at the arguments
that a method needs rather than a constructor of a class.

So, maybe there could be standardized names for paramaters of AddItem or
RemoveItem so that a front-end would know what exactly to get from the user
to add or remove an item. GetChildren could also just return either a list
or a dict, and the front-end would handle it appropriately.

This is not a developed idea at all, and I just wanna run it by anyone who
cares. Standardizing names of paramaters doesn't seem very clean to me, but
I can't think of much else..
-- 
Chris Armstrong   http://twistedmatrix.com/~carmstro     carmstro at dynup.net
There is a 90% chance that this message was written when the author's been
awake longer than he should have. Please disregard any senseless drivel.




From glyph at twistedmatrix.com  Wed Apr 11 05:31:32 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 11 Apr 2001 06:31:32 -0500
Subject: [Twisted-Python] config interface
In-Reply-To: <20010408210402.A325@Fookidla.org>
References: <20010408210402.A325@Fookidla.org>
Message-ID: <0104110528160H.26755@helix>

On Sunday 08 April 2001 20:04, you wrote:
> configurable objects are organized in a tree. Every object defines these
> methods:

>     #ContainableTypes should return a list of classes that
>     #it can hold.
>     def configContainableTypes(self): pass

This seems fine...

>     #Type should return the type of the current object
>     def configType(self): pass

I don't think this is necessary though.  Can't you just use the Python class?

>     #GetContents should return a dict of children of this object. {"name":
> obj} def configGetChildren(self): pass

Seems like a list of tuples (.items() style) might be more appropriate than a 
dict, considering that this really isn't mutable.

>     #AddItem should add a child to this object
>     def configAddItem(self, id, item): pass

Also fine...

>     #RemoveItem should remove a child from this object.
>     def configRemoveItem(self, id): pass

> I'd like to change this API somewhat to allow different paramaters to add
> and remove item methods. Not all objects need ids to add an object, and
> it's not natural for some objects to represent their contents as a dict
> (selectors, for instance). I was thinking about a solution similar to the
> improper-state trick that glyph described to me, only it would just look at
> the arguments that a method needs rather than a constructor of a class.

That trick is a necessary addition to the API in any case -- these functions 
aren't enough.  However, you might want to have ConfigurableDictionary, 
ConfigurableItem, and ConfigurableSequence types which have different ideas 
about how things get added to them.


In order for new configurable things to be instantiatable, you'll need API 
additions like:

def configGetRequiredInitArgs(self)

This returns a 2-tuple of a sequence and a hash.  The first sequence is a 
list of types/classes of the required arguments, in order, and the second is 
a hash of name:type/class of optional argument.

These arguments get filled in by your configuration interface code, and 
passed to:

def configCheckInitArgs(self, args, kw)

This to separate preconditions of the init from the init itself -- if this 
indicates there's something wrong with the arguments (for example, an integer 
is outside of its acceptable range) then this message can be displayed to the 
user for them to try again.

def configDoInit(self, args, kw)

This will most likely be a passthru to self.__init__, probably frequently 
enough to make that the default implementation, but since 
configGetRequiredInitArgs may want to do some pre-initialization, things 
could be different.


Note that if something returned by configGetRequiredInitArgs is a class, that 
class be configurable as well -- that, and your interface may need to be 
somewhat recursive in order to allow you to pass configurable elements to the 
initializers of other configurable elements... I'd recommend trying to get 
something work only supporting basic types at first.

Also, what are you planning on doing for configuring an object's attributes?  
It seems like that should behave differently from configuring the objects it 
contains.


-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Wed Apr 11 09:42:20 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 11 Apr 2001 11:42:20 -0400
Subject: [Twisted-Python] config interface
In-Reply-To: <0104110528160H.26755@helix>; from glyph@twistedmatrix.com on Wed, Apr 11, 2001 at 06:31:32AM -0500
References: <20010408210402.A325@Fookidla.org> <0104110528160H.26755@helix>
Message-ID: <20010411114220.A2931@Fookidla.org>

On Wed, Apr 11, 2001 at 06:31:32AM -0500, Glyph Lefkowitz wrote:
> >     #Type should return the type of the current object
> >     def configType(self): pass
> 
> I don't think this is necessary though.  Can't you just use the Python class?

You're right. I was switching to classes for the type system, anyway.

> >     #GetContents should return a dict of children of this object. {"name":
> > obj} def configGetChildren(self): pass
> 
> Seems like a list of tuples (.items() style) might be more appropriate than a 
> dict, considering that this really isn't mutable.

Ok, makes sense.

> > I'd like to change this API somewhat to allow different paramaters to add
> > and remove item methods. Not all objects need ids to add an object, and
> > it's not natural for some objects to represent their contents as a dict
> > (selectors, for instance). I was thinking about a solution similar to the
> > improper-state trick that glyph described to me, only it would just look at
> > the arguments that a method needs rather than a constructor of a class.
> 
> That trick is a necessary addition to the API in any case -- these functions 
> aren't enough.  However, you might want to have ConfigurableDictionary, 
> ConfigurableItem, and ConfigurableSequence types which have different ideas 
> about how things get added to them.

I don't understand what those methods should do. Could you explain a bit
more?

The main thing I was confused about was what exact paramaters might 
configAddItem and configRemoveItem need. Not all containers will have an
'id' for each of their children, but I suppose they could be somehow
generated. For instance, for Selector, I was starting to implement the ids
for each server as 'str(serverObj)', but this didn't seem very nice to me.
I guess now that I think of it again, it doesn't seem all that bad. I might
need to add id(Obj) onto that, though, in some cases.

The following you described to me on IRC, but I appreciate you organizing
it for my benefit. :)

> In order for new configurable things to be instantiatable, you'll need API 
> additions like:
> 
> def configGetRequiredInitArgs(self)
> 
> This returns a 2-tuple of a sequence and a hash.  The first sequence is a 
...
> Note that if something returned by configGetRequiredInitArgs is a class, that 
> class be configurable as well -- that, and your interface may need to be 
> somewhat recursive in order to allow you to pass configurable elements to the 
> initializers of other configurable elements... I'd recommend trying to get 
> something work only supporting basic types at first.

That sounds pretty neat. Recursion is such fun. :)

> Also, what are you planning on doing for configuring an object's attributes?  
> It seems like that should behave differently from configuring the objects it 
> contains.

I already have that implemented. Remember config_strings and config_callbacks?


Thanks for the reply
-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From glyph at twistedmatrix.com  Wed Apr 11 09:50:05 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 11 Apr 2001 10:50:05 -0500
Subject: [Twisted-Python] And Now I Eat humble.py
Message-ID: <0104111050060L.26755@helix>

Well, the "Super-Duper It-Can't-Break 
No-Really-It's-Not-Like-The-Java-Version-I-Swear" version of containment in 
Twisted Reality broke rather nastily after dash sent out his update email 
regarding the demo.  I *think* I've got it mostly fixed now... at least, a 
nastily contrived, pathological unit test passes, and it appears to do the 
correct thing interactively.  It doesn't try to keep track of nearly so much 
stuff now, so even if it does break, it's likely that the breakage will be in 
event updates and not the actual structure of the game.

Curiously enough, all this stuff broke when we introduced a certain 
mechanical cockroach into the demo world...

In other news, I've ported the old Java Faucet to Jython (only works on 
2.1a1, since previous versions of jython don't implement getattr properly!!), 
which means that the faucet is runnable with a nice gui on MacOS X now.  The 
other important note is that since Gloop now works on Jython, it is possible 
to hook arbitrary Java programs and libraries into a Gloop distributed 
network (this turned out to be very simple, actually).  The possibilities of 
this are left as an exercise for the reader.

Currently, I'm adding features to the demo -- testing guest login -- and 
taking some screenshots of various GUI things.  The way things are going at 
this point, I think the next release (after the demo is done) should be 
0.9.0; post that, (after carmstro's config interface is done, and hopefully 
Inheritance) we should move on to 0.99.0 and concentrate mainly on writing 
tests... once we've tested every module, 1.0.

This concludes this morning's State of the Matrix Address :)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Wed Apr 11 10:00:48 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 11 Apr 2001 12:00:48 -0400
Subject: [Twisted-Python] And Now I Eat humble.py
In-Reply-To: <0104111050060L.26755@helix>; from glyph@twistedmatrix.com on Wed, Apr 11, 2001 at 10:50:05AM -0500
References: <0104111050060L.26755@helix>
Message-ID: <20010411120048.A2985@Fookidla.org>

On Wed, Apr 11, 2001 at 10:50:05AM -0500, Glyph Lefkowitz wrote:
> Currently, I'm adding features to the demo -- testing guest login -- and 
> taking some screenshots of various GUI things.  The way things are going at 
> this point, I think the next release (after the demo is done) should be 
> 0.9.0; post that, (after carmstro's config interface is done, and hopefully 
> Inheritance) we should move on to 0.99.0 and concentrate mainly on writing 
> tests... once we've tested every module, 1.0.

I'd like to propose making web.py a package for the TODO for 1.0. :)

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From glyph at twistedmatrix.com  Wed Apr 11 10:31:12 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 11 Apr 2001 11:31:12 -0500
Subject: [Twisted-Python] config interface
In-Reply-To: <20010411114220.A2931@Fookidla.org>
References: <20010408210402.A325@Fookidla.org> <0104110528160H.26755@helix> <20010411114220.A2931@Fookidla.org>
Message-ID: <0104111131120M.26755@helix>

On Wednesday 11 April 2001 10:42, you wrote:

> > That trick is a necessary addition to the API in any case -- these
> > functions aren't enough.  However, you might want to have
> > ConfigurableDictionary, ConfigurableItem, and ConfigurableSequence types
> > which have different ideas about how things get added to them.
>
> I don't understand what those methods should do. Could you explain a bit
> more?

class Configurable
class ConfigurableDict(UserDict.UserDict, Configurable)
class ConfigurableSequence(UserList.UserList, Configurable)

Rather than adding a whole new interface (configAddItem etc) why not just use 
the built-in list/dictionary interfaces for the two kinds of collection you 
have?

> The main thing I was confused about was what exact paramaters might
> configAddItem and configRemoveItem need. Not all containers will have an
> 'id' for each of their children, but I suppose they could be somehow
> generated. For instance, for Selector, I was starting to implement the ids
> for each server as 'str(serverObj)', but this didn't seem very nice to me.
> I guess now that I think of it again, it doesn't seem all that bad. I might
> need to add id(Obj) onto that, though, in some cases.

I don't really understand why this is relevant; why would you need IDs for 
servers?  Aren't they just added in some order (a list)?

> > Also, what are you planning on doing for configuring an object's
> > attributes? It seems like that should behave differently from configuring
> > the objects it contains.
>
> I already have that implemented. Remember config_strings and
> config_callbacks?

I'm still not 100% comfortable with that implementation, but I suppose it can 
be refactored later.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Wed Apr 11 13:10:07 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 11 Apr 2001 15:10:07 -0400
Subject: [Twisted-Python] config interface
In-Reply-To: <0104111131120M.26755@helix>; from glyph@twistedmatrix.com on Wed, Apr 11, 2001 at 11:31:12AM -0500
References: <20010408210402.A325@Fookidla.org> <0104110528160H.26755@helix> <20010411114220.A2931@Fookidla.org> <0104111131120M.26755@helix>
Message-ID: <20010411151007.A3314@Fookidla.org>

On Wed, Apr 11, 2001 at 11:31:12AM -0500, Glyph Lefkowitz wrote:
> > I don't understand what those methods should do. Could you explain a bit
> > more?
> 
> class Configurable
> class ConfigurableDict(UserDict.UserDict, Configurable)
> class ConfigurableSequence(UserList.UserList, Configurable)
> 
> Rather than adding a whole new interface (configAddItem etc) why not just use 
> the built-in list/dictionary interfaces for the two kinds of collection you 
> have?

Ok, I get you know. Good idea. :)

> 
> > The main thing I was confused about was what exact paramaters might
> > configAddItem and configRemoveItem need. Not all containers will have an
> > 'id' for each of their children, but I suppose they could be somehow
> > generated. For instance, for Selector, I was starting to implement the ids
> > for each server as 'str(serverObj)', but this didn't seem very nice to me.
> > I guess now that I think of it again, it doesn't seem all that bad. I might
> > need to add id(Obj) onto that, though, in some cases.
> 
> I don't really understand why this is relevant; why would you need IDs for 
> servers?  Aren't they just added in some order (a list)?

Exactly, servers really don't have IDs. But other things do. That's why I was
confused in the first place. But it is useful to have them for the UI.
str(serverObj) may not be that user friendly, but it has to be unique.
Also the ID is needed for deleting things from the selector.

Now that I think of it, with your dict and list overriding ideas, I don't
think IDs would even be needed. Or maybe they would. I'll work on it. :)

> > I already have that implemented. Remember config_strings and
> > config_callbacks?
> 
> I'm still not 100% comfortable with that implementation, but I suppose it can 
> be refactored later.

Okie dokie.
-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From carmstro at dynup.net  Fri Apr 13 18:13:37 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Fri, 13 Apr 2001 20:13:37 -0400
Subject: [Twisted-Python] weird problem with subclassing library.door.Door
Message-ID: <20010413201337.A6302@Fookidla.org>

Ok, I made a subclass of Door called SecretDoor. The point of this door is
that it's opened with a remote button and is not visible unless it is open.
I tried implementing this by overriding _close() in my class.

class SecretDoor(door.Door):
    def verb_open(self, sentence):
            sentence.subject.hears("This door is opened elsewhere.")

    def _close(self, actor):
        self._undescribe()

Unfortunately, this did not work.
The _undescribe call was apparently being cancelled out by something that was
resetting the description in the current room. I looked for calls to 
_redescribe(), but couldn't find any that were being called after my 
_undescribe(). Eventually I just decided to hack it out and added:

    def _redescribe(self):
        if not self.isOpen:
            self._undescribe()
        else:
            door.Door._redescribe(self)

This is very bad, but I could not figure out any other way to do it. I still
have it this way, and I just wanted to notify glyph and anyone else who's
interested. Is there a better way to do this? Where is the description being
added back into the room?

Ahh well, thanks a bunch.

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Mon Apr 16 15:07:08 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 00:07:08 +0300
Subject: [Twisted-Python] twisted.net refactoring
Message-ID: <E14pGDE-0000nW-00@darjeeling>

Hi!
I've started to work on refactoring twisted.net for minimal dependancies.
Currently, in the vein of "research project", what interests me is how
layering of protocols in an event-oriented framework can be accomplished.
Please have a look at http://moshez.org/protocols.tgz
I've written tests for all the protocol handlers I wrote, and I'd
be happy to work with anyone who wants to write tests for the irc client
and telnet server.

Basically, the idea is to turn low-level events (basically just handleData)
into high level events (like handleRequest, for HTTP, at the other end
of the spectrum). The idea is to reflect the layering of protocols (and 
only the layering of protocols -- read on) in the classes. 

So, inheritance happens when the spec references another spec -- e.g.,
XML-RPC is defined to be over HTTP, so it would be correct to have

class XMLRPCHandler(HTTPHandler):

    def handleRequest(self, command, selector, version, request):
        ...parse request into Python tuple...
        result = self.handleMethod(params)
        ....return HTTP response...

But, on the other hand, HTTP does not say anything about TCP/IP, so
HTTP should *not* be layered above any transport. This allows us to
use SSL, SOCKS or files just as well.

One big advantage I'm interested in is testability -- see the examples
already there to get my point -- you can bombard your handler hard-coded
strings and watch for the answers.
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Tue Apr 17 02:15:42 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 17 Apr 2001 03:15:42 -0500
Subject: [Twisted-Python] twisted.net refactoring
In-Reply-To: <E14pGDE-0000nW-00@darjeeling>
References: <E14pGDE-0000nW-00@darjeeling>
Message-ID: <01041703154214.26755@helix>

This is definitely the direction I want twisted.net to be going in.  Thank 
you for implmenting it (as well as the additional protocols!).

Have you started making the requisite changes in net.py as well?

On Monday 16 April 2001 16:07, you wrote:
> Hi!
> I've started to work on refactoring twisted.net for minimal dependancies.
> Currently, in the vein of "research project", what interests me is how
> layering of protocols in an event-oriented framework can be accomplished.
> Please have a look at http://moshez.org/protocols.tgz
> I've written tests for all the protocol handlers I wrote, and I'd
> be happy to work with anyone who wants to write tests for the irc client
> and telnet server.
>
> Basically, the idea is to turn low-level events (basically just handleData)
> into high level events (like handleRequest, for HTTP, at the other end
> of the spectrum). The idea is to reflect the layering of protocols (and
> only the layering of protocols -- read on) in the classes.
>
> So, inheritance happens when the spec references another spec -- e.g.,
> XML-RPC is defined to be over HTTP, so it would be correct to have
>
> class XMLRPCHandler(HTTPHandler):
>
>     def handleRequest(self, command, selector, version, request):
>         ...parse request into Python tuple...
>         result = self.handleMethod(params)
>         ....return HTTP response...
>
> But, on the other hand, HTTP does not say anything about TCP/IP, so
> HTTP should *not* be layered above any transport. This allows us to
> use SSL, SOCKS or files just as well.
>
> One big advantage I'm interested in is testability -- see the examples
> already there to get my point -- you can bombard your handler hard-coded
> strings and watch for the answers.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Tue Apr 17 02:30:56 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 11:30:56 +0300
Subject: [Twisted-Python] twisted.net refactoring
In-Reply-To: <01041703154214.26755@helix>
References: <01041703154214.26755@helix>, <E14pGDE-0000nW-00@darjeeling>
Message-ID: <E14pQsy-0001s8-00@darjeeling>

On Tue, 17 Apr 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:

> This is definitely the direction I want twisted.net to be going in.  Thank 
> you for implmenting it (as well as the additional protocols!).
> 
> Have you started making the requisite changes in net.py as well?

Not yet. 
I'm not *exactly* sure of the design of net.py itself -- it's a bit
too big for me to digest it right now.
Twisted.net is not the only one that needs to be changed though --
.web, .irc and .telnet should also be modified to take advantage
of it. 

I'm starting to think I want to change my original direction a bit --
just have protocols as twisted.protocols package, think of it as
a library that bridges a level mismatch in event-based protocol
handling -- that is, transforms low-level events (got chunk of
data) into semantic events (got an e-mail message). Then we can
port .net and friends over one by one when we have the chance.

IOW .net should specialize in things that call .handleData and and supply
.write, and .protocols should specialize in providing mixins that supply
.handleData and .write -- and never the twain shall meet, except in high-level
things like twisted.web or twisted.irc which use .net *and* .protocols
to provide useful services. Well, actually, the interface should be
enhanced to .goodBye() -- this is a method .net's should provide and
.protocol's use to signal the remote end requested a shutdown. Oh, 
and .welcome() which the .net's should call 

.net and .protcols should be considered seperate packages that are not
allowed to have any dependancy on any part of twisted.

So here is a summary
- .protocol -- has .welcome() and .handleData method, will call .write()
  and .goodBye() methods.
- .net -- has .write() and .goodBye() methods, will call .welcome() on
  connecting and .handleData() when the transport layer has data.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Mon Apr 16 12:32:44 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: 16 Apr 2001 18:32:44 -0000
Subject: [Twisted-Python] First Port to twisted.protocols
Message-ID: <20010416183244.26197.qmail@stimpy.scso.com>

I'll check in the protocols stuff later today.
In the mean time, for you early adopters, http://moshez.org/protocls.tgz
has the latest and snazziest.
And....as a special surprise, I've ported twisted.web over to stop
knowing so much HTTP. HTTP knowledge used to be smeared all over
Request and HTTPHandler, and now neither of them knows much HTTP.





From moshez at zadka.site.co.il  Tue Apr 17 09:53:57 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 18:53:57 +0300
Subject: [Twisted-Python] First Port to twisted.protocols
In-Reply-To: <20010416183244.26197.qmail@stimpy.scso.com>
References: <20010416183244.26197.qmail@stimpy.scso.com>
Message-ID: <E14pXnh-0002x3-00@darjeeling>

On 16 Apr 2001 18:32:44 -0000, Moshe Zadka <moshez at zadka.site.co.il> wrote:

> I'll check in the protocols stuff later today.

As promised, I've check it in.

> And....as a special surprise, I've ported twisted.web over to stop
> knowing so much HTTP. HTTP knowledge used to be smeared all over
> Request and HTTPHandler, and now neither of them knows much HTTP.

I'm working on integrating and testing my web.py port.
I'll think of Resource testability later. 
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Tue Apr 17 12:58:38 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 21:58:38 +0300
Subject: [Twisted-Python] First Port to twisted.protocols
In-Reply-To: <E14pXnh-0002x3-00@darjeeling>
References: <E14pXnh-0002x3-00@darjeeling>, <20010416183244.26197.qmail@stimpy.scso.com>
Message-ID: <E14pagQ-0003Yp-00@darjeeling>

On Tue, 17 Apr 2001 18:53:57 +0300, Moshe Zadka <moshez at zadka.site.co.il> wrote:
 
> > I'll check in the protocols stuff later today.
> 
> As promised, I've check it in.

And now I've fixed a little bug in twisted.protocols.http
The HTTP server code now works fine.

> > And....as a special surprise, I've ported twisted.web over to stop
> > knowing so much HTTP. HTTP knowledge used to be smeared all over
> > Request and HTTPHandler, and now neither of them knows much HTTP.
> 
> I'm working on integrating and testing my web.py port.

Here's a first rough patch to do that:

Please do *not* apply it -- I've got some ideas about improving the
HTTP handlers to make it even smoother.

Stay tuned!

Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.81
diff -c -r1.81 web.py
*** twisted/web.py	2001/04/12 17:32:14	1.81
--- twisted/web.py	2001/04/17 18:59:16
***************
*** 29,34 ****
--- 29,36 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ import twisted.protocols.http
+ from twisted import protocols
  
  # Useful constants
  
***************
*** 238,280 ****
              else:
                  return name
  
!     def __init__(self, blob):
          # parse the blob
          # ...
          split = string.split
          find = string.find
          lower = string.lower
  
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
          received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         reqfields = split(reqstring, ' ')
! 
!         assert 2 <= len(reqfields) <=3, "Invalid request format."
! 
!         self.method, self.uri = reqfields[0], reqfields[1]
! 
!         if len(reqfields) == 2:
!             # we are dealing with HTTP/0.9
!             self.clientproto = "HTTP/0.9"
!         else:
!             self.clientproto = reqfields[2]
! 
!         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = urllib.unquote(self.uri)
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = urllib.unquote(x[0]), x[1]
              for kvp in split(argstring,'&'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
--- 240,270 ----
              else:
                  return name
  
!     def __init__(self, method, uri, version, blob):
          # parse the blob
          # ...
          split = string.split
          find = string.find
          lower = string.lower
  
!         blobf = StringIO.StringIO(blob)
          received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri, self.clientproto = method, uri, version
!         self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = self.uri
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = x[0], x[1]
              for kvp in split(argstring,'&'):
!                 keyval = split(kvp, '=')
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
***************
*** 282,304 ****
                      else:
                          args[key] = [value]
  
!         for header in blobs:
              x = find(header,":")
              if x != -1:
                  received[lower(header[:x])] = header[x+2:]
              else:
                  print 'Invalid HTTP/1.1 protocol message?'
                  print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
--- 272,292 ----
                      else:
                          args[key] = [value]
  
!         while 1:
!             header = blobf.readline()
!             if header == '\n':
!                 break
              x = find(header,":")
              if x != -1:
                  received[lower(header[:x])] = header[x+2:]
              else:
                  print 'Invalid HTTP/1.1 protocol message?'
                  print header
!         self.content = blobf.read()
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
***************
*** 370,387 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.write("%s %s %s\r\n" % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write("%s: %s\r\n" % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
--- 358,372 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.handler.sendStatus(self.code, message)
!                 for header, value in self.headers.items():
!                     self.handler.sendHeader(header, value)
!                 self.handler.endHeaders
!         self.handler.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
***************
*** 1386,1441 ****
              return page
  
  
! class HTTPHandler(net.GenericHandler):
!     contentLength = 0
!     request = None
!     recvd = ""
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def _process(self, request):
!         """ (private) """
!         request.handler = self
!         request.process(self.server)
! 
!     def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend < 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
-         if self.contentLength:
-             if len(self.recvd) >= self.contentLength:
-                 self.request.content = recvd[:self.contentLength]
-                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1371,1387 ----
              return page
  
  
! class HTTPHandler(net.GenericHandler, protocols.http.HTTPHandler):
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def handleRequest(self, command, selector, version, request):
!         self.request = Request(command, selector, version, request)
!         self.request.handler = self
!         self.request.process(self.server)
  
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
************************************************************




From moshez at zadka.site.co.il  Tue Apr 17 13:24:15 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 17 Apr 2001 22:24:15 +0300
Subject: [Twisted-Python] First Port to twisted.protocols
In-Reply-To: <E14pagQ-0003Yp-00@darjeeling>
References: <E14pagQ-0003Yp-00@darjeeling>, <E14pXnh-0002x3-00@darjeeling>, <20010416183244.26197.qmail@stimpy.scso.com>
Message-ID: <E14pb5D-0003c0-00@darjeeling>

On Tue, 17 Apr 2001 21:58:38 +0300, Moshe Zadka <moshez at zadka.site.co.il> wrote:
 
> Here's a first rough patch to do that:
> 
> Please do *not* apply it -- I've got some ideas about improving the
> HTTP handlers to make it even smoother.
> 
> Stay tuned!

Thank you for your patience.
A new patch attached, which uses the most work-saving features of
HTTPHandler to make the actual code which handles HTTP short
and highlevel.
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org

Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.81
diff -c -r1.81 web.py
*** twisted/web.py	2001/04/12 17:32:14	1.81
--- twisted/web.py	2001/04/17 19:18:47
***************
*** 29,34 ****
--- 29,36 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ import twisted.protocols.http
+ from twisted import protocols
  
  # Useful constants
  
***************
*** 238,280 ****
              else:
                  return name
  
!     def __init__(self, blob):
!         # parse the blob
!         # ...
!         split = string.split
!         find = string.find
!         lower = string.lower
! 
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
!         received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
- 
-         reqfields = split(reqstring, ' ')
- 
-         assert 2 <= len(reqfields) <=3, "Invalid request format."
- 
-         self.method, self.uri = reqfields[0], reqfields[1]
  
!         if len(reqfields) == 2:
!             # we are dealing with HTTP/0.9
!             self.clientproto = "HTTP/0.9"
!         else:
!             self.clientproto = reqfields[2]
! 
!         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = urllib.unquote(self.uri)
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = urllib.unquote(x[0]), x[1]
              for kvp in split(argstring,'&'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
--- 240,265 ----
              else:
                  return name
  
!     def __init__(self, method, uri, version, request):
!         from string import split
! 
!         received = self.received = request
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri, self.clientproto = method, uri, version
!         self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = self.uri
          else:
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
!             self.path, argstring = x[0], x[1]
              for kvp in split(argstring,'&'):
!                 keyval = split(kvp, '=')
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
***************
*** 282,304 ****
                      else:
                          args[key] = [value]
  
!         for header in blobs:
!             x = find(header,":")
!             if x != -1:
!                 received[lower(header[:x])] = header[x+2:]
!             else:
!                 print 'Invalid HTTP/1.1 protocol message?'
!                 print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
--- 267,277 ----
                      else:
                          args[key] = [value]
  
!         self.content = request.fp.read()
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
***************
*** 370,387 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.write("%s %s %s\r\n" % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write("%s: %s\r\n" % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
--- 343,357 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.handler.sendStatus(self.code, message)
!                 for header, value in self.headers.items():
!                     self.handler.sendHeader(header, value)
!                 self.handler.endHeaders
!         self.handler.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
***************
*** 1386,1441 ****
              return page
  
  
! class HTTPHandler(net.GenericHandler):
!     contentLength = 0
!     request = None
!     recvd = ""
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
- 
-     def _process(self, request):
-         """ (private) """
-         request.handler = self
-         request.process(self.server)
  
!     def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend < 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
-         if self.contentLength:
-             if len(self.recvd) >= self.contentLength:
-                 self.request.content = recvd[:self.contentLength]
-                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1356,1372 ----
              return page
  
  
! class HTTPHandler(net.GenericHandler, protocols.http.HTTPHandler):
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def handleRFC822Request(self, command, selector, version, request):
!         self.request = Request(command, selector, version, request)
!         self.request.handler = self
!         self.request.process(self.server)
  
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler




From moshez at lerner.co.il  Wed Apr 18 01:04:00 2001
From: moshez at lerner.co.il (Moshe Zadka)
Date: Wed, 18 Apr 2001 10:04:00 +0300
Subject: [Twisted-Python] PIRP for Twisted Python
Message-ID: <200104180704.KAA15495@jabotinsky.lerner.co.il>

Hello, dear Twisted developers!

Attached is a twisted.protocol for PIRP, DJB's publishing protocol.
I think it would be interesting to write an interface for twisted.web
so Resources would be publishable both by the web and by PIRP (and
possibly, later, other protocols?)
 
The big point would probably to think up an interface to the request
which is portable enough.

I think something like:
  - request.components(): return the requested path as a list of components
  - request.received_headers(): return the headers
  - request.write(packet): write a packet to the user

I'm still not sure how to signal failure: while in PIRP there's a single
form of failure, HTTP defines millions of them.
Anyway, I'll go off an implement a PIRP client now.
-- 
Moshe Zadka <moshez at lerner.co.il>
Web Developer, Python Developer

import NetstringReceiver

class PIRPHandler(NetstringReceiver.NetstringReceiver):

    __buffer = None

    def handleString(self, s):
        if s:
            if self.__buffer is None:
                self.__buffer = []
            self.__buffer.append(s)
        else:
            buffer, self.__buffer = self.__buffer, None
            self.handlePIRP(buffer)

    def sendError(self):
        self.write('!')

    def sendPacket(self, packet):
        self.write('%d:%s,' % (len(packet), packet)))

    def endPackets(self):
        self.sendPacket('')

    def sendPackets(self, packets):
        for packet in packets:
             self.sendPacket(packet)
        self.endPackets()
-- 
Moshe Zadka <moshez at lerner.co.il>
Web Developer, Python Developer




From moshez at zadka.site.co.il  Wed Apr 18 05:02:32 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Wed, 18 Apr 2001 14:02:32 +0300
Subject: [Twisted-Python] twisted.protocols.http: RFC
Message-ID: <200104181102.OAA15816@jabotinsky.lerner.co.il>

Glyph and I talked and decided the HTTP handling should be more
flexible.
Here is a preliminary patch for the flexibility:

on finishing headers, the handler calls handleHeaders()
Presumably, that call causes .setCallback(some_callable) to be called
on the handler. Then, content chunks are passed back via some_callable(chunk)
when there is no more, some_callable('') is called.

I haven't checked it in yet.
Please loot at HTTPCallBackHandler and let me know what you think.
Of course, I can still read everything into memory if I'm using 
HTTPRequestHandler.

Please note that the handler is smart about content-length...

-- 
Moshe Zadka <moshez at lerner.co.il>
Web Developer, Python Developer

import string
from LineReceiver import LineReceiver

class HTTPClient(LineReceiver):

    __length = None
    __buffer = ''

    def sendCommand(self, command, selector):
        self.write('%s %s HTTP/1.0\r\n' % (command, selector))

    def sendHeader(self, name, value):
        self.write('%s: %s\r\n' % (name, value))

    def endHeaders(self):
        self.write('\r\n')

    def handleLine(self, line):
        if line:
            self.handleHeader(line)
        else:
            self.handleEndHeaders()
            self.setRawMode()

    def handleEndHeaders(self):
        self.__buffer = self.__buffer + '\n'

    def handleRawData(self, data):
        if not data:
            self.handleResponse(self.__buffer)
            self.__buffer = ''
            return
        if self.length is not None:
            data, rest = data[:self.length], data[self.length:]
            self.length = self.length - len(data)
        else:
            rest = ''
        self.__buffer = self.__buffer + data
        if self.length == 0:
            self.handleResponse(self.__buffer)
            self.__buffer = ''

    def handleHeader(self, line):
        __buffer = __buffer + line + '\n'
        if string.find(line, 'content-length: ') == 0:
            self.length = int(string.strip(string.split(line, ':', 1)[0]))


class HTTPHandler(LineReceiver):

    __length = 0
    __header = ''
    __first_line = 1

    def _parse_command(self, command):
        parts = string.split(command)
        if len(parts)<3:
            parts.append('HTTP/0.9') # isn't backwards compat great!
        if len(parts) != 3:
            self.sendError(405, 'Bad command')
            raise ValueError(str(parts))
        return parts

    def sendStatus(self, code, resp=''):
        self.write('HTTP/1.0 %s %s\r\n' % (code, resp))

    def sendHeader(self, name, value):
        self.write('%s: %s\r\n' % (name, value))

    def endHeaders(self):
        self.write('\r\n')

    def sendError(self, code, resp=''):
        self.sendStatus(code, resp)
        self.endHeaders()

    def handleLine(self, line):
        if self.__first_line:
            self.__first_line = 0
            command, request, version = self._parse_command(line)
            self.handleCommand(command, request, version)
            if version == 'HTTP/0.9':
                self.handleEndHeaders()
                self.callHandleEndContent()
        elif line == '':
            if self.__header:
                self.callHandleHeader(self.__header)
            self.__header = ''
            self.handleEndHeaders()
            if self.__length == 0:
                self.callHandleEndContent()
            else:
                self.setRawMode()
        elif line[0] in ' \t':
            self.__header = self.__header+'\n'+line
        else:
            if self.__header:
            	self.callHandleHeader(self.__header)
            self.__header = line

    def callHandleHeader(self, line):
        assert line
        if string.find(string.lower(line), 'content-length: ') == 0:
            self.__length = int(string.strip(string.split(line, ':', 1)[1]))
        self.handleHeader(line)

    def callHandleEndContent(self):
        self.__first_line = 1
        self.handleEndContent()

    def handleRawData(self, data):
        if not data:
            self.callHandleEndContent()
        if len(data) < self.__length:
            self.handleContentChunk(data)
            self.__length = self.__length - len(data)
        else:
            self.handleContentChunk(data[:self.__length])
            self.callHandleEndContent()
            self.setLineMode(data[self.__length:])

from cStringIO import StringIO
import rfc822

class HTTPHeadersHandler(HTTPHandler):

    def handleCommand(self, command, selector, version):
        self.__command = command
        self.__selector = selector
        self.__version = version
        self.__headers = StringIO()

    def handleHeader(self, line):
        self.__headers.write(line+'\n')

    def handleEndHeaders(self):
        self.__headers.write('\n')
        self.__headers.seek(0)
        headers = rfc822.Message(self.__headers)
        self.handleHeaders(self.__command, self.__selector, 
                           self.__version, headers)
        del self.__command, self.__selector, self.__version, self.__headers


class HTTPCallbackOnContentHandler(HTTPHeadersHandler):

    def setCallBack(self, call):
        self.__call = call

    def handleContentChunk(self, data):
        self.__call(data)

    def handleEndContent(self):
        self.__call('')


class HTTPRequestHandler(HTTPHeadersHandler):

    def handleHeaders(self, command, selector, version, headers):
        self.__command, self.__selector, self.__version, self.__headers = \
                                         command, selector, version, headers
        self.__content = StringIO()

    def handleContentChunk(self, data):
        self.__content.write(data)

    def handleEndContent(self):
        data = self.__content.getvalue()
        del self.__content
        self.handleRequest(self.__command, self.__selector, 
                           self.__version, self.__headers, data)


def _test():

    class DummyHTTPHandler(HTTPRequestHandler):

        def __init__(self):
            import StringIO
            self.output = StringIO.StringIO()
            self.write = self.output.write

        def handleRequest(self, command, selector, version, headers, data):
            request = "'''\n"+str(headers)+"\n"+data+"'''\n"
            self.sendStatus(200, "OK")
            self.sendHeader("Request", selector)
            self.sendHeader("Command", command)
            self.sendHeader("Version", version)
            self.sendHeader("Content-Length", len(request))
            self.endHeaders()
            self.write(request)

    requests = '''\
GET / HTTP/1.0

GET / HTTP/1.1
Accept: text/html

POST / HTTP/1.1
Content-Length: 10

0123456789HEAD /
'''
    requests = string.replace(requests, '\n', '\r\n')
    expected_response = "HTTP/1.0 200 OK\015\012Request: /\015\012Command: GET\015\012Version: HTTP/1.0\015\012Content-Length: 9\015\012\015\012'''\012\012'''\012HTTP/1.0 200 OK\015\012Request: /\015\012Command: GET\015\012Version: HTTP/1.1\015\012Content-Length: 27\015\012\015\012'''\012Accept: text/html\012\012'''\012HTTP/1.0 200 OK\015\012Request: /\015\012Command: POST\015\012Version: HTTP/1.1\015\012Content-Length: 38\015\012\015\012'''\012Content-Length: 10\012\0120123456789'''\012HTTP/1.0 200 OK\015\012Request: /\015\012Command: HEAD\015\012Version: HTTP/0.9\015\012Content-Length: 9\015\012\015\012'''\012\012'''\012"
    a = DummyHTTPHandler()
    a.handleData(requests)
    value = a.output.getvalue()
    if value != expected_response:
	for i in range(len(value)):
            if value[i] != expected_response[i]:
                print `value[i-5:i+10]`, `expected_response[i-5:i+10]`
                break
        raise AssertionError

if __name__ == '__main__':
    _test()




From glyph at twistedmatrix.com  Sat Apr 28 16:39:14 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sat, 28 Apr 2001 17:39:14 -0500
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
Message-ID: <01042817391401.10809@helix>

Looks like 0.9 has been quite a while in coming.  The Rt. Hon. Rev. Short and 
I have been discussing lots of interesting ideas for improvement of twisted 
reality; I quite some time looking at Squeak and considering strategies for 
adopting Smalltalk to improve the reliability of the core, but eventually 
gave up.

It looks like the strategy for insulating the game engine from unstable code 
is going to be server distribution; much like twisted web allows multiple 
users to run untrusted (except for the fact that gloop sends pickles, but 
this is an implementation deficiency not a design flaw) web servers on the 
same machine, I think that the central "reality reservoir" server on Zaibach 
will allow users to install doors to their areas.

I also think that there's going to be a small paradigm shift in TR's approach 
to game code; I think that twisted.reality was attempting to be 
unrealistically game-agnostic.  The core will start to make a few more 
assumptions about things like inventory, damage, and containment.  The 
supporting "bulky" code (containing big string and tuple constants et. al.) 
will continue to live in twisted/library/, but I don't think it's possible to 
elegantly encapsulate anything meaningful in such a bare-bones simulation 
that's currently twisted/reality.py.

I've written a draft "official twisted python coding standard", currently at

	http://www.twistedmatrix.com/users/glyph/standard.html

Comments, corrections, and pointers to inconsistencies in the existing code 
will be welcomed, but if anybody says anything about NerdyCaps, I'm going to 
break some teeth.

And finally, I'd like to see some discussion of a release strategy, as 
charming as "whenever we get around to it" has been :).  I recommend 
something like this (note that I don't put dates next to *anything*...

	0.8.5: the fixes which are currently in (CGI, refactorings to Twisted 
Reality, swing faucet, etc), preliminary demo code, segregation of 
Inheritance into a separate package, "dead" protocols directory.

	0.9.0: "live" protocols implementation, used by at least .web (hopefully 
.gloop too); full, publicly running TR demo (assuming also some more 
improvements to the TR core, some more library functionality).

	0.9.1: Simple distributed TR server.

	0.9.2: Distributed TR server + SSL certificates.

	0.9.3: Postgres protocol client, asynchronous DB API spec.

	0.9.4: Some sort of relational storage for TR objects (?)

	0.99.*: Writing tests and hammering the heck out of what we've got, adding 
minor features and polish to TR and the TR demo.

	1.0.0: unit tests for everything.  Media firestorm, we take radix's leash 
and dash and I run the mop-up operation in-character in the TR demo :)

Here, there's some speculation as to whether we should do a fork to "stable" 
and "unstable" versions of TPy.  Any thoughts?  Further #s here assume such a 
fork doesn't happen.  These are more of an overarching plan than specific 
functionality.

	1.1.0: Rudimentary relational storage of Things, Radix's config interface.  
Finished version of Inheritance, packaged separately.  Batteries not 
included.

	1.2.0: "dict" protocol client and server for TR.  More and better of the 
config interface.  Meatier back-end for mail handling, real mail server 
(perhaps integrated with PMS?)

	1.3.0: better Faucet, perhaps with PyGame.  Start of work on 
_Inheritance_II:Acquisition_, which has a "massively" multiplayer "mode" as 
well as the multi- and single-player modes.  (This will, in truth, be a 
different game, set in a similiar but much larger world.)  The game won't be 
a strict sequel, but more in the way that Beyond Zork was a Zork sequel.

	1.4.0: Fairly complete inet.d replacement: pop3, imap, telnet, talk, ident, 
IRC client-compatible server; all implemented with Moshe's protocols 
framework.

	1.5.0: 100% for-real relational storage of TR objects, finished version of 
the schema and extensibility mechanisms for that schema.

	1.6.0: Peer-to-peer TR additions; each client is a server too.  Finish 
_Acquisition_, beginnings of serious work on an even larger game.

	1.7.0: _Inheritance_III:Collection_, single-player only, but a testbed for 
features used in a larger game, mostly those which involve automatically 
generating large areas.  If we do spatiality, here's where it gets exercised.

	1.8.0: generalizations of peer-to-peer framework and trust web, to do 
something like mojo nation.

	1.9.0: Robustness improvements.  netcat from /dev/urandom to a gloop or 
twisted.web socket fails gracefully.  I go to jail for a year because of 
features released with 1.8.0.

	2.0.0: Full implementation of CORBA, NFS, XML-RPC, SMB, SSH, and NTP, all of 
which are TR-aware.  Javascript interpreter.  Enterprise.  Highly concurrent 
resource control for multi-user Python.  Moxie.  Green eggs.  Appleshare 
server and client.  Ham.  X font server.  Kerberos.  Zephyr.  CODA.  built-in 
remote debugging.  Completely transparent python-relational interface with 
syntax additions built using MobiusPython.  Kitchen sink.  Bathroom sink.  
Implement "corridors" before Lilo gets around to it, move OPN to 
twistedmatrix.com.  _Inheritance_IV:Subtype_Polymorphism_.

	2.0.1: Internet.

	2.0.2: Divunal.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Sat Apr 28 17:12:48 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sat, 28 Apr 2001 19:12:48 -0400
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <01042817391401.10809@helix>; from glyph@twistedmatrix.com on Sat, Apr 28, 2001 at 05:39:14PM -0500
References: <01042817391401.10809@helix>
Message-ID: <20010428191248.A1263@Fookidla.org>

Ok, 3 points.

1) I think 0.9.0 should be feature-complete with 1.0, and 0.9.* only be bug
fixes, and all your current 0.9.* releases be 0.8.* releases.

2) package-izing of web. I think this needs to be done (we have webconfig
and webutils in twisted, and these should be web.config and web.utils).
I've been bitching about this for a very long time. I think it should be 
done before 1.0. It makes sense to do it now, while the protocol handling
part of web is being factored out into protocols.http.

3) Maybe releases >1.0 should be a little more spread out numerically. Maybe
not. I donno.

On Sat, Apr 28, 2001 at 05:39:14PM -0500, Glyph Lefkowitz wrote:
> Looks like 0.9 has been quite a while in coming.  The Rt. Hon. Rev. Short and 
> I have been discussing lots of interesting ideas for improvement of twisted 
> reality; I quite some time looking at Squeak and considering strategies for 
> adopting Smalltalk to improve the reliability of the core, but eventually 
> gave up.
> 

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Sat Apr 28 23:33:33 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sun, 29 Apr 2001 08:33:33 +0300
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <01042817391401.10809@helix>
References: <01042817391401.10809@helix>
Message-ID: <E14tjpt-0005Wc-00@darjeeling>

On Sat, 28 Apr 2001matrix.com> wrote:

> I've written a draft "official twisted python coding standard", currently at
> 
> 	http://www.twistedmatrix.com/users/glyph/standard.html

Thanks.

> 	0.9.3: Postgres protocol client, asynchronous DB API spec.

Wow! Sounds heavy...

> Here, there's some speculation as to whether we should do a fork to "stable" 
> and "unstable" versions of TPy.  Any thoughts?

No need, until you've got 1000s of users, which won't happen until 2.0,
probably, if at all.

> 	1.4.0: Fairly complete inet.d replacement: pop3, imap, telnet, talk, ident, 
> IRC client-compatible server; all implemented with Moshe's protocols 
> framework.

And I'm still thinking of APX and SIMAP -- http://em.ca/~bruceg/

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From thyrr at bb3.betterbox.net  Sun Apr 29 01:55:19 2001
From: thyrr at bb3.betterbox.net (Thyrr)
Date: Sun, 29 Apr 2001 02:55:19 -0500 (CDT)
Subject: [Twisted-Python] Twisted.Web memory usage, and other things
Message-ID: <Pine.LNX.3.96.1010429023511.26828A-100000@bb3.betterbox.net>

I'm planning on setting up a web server and was wondering how much
memory TwistedPython uses up compared to Apache, especially since my
RAM is limited. I would also like to know is TwistedPython supports
virtual hosts at this time, and whether there's any way to have a
persistant interpreter like mod_perl and mod_php.

Oh, and while I'm asking questions, how does one create a multi-user
interactive fiction? Strikes me as an odd concept as I've never seen one,
but an interesting possibility. Python is in some ways similar to TADS
(text adventure development system)'s scripting language, but TADS is
geared towards a single user. Wouldn't a multiplayer IF game be like a
singleplayer IF game except there's only one set of objects for the
players to fight over? By the way, there's a MUD base derived from LPC
called MudOS that tried to accomplish some of the same goals as
TwistedPython, like network services including HTTP, FTP, Intermud Chat,
etc, and providing sort of an internal shell with programs.

And another quick question: What's the GTK stuff for?

Anyways:
  Thank you in advance for any help you can provide,

 - Thyrr at BB3.BetterBox.net





From glyph at twistedmatrix.com  Sun Apr 29 10:00:54 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 29 Apr 2001 11:00:54 -0500
Subject: [Twisted-Python] Twisted.Web memory usage, and other things
In-Reply-To: <Pine.LNX.3.96.1010429023511.26828A-100000@bb3.betterbox.net>
References: <Pine.LNX.3.96.1010429023511.26828A-100000@bb3.betterbox.net>
Message-ID: <01042911005403.10809@helix>

On Sunday 29 April 2001 02:55, you wrote:
> I'm planning on setting up a web server and was wondering how much
> memory TwistedPython uses up compared to Apache, especially since my
> RAM is limited.

RAM usage is hard to measure on UNIX, but if you can run Python on your 
limited-RAM machine (e.g. it's not an embedded system with sub-megabyte hard 
allocation requirements), you ought to be able to bring up a basic Twisted 
Web server; it doesn't have many requirements in excess of just a standard 
python interpreter.  As far as how it measures up to Apache; it depends on 
what you configure each of them to do :).  I would guess that in the average 
case, twisted web would be lighter, memory-wise, than apache, but that apache 
can be configured to take up much less RAM if you know what you're doing.

Here is some sample output of PS, indicating what a bunch of average users do 
with twisted web:

USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
jh       17110  0.0  1.8  6312 2372 ?        S    Mar10   3:38 python2.0 
shae     24700  0.0  1.4  3708 1796 ?        S    Mar15   0:02 python 
glyph    22519  0.0  2.1  5380 2804 ?        S    Mar27   0:44 python 
carmstro 19275  0.0  1.7  4568 2280 ?        S    Apr03   0:22 python 
matsaleh  8402  0.0  1.6  3804 2096 ?        S    Apr06   0:01 python
washort  27718  0.1  1.4  5052 1816 ?        S    Apr12  28:52 python
det       3675  0.0  1.9  4160 2464 ?        S    Apr20   0:01 python 
www-data 30020  0.0  3.7  5568 4760 ?        S    Apr26   0:39 python
rikyu    12063  0.0  2.8  4480 3676 ?        S    Apr27   0:01 python

By contrast, here's my single-user testing machine with a single instance of 
Apache running (debian's default config)

USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root       435  0.0  0.9  2840 1164 ?        S    Apr04   0:00 apache
www-data 14321  0.0  0.8  2900 1044 ?        S    07:35   0:00 apache
www-data 14322  0.0  0.8  2888 1076 ?        S    07:35   0:00 apache
www-data 14323  0.0  0.8  2888 1060 ?        S    07:35   0:00 apache
www-data 14324  0.0  0.8  2900 1064 ?        S    07:35   0:00 apache
www-data 14325  0.0  0.8  2900 1060 ?        S    07:35   0:00 apache
www-data 14733  0.0  0.5  2852  764 ?        S    10:17   0:00 apache
www-data 14738  0.0  0.6  2852  776 ?        S    10:17   0:00 apache
www-data 14739  0.0  0.9  2852 1212 ?        S    10:17   0:00 apache
www-data 14740  0.0  0.9  2852 1212 ?        S    10:17   0:00 apache
www-data 14741  0.0  0.9  2852 1212 ?        S    10:17   0:00 apache

(Note, also, that "root" is not one of the users in that first list! ^_^)

> I would also like to know is TwistedPython supports virtual hosts at this
> time,

While at the time that you sent the message that wasn't true, named virtual 
host is such a trivial feature that I added it: it took 7 minutes to add and 
5 minutes to test.  Also, the implementation is 29 lines, which includes 11 
lines of API documentation and 4 blank lines.  Other features are just as 
easy to add :)

> and whether there's any way to have a persistant interpreter like mod_perl
> and mod_php.

Twisted Python *is* a persistent interpreter.  There are a number of 
different ways to run code in it, depending on your preferred modality of 
thinking about web servers.  However, it only supports Python (obviously).

It wouldn't be too hard to implement a filtered process which talked to a 
persistent interpreter of some other language, but I don't see the point, 
since python is more than good enough for me :)

> Oh, and while I'm asking questions, how does one create a multi-user
> interactive fiction? Strikes me as an odd concept as I've never seen one,
> but an interesting possibility.

Good question!  I've been hacking away trying to solve it for years, and I'm 
still not sure it can be done :).  When we get something good done, I'll tell 
you... :)

> Python is in some ways similar to TADS
> (text adventure development system)'s scripting language, but TADS is
> geared towards a single user. Wouldn't a multiplayer IF game be like a
> singleplayer IF game except there's only one set of objects for the
> players to fight over?

Yes, and that's a tough nut to crack.  The idea being that you create LOTS of 
objects to fight over.  Then you make it hard to fight...

> By the way, there's a MUD base derived from LPC
> called MudOS that tried to accomplish some of the same goals as
> TwistedPython, like network services including HTTP, FTP, Intermud Chat,
> etc, and providing sort of an internal shell with programs.

I'm familiar with MudOS.  It's certainly older and more established than TPy, 
but I think you'll find the integration of services in TPy somewhat more ... 
streamlined.

> And another quick question: What's the GTK stuff for?

I am a very lazy person and I am highly resistant to change.  So I have these 
crazy ideas, like writing servers should be about the same as writing clients 
on the network level.  The GTK stuff allows me to do that, by integrating the 
network layer API (twisted net) with a GUI API (gtk).  This means, for 
example, you can run a webserver inside a PyGTK application with almost no 
extra work; the glue code will be on the order of 3 lines.  Not only that, 
but it'll be a relatively high-performance webserver, that you could handle a 
decent amount of traffic on, and one that won't hang your UI while doing 
stuff, rather than the standard "joke" blocking webserver included with 
Python.  If it still works, the map "editor" should demonstrate this :)

> Anyways:
>   Thank you in advance for any help you can provide,

And you're welcome.  Happy twisting.


-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Sun Apr 29 10:17:45 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 29 Apr 2001 11:17:45 -0500
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <20010428191248.A1263@Fookidla.org>
References: <01042817391401.10809@helix> <20010428191248.A1263@Fookidla.org>
Message-ID: <01042911174504.10809@helix>

On Saturday 28 April 2001 18:12, you wrote:
> Ok, 3 points.
>
> 1) I think 0.9.0 should be feature-complete with 1.0, and 0.9.* only be bug
> fixes, and all your current 0.9.* releases be 0.8.* releases.

The gimp-style versioning is intentional.  I think that 0.99.* indicates 
"slogging towards 1.0!!" whereas 0.9 seems like a decent release in its own 
right.  I'll vote (i.e. use my divine mandate to dictate) that we keep it 
that way :)

> 2) package-izing of web. I think this needs to be done (we have webconfig
> and webutils in twisted, and these should be web.config and web.utils).
> I've been bitching about this for a very long time. I think it should be
> done before 1.0. It makes sense to do it now, while the protocol handling
> part of web is being factored out into protocols.http.

The trouble is that webutils and webconfig are not logically "owned" by web.  
webutils could grow into a separate distribution; webconfig might just as 
logically be config.web.  I don't see a compelling reason for organizing them 
in a package yet.  (Something like twisted.reality may bear packagizing, 
since twisted.library *is* logically "owned" by reality).

Also, anything called "util" is basically crying out for refactoring.  
Perhaps web and reality should both be packages and both have a "library" 
subpackage?  I dunno.  Suggestions are welcome.

> 3) Maybe releases >1.0 should be a little more spread out numerically.
> Maybe not. I donno.

Well, there are 1.0.1, 1.0.2, 1.0.3 releases in between, etc, that were not 
detailed.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Sun Apr 29 10:26:33 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 29 Apr 2001 11:26:33 -0500
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <E14tjpt-0005Wc-00@darjeeling>
References: <01042817391401.10809@helix> <E14tjpt-0005Wc-00@darjeeling>
Message-ID: <01042911263305.10809@helix>

On Sunday 29 April 2001 00:33, you wrote:
> On Sat, 28 Apr 2001matrix.com> wrote:
> > I've written a draft "official twisted python coding standard", currently
> > at
> >
> > 	http://www.twistedmatrix.com/users/glyph/standard.html
>
> Thanks.

As you mentioned to me offline, I forgot about whitespace and docstring 
indentation.  I've updated it to include a blurb about those.

> > 	0.9.3: Postgres protocol client, asynchronous DB API spec.
>
> Wow! Sounds heavy...

Not that heavy (I hope)... there's a standard for the protocol, there is a 
reference implementation of it in libpq and a 3rd-party implementation using 
emacs.  The nastiest part, I think, will be in trying to design a database 
API that makes sense asynchronously.

> > Here, there's some speculation as to whether we should do a fork to
> > "stable" and "unstable" versions of TPy.  Any thoughts?
>
> No need, until you've got 1000s of users, which won't happen until 2.0,
> probably, if at all.

That's what I thought...

> > 	1.4.0: Fairly complete inet.d replacement: pop3, imap, telnet, talk,
> > ident, IRC client-compatible server; all implemented with Moshe's
> > protocols framework.
>
> And I'm still thinking of APX and SIMAP -- http://em.ca/~bruceg/

Good to hear :).  But first get web integrated with twisted.protocols.http! 
:))

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Sun Apr 29 11:53:37 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sun, 29 Apr 2001 13:53:37 -0400
Subject: [Twisted-Python] I was looking for offhanded ways to improve us.
In-Reply-To: <01042911174504.10809@helix>; from glyph@twistedmatrix.com on Sun, Apr 29, 2001 at 11:17:45AM -0500
References: <01042817391401.10809@helix> <20010428191248.A1263@Fookidla.org> <01042911174504.10809@helix>
Message-ID: <20010429135336.A2424@Fookidla.org>

On Sun, Apr 29, 2001 at 11:17:45AM -0500, Glyph Lefkowitz wrote:
> > 1) I think 0.9.0 should be feature-complete with 1.0, and 0.9.* only be bug
> > fixes, and all your current 0.9.* releases be 0.8.* releases.
> 
> The gimp-style versioning is intentional.  I think that 0.99.* indicates 
> "slogging towards 1.0!!" whereas 0.9 seems like a decent release in its own 
> right.  I'll vote (i.e. use my divine mandate to dictate) that we keep it 
> that way :)

Sorry about that, I didn't notice 0.99.* before sending the last mail, and
dash straightened me out yesterday. :)

> > 2) package-izing of web. I think this needs to be done (we have webconfig
> > and webutils in twisted, and these should be web.config and web.utils).
> > I've been bitching about this for a very long time. I think it should be
> > done before 1.0. It makes sense to do it now, while the protocol handling
> > part of web is being factored out into protocols.http.
> 
> The trouble is that webutils and webconfig are not logically "owned" by web.  
> webutils could grow into a separate distribution; webconfig might just as 
> logically be config.web.  I don't see a compelling reason for organizing them 
> in a package yet.  (Something like twisted.reality may bear packagizing, 
> since twisted.library *is* logically "owned" by reality).
> 
> Also, anything called "util" is basically crying out for refactoring.  
> Perhaps web and reality should both be packages and both have a "library" 
> subpackage?  I dunno.  Suggestions are welcome.

Yeah, web.library sounds good. webutils is basically the same as library,
only all classes are in the same file. And where to put webconfig is a toughy,
since it's related to both config and web. Which is more important? The way
it's implemented, or what it does? I think config.web seems more logical.
Then there could also be config.reality, config.gloop, etc. (when we get
around to it).

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Sun Apr 29 22:57:45 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 30 Apr 2001 07:57:45 +0300
Subject: [Twisted-Python] twisted.web uses twisted.protocols
Message-ID: <E14u5kn-0000QE-00@darjeeling>

Well, not the official version, but here's a patch:


Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.82
diff -c -r1.82 web.py
*** twisted/web.py	2001/04/27 13:27:37	1.82
--- twisted/web.py	2001/04/30 04:56:59
***************
*** 29,34 ****
--- 29,35 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ from twisted.protocols import http
  
  # Useful constants
  
***************
*** 206,219 ****
  
  
  
! class Request:
!     """web.Request(blob)
  
-     This defines HTTP request.  'blob' is a list of lines that
-     represent the request to parse.
-     """
- 
-     content = None
      code = HTTP.OK
  
      # HTML generation helpers
--- 207,214 ----
  
  
  
! class Request(http.HTTPRequestHandler):
  
      code = HTTP.OK
  
      # HTML generation helpers
***************
*** 238,270 ****
              else:
                  return name
  
!     def __init__(self, blob):
!         # parse the blob
!         # ...
!         split = string.split
!         find = string.find
!         lower = string.lower
! 
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
!         received = self.received = {}
!         args = self.args = {}
          self.stack = []
          self.headers = {}
- 
-         reqfields = split(reqstring, ' ')
  
!         assert 2 <= len(reqfields) <=3, "Invalid request format."
  
-         self.method, self.uri = reqfields[0], reqfields[1]
- 
-         if len(reqfields) == 2:
-             # we are dealing with HTTP/0.9
-             self.clientproto = "HTTP/0.9"
-         else:
-             self.clientproto = reqfields[2]
- 
-         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
--- 233,257 ----
              else:
                  return name
  
!     def _parse_argstring(self, argstring, split=string.split):
!         for kvp in split(argstring, '&'):
!             keyval = map(urllib.unquote, split(kvp, '='))
!             if len(keyval) != 2:
!                 continue
!             arg = self.args[key] = self.args.get(key, [])
!             arg.append(value)
! 
!     def handleRequest(self, command, selector, version, headers, content):
!         from string import split
!         self.received = headers
!         self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri = command, selector
!         self.clientproto = version
!         self.content = content
  
          x = split(self.uri,'?')
  
          if len(x) == 1:
***************
*** 273,311 ****
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
              self.path, argstring = urllib.unquote(x[0]), x[1]
!             for kvp in split(argstring,'&'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
!                 if len(keyval)==2:
!                     key, value = keyval
!                     if args.has_key(key):
!                         args[key].append(value)
!                     else:
!                         args[key] = [value]
  
!         for header in blobs:
!             x = find(header,":")
!             if x != -1:
!                 received[lower(header[:x])] = header[x+2:]
!             else:
!                 print 'Invalid HTTP/1.1 protocol message?'
!                 print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
!     def process(self, server):
          "Process a request."
          # Log the request to a file.
          print self
!         self.setHeader('server', Server.version)
          self.setHeader('date', date_time_string())
          self.setHeader('content-type', "text/html")
          self.setHeader('connection', 'close')
--- 260,279 ----
              if len(x) != 2:
                  print "May ignore parts of this invalid URI:",repr(self.uri)
              self.path, argstring = urllib.unquote(x[0]), x[1]
!             self._parse_args(argstring)
  
!         self.process()
  
      def __repr__(self):
          return '<%s %s %s>'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
!     def process(self):
          "Process a request."
          # Log the request to a file.
          print self
!         self.setHeader('server', self.server.version)
          self.setHeader('date', date_time_string())
          self.setHeader('content-type', "text/html")
          self.setHeader('connection', 'close')
***************
*** 327,336 ****
                      raise 'bad content-type'
  
              # Resource Identification
!             self.server = server
!             self.selector = server.selector
!             self.server_port = server.port
!             resource = server.resource(self)
              body = resource.render(self)
              if body == NOT_DONE_YET:
                  return
--- 295,303 ----
                      raise 'bad content-type'
  
              # Resource Identification
!             self.selector = self.handler.server.selector
!             self.server_port = self.handler.server.port
!             resource = self.handler.server.resource(self)
              body = resource.render(self)
              if body == NOT_DONE_YET:
                  return
***************
*** 371,392 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.write("%s %s %s\r\n" % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write("%s: %s\r\n" % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
!         self.handler.stopConsuming()
!         del self.handler
  
      def setHeader(self, k, v):
          self.headers[string.lower(k)] = v
--- 338,355 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          """
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != "HTTP/0.9":
                  message = HTTP.responses.get(self.code, "Unknown Status")
!                 self.sendStatus(self.code, message)
!                 for name, value in self.headers.items():
!                     self.sendHeader(name, value)
!                 self.endHeaders()
!         self.handler.write(data)
  
      def finish(self):
!         self.handler.close()
  
      def setHeader(self, k, v):
          self.headers[string.lower(k)] = v
***************
*** 1393,1447 ****
  
  
  class HTTPHandler(net.GenericHandler):
!     contentLength = 0
      request = None
-     recvd = ""
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
-     def _process(self, request):
-         """ (private) """
-         request.handler = self
-         request.process(self.server)
- 
      def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend < 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
!         if self.contentLength:
!             if len(self.recvd) >= self.contentLength:
!                 self.request.content = recvd[:self.contentLength]
!                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1356,1376 ----
  
  
  class HTTPHandler(net.GenericHandler):
! 
      request = None
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
      def handleData(self, data):
!         if self.request is None:
!             self.request = Request(self)
!             self.request.server = self.server
!         self.request.handleData(data)
  
!     def close(self):
!         self.loseConnection()
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler




From moshez at zadka.site.co.il  Mon Apr 30 11:14:46 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 30 Apr 2001 20:14:46 +0300
Subject: [Twisted-Python] twisted.web split
Message-ID: <E14uHG2-0001DH-00@darjeeling>

Hello, all.
I talked a bit with glyph and radix about splitting twisted.web.
It's over 1500 lines now, and I think it's becoming unmanageable.
Here is how I propose it will be split:

- twisted/web/html.py -- HTML generation helpers
- twisted/web/protocol.py -- Web protocols (HTTP and Gloop, currently)
- twisted/web/resource.py -- Resources.

Specifically:

- twisted/web/resource.py

	class Data(Resource):
	class Interface(Resource):
	class FileTransfer:
	class DirectoryListing(Interface):
	class File(Resource):
	class CGIDirectory(Resource):
	class ErrorPage(Interface):
	class NoResource(ErrorPage):
        class ResourceIssue:
	class ResourceSubscription(Resource):
	class PythonScript(Resource):
	class CGIScript(Resource):
	class FilteredScript(CGIScript):
	class PHPScript(FilteredScript):
	class MethodDirectory(Interface):
	class UserDirectory(Interface):

- twisted/web/html.py

	def escape(text):
	def PRE(text):
	def output(func, *args, **kw):
	def date_time_string(msSinceEpoch=None):
	def d(**z):

- twisted/web/protocol.py

	class HTTP: (might move completely outside)
	class Request(http.HTTPRequestHandler):
	class CGIProcess(net.Process):
	class ResourcePublish(gloop.Handler):
	class ResourcePublisher(gloop.Server, authenticator.SessionManager):
	class HTTPHandler(net.GenericHandler):
	class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
	class HTTPClient(net.GenericClient, log.Logger):
	class HTTPCallback(HTTPClient):
	class ResourcePublisherClient(gloop.Client, log.Logger):

>From a simple grep I think I've covered everything.
Anything else that might have slipped should be easy to put somewhere.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Mon Apr 30 13:41:29 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 30 Apr 2001 22:41:29 +0300
Subject: [Twisted-Python] GLOOP2 -- No more Mr. Passive Resistance
Message-ID: <E14uJY1-0001PP-00@darjeeling>

Glyph and I talked a bit about revising Gloop. I don't have
yet a proposal for the high level protocol, but I did put together
a simple protocol for transferring objects. There's a super-pre-alpha
implementation already, though.
It's at http://moshez.org/gloop2

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From carmstro at dynup.net  Mon Apr 30 18:47:30 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Mon, 30 Apr 2001 20:47:30 -0400
Subject: [Twisted-Python] twisted.web split
In-Reply-To: <E14uHG2-0001DH-00@darjeeling>; from moshez@zadka.site.co.il on Mon, Apr 30, 2001 at 08:14:46PM +0300
References: <E14uHG2-0001DH-00@darjeeling>
Message-ID: <20010430204729.A3640@Fookidla.org>

One addition: twisted/web/library.py - same as twisted/webutils.py.

On Mon, Apr 30, 2001 at 08:14:46PM +0300, Moshe Zadka wrote:
> Hello, all.
> I talked a bit with glyph and radix about splitting twisted.web.
> It's over 1500 lines now, and I think it's becoming unmanageable.
> Here is how I propose it will be split:
> 
> - twisted/web/html.py -- HTML generation helpers
> - twisted/web/protocol.py -- Web protocols (HTTP and Gloop, currently)
> - twisted/web/resource.py -- Resources.

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From thyrr at bb3.betterbox.net  Mon Apr 30 23:29:27 2001
From: thyrr at bb3.betterbox.net (Thyrr)
Date: Tue, 1 May 2001 00:29:27 -0500 (CDT)
Subject: [Twisted-Python] twisted.web split
In-Reply-To: <E14uHG2-0001DH-00@darjeeling>
Message-ID: <Pine.LNX.3.96.1010501001944.9748A-100000@bb3.betterbox.net>

How about splitting it into more files than that? It's a bit easier
generally to navigate and isolate problems, reuse for other things, and
update things. Maybe a file for CGI/epy code, a file for getting files and
such, a file for generating automatic directory listings, etc.

Just my suggestion (though I've only looked at Twisted Python for a few
days now, so maybe that's not a good way to do it?)

 - Thyrr at bb3.betterbox.net

On Mon, 30 Apr 2001, Moshe Zadka wrote:

> Hello, all.
> I talked a bit with glyph and radix about splitting twisted.web.
> It's over 1500 lines now, and I think it's becoming unmanageable.
> Here is how I propose it will be split:
> 
> - twisted/web/html.py -- HTML generation helpers
> - twisted/web/protocol.py -- Web protocols (HTTP and Gloop, currently)
> - twisted/web/resource.py -- Resources.
> 
> Specifically:
> 
> - twisted/web/resource.py
> 
> 	class Data(Resource):
> 	class Interface(Resource):
> 	class FileTransfer:
> 	class DirectoryListing(Interface):
> 	class File(Resource):
> 	class CGIDirectory(Resource):
> 	class ErrorPage(Interface):
> 	class NoResource(ErrorPage):
>         class ResourceIssue:
> 	class ResourceSubscription(Resource):
> 	class PythonScript(Resource):
> 	class CGIScript(Resource):
> 	class FilteredScript(CGIScript):
> 	class PHPScript(FilteredScript):
> 	class MethodDirectory(Interface):
> 	class UserDirectory(Interface):
> 
> - twisted/web/html.py
> 
> 	def escape(text):
> 	def PRE(text):
> 	def output(func, *args, **kw):
> 	def date_time_string(msSinceEpoch=None):
> 	def d(**z):
> 
> - twisted/web/protocol.py
> 
> 	class HTTP: (might move completely outside)
> 	class Request(http.HTTPRequestHandler):
> 	class CGIProcess(net.Process):
> 	class ResourcePublish(gloop.Handler):
> 	class ResourcePublisher(gloop.Server, authenticator.SessionManager):
> 	class HTTPHandler(net.GenericHandler):
> 	class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
> 	class HTTPClient(net.GenericClient, log.Logger):
> 	class HTTPCallback(HTTPClient):
> 	class ResourcePublisherClient(gloop.Client, log.Logger):
> 
> >From a simple grep I think I've covered everything.
> Anything else that might have slipped should be easy to put somewhere.
> 
> -- 
> "I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
> looking for someplace else to grab power."|YODA: No...no... no. Quicker,
>    -- Wichert Akkerman (on debian-private)|      easier, more seductive.
> For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org
> 
> 
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python
> 





