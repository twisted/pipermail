<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Twisted protocol
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Twisted%20protocol&In-Reply-To=3C8CEEBD.4070708%40chello.se">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000886.html">
   <LINK REL="Next"  HREF="000888.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Twisted protocol</H1>
    <B>Andrew Bennetts</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Twisted%20protocol&In-Reply-To=3C8CEEBD.4070708%40chello.se"
       TITLE="[Twisted-Python] Re: Twisted protocol">andrew-twisted at puzzling.org
       </A><BR>
    <I>Mon Mar 11 20:25:10 EST 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="000886.html">[Twisted-Python] Win32 updates
</A></li>
        <LI>Next message: <A HREF="000888.html">[Twisted-Python] Re: Twisted protocol
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, Mar 11, 2002 at 06:51:57PM +0100, David wrote:
&gt;<i> Hello spiv, this is supposed to be reaching you =)
</I>&gt;<i> I was told by radix on #<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">python at opn</A> that you had written &quot;a little proxy 
</I>&gt;<i> protocol which dispatches to multiple other protocol objects&quot; in 
</I>&gt;<i> twisted. This is exactly what i need for a project of mine.
</I>&gt;<i> I'd very much appriciate if you would share this little piece of code 
</I>&gt;<i> with me or alternativly explain how it works.
</I>
Heh.  I'm CC'ing the list with this, just for the sake of it :)

Here is the class.  I created it for a case where I had a protocol that was
sometimes inheriting from one Protocol, and sometimes another, and I didn't
want to diddle with __bases__ or munge the two bases into one class
(although perhaps that is the &quot;better&quot; solution?).  If you like, imagine
PacketBasedProtocolA/B to be basic.LineReceiver and Int32StringReceiver,
where lineReceived and stringReceived are both aliased to packetReceived.

class ProxiedPacketProtocol(Protocol):
    &quot;&quot;&quot;General packet-based protocol.
    
    This class provides a simple way to use either PacketBasedProtocolA or
    PacketBasedProtocolB (or potentially others) as protocol for a data feed,
    without having to change which one you inherit from at runtime.  It
    basically acts as a proxy protocol between the low-level protocol and your
    subclass.  

    Simply override parentProtocol with the &quot;parent&quot; protocol (the default is
    PacketBasedProtocolA) and then when packetReceived is triggered in the
    parent, packetReceived is called in me.  

    Inherit from this class, and override packetReceived.&quot;&quot;&quot;
    
    parentProtocol = PacketBasedProtocolA
    packets = {}        # This is copied to the parent

    def __init__(self):
        # Create a private subclass of the parentProtocol so that we can
        # override its class-level data attribute(s).
        class ParentProtocol(self.parentProtocol):
            packets = self.packets

        # Create the parent protocol
        self.parent = ParentProtocol()

        # Raw data should get delivered to the parent...
        self.dataReceived = self.parent.dataReceived
        
        # ...and processed packets should come back to me
        self.parent.packetReceived = self.packetReceived
        self.parent.unknownPacket = self.unknownPacket

        # Data from the pinger needs to come via me
        self.parent.transport = self.transport

    def packetReceived(self, packet):
        &quot;&quot;&quot;Override this.  
        
        Called whenever the parentProtocol receives a packet.&quot;&quot;&quot;
        pass

    def unknownPacket(self, messageType, data):
        print &quot;Received unknown packet of type '%s': %s&quot; \
              % (messageType, repr(data))


David, I hope this is what you were after :)

It should be fairly easy to use and adapt -- but my question for the list is,
is it worth the extra effort it would take to make this more general?  i.e.
take arbitrary lists of attributes to copy from the parent to the proxy (and
vice versa?), instead of hard-coded names in __init__?

My other question is, is this a useful enough concept to include it in 
Twisted?  :)

-Andrew.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000886.html">[Twisted-Python] Win32 updates
</A></li>
	<LI>Next message: <A HREF="000888.html">[Twisted-Python] Re: Twisted protocol
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
