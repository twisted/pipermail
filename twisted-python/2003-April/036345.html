<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Resource.render() returning NOT_DONE_YET
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20Resource.render%28%29%20returning%20NOT_DONE_YET&In-Reply-To=%3CECAECBFE-79C2-11D7-B928-000393756786%40ruggier.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="036340.html">
   <LINK REL="Next"  HREF="036346.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Resource.render() returning NOT_DONE_YET</H1>
    <B>Mario Ruggier</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20Resource.render%28%29%20returning%20NOT_DONE_YET&In-Reply-To=%3CECAECBFE-79C2-11D7-B928-000393756786%40ruggier.org%3E"
       TITLE="[Twisted-Python] Re: Resource.render() returning NOT_DONE_YET">mario at ruggier.org
       </A><BR>
    <I>Mon Apr 28 15:46:53 MDT 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="036340.html">[Twisted-Python] Re: Resource.render() returning NOT_DONE_YET
</A></li>
        <LI>Next message (by thread): <A HREF="036346.html">[Twisted-Python] Re: Resource.render() returning NOT_DONE_YET
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36345">[ date ]</a>
              <a href="thread.html#36345">[ thread ]</a>
              <a href="subject.html#36345">[ subject ]</a>
              <a href="author.html#36345">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On lundi, avr 28, 2003, at 21:57 Europe/Amsterdam, Glyph Lefkowitz 
wrote:
&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> Hash: SHA1
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Monday, April 28, 2003, at 11:17 AM, Clark C. Evans wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On Mon, Apr 28, 2003 at 04:09:35PM +0000, Clark C. Evans wrote:
</I>&gt;&gt;<i> | I was just giving a quick Twisted tutorial to someone using
</I>&gt;&gt;<i> | twisted and as we were breaking page construction into more
</I>&gt;&gt;<i> | than one chunk... an unexpected stumbling block occurred --
</I>&gt;&gt;<i> | returning NOT_DONE_YET form the resource's render() function.
</I>&gt;&gt;<i> |
</I>&gt;&gt;<i> | I was thinking about two other options:
</I>&gt;&gt;<i> |
</I>&gt;&gt;<i> |   1.  Perhaps NOT_DONE_YET could just be None, this
</I>&gt;&gt;<i> |       way, it can be the default return value.  As I'm
</I>&gt;&gt;<i> |       browsing through my code this is the most common
</I>&gt;&gt;<i> |       return... why not make it the default.
</I>&gt;<i>
</I>&gt;<i> The reasoning behind not allowing None as a default value is that 
</I>&gt;<i> forgetting is too easy.  If you're writing a simple request that has a 
</I>&gt;<i> render() method that looks like
</I>&gt;<i>
</I>&gt;<i>     def render(self, request):
</I>&gt;<i>         if self.authenticated:
</I>&gt;<i>             return self.goodies
</I>&gt;<i>
</I>&gt;<i> the default behavior should not be &quot;hang forever&quot;.
</I>&gt;<i>
</I>&gt;&gt;<i>         Err, this isn't exactly what I was thinking.  What
</I>&gt;&gt;<i>         I was proposing...  if during the scope of the render()
</I>&gt;&gt;<i>         function, req.write() is called, then a None value
</I>&gt;&gt;<i>         would be an allowable return.   And if None is returned,
</I>&gt;&gt;<i>         req.finish() would be called automagically.
</I>&gt;<i>
</I>&gt;<i> What if you wanted to start writing the page in the render() method 
</I>&gt;<i> but keep writing it later?  Then we have None as a synonym for 
</I>&gt;<i> NOT_DONE_YET except in certain situations where you've done something 
</I>&gt;<i> to the request?
</I>&gt;<i>
</I>&gt;&gt;<i> |   2.  Alternatively, allow a Deferred to be a return
</I>&gt;&gt;<i> |       value.  Then the underlying caller can add
</I>&gt;&gt;<i> |       result.finish() to the deferred chain.   This
</I>&gt;&gt;<i> |       has the advantage of not requiring finish() to
</I>&gt;&gt;<i> |       really be managed.   Either the return value is
</I>&gt;&gt;<i> |       a string, a Deferred, (or for backwards compatibiliy
</I>&gt;&gt;<i> |       NOT_DONE_YET).  In either of the primary cases,
</I>&gt;&gt;<i> |       result.finish() always gets called... thus making
</I>&gt;&gt;<i> |       it easier on newbies.
</I>&gt;<i>
</I>&gt;<i> I've discussed this with several different people at various times... 
</I>&gt;<i> the trouble is, there isn't really a use-case that Deferreds make 
</I>&gt;<i> easier.  render() ends up being a relatively low-level interface, and 
</I>&gt;<i> the NOT_DONE_YET/write/finish API is quite convenient for the stuff 
</I>&gt;<i> that has been implemented with it.
</I>&gt;<i>
</I>&gt;<i> I am definitely a True Believer in the Deferred, but in this case it 
</I>&gt;<i> just doesn't seem worth the inconvenience of deprecating things and 
</I>&gt;<i> shuffling stuff around for a vanishingly small benefit.
</I>
Completely agree. Related to this issue, i feel, is what should be best 
practices
for a twisted web application? With all that's available, and little 
imagination,
one can very easily get all tangled up in blue ;)

In view of a site that I have the intention to build, I have been 
trying to select
what best implementation architecture to adopt, looking always for the 
most
stupidly simple. I also want to be able to handle errors as nicely as 
possible
for the users -- meaning I would like to, _whenever_ possible, return a
fully consistent page (and hopefully the one expected by the user) that
provides also the error info, but that would not require the user to do 
anything
more than correct form input data on the _same_ page (without even 
hitting Back
on the browser). I hate the feeling of being surprised with drastic 
error pages,
with all my input data apparently disappeared (also dislike pop-ups 
asking to
repost data, ...). Of course these errors will be of the type 'Ah, that 
one exists
already please try another'... This is all somewhat application 
specific, and
about interfaces, but i feel implementation style can both help or 
hinder this.

A further issue that i find very nagging (at least during development), 
is that
if an error occurs within the presentation layer, the response hangs 
forever.
(These should of course be only development bugs, but i would not like 
to
deliver an app that *may* have presentation bugs yet unknown.) I 
therefore
wrap the call to the real presentation handler in a try/catch. Errors 
in the
business logic are raised to the error handler, so this is not a 
problem. Since I
want my errors to be rendered with a fully functional response, the 
error callback
simply sets the additional response data object, and passes to the
presentation layer (this assumes that the business layer has behaved 
nicely
and attached to request the necessary and sufficient data objects, so 
that
the presentation can render it into a coherent page).

  I am going for this anatomy:


class WebAppPage(twisted.web.resource.Resource):

     def render(self, request):
         request.setHeader('Content-Type', 'text/html; charset=utf-8')
         ...
         d = threads.deferToThread(self.businessLogic, request) # to be 
threadpooled ;)
         d.addCallback(self.presentationLogic, request)
         d.addErrback(self.errBack, request)
         return NOT_DONE_YET

   def businessLogic(self, request):
       # uses functionality that is neatly factored in external modules 
;)
       # and attaches the resulting data objects to request in a 
designated
       # container, separate from args (e.g. respargs).
       # Knows no HTML, never calls request.write()

  def presentationLogic(self, result, request, error=None):
     try:
         self._presentationLogic(result, request, error)
     except:
         import sys
         request.write( '''Ooops, error in presentation layer:&lt;p&gt;%s: 
%s&lt;/p&gt;'''
                         % ( sys.exc_info()[0], ' -- 
'.join(sys.exc_info()[1].args) ))

   def _presentationLogic(self, result, request, error=None):
       # combines the data objects in args, and result (if any - thus 
may be None)
       # with rendering templates, html, js, css, ...

def errBack(self, error, request):
     self.presentationLogic([],request,error=error)


This suggests that my site's rpy resources should inherit from a 
subclass of resource,
to at least define a common error callback and presentation try/catch 
wrap for the whole
site. However, a small thing escapes me -- how do i guarantee specific 
and automatic
treatment to the request object for all my resources? E.g. setting 
specific headers,
reading cookies/session info, etc., without coding this in every rpy 
instance?

       mario



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="036340.html">[Twisted-Python] Re: Resource.render() returning NOT_DONE_YET
</A></li>
	<LI>Next message (by thread): <A HREF="036346.html">[Twisted-Python] Re: Resource.render() returning NOT_DONE_YET
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36345">[ date ]</a>
              <a href="thread.html#36345">[ thread ]</a>
              <a href="subject.html#36345">[ subject ]</a>
              <a href="author.html#36345">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
