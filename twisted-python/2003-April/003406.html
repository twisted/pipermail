<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] non-blocking .read
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20non-blocking%20.read&In-Reply-To=E190cRJ-0003PJ-00%40pyramid.twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003411.html">
   <LINK REL="Next"  HREF="003393.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] non-blocking .read</H1>
    <B>Bob Ippolito</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20non-blocking%20.read&In-Reply-To=E190cRJ-0003PJ-00%40pyramid.twistedmatrix.com"
       TITLE="[Twisted-Python] non-blocking .read">bob at redivi.com
       </A><BR>
    <I>Wed Apr  2 16:22:21 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="003411.html">[Twisted-Python] non-blocking .read
</A></li>
        <LI>Next message: <A HREF="003393.html">[Twisted-Python] FTP Server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3406">[ date ]</a>
              <a href="thread.html#3406">[ thread ]</a>
              <a href="subject.html#3406">[ subject ]</a>
              <a href="author.html#3406">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Just to bring generators back up..  Note that of course, the wrappers 
for read and the actual flow.BufferedProtocol class don't exist.. but 
their implementation is possible with the given syntax.
I'm imagining that a &quot;flow&quot; version of Int32Receiver could be coded 
like this:

class NetstringProtocol(flow.BufferedProtocol):
	def connectionMade(self):
		pass

	def handleConnection(self):
		self.connectionMade()
		reason = None

		# the string receive loop
		while 1:
			# read int32, size of int32 is 4
			result = self.read(4)
			yield result
			if result.isFailure():
				reason = result.get()
				break
			strlen, = struct.unpack('!I', result.get())
			if strlen &lt;= 0:
				endFailure = Failure(ValueError('Zero length strings are not 
valid'))
				break
			# read string
			result = self.read(strlen)
			yield result
			if result.isFailure():
				reason = result.get()
				break
			self.stringReceived(result.get())

		# exception caused connection to drop, or connection dropped on its 
own
		self.connectionLost(reason)

	def connectionLost(self, reason):
		pass	



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003411.html">[Twisted-Python] non-blocking .read
</A></li>
	<LI>Next message: <A HREF="003393.html">[Twisted-Python] FTP Server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3406">[ date ]</a>
              <a href="thread.html#3406">[ thread ]</a>
              <a href="subject.html#3406">[ subject ]</a>
              <a href="author.html#3406">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
