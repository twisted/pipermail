<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Transporting pb.Copyable classes?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Transporting%20pb.Copyable%20classes%3F&In-Reply-To=%3C6.0.1.1.0.20040421094151.04425c80%40pop.mindspring.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="040152.html">
   <LINK REL="Next"  HREF="040160.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Transporting pb.Copyable classes?</H1>
    <B>Samuel Reynolds</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Transporting%20pb.Copyable%20classes%3F&In-Reply-To=%3C6.0.1.1.0.20040421094151.04425c80%40pop.mindspring.com%3E"
       TITLE="[Twisted-Python] Transporting pb.Copyable classes?">sam at SpinwardStars.com
       </A><BR>
    <I>Wed Apr 21 09:54:03 MDT 2004</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="040152.html">[Twisted-Python] Transporting pb.Copyable classes?
</A></li>
        <LI>Next message (by thread): <A HREF="040160.html">[Twisted-Python] Transporting pb.Copyable classes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40159">[ date ]</a>
              <a href="thread.html#40159">[ thread ]</a>
              <a href="subject.html#40159">[ subject ]</a>
              <a href="author.html#40159">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 2004-04-20 06:44 PM -0700, you wrote:
&gt;<i>Oh no, no mutable state!  Purely static data and static methods.
</I>&gt;<i>What I have coils down to something like this:
</I>&gt;<i>
</I>&gt;<i>class Terrain( pb.Copyable, pb.RemoteCopy ):
</I>&gt;<i>     def moveCost( cls, unit ):
</I>&gt;<i>         return cls.cost
</I>&gt;<i>     moveCost = classmethod( moveCost )
</I>&gt;<i>
</I>&gt;<i>class Mountains( Terrain ):
</I>&gt;<i>     cost = 6
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>A bunch of hexes then have their .terrain = Mountains (etc.)  I could easily
</I>&gt;<i>change this to instantiation the various Terrains, but in my mind that
</I>&gt;<i>implies that an instance's state could differ.  I'm beginning to think
</I>&gt;<i>the distinction is more trouble than it's worth however, and potentially
</I>&gt;<i>confusing.
</I>...and...
&gt;<i>I have a dictionary of hexes keyed by their grid location.
</I>&gt;<i>
</I>&gt;<i>map.cells = {(1,1):hexCellInstance, ...}
</I>&gt;<i>
</I>&gt;<i>Each of these cells has a .terrain, which is a reference to a Terrain
</I>&gt;<i>subclass.  These have static data and methods, for use by various game
</I>&gt;<i>algorithms, e.g. how far can unit Foo move through Mountains.
</I>&gt;<i>
</I>&gt;<i>On each turn a (filtered) version of this state is passed to game clients,
</I>&gt;<i>so that they can view it, validate their orders against it, etc.
</I>
How about making Mountains, Plains, etc. Singletons?
Then, instead of assigning hexCellInstance.terrain=Mountain,
you assign hexCellInstance.terrain=Mountain() (note the
parentheses!). At that point, each cell.terrain is an object
reference instead of a class reference and (IIUC) should
remote-copy properly.

Caveat: I've not used pb; this is based on my *very* weak
understanding (misunderstanding?) of it. In particular,
I don't know how pb/copyable would interact with a singleton.
I would *expect* that the remote unserialization would
(eventually) invoke Mountains.__call__ and get a reference
to the corresponding singleton on the client side.

class Singleton(type):
     def __init__( cls, name, bases, classdict ):
         super( Singleton, cls ).__init__( name, bases, classdict )
         cls.instance = None
     def __call__( cls, *args, **kw ):
         if cls.instance is None:
             cls.instance = super( Singleton, cls ).__call__( *args, **kw )
         return cls.instance

class Mountains( Terrain ):
     __metaclass__ = Singleton
     cost = 6

- Sam


__________________________________________________________
Spinward Stars, LLC                        Samuel Reynolds
Software Consulting and Development           303-805-1446
<A HREF="http://SpinwardStars.com/">http://SpinwardStars.com/</A>            <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">sam at SpinwardStars.com</A> 




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="040152.html">[Twisted-Python] Transporting pb.Copyable classes?
</A></li>
	<LI>Next message (by thread): <A HREF="040160.html">[Twisted-Python] Transporting pb.Copyable classes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40159">[ date ]</a>
              <a href="thread.html#40159">[ thread ]</a>
              <a href="subject.html#40159">[ subject ]</a>
              <a href="author.html#40159">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
