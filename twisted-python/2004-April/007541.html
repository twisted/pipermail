<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] why deferred.setTimeout is not my favorite API	method
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20why%20deferred.setTimeout%20is%20not%20my%20favorite%20API%0A%09method&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007540.html">
   <LINK REL="Next"  HREF="007542.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] why deferred.setTimeout is not my favorite API	method</H1>
    <B>slyphon at twistedmatrix.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20why%20deferred.setTimeout%20is%20not%20my%20favorite%20API%0A%09method&In-Reply-To="
       TITLE="[Twisted-Python] why deferred.setTimeout is not my favorite API	method">slyphon at twistedmatrix.com
       </A><BR>
    <I>Sun Apr 18 04:48:28 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="007540.html">[Twisted-Python] addCallbacks issue
</A></li>
        <LI>Next message: <A HREF="007542.html">[Twisted-Python] why deferred.setTimeout is not my favorite API	method
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7541">[ date ]</a>
              <a href="thread.html#7541">[ thread ]</a>
              <a href="subject.html#7541">[ subject ]</a>
              <a href="author.html#7541">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>It looks like I've succeeded in rekindling interest in this issue :)
</I>&gt;<i>
</I>&gt;&gt;<i> The reason why I added a &quot;DON'T USE THIS&quot; to the docstring was that I
</I>&gt;&gt;<i> find that we are telling people this at least once a week. I think it
</I>&gt;&gt;<i> has more gravitas coming from the API documentation, as there is this
</I>&gt;&gt;<i> illusion that the people on IRC don't really know what they're talking
</I>&gt;&gt;<i> about, but if the author has marked something in the documentation, it
</I>&gt;&gt;<i> has a certain level of legitimacy.
</I>&gt;<i>
</I>&gt;<i>Well, I guess I'm a bit confused.  Why not raise a DeprecationWarning as
</I>&gt;<i>well then?  Is &quot;DON'T USE THIS&quot; meant to be a watered-down version of a
</I>&gt;<i>DeprecationWarning?
</I>
Yes. It was a diplomatic move. I understand that you wrote this
function, and that you feel strongly that it adds value to the twisted
library. To me, a DeprecationWarning represents that there has been a
consensus reached that a certain function is not going to be supported
in the future. I wouldn't be so haughty as to decide that on my own, so
I put a note that reflected the advice that we normally give users on
IRC into the API docs.

&gt;<i>
</I>&gt;&gt;<i> I agree with spiv in the sense that it would be nice to have a minimal
</I>&gt;&gt;<i> interface that would provide this functionality. However, i think that
</I>&gt;&gt;<i> the level of control that is needed to pull this off properly is best
</I>&gt;&gt;<i> served by writing an explicit timeout method and accompanying call to
</I>&gt;&gt;<i> callLater. 
</I>&gt;<i>
</I>&gt;<i>The tricky part isn't the callLater, it's the actual cancellation of
</I>&gt;<i>whatever the operation that would've produced a deferred result -- and
</I>&gt;<i>that's something defer.py can't help with, because it is app-specific.
</I>
Indeed, i realised the flaws in my example about 20 minutes after
sending it

&gt;&gt;<i>
</I>&gt;&gt;<i> now, I'd like to present the idiom that we are try to encourage users to
</I>&gt;&gt;<i> follow every time we have to steer them away from setTimeout. 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> ------------------------------------------------------
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> d = iReturnADeferred()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> def onTimeout():
</I>&gt;&gt;<i>     handleTimeoutCondition()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> delayedCall = reactor.callLater(timeoutLen, onTimeout)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> def success(value):
</I>&gt;&gt;<i>     handleSuccess()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> def nonTimeoutFailure(reason):
</I>&gt;&gt;<i>     handleErrorCondition()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> def cancelTimeout(val):
</I>&gt;&gt;<i>     if delayedCall.active():
</I>&gt;&gt;<i>         delayedCall.cancel()
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> d.addBoth(cancelTimeout)
</I>&gt;&gt;<i> d.addCallback(success)
</I>&gt;&gt;<i> d.addErrback(nonTimeoutFailure)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> -------------------------------------------------------
</I>&gt;&gt;<i> 
</I>&gt;<i>First, there's a bug.  Presumably, cancelTimeout should return val,
</I>&gt;<i>otherwise you swallow the result/failure, regardless of what actually
</I>&gt;<i>happens.
</I>
Yes, indeed.

&gt;<i>
</I>&gt;<i>What I don't see here is the most important part: presumably,
</I>&gt;<i>iReturnADeferred starts a long-running operation going, maybe a call to a
</I>&gt;<i>remote server.  This code doesn't do anything to stop that operation, and
</I>&gt;<i>doesn't do anything to prevent an AlreadyCalledError happening in that code
</I>&gt;<i>when the long-running operation completes.  Or does the mysterious
</I>&gt;<i>handleTimeoutCondition method do that?
</I>&gt;<i>
</I>&gt;<i>setTimeout doesn't provide that either -- but it was my understanding that
</I>&gt;<i>that was the main objection to it.  Why is handling this yourself (which as
</I>&gt;<i>you demonstrate is error-prone!) an improvement over setTimeout?
</I>
I apologise for the magicness implied by my example. 

What offends me about setTimeout is that it is a solution to a vague
problem. It seems to me that there are two different issues here, and
setTimeout doesn't solve either of them cleanly. 

The first is how to actually stop a long-running operation after a given
amount of time. Indeed, this functionality must be provided by the
framework author, perhaps exposing a public '.cancel()' method. There is
no way to provide or deal with this behavior in a generic way.

The other problem that I believe could be solved by a setTimeout-y
method is how to indicate that the client isn't interested in the
result of a long-running operation any more. 

I think this is an important distinction to make. It is a condition that
happens at the interface between your code and iReturnADeferred().
Instead of trying to stop whatever iReturnADeferred() is doing, you come
up with a way of saying, &quot;after foo seconds, _i don't care about this
result_ and this is what we should do...&quot; 


&gt;<i>
</I>&gt;&gt;<i>     Deferreds are a _reactive_ tool, they fire in response to an event
</I>&gt;&gt;<i>     
</I>&gt;&gt;<i>     delayed calls are a _proactive_ tool, they cause events to fire
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>     Mixing the two together for the special case of dealing with a
</I>&gt;&gt;<i>     timeout is at best hairy and at worst ugly and confusing.
</I>&gt;<i>
</I>&gt;<i>I disagree.  The event that Deferreds react to has to come from *somewhere*.
</I>
Yes, but the deferred is a reaction to an event. My point was that
you're adding event-creating code to an object whose job it is to react
to events. All i'm saying is that this adds complexity. Without the
current implementation of setTimeout, deferreds would be /completely
reactive/, and i think we can find a way to make them _appear_ that way.


&gt;<i>
</I>&gt;<i>What is problematic is that timeouts provide a *second* place that might
</I>&gt;<i>trigger the Deferred, in addition to whatever the usual place the creator
</I>&gt;<i>expects.  With setTimeout, this means that AlreadyCalledErrors can arise
</I>&gt;<i>from calls to d.callback/d.errback where the original author didn't expect
</I>&gt;<i>them, just because a user of that module is setting timeouts to Deferreds.
</I>&gt;<i>I thought this was the primary objection to setTimeout?  It's certainly the
</I>&gt;<i>biggest concern I have about it.
</I>
indeed, i think this is the biggest problem I've faced when dealing with
deferreds

&gt;<i>
</I>&gt;<i>Ok, how about a compromise: if a creator a Deferred is able to cope with
</I>&gt;<i>timeouts, they should pass an &quot;allowTimeouts=True&quot; flag to the constructor.
</I>&gt;<i>Without it, the setTimeout method will raise an AssertionError.  (For
</I>&gt;<i>backwards-compatibility, for a release it will merely raise a Warning rather
</I>&gt;<i>than an exception).  I'm willing to implement this, and properly document
</I>&gt;<i>setTimeout in the Deferred HOWTO while I'm at it.  This is now my preferred
</I>&gt;<i>option.
</I>
Hrrrrrrrrrrrrrrrrrrrmmmmm. Not a baaaaaaad compromise, but there's
something about it that doesn't sit with me. It seems that it would add
complexity to the very elegant design of Deferreds. My overall qualm
with setTimeout is that I think that if the API was in the state of
stability it is now, and setTimeout was proposed, that it's current
implementation would be rejected. 

I think that if we're going to provide this functionality, we should try
to come up with as transparent a solution as we can.

the following is an example of an idea i've been kicking around. Why
can't we just ignore the deferred after the timeout happens? 

(I use the style of my example above because that is what i'm
more comfortable with. If setTimeout would provide a similar
functionality, then i'm all for it.)

-----------------------------------------------------------------------

#!/usr/bin/env python2.3

from twisted.internet import defer, reactor

iTimedOut = False

defer.Deferred.debug = True

def setTimeoutForDeferred(d, seconds):
    aNewDeferred = defer.Deferred()
    
    from twisted.internet import reactor
    
    def onTimeout():
        # kill any further action on this deferred to avoid AlreadyCalledErrors
        d.callbacks = []  

        iTimedOut = True
        aNewDeferred.errback(defer.TimeoutError('deferred timed out'))
        
    delayed = reactor.callLater(seconds, onTimeout)
        
    def cb(value):
        if not iTimedOut:
            aNewDeferred.callback(value)
        
    def eb(reason):
        if not iTimedOut:
            aNewDeferred.errback(reason)
            
    def cancelTimeout(val):
        if delayed.active():
            delayed.cancel()
        return val

    d.addCallbacks(cb, eb)
    d.addBoth(cancelTimeout)

    return aNewDeferred


def iReturnADeferred():    # this is frameworky code
    d = defer.Deferred()
    reactor.callLater(5, d.callback, 'winnar!')
    return d


def iSetATimeout():    # this represents client-programmer code
    origd = iReturnADeferred()

    d = setTimeoutForDeferred(origd, 2)

    def cb(val):
        # if we time out, this code should not be called
        print &quot;hooray!iReturnADeferred returned: %s&quot; % val

    def eb(reason):
        e = reason.trap(defer.TimeoutError)
        if e == defer.TimeoutError:
            print &quot;woops! we timed out&quot;
        else:
            print &quot;uh-oh! we didn't time out and there was an error!&quot;

    d.addCallbacks(cb, eb)
    return d



if __name__ == &quot;__main__&quot;:
    d = iSetATimeout()

    reactor.run()


-----------------------------------------------------------------------

Again, this is just code to illustrate my idea. There's no reason why
we have to hand the deferred that's returned by iReturnADeferred to the
rest of our code. We can hold on to that one and can substitute our own
deferred that is a bit more intelligent, it understands how to break the
chain after a length of time has passed.

The advantage here is that the author of iReturnADeferred doesn't need
to plan specially for timeout conditions, and the client doesn't have to
worry about AlreadyCalled errors (which to me are not something to
pooh-pooh, I take them as a sign that there's something wrong with my
design).

&gt;&gt;<i>     I would like to recommend that we document a best-practice idiom
</I>&gt;&gt;<i>     in the deferred api documentation, and remove setTimeout.
</I>&gt;<i>
</I>&gt;<i>I don't believe it's easily written until you have a pretty advanced grasp
</I>&gt;<i>of both Deferreds and reactor.callLater.  I don't see why allowing users of
</I>&gt;<i>Deferreds to just say &quot;d.setTimeout(5)&quot; is a bad thing?
</I>

again, there's a difference between stopping a long-running or
long-waiting operation, which is something that deferreds cannot handle
at all, and indicating that after a certain amount of time, we don't
care about the result of that operation and would like to consider it an
erroneous condition.

I don't think that setTimeout makes this distinction clear (which may,
of course be a fault of the documentation/examples). Also, I want
whatever solution is accepted to make it easier to avoid
AlreadyCalled errors.


&gt;<i>
</I>&gt;<i>setTimeout has the big big advantage that it's dead easy for *users* of
</I>&gt;<i>Deferreds to work with.  The trouble with it is that it requires some work
</I>&gt;<i>from the *creators* of Deferreds to support safely -- but I see the same
</I>&gt;<i>flaw in every solution proposed, including your own of documenting and
</I>&gt;<i>entirely by-hand idiom.
</I>&gt;<i>
</I>
okay, i can understand this, and can agree in some sense. 


&gt;&gt;<i> spiv said: 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> &quot;In hindsight, I should've thought harder about the implications of
</I>&gt;&gt;<i> setTimeout before I committed it... but now it's there, I don't like the
</I>&gt;&gt;<i> idea of ripping it out unless we have a clearly better solution.&quot;
</I>&gt;<i>
</I>&gt;<i>I think my &quot;allowTimeouts&quot; proposal above is a clearly better solution. :)
</I>
I don't like it. It just seems hacky. deferreds should handle this case,
without any extra specification from the author, as I believe that my
idea above would. 

&gt;<i>
</I>&gt;<i>I'm going to spend a little time pondering it, then I'll look at
</I>&gt;<i>implementing a patch and adding it to the bug.
</I>
please, lets come to a consensus before committing anything. ;)


Respectfully yours,
Jonathan 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007540.html">[Twisted-Python] addCallbacks issue
</A></li>
	<LI>Next message: <A HREF="007542.html">[Twisted-Python] why deferred.setTimeout is not my favorite API	method
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7541">[ date ]</a>
              <a href="thread.html#7541">[ thread ]</a>
              <a href="subject.html#7541">[ subject ]</a>
              <a href="author.html#7541">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
