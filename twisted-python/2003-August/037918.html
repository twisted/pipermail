<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Breaking up long computations
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Breaking%20up%20long%20computations&In-Reply-To=%3C20030806095027.GA11724%40frobozz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="037916.html">
   <LINK REL="Next"  HREF="037921.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Breaking up long computations</H1>
    <B>Andrew Bennetts</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Breaking%20up%20long%20computations&In-Reply-To=%3C20030806095027.GA11724%40frobozz%3E"
       TITLE="[Twisted-Python] Breaking up long computations">andrew-twisted at puzzling.org
       </A><BR>
    <I>Wed Aug  6 03:50:27 MDT 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="037916.html">[Twisted-Python] Breaking up long computations
</A></li>
        <LI>Next message (by thread): <A HREF="037921.html">[Twisted-Python] Breaking up long computations
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37918">[ date ]</a>
              <a href="thread.html#37918">[ thread ]</a>
              <a href="subject.html#37918">[ subject ]</a>
              <a href="author.html#37918">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Aug 06, 2003 at 10:55:49AM +0200, Nicola Larosa wrote:
[...]
&gt;<i> To be able to make one operation per event, I break the loops using iter()
</I>&gt;<i> and reactor.callLater(), and end up with this, actually working, script:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> from twisted.internet import reactor
</I>&gt;<i> 
</I>&gt;<i> def computeRow(sqrSum, rowIter, dataIter):
</I>&gt;<i>     try:
</I>&gt;<i>         num = rowIter.next()
</I>&gt;<i>     except StopIteration:
</I>&gt;<i>         reactor.callLater(0, computeData, sqrSum, dataIter)
</I>&gt;<i>     else:
</I>&gt;<i>         sqrSum += num*num
</I>&gt;<i>         reactor.callLater(0, computeRow, sqrSum, rowIter, dataIter)
</I>&gt;<i> 
</I>&gt;<i> def computeData(sqrSum, dataIter):
</I>&gt;<i>     try:
</I>&gt;<i>         row = dataIter.next()
</I>&gt;<i>     except StopIteration:
</I>&gt;<i>         print sqrSum
</I>&gt;<i>         reactor.stop()
</I>&gt;<i>     else:
</I>&gt;<i>         rowIter = iter(row)
</I>&gt;<i>         reactor.callLater(0, computeRow, sqrSum, rowIter, dataIter)
</I>&gt;<i> 
</I>&gt;<i> data = ((1, 1, 1),
</I>&gt;<i>         (2, 2, 2),
</I>&gt;<i>         (3, 3, 3))
</I>&gt;<i> sqrSum = 0
</I>&gt;<i> dataIter = iter(data)
</I>&gt;<i> computeData(sqrSum, dataIter)
</I>&gt;<i> reactor.run()
</I>
Note that both computeRow and computeData return immediately.  (Well,
computeRow does a tiny amount of work, but no matter how big your data
matrix is, computeRow will always do a small but constant amount per call,
which is the main thing)

&gt;<i> Apparently, this allows Twisted to process any other events that may happen
</I>&gt;<i> in the middle of the computation. But I wonder, since I'm not using threads,
</I>&gt;<i> and Twisted runs the reactor and my code in the same process/thread, how
</I>&gt;<i> could such events get inserted into the queue?
</I>
Precisely because your functions return control to the reactor repeatedly,
rather than doing it all in one hit, there is now room for the reactor to
process any other events that need processing, if any.

&gt;<i> I mean, if I'm appending non-delaying events from inside the computation,
</I>&gt;<i> one after the other, how can anything else get a chance to get started
</I>&gt;<i> *before* the computation completes?
</I>
The key here is that reactor.callLater(0, func) will *always* cause the
function to be called on the next iteration of the reactor, even though it
can be considered already due, so that other events get a chance to happen.

E.g., consider a network server that is doing the above calculation in
addition to serving some network clients.  Network events can happen at any
time, they are caused by things completely external to your process, so it's
entirely possible that some data might arrive while computeRow is doing its
subset of the calculation.  Then, when computeRow returns, and the reactor
will do something like this:
    - check that there are no more scheduled events that need to be run *in
      this iteration*.  It *won't* pull anything off the delayed call queue
      that wasn't there before it started processing delayed calls.  Let's
      assume there's nothing else to do here.  [I'm guessing this is the bit
      you weren't getting, but I'll tell complete story anyway, just in
      case]
    - then the reactor will finish that iteration, so it'll start a new one.
    - it'll peek at the first thing on the delayed call queue, to see how
      long until something needs to be called
    - it will then check for IO events using select (or poll, or kqueue,
      or ...).  It passes the time to the next event as the timeout for the
      select call, so if there's been no unprocessed network activity since
      the last iteration, it will block until that timeout, or there is some
      activity (which ever happens first).
    - If there's any IO events to be processed, it calls the relevant event
      handlers.  In my example above, perhaps a message from a client just
      arrived, this will lead (via a few layers of abstraction) to a
      protocol's dataReceived method being called (which in turn may call a
      'messageReceived' handler and spawn a database query, or something).
    - After the IO events have been processed, it will finally turn its
      attention back to the delayed call queue, find all of them that are
      now due, and run those.
    - And then the next reactor iteration will happen.

So, every time you call reactor.callLater(0, func) and return back to the
reactor, rather than doing the work immediately, you're giving the reactor a
chance to breath and catch up on any other events that have been happening
-- but it will get back to your work as soon as it has.  If there's nothing
else happening, then your task will be getting 100% of the CPU time, minus the
overhead of jumping back-and-forth between the reactor and your functions
periodically to make sure nothing else needs Twisted's attention.

I hope I've made things clearer, rather than just confusing them :)

-Andrew.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="037916.html">[Twisted-Python] Breaking up long computations
</A></li>
	<LI>Next message (by thread): <A HREF="037921.html">[Twisted-Python] Breaking up long computations
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37918">[ date ]</a>
              <a href="thread.html#37918">[ thread ]</a>
              <a href="subject.html#37918">[ subject ]</a>
              <a href="author.html#37918">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
