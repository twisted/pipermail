<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Interface.adaptWith and  Interface.__adapt__
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Interface.adaptWith%20and%0A%20%20Interface.__adapt__&In-Reply-To=%3C5.1.0.14.0.20030605082143.03f09ec0%40mail.telecommunity.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="036902.html">
   <LINK REL="Next"  HREF="036951.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Interface.adaptWith and  Interface.__adapt__</H1>
    <B>Phillip J. Eby</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Interface.adaptWith%20and%0A%20%20Interface.__adapt__&In-Reply-To=%3C5.1.0.14.0.20030605082143.03f09ec0%40mail.telecommunity.com%3E"
       TITLE="[Twisted-Python] Interface.adaptWith and  Interface.__adapt__">pje at telecommunity.com
       </A><BR>
    <I>Thu Jun  5 07:00:25 MDT 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="036902.html">[Twisted-Python] Interface.adaptWith and Interface.__adapt__
</A></li>
        <LI>Next message (by thread): <A HREF="036951.html">[Twisted-Python] Interface.adaptWith and Interface.__adapt__
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36920">[ date ]</a>
              <a href="thread.html#36920">[ thread ]</a>
              <a href="subject.html#36920">[ subject ]</a>
              <a href="author.html#36920">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 01:59 AM 6/5/03 -0400, Glyph Lefkowitz wrote:
&gt;<i>On Wednesday, June 4, 2003, at 06:10 PM, Phillip J. Eby wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>Anyway...  I noticed that the only code in Twisted currently (that I 
</I>&gt;&gt;<i>could find) that actually uses the current __adapt__ setup is the test 
</I>&gt;&gt;<i>suite.  Is there any way this might be changeable to something more 
</I>&gt;&gt;<i>compatible with PEP 246?
</I>&gt;<i>
</I>&gt;<i>Thanks for bringing this to my attention.  As I was perusing the 
</I>&gt;<i>implementation, I realized that the reason we committed this particular 
</I>&gt;<i>incompatibility was being invalidated a scant two lines away :-).  I could 
</I>&gt;<i>have sworn it didn't used to have a try:except: block, but I've checked in 
</I>&gt;<i>a revised version now.
</I>&gt;<i>
</I>&gt;<i>As I understand it, PEP 246 cannot be implemented without raising 
</I>&gt;<i>exceptions in __adapt__.
</I>
Actually, no.  __adapt__ is also allowed to return None to signal inability 
to adapt.  And, the consensus so far of people I've talked with (Jim Fulton 
and Guido) is that PEP 246 should be revised in that area anyway, such that 
it isn't even an *option* to raise TypeError to signal 
failure.  PyProtocols will only ignore TypeError if it looks like it came 
from calling an unbound class method, not if it looks like it came from the 
__conform__ or __adapt__ method body.


&gt;&gt;<i>I mean, if I jump through enough hoops building adapters and 
</I>&gt;&gt;<i>monkeypatching, I can probably make it so that this will work 
</I>&gt;&gt;<i>transparently, and anybody who uses PyProtocols will then be able to mix 
</I>&gt;&gt;<i>Twisted, Zope, and PyProtocols interfaces in their applications.
</I>&gt;&gt;<i>But it's pretty messy, and I'm wondering about the copyright status if I 
</I>&gt;&gt;<i>have to copy a lot of code from MetaInterface.__call__ in order to 
</I>&gt;&gt;<i>monkeypatch a replacement.  (I'd like to release PyProtocols under the 
</I>&gt;&gt;<i>PSF license.)
</I>&gt;<i>
</I>&gt;<i>PyProtocols looks like an interesting project, and I'd like to support 
</I>&gt;<i>such an effort at interoperability.  Monkey-patching MetaInterface is 
</I>&gt;<i>almost certainly the wrong thing to do.  Perhaps it would be best if we 
</I>&gt;<i>did not call our interface-aware adaptation mechanism &quot;__adapt__&quot;, but 
</I>&gt;<i>something like &quot;adaptWithDefault&quot;?
</I>
That would work; at least, it makes the monkeypatch quite a bit simpler.

Are you actually using the __adapt__ method for anything yet?  The only 
code I found with an actual __adapt__ method was in the test suite.


&gt;<i>I am not sure exactly how you're doing compatibility, but perhaps then you 
</I>&gt;<i>could provide a subclass of Interface that provided an adaptWithDefault 
</I>&gt;<i>that called __adapt__ with the proper arguments?
</I>
PyProtocols does compatibility by:

1. defining adapters to adapt &quot;foreign&quot; interface types (Zope, Twisted) to 
its own IOpenProtocol interface

2. monkeypatching the foreign interface type itself (Zope InterfaceClass, 
Twisted MetaInterface) to add an __adapt__ method that implements PEP 246 
by &quot;calling down&quot; to the foreign type's normal adaptation methods.  E.g. 
for Zope, the __adapt__ I patch in just does:

if self.isImplementedBy(obj):
     return obj

And for Twisted, the __adapt__ I add does the equivalent of:

     def __adapt__(self, obj):

         if implements(obj, self):
             return obj

         # Get Twisted to try and adapt
         return self(ob, None)

In other words, the __adapt__ I add checks whether Twisted says the object 
already implements the interface, and if so, return it.  Otherwise, adapt 
it by calling the interface on the object, with a default of None.

If you were to switch from using __adapt__ to adaptWithDefault in your 
__call__ method, and added the above as MetaInterface.__adapt__, your 
interfaces would be PEP 246 compatible without any monkeypatching.  For 
compatibility with PyProtocols' declaration API, I would just supply an 
adapter.

(From recent conversations with Jim Fulton, it sounds like he plans to 
eventually add a PEP 246-compatible __adapt__ method to Zope interfaces as 
well, so at that point I could drop the monkeypatching for Zope too.)

I've done a preliminary sketch of an adapter for Twisted interfaces, but 
there are a few holes because I'm not 100% clear on the intended semantics 
of Twisted interfaces in some areas.  Actually, I get the impression that 
that's because Twisted hasn't really defined those semantics either.  For 
example, Twisted doesn't appear to distinguish between &quot;object implements&quot; 
and &quot;class implements&quot;.  If I call 'getInterfaces()' on a class, it will 
tell me that the class implements the same interfaces that its instances 
do.  From my POV, that doesn't make any sense, but perhaps it is a 
documented or at least intended limitation?  Certainly, I will need to 
document it in my &quot;Compatibility&quot; section (not yet written).

For right now, my Twisted adapter just pokes a new __implements__ onto 
whatever object is having declarations made about it, whether it's a type 
declaration or an instance declaration.  This means that PyProtocols will 
behave oddly if you pass a class to adapt().  Of course, Twisted will also 
behave oddly if you pass a class to ISomething().

I'm also having trouble figuring out how to apply transitive adapter 
semantics to Twisted.  AFAICT, Twisted adapters are not normally 
transitive.  However, unlike PyProtocols, Twisted interfaces don't know 
about all their adaptations, so there doesn't seem to be a way to issue 
declarations to make them transitive.  But I guess that's optional, since I 
didn't really intend to make PyProtocols add any new functionality to Zope 
or Twisted, just make it reasonably possible to interact with them.

It should be possible at this point to have a PyProtocols interface declare 
that it extends both a Twisted and a Zope interface, without any metaclass 
incompatibilities.  Of course, Twisted and Zope still use mutually 
incompatible definitions of '__implements__', so actually *using* an 
interface that extended both a Twisted and a Zope interface would be 
problematic.  :)



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="036902.html">[Twisted-Python] Interface.adaptWith and Interface.__adapt__
</A></li>
	<LI>Next message (by thread): <A HREF="036951.html">[Twisted-Python] Interface.adaptWith and Interface.__adapt__
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36920">[ date ]</a>
              <a href="thread.html#36920">[ thread ]</a>
              <a href="subject.html#36920">[ subject ]</a>
              <a href="author.html#36920">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
