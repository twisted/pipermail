<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Subclassing Resource, problems accessing persistent data/using registry
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Subclassing%20Resource%2C%20problems%20accessing%20persistent%20data/using%20registry&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004612.html">
   <LINK REL="Next"  HREF="004614.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Subclassing Resource, problems accessing persistent data/using registry</H1>
    <B>Thomas Weholt</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Subclassing%20Resource%2C%20problems%20accessing%20persistent%20data/using%20registry&In-Reply-To="
       TITLE="[Twisted-Python] Subclassing Resource, problems accessing persistent data/using registry">2002 at weholt.org
       </A><BR>
    <I>Wed Jun 18 17:53:51 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="004612.html">[Twisted-Python] passing exceptions to an xmlrpc client
</A></li>
        <LI>Next message: <A HREF="004614.html">[Twisted-Python] To twisted.web beginners: don't use RPYs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4613">[ date ]</a>
              <a href="thread.html#4613">[ thread ]</a>
              <a href="subject.html#4613">[ subject ]</a>
              <a href="author.html#4613">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I've subclassed twisted.web.resource to create my own type of rpys where the
content is wrapped in a site-wide template before being returned to the
client. This makes it easier and quicker to generate content in the rpys
themselves. I've also created a response-object instead of returning just a
string from the render-method or using request.write. IMHO a server should
work with a response to a request, not use the request itself to send
content back to the client.

The code in the bottom of the posting works great ( making it into a rpy,
running mktap + twistd etc. ), but if I create a rpy file called test.rpy,
with something like :

--------------------- snip
snip --------------------------------------------------

from hs.twisted.eloperesource import ElopeRespource

class test(ElopeRespource):
    def content(self, request, response, server):
        response.add('hello world, once again')

resource = test()

--------------------- snip
snip --------------------------------------------------

I cannot get the persistent data in my custom server-class to be registered,
the registry.getComponent-method is not available. Can I register persistent
data in any other way and somehow pass it to my own rpys? How can I manually
register persistent data, not use the automagical-way in rpys? I create a
web.tap file and try to serve the data using twisted -f web.tap etc. but it
raises an exception.

Any hint, idea, flame or constructive comment would be appreciated.

Best regards,
Thomas W

--------------------- snip
snip --------------------------------------------------

import os, types, sys, cgi, time, string, cStringIO, gzip, traceback, PyMeld
from twisted.web import server, resource
from twisted.internet import reactor
from twisted.web import server, resource, error
from twisted.protocols import http
from twisted.web.static import File
from twisted.internet import reactor

# special custom classes
from hs.twisted.response import response
from hs.twisted.Server import Server

server = registry.getComponent(Server)
if not server:
    registry.setComponent(Server, Server())
server = registry.getComponent(Server)

class ElopeResource(resource.Resource):

    isLeaf = True

    def __init__(self):
        resource.Resource.__init__(self)

    def content(self, request, response, server):
        # Should be overridden by the rpy
        response.add('Should be overridden') # added content is accumulated
in the response-object

    def render(self, request):
        resp = response()
        self.content(request, resp, server)

        if resp.filename and not resp.content_type in ['text/xml',
'text/plain', 'text/html', 'text/css']:
            # special handler to return files not directly available online,
located somewhere on local filesystem
            filesize = os.stat(resp.filename)[6]
            modification_time = os.stat(resp.filename)[8]
            request.setHeader(&quot;Content-Length&quot;, filesize)
            request.setHeader(&quot;Last-modified&quot;,
time.ctime(modification_time))
            request.setHeader(&quot;Content-Disposition&quot;, 'file; filename=&quot;%s&quot;' %
os.path.split(resp.filename)[1])
            return File(resp.filename,
getContentType(resp.filename)).render(request)

        elif resp.url:
            request.redirect(resp.url)
            return 'You should be redirect to %s' % resp.url

        else:
            if resp.filename: # a plain-text, html or xml-file
                resp.content = open(resp.filename).read()

            request.setResponseCode(resp.response_code, 'OK')
            request.setHeader(&quot;Content-type&quot;, resp.content_type)
            if request.received_headers.has_key('accept-encoding'): # custom
gzip-encoding
                if 'gzip' in map(string.strip,
request.received_headers['accept-encoding'].split(',')) and \
                   resp.content_type in ['text/xml', 'text/plain',
'text/html', 'text/css']:
                    try:
                        fd = cStringIO.StringIO()
                        gz = gzip.GzipFile(filename='', mode='wb',
compresslevel=9, fileobj=fd)
                        resp.content = '&lt;html&gt;&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;' %
resp.content
                        gz.write(resp.content)
                        gz.close()
                        gzHtml = fd.getvalue()
                        request.setHeader(&quot;Content-Length&quot;, len(gzHtml))
                        request.setHeader(&quot;Content-Encoding&quot;, 'gzip')
                        return gzHtml
                    except:
                        fp = cStringIO.StringIO()
                        traceback.print_exc(file=fp)
                        content = fp.getvalue()
                        return self.templates.populateSceleton(content,
'default')
            else:
                content = '&lt;html&gt;&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;' % resp.content
                request.setHeader(&quot;Content-Length&quot;, len(content))
                return content

class Simple(ElopeResource):

    def content(self, request, response, server):
        response.add('Hello world! And there\'s even some persistent data
from the server : %s' % vars(server))
        server.data['time'] = time.ctime(time.time())

resource = Simple()



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004612.html">[Twisted-Python] passing exceptions to an xmlrpc client
</A></li>
	<LI>Next message: <A HREF="004614.html">[Twisted-Python] To twisted.web beginners: don't use RPYs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4613">[ date ]</a>
              <a href="thread.html#4613">[ thread ]</a>
              <a href="subject.html#4613">[ subject ]</a>
              <a href="author.html#4613">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
