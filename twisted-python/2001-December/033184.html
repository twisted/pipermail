<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Passport, my ideas about an LDAP backend
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Passport%2C%20my%20ideas%20about%20an%20LDAP%20backend&In-Reply-To=%3C87k7v3icaj.fsf%40ki.yok.utu.fi%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="033183.html">
   <LINK REL="Next"  HREF="033180.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Passport, my ideas about an LDAP backend</H1>
    <B>Tommi Virtanen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Passport%2C%20my%20ideas%20about%20an%20LDAP%20backend&In-Reply-To=%3C87k7v3icaj.fsf%40ki.yok.utu.fi%3E"
       TITLE="[Twisted-Python] Passport, my ideas about an LDAP backend">tv at twistedmatrix.com
       </A><BR>
    <I>Mon Dec 31 09:28:52 MST 2001</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="033183.html">[Twisted-Python] Passport, my ideas about an LDAP backend
</A></li>
        <LI>Next message (by thread): <A HREF="033180.html">[Twisted-Python] newbie question: error handling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33184">[ date ]</a>
              <a href="thread.html#33184">[ thread ]</a>
              <a href="subject.html#33184">[ subject ]</a>
              <a href="author.html#33184">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Glyph Lefkowitz &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at twistedmatrix.com</A>&gt; writes:

&gt;<i> &gt; Requirement #2: Passport must be able to store data in the
</I>&gt;<i> &gt; Perspective during authentication.
</I>&gt;<i> 
</I>&gt;<i> &gt; However, if the application wants to use LDAP for more than just user
</I>&gt;<i> &gt; authentication, things get a bit worse. We could just store the
</I>&gt;<i> &gt; password we saw the user enter, and later bind to the LDAP server as
</I>&gt;<i> &gt; this user. However, I dislike storing plain-text passwords in virtual
</I>&gt;<i> &gt; memory.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure what you're talking about here -- it sounds like you're
</I>&gt;<i> using &quot;authentication&quot; to mean two different things.  First, what is
</I>&gt;<i> *the* Perspective?  An Identity (presumably Identities are stored in
</I>&gt;<i> LDAP) has multiple Perspectives.
</I>
	I'm probably all confused by Perspectives and Identities. 
	s/Perspective/Identity/. And naturally the fd shouldn't be
	persistent -- just to make sure.

	Yes, I want LDAP to be more than authentication. Consider an
	application that has users stored in the LDAP tree, in one
	subtree. It also has some user-editable data stored in (same
	or different) subtree. LDAP server ACLs allow some of the
	users access to some of the fields, etc. If you want to make a
	web frontend, you need to use LDAP as an authentication
	backend, and you need to use that authentication (to the LDAP
	server) in order to perform actions on the LDAP server.

	Think of it this way: an authentication server gives you a
	key, and when you later perform actions toward external
	services as the authenticated user, you need to provide the
	key. In this case, the key is a TCP connection. I believe
        Kerberos follows this model, with a &quot;real&quot; key.

&gt;<i> &gt; Requirement #3: Passport must be able to ask users to
</I>&gt;<i> &gt; reauthenticate.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; A better way is to remember that we already did bind (authenticate) to
</I>&gt;<i> &gt; the LDAP server as that user. Just reserve that connection for that
</I>&gt;<i> &gt; user alone. As long as the connection is alive, we can keep on talking
</I>&gt;<i> &gt; to the LDAP server.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Now, programs can be restarted, TCP connections can die, and servers
</I>&gt;<i> &gt; can utilize idle timeouts, maximum time limits, or limit maximum
</I>&gt;<i> &gt; number of operations per connection. The TCP connection can die any
</I>&gt;<i> &gt; moment. As we didn't store the user password, we need to ask it again
</I>&gt;<i> &gt; when we see the connection has closed and the user tries an operation
</I>&gt;<i> &gt; that requires talking to the LDAP server. This requires &quot;invalidating&quot;
</I>&gt;<i> &gt; the users previous authentication.
</I>&gt;<i> 
</I>&gt;<i> OK.  So it sounds like you want any interaction with a perspective or
</I>&gt;<i> identity to be able to potentially raise an exception that says &quot;you
</I>&gt;<i> need to offer credentials for this Identity again&quot;.  Frameworks (e.g.
</I>&gt;<i> web.guard, pb.AuthRoot) will need to handle this sensibly.
</I>
	Well, it is possible to handle with voiding the authentication
	data. For example, with web.guard, this could mean that

        1. web.guard sees authentication is still valid, lets a request
           continue

        2. actual request causes actions that discover the LDAP connection
           has closed, give back error

        3. user sees error, clicks &quot;submit&quot; again, or refreshes.

        4. web.guard sees an unauthenticated user, asks for authentication

        5. user authenticates

        6. web.guard lets the resource pass by (A separate ugliness is that
           web.guard complains if it has to authenticate anything with
           forms, and destroys submitted data)

&gt;<i> It's a reasonable requirement, but it may be domain-specific to your
</I>&gt;<i> LDAP interaction stuff.  I know that I have at least one system where
</I>&gt;<i> authentication is persistent within a server once it's been accomplished
</I>&gt;<i> (interaction with the authentication database stops after the user's
</I>&gt;<i> been verified).
</I>
	Yes, and one time would be enough even for an LDAP server that
	is used as authentication only. The point where it isn't
	enough is achieved by creating a proxy in Twisted, where the
	proxy isn't the final service that authenticates users, but
	just acts as a smart protocol converter. Then the proxy is at
        the mercy of the final service.

	And that's what I've been doing. LDAP &lt;-&gt; web.

-- 
tv@{{hq.yok.utu,havoc,gaeshido}.fi,{debian,wanderer}.org,stonesoft.com}
double a,b=4,c;main(){for(;++a&lt;2e6;c-=(b=-b)/a++);printf(&quot;%f\n&quot;,c);}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="033183.html">[Twisted-Python] Passport, my ideas about an LDAP backend
</A></li>
	<LI>Next message (by thread): <A HREF="033180.html">[Twisted-Python] newbie question: error handling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33184">[ date ]</a>
              <a href="thread.html#33184">[ thread ]</a>
              <a href="subject.html#33184">[ subject ]</a>
              <a href="author.html#33184">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
