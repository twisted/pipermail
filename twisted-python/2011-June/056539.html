<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Information on new endpoints API?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Information%20on%20new%20endpoints%20API%3F&In-Reply-To=%3C316A2E38-DB70-4751-8558-E7EDC469ED50%40twistedmatrix.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="056538.html">
   <LINK REL="Next"  HREF="056540.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Information on new endpoints API?</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Information%20on%20new%20endpoints%20API%3F&In-Reply-To=%3C316A2E38-DB70-4751-8558-E7EDC469ED50%40twistedmatrix.com%3E"
       TITLE="[Twisted-Python] Information on new endpoints API?">glyph at twistedmatrix.com
       </A><BR>
    <I>Tue Jun 14 17:37:50 MDT 2011</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="056538.html">[Twisted-Python] Information on new endpoints API?
</A></li>
        <LI>Next message (by thread): <A HREF="056540.html">[Twisted-Python] Information on new endpoints API?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#56539">[ date ]</a>
              <a href="thread.html#56539">[ thread ]</a>
              <a href="subject.html#56539">[ subject ]</a>
              <a href="author.html#56539">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Jun 14, 2011, at 2:37 PM, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">exarkun at twistedmatrix.com</A> wrote:

&gt;<i> On 07:37 am, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">albert.brandl at weiermayer.com</A> wrote:
</I>&gt;&gt;<i> 
</I>
&gt;&gt;<i> We've defined a constant GPS_PORT as &quot;SERIAL:/dev/ttyS2:baudrate=4800&quot;
</I>&gt;&gt;<i> for the production environment and &quot;tcp:1049&quot; for the test environment
</I>&gt;<i> 
</I>&gt;<i> To be clear, though, it sounds like you're defining GPS_PORT in a .py 
</I>&gt;<i> file, and that's more or less what I was speaking against. :)  Instead, 
</I>&gt;<i> I would define GPS_PORT as either SerialEndpoint(reactor, &quot;/dev/ttyS2&quot;, 
</I>&gt;<i> baudrate=4800) or TCP4ServerEndpoint(reactor, 1049).
</I>
In a rare show of dissent within the cabal[1], I disagree with Jean-Paul on this.

&gt;<i> The rest of your code can still be indifferent to which of these is in play (and you can have a service for either of these using StreamServerEndpointService).
</I>
This is the most important point to take away, and I agree with it.  As much as possible, code should interact with endpoints as parameters.  If you need to pass something around, pass the endpoint or the service itself, not the string or the parameters used to construct it.

&gt;<i> If you misspell something or leave off a required argument, though, you're more likely to get an exception that points more directly at the problem.
</I>
First, if you find bad error reporting while using the string-using APIs, it would be better to file a bug for improved error handling than to switch to hard-coding your endpoint types.  There's no particular reason that error-reporting needs to be worse in that case.

Second, I hate to say so, but the current error-reporting behavior wasn't designed particularly thoughtfully in either system, so in practice, sometimes you'll get better reporting from one and in some you'll get it from the other.  For example:

&gt;&gt;&gt;<i> from twisted.internet.endpoints import TCP4ServerEndpoint, serverFromString
</I>&gt;&gt;&gt;<i> from twisted.internet import reactor
</I>&gt;&gt;&gt;<i> serverFromString(reactor, 'bananas')
</I>   ...
ValueError: Unqualified strport description passed to 'service'. Use qualified endpoint descriptions; for example, 'tcp:bananas'.
&gt;&gt;&gt;<i> serverFromString(reactor, 'tcp:bananas')
</I>   ...
ValueError: invalid literal for int() with base 10: 'bananas'
&gt;&gt;&gt;<i> TCP4ServerEndpoint(reactor, 'bananas')
</I>&lt;twisted.internet.endpoints.TCP4ServerEndpoint object at 0x103629190&gt;
&gt;&gt;&gt;<i> TCP4ServerEndpoint(reactor)
</I>   ...
TypeError: __init__() takes at least 3 arguments (2 given)
&gt;&gt;&gt;<i> serverFromString(reactor, 'tcp:')
</I>Traceback (most recent call last):
   ...
ValueError: invalid literal for int() with base 10: ''
&gt;&gt;&gt;<i> serverFromString(reactor, &quot;bananas:&quot;)
</I>   ...
ValueError: Unknown endpoint type: 'bananas'

Both of these really *should* be saying: &quot;'bananas' is not a valid TCP port number&quot; or &quot;TCP requires a port number&quot;.  (Python's error reporting could use some improving here too: which __init__, exactly?)

Personally, I recommend that most developers prefer the string-based APIs, because they allow for more flexibility with less code.  (Granted, not a lot less code: just the N imports for each endpoint type you might support vs. the 1 import for serverFromString or strports.service.)

When you create a TCP4ServerEndpoint, that is an object with a very specific contract.  However, an endpoint created with the &quot;tcp:&quot; prefix passed to serverFromString has an opportunity for more dynamic behavior.  The former must always bind to TCPv4 sockets.  The latter, however, may develop different behavior.  For example, IPv6 support &quot;for free&quot; would be possible with this API, because by using the string-based APIs you are explicitly saying &quot;I am passing some input in here, and I don't know what kind of stream-based transport I might get&quot;.  The compatibility contract with this code is much weaker, because it supports plugins, and already might be giving you lots of different kinds of objects depending on your configuration.

The place where I would recommend against using the string-based APIs is in systems which require knowledge of their transports.  For example, if you want to report about the apparent address of your peer in a protocol message with a specific format, you can't correctly do that with an arbitrary endpoint, because you won't know what datatype to expect from the getPeer() and getHost() methods on your transport.  You can't accept any endpoint that serverFromString might give you and then assume it will give you an IPv4Address as a peer.

So, you should be as flexible as you can, but no more.

&gt;<i> Put another way, I suggest writing this:
</I>&gt;<i> 
</I>&gt;<i>    if debug_mode():
</I>&gt;<i>        gps_port = TCP4ServerEndpoint(reactor, 1049)
</I>&gt;<i>    else:
</I>&gt;<i>        gps_port = SerialEndpoint(reactor, &quot;/dev/ttyS2&quot;, baudrate=4800)
</I>&gt;<i> 
</I>&gt;<i>    ...
</I>&gt;<i> 
</I>&gt;<i>    gps_service = StreamServerEndpointService(gps_port, gps_factory)
</I>&gt;<i> 
</I>&gt;<i> And save the &quot;tcp:1049&quot;-style strings for your .ini files where you 
</I>&gt;<i> cannot write it that way.
</I>
This then begs the question: where does &quot;debug_mode()&quot;'s result come from?  Presumably someone had to indicate a boolean to this code somehow.  It would be simpler for whoever was supplying the value for debug_mode to just supply a value for the endpoint string description instead.  And if it's OK to hard-code the debug_mode boolean, why not just hard-code the string?  Since gps_factory already needs to accept being connected to different transport types, this is 8 lines of code (including the imports, not shown above) where 3 will do fine.

Can this code really only run over plain TCP and serial ports?  If not, then you might have to add an 'if secure()' to the TCP case.  And then you suddenly need a way to get a certificate in there, and all kinds of other information related to TLS.  Better to let the existing string-parsing configuration system do that for you.

-glyph

[1]: There is no cabal.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20110614/7fc5e13a/attachment.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="056538.html">[Twisted-Python] Information on new endpoints API?
</A></li>
	<LI>Next message (by thread): <A HREF="056540.html">[Twisted-Python] Information on new endpoints API?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#56539">[ date ]</a>
              <a href="thread.html#56539">[ thread ]</a>
              <a href="subject.html#56539">[ subject ]</a>
              <a href="author.html#56539">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
