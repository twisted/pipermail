<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Autobahn WebSockets 0.4.3
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Autobahn%20WebSockets%200.4.3&In-Reply-To=CALiqSLeh_3UQ49kzT-zt3%3DQBy2Vv3rGFx_RD-iwWwjEiKX21MQ%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024725.html">
   <LINK REL="Next"  HREF="024727.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Autobahn WebSockets 0.4.3</H1>
    <B>Tobias Oberstein</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Autobahn%20WebSockets%200.4.3&In-Reply-To=CALiqSLeh_3UQ49kzT-zt3%3DQBy2Vv3rGFx_RD-iwWwjEiKX21MQ%40mail.gmail.com"
       TITLE="[Twisted-Python] Autobahn WebSockets 0.4.3">tobias.oberstein at tavendo.de
       </A><BR>
    <I>Mon Oct 31 18:25:05 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="024725.html">[Twisted-Python] Autobahn WebSockets 0.4.3
</A></li>
        <LI>Next message: <A HREF="024727.html">[Twisted-Python] Autobahn WebSockets 0.4.3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24726">[ date ]</a>
              <a href="thread.html#24726">[ thread ]</a>
              <a href="subject.html#24726">[ subject ]</a>
              <a href="author.html#24726">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> &gt; What do you want to test? Own client, own server?
</I>&gt;<i> 
</I>&gt;<i> I wanted to test Autobahn's internals. Unit tests, not integration tests. The
</I>&gt;<i> integration test stuff is pretty cool, too, but I was hoping for tests which
</I>&gt;<i> verify Autobahn's behavior internally.
</I>
You can use Autobahn to test Autobahn of course.

Autobahn's test approach is tailored towards it's domain (communication
protocols) and based on the following perspective:

If you have a black box, that behaves to a protocol spec regarding
all it's externally visible behavior, you can call that black box conforming
to the protocol.

Whether you then have unit tests for stuff that happens within the black
box is less relevant, as long as you have covered all the spec with
behavioral test cases.

When you only have unit tests for stuff happening inside the box,
you still can't say if the box conforms to the spec. It may pass all
unit tests and fail when talking to the world.

For protocols, the reason for this is: any unit test by definition
misses an essential part: the peer you communicate with.

As an example, instead of writing a unit test that checks whether
a UTF-8 decoding function raises upon invalid sequences, 
execute a fuzzing test case where the fuzzer will actually send
the tested implementation invalid UTF-8 and check the externally
visible behavior.

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024725.html">[Twisted-Python] Autobahn WebSockets 0.4.3
</A></li>
	<LI>Next message: <A HREF="024727.html">[Twisted-Python] Autobahn WebSockets 0.4.3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24726">[ date ]</a>
              <a href="thread.html#24726">[ thread ]</a>
              <a href="subject.html#24726">[ subject ]</a>
              <a href="author.html#24726">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
