<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] dataReveived() buffer best practice?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20dataReveived%28%29%20buffer%20best%20practice%3F&In-Reply-To=CAB3A25A.1C2DA%25fabian.rothfuchs%40gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024604.html">
   <LINK REL="Next"  HREF="024606.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] dataReveived() buffer best practice?</H1>
    <B>John Santos</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20dataReveived%28%29%20buffer%20best%20practice%3F&In-Reply-To=CAB3A25A.1C2DA%25fabian.rothfuchs%40gmail.com"
       TITLE="[Twisted-Python] dataReveived() buffer best practice?">JOHN at egh.com
       </A><BR>
    <I>Thu Oct  6 17:02:26 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="024604.html">[Twisted-Python] dataReveived() buffer best practice?
</A></li>
        <LI>Next message: <A HREF="024606.html">[Twisted-Python] dataReveived() buffer best practice?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24605">[ date ]</a>
              <a href="thread.html#24605">[ thread ]</a>
              <a href="subject.html#24605">[ subject ]</a>
              <a href="author.html#24605">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
I'm doing something very similar.


I have (greatly simplified, because I'm doing lots of other stuff 
with the data):

    def applicationDataReceived(self, data):

	global savedText, delayCounter
        newline = &quot;\n&quot;
        text = savedText + data
        savedText = &quot;&quot;
        # normalize text (replace escapes, search for and normalize newlines)
        text = text.replace(&quot;\000&quot;,&quot;&quot;)
        text = text.replace(&quot;\033&quot;,&quot;$&quot;)
        text = text.replace(&quot;\r\n&quot;,newline)
        text = text.replace(&quot;\r&quot;,newline)
        lines = text.split(newline)
        for line in lines[:-1]:
            if len(line):
                write( line+newline )
        savedText = lines[-1]
        # (if savedText &lt;&gt; &quot;&quot; then we are waiting for more...)

        def printPartialMessage(myCounter):
            global savedText, savedTimestamp, delayCounter
            #print &quot;delay routine called %i %i&quot; % (myCounter, delayCounter)
            if myCounter == delayCounter:
                if savedText &lt;&gt; &quot;&quot;:
                    newline = &quot;\n&quot;
                    write( savedText+&quot; (terminator not seen)&quot;+newline )
                    savedText = &quot;&quot;
                delayCounter = 0
            # If the passed counter (myCounter) equals the current value of
            # the delay counter, then we know the savedText is that left over
            # when we were queued.  Otherwise, more text has come in and
            # caused the counter to be incremented and more calls to be
            # made to printPartialMessage.  We'll let them handle it.

        if savedText &lt;&gt; &quot;&quot;:
            delayCounter += 1
            reactor.callLater(60, printPartialMessage, delayCounter)



I'm actually writing this to a time-stamped log file, but I've removed
all the code to maintain the time stamps, create and roll over the log
files, etc.

If you are willing to wait indefinitely for partial lines, you can get rid
of the &quot;printPartialMessage()&quot; deferred, and the conditional call to it. 

delayCounter is a &quot;pending calls to printPartialMessage()&quot; counter (reset
to 0 when there are none), because the only one we are interested in is
the last one.  Instead, the deferred could be canceled when new text
arrives, but I think the ability to cancel defereds is newer than this
code.  I just let the deferreds exexute and dismiss them immediately if
they aren't current.

The constant &quot;60&quot; in the reactor.callLater() is the number of seconds I'm
willing to wait for a partial message to receive more data.

You might not want to normalize the text (since I'm printing to a text log
file, I didn't want embedded escape sequences to cause conniptions when
the log file was printed to a terminal), or you might want to use a 
different line terminator. 

Also, for conch.telnet, I think you want to override 
&quot;applicationDataReceived()&quot; and not &quot;dataReceived()&quot; because 
&quot;dataReceived()&quot; sees all the telnet protocol negotiations, which you
might want to let conch.telnet handle.



-- 
John Santos
Evans Griffiths &amp; Hart, Inc.
781-861-0670 ext 539
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024604.html">[Twisted-Python] dataReveived() buffer best practice?
</A></li>
	<LI>Next message: <A HREF="024606.html">[Twisted-Python] dataReveived() buffer best practice?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24605">[ date ]</a>
              <a href="thread.html#24605">[ thread ]</a>
              <a href="subject.html#24605">[ subject ]</a>
              <a href="author.html#24605">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
