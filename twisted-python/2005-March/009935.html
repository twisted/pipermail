<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: clients of perspective brokers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20clients%20of%20perspective%20brokers&In-Reply-To=u3bv72csp.fsf%40fitlinxx.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009702.html">
   <LINK REL="Next"  HREF="009699.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: clients of perspective brokers</H1>
    <B>Joachim Boomberschloss</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20clients%20of%20perspective%20brokers&In-Reply-To=u3bv72csp.fsf%40fitlinxx.com"
       TITLE="[Twisted-Python] Re: clients of perspective brokers">boomberschloss at yahoo.com
       </A><BR>
    <I>Sun Mar 20 13:01:13 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="009702.html">[Twisted-Python] Re: clients of perspective brokers
</A></li>
        <LI>Next message: <A HREF="009699.html">[Twisted-Python] process directory or alike in Twisted?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9935">[ date ]</a>
              <a href="thread.html#9935">[ thread ]</a>
              <a href="subject.html#9935">[ subject ]</a>
              <a href="author.html#9935">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the detailed response! It really helped me
to get a sturdier perspective on everything.

My situation is slightly different than what you
described. My application consists of multiple servers
and clients responsible for the different aspects of
data processing, acquisition and storage (there are,
for example, a database, a configuration server,
arbitrary GUI clients, etc.), and each server exposes
only one referencable object (the root) representing
the server's interface. One consequence, for example,
is that a unit may disappear and re-appear at a
different location (ex. the same user logging in at a
different machine).

I had in mind something very similar to your component
registry: a central server would act as a &quot;unit
directory&quot;, containing a listing of units with unique
id's, contact information, and other arbitrary
details. Each unit in the system announces its
existence to the central server every once in a while,
and receives a remote cache of the listing, which gets
updated every time there is a change in the list.

In addition to the local copy of the central unit
directory that every unit holds, it would also hold a
pool of open connections. When a unit wants to contact
another unit, it would query the local copy of the
directory for the desired unit (ex. database, gui unit
of user &quot;bob&quot;, etc.), get an address and port number,
and return a wrapper around the remote reference of
the other server's root containing the address
information, called a &quot;friend&quot;. If the required
address is already connected to in the local pool of
connections, it is simply directed to use that
connection. When a call is made on the &quot;friend&quot;
object, it attempts to open a connection (if needed,
in which case the new connection is added to the
pool), and makes the remote method call. If it is an
old connection and the call fails, it would attempt to
make a new connection once and repeat the process,
after which the failure (if it persists) is reported
to the caller.

This covers nicely most situations, but with some I am
still struggling:

The main issue is this: it often happens that one unit
in the system wants to be notified when something
happens at another unit. The problems begin when there
are network problems. For example, let's suppose the
unit that wants to be notified sends its root object
as the object that should be kept by the notifying
unit and used as a remote reference to make the
notification. The question is how to handle such
notifications during network problems; for example,
assume that a notification request is made, then the
connection is lost, then network problems subside but
the connection is or is not resumed, and then the
event to notify about happens. Who's responsibility is
it to take care of that? I'm just asking if there is
any standard or common way to approach this, or if I'm
on my own.

Thanks a lot,

Joe.

--- David Bolen &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">db3l at fitlinxx.com</A>&gt; wrote:

&gt;<i> Joachim Boomberschloss &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">boomberschloss at yahoo.com</A>&gt;
</I>&gt;<i> writes:
</I>&gt;<i> 
</I>&gt;<i> &gt; Also, it is unclear to me how reconnection works
</I>&gt;<i> for
</I>&gt;<i> &gt; perspective broker clients. If a connection is
</I>&gt;<i> dropped
</I>&gt;<i> &gt; by the server, and then a clients tries to make a
</I>&gt;<i> &gt; method call on a remote object, will the client
</I>&gt;<i> &gt; factory try to reconnect before making the
</I>&gt;<i> request, or
</I>&gt;<i> &gt; will the request fail, and re-connection be
</I>&gt;<i> attempted
</I>&gt;<i> &gt; the next time, etc.?
</I>&gt;<i> 
</I>&gt;<i> There are no automatic reconnects by default. 
</I>&gt;<i> Additionally once you
</I>&gt;<i> have lost a connection, all existing references held
</I>&gt;<i> by the client to
</I>&gt;<i> objects on the server will be invalid from that
</I>&gt;<i> point on.
</I>&gt;<i> 
</I>&gt;<i> There is a general purpose ReconnectingClientFactory
</I>&gt;<i> in the
</I>&gt;<i> twisted.internet.protocols module, but it only
</I>&gt;<i> handles making the
</I>&gt;<i> basic socket reconnection, and not any higher level
</I>&gt;<i> re-establishment
</I>&gt;<i> of protocol communication.  There was also some work
</I>&gt;<i> on a more
</I>&gt;<i> persistent remote reference scheme (in the sturdy
</I>&gt;<i> module).
</I>&gt;<i> 
</I>&gt;<i> The problem with handling reconnects is that PB
</I>&gt;<i> object references are
</I>&gt;<i> only good for a particular session (since they match
</I>&gt;<i> up with broker
</I>&gt;<i> object dictionaries that are part of the remote
</I>&gt;<i> protocol instance and
</I>&gt;<i> go away when the session drops).  So even if you
</I>&gt;<i> re-establish the raw
</I>&gt;<i> PB connection, none of the object references
</I>&gt;<i> previously held by the
</I>&gt;<i> client will be valid any longer.  Even the sturdy
</I>&gt;<i> module only seemed
</I>&gt;<i> to work for the root object and not other random
</I>&gt;<i> references held by
</I>&gt;<i> the application.  Back when I was looking to solve
</I>&gt;<i> the same issue, I
</I>&gt;<i> didn't really find anything suitable in the twisted
</I>&gt;<i> code base itself.
</I>&gt;<i> 
</I>&gt;<i> So it's mostly up to your application to handle
</I>&gt;<i> these sorts of
</I>&gt;<i> scenarios.  To be honest though, since your
</I>&gt;<i> application knows the most
</I>&gt;<i> about how it is using references and objects, it can
</I>&gt;<i> often have the
</I>&gt;<i> simplest implementation.
</I>&gt;<i> 
</I>&gt;<i> For example, in our application we make use of a
</I>&gt;<i> registry of
</I>&gt;<i> components, and when distributing the application,
</I>&gt;<i> the client starts
</I>&gt;<i> with a remote registry (a Referenceable), and then
</I>&gt;<i> retrieves remote
</I>&gt;<i> component references (also Referenceables) for any
</I>&gt;<i> component they
</I>&gt;<i> interact with.  Pretty much everything else is a
</I>&gt;<i> normal remote copy (a
</I>&gt;<i> Copyable rather than Referenceable).  So the
</I>&gt;<i> registry and components
</I>&gt;<i> provided a great control point to handle network
</I>&gt;<i> outages.  Also, the
</I>&gt;<i> components whose references are long lived in the
</I>&gt;<i> client (and who we
</I>&gt;<i> care about maintaining across an outage) are
</I>&gt;<i> independent of the remote
</I>&gt;<i> session - that is they exist independently on the
</I>&gt;<i> server.  So recovery
</I>&gt;<i> from loss of a network connection is simply
</I>&gt;<i> re-accessing the prior
</I>&gt;<i> remote component.  That makes handling such outages
</I>&gt;<i> in a transparent
</I>&gt;<i> manner fairly straight forward since we can use the
</I>&gt;<i> original
</I>&gt;<i> connection information to perform a reconnect
</I>&gt;<i> without re-involving
</I>&gt;<i> high level application code.
</I>&gt;<i> 
</I>&gt;<i> We ended up with  three main parts to the recovery
</I>&gt;<i> system:
</I>&gt;<i> 
</I>&gt;<i> * A remote registry wrapper that works just like a
</I>&gt;<i> local registry but
</I>&gt;<i>   automatically wraps references to remote
</I>&gt;<i> components in a component wrapper.
</I>&gt;<i> * A remote component wrapper that handles wrapping a
</I>&gt;<i> remote reference both
</I>&gt;<i>   to control method access (so we can specially
</I>&gt;<i> handle some methods locally)
</I>&gt;<i>   but also to isolate the application from directly
</I>&gt;<i> holding onto a PB
</I>&gt;<i>   reference for the remote component object.
</I>&gt;<i> * Our own PBClientFactory subclass that handles
</I>&gt;<i> connectivity issues, and
</I>&gt;<i>   automatically wraps a reference to a remote
</I>&gt;<i> registry (which is obtained
</I>&gt;<i>   through our Root object) in the remote registry
</I>&gt;<i> wrapper.
</I>&gt;<i> 
</I>&gt;<i> In addition, we tie them together with various
</I>&gt;<i> signals (currently
</I>&gt;<i> using the pyDispatcher package).
</I>&gt;<i> 
</I>&gt;<i> A client app starts with the client factory, which
</I>&gt;<i> knows how to
</I>&gt;<i> connect, reconnect after a failure (with a
</I>&gt;<i> prescribed retry timing
</I>&gt;<i> mechanism), periodically ping the remote root object
</I>&gt;<i> for a live
</I>&gt;<i> session, and emit signals when the connection goes
</I>&gt;<i> up or down.  The
</I>&gt;<i> application asks the client factory for the remote
</I>&gt;<i> registry, and gets
</I>&gt;<i> back a remote registry wrapper.  Since the wrapper
</I>&gt;<i> operates as a local
</I>&gt;<i> registry, the application code can work locally or
</I>&gt;<i> remotely.  If the
</I>&gt;<i> client factory sees the connection drop, once it
</I>&gt;<i> reconnects, it emits
</I>&gt;<i> a connection signal which includes the new registry
</I>&gt;<i> wrapper.
</I>&gt;<i> 
</I>&gt;<i> The client factory also gives us a good place to
</I>&gt;<i> perform a series of
</I>&gt;<i> steps we need to do with the remote root object in
</I>&gt;<i> order to get access
</I>&gt;<i> to the remote registry, providing for those
</I>&gt;<i> operations to complete
</I>&gt;<i> before giving the registry back to the application
</I>&gt;<i> either during
</I>&gt;<i> initial connection (through a waiting deferred) or
</I>&gt;<i> on a reconnect (via
</I>&gt;<i> the connection signal).
</I>&gt;<i> 
</I>&gt;<i> The remote component wrappers (which also include
</I>&gt;<i> the remote registry
</I>&gt;<i> wrapper) handle the low level potential for
</I>&gt;<i> failures.  The wrapper
</I>&gt;<i> handles failures during any PB request (both
</I>&gt;<i> DeadReferenceError and
</I>&gt;<i> PBConnectionLost) and in addition to passing up the
</I>&gt;<i> error, it emits
</I>&gt;<i> its own signal for a failed request.  The client
</I>&gt;<i> factory listens for
</I>&gt;<i> such signals, which it uses to initiate an immediate
</I>&gt;<i> ping test - which
</I>&gt;<i> in turn can lead to notifying the entire system that
</I>&gt;<i> the connection is
</I>&gt;<i> down.
</I>&gt;<i> 
</I>&gt;<i> We did patch our Twisted so the DeadReferenceError
</I>&gt;<i> was returned as a
</I>&gt;<i> deferred rather than raised inline.  But once
</I>&gt;<i> everything centralized
</I>&gt;<i> around the remote wrappers, technically that became
</I>&gt;<i> unnecessary
</I>&gt;<i> because that's the only place (aside from the client
</I>&gt;<i> factory) that
</I>&gt;<i> issues the callRemote call, so it's not that hard to
</I>&gt;<i> handle both the
</I>&gt;<i> local exception or the deferred error.
</I>&gt;<i> 
</I>&gt;<i> In the other direction, the wrappers all listen for
</I>&gt;<i> the client
</I>&gt;<i> factory's connected signal, and upon receipt, they
</I>&gt;<i> use the supplied
</I>&gt;<i> remote registry to re-query the component they wrap
</I>&gt;<i> (information on
</I>&gt;<i> which they saved when created) in order to get a new
</I>&gt;<i> remote reference.
</I>&gt;<i> Because all of the higher level application code is
</I>&gt;<i> holding a
</I>&gt;<i> reference (Python-wise) to the wrapper object and
</I>&gt;<i> not the PB
</I>&gt;<i> reference, we can adjust to a new reference inside
</I>&gt;<i> the wrapper without
</I>&gt;<i> anything in the application being the wiser or
</I>&gt;<i> needing to change.
</I>&gt;<i> 
</I>&gt;<i> Having the network connect/disconnect signals from
</I>&gt;<i> the client factory
</I>&gt;<i> also permits any other part of the application to
</I>&gt;<i> perform certain
</I>&gt;<i> operations during an outage (so sometimes at our top
</I>&gt;<i> level UI we'll
</I>&gt;<i> put up a &quot;temporary outage&quot; message during
</I>&gt;<i> downtime).
</I>&gt;<i> 
</I>&gt;<i> While this is fairly specific to our environment, it
</I>&gt;<i> lets 
</I>=== message truncated ===


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
<A HREF="http://mail.yahoo.com">http://mail.yahoo.com</A> 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009702.html">[Twisted-Python] Re: clients of perspective brokers
</A></li>
	<LI>Next message: <A HREF="009699.html">[Twisted-Python] process directory or alike in Twisted?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9935">[ date ]</a>
              <a href="thread.html#9935">[ thread ]</a>
              <a href="subject.html#9935">[ subject ]</a>
              <a href="author.html#9935">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
