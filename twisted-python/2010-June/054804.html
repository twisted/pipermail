<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Integrating Twisted with ZeroMQ
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Integrating%20Twisted%20with%20ZeroMQ&In-Reply-To=%3C20100607045414.1708.293470391.divmod.xquotient.158%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="054803.html">
   <LINK REL="Next"  HREF="054805.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Integrating Twisted with ZeroMQ</H1>
    <B>exarkun at twistedmatrix.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Integrating%20Twisted%20with%20ZeroMQ&In-Reply-To=%3C20100607045414.1708.293470391.divmod.xquotient.158%40localhost.localdomain%3E"
       TITLE="[Twisted-Python] Integrating Twisted with ZeroMQ">exarkun at twistedmatrix.com
       </A><BR>
    <I>Sun Jun  6 22:54:14 MDT 2010</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="054803.html">[Twisted-Python] Integrating Twisted with ZeroMQ
</A></li>
        <LI>Next message (by thread): <A HREF="054805.html">[Twisted-Python] Integrating Twisted with ZeroMQ
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#54804">[ date ]</a>
              <a href="thread.html#54804">[ thread ]</a>
              <a href="subject.html#54804">[ subject ]</a>
              <a href="author.html#54804">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 6 Jun, 07:59 pm, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">lvh at laurensvh.be</A> wrote:
&gt;<i>Hey,
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>For the Twisted folks: this thing has been reviewed by the ZeroMQ
</I>&gt;<i>folks first because I wanted to be sure I got the technical details
</I>&gt;<i>right on the their side of things.
</I>&gt;<i>
</I>&gt;<i>I'd like to open up a discussion from a while back regarding the
</I>&gt;<i>integration of ZeroMQ (a messaging system: similar to AMQP but with
</I>&gt;<i>the intent to be simpler) into Twisted.
</I>&gt;<i>
</I>&gt;<i>The interested ZeroMQ people and the interested Twisted people (names
</I>&gt;<i>withheld to protect the guilty) disagreed on what it should look like.
</I>&gt;<i>I think that's mostly because neither party really understood what the
</I>&gt;<i>other's software wanted to do. So, I'll try to give everyone a basic
</I>&gt;<i>explanation without going too deep into either Twisted or ZeroMQ: my
</I>&gt;<i>apologies if I spell out the basics of your thing too much and it gets
</I>&gt;<i>boring :)
</I>&gt;<i>
</I>&gt;<i>ZeroMQ aims to be a thin layer above TCP, behaving like TCP but
</I>&gt;<i>'better'. That sounds like a vague marketing statement, but it helps
</I>&gt;<i>to understand some of the terminology if you keep that in the back of
</I>&gt;<i>your head. (What exactly 'better' means is way beyond the current
</I>&gt;<i>scope: basically, ZeroMQ wants to help socket programmers to stop
</I>&gt;<i>reinventing the wheel by implementing common behavior such as pub/sub,
</I>&gt;<i>request/reply...). Essentially AMQP but much simpler, and brokerless
</I>&gt;<i>in most cases. This email is already going to go way over the sane
</I>&gt;<i>character count, thankfully the ZeroMQ webpage does a great job at
</I>&gt;<i>explaining stuff :-)
</I>&gt;<i>
</I>&gt;<i>I think this highlights the main problem people had. There a partial
</I>&gt;<i>overlap between Twisted and ZeroMQ. The ZeroMQ implementation does
</I>&gt;<i>things Twisted does too: it implements a bunch of low level networking
</I>&gt;<i>stuff using eg epoll. It deals with real sockets, and Twisted wants to
</I>&gt;<i>do that as well.
</I>&gt;<i>
</I>&gt;<i>ZeroMQ uses things called Sockets. They're similar but not the same
</I>&gt;<i>thing as TCP sockets (instead delegating work to TCP eventually), so
</I>&gt;<i>you can't use traditional methods like select or epoll with them,
</I>&gt;<i>because, for example, they don't have file descriptors. Some
</I>&gt;<i>underlying thing probably does have fds; but ZeroMQ worries about that
</I>&gt;<i>for you under the hood, just like Twisted does for other TCP traffic.
</I>&gt;<i>
</I>&gt;<i>There are a couple of options for making ZeroMQ work with Twisted:
</I>&gt;<i>
</I>&gt;<i>1) implement everything in Python, using Twisted's TCP stuff. I think
</I>&gt;<i>this is mostly a bad idea and the ZeroMQ people seem to agree: _lots_
</I>&gt;<i>of work, ZeroMQ libs are stupidly fast already, Python not being the
</I>&gt;<i>best tool for binary protocols...
</I>&gt;<i>2) write a thin wrapper around the C(++) libs: great, as long as it
</I>&gt;<i>never has to go into the Twisted trunk
</I>&gt;<i>3) use pyzmq's thin wrapper around the C(++) libs: sounds like the
</I>&gt;<i>best idea to me, again with reservations wrt the Twisted trunk
</I>&gt;<i>
</I>&gt;<i>Originally there was a fourth idea, which considered libzmq as a new
</I>&gt;<i>mechanism: like epoll, so you'd have a ZMQ-specific reactor. A bunch
</I>&gt;<i>of people didn't like this, and I can somewhat see the point: hard to
</I>&gt;<i>integrate with other event loops like GUIs, for example.
</I>&gt;<i>
</I>&gt;<i>pyzmq offers something called select, which works just like select
</I>&gt;<i>except it works on both file descriptors and ZeroMQ Sockets. It just
</I>&gt;<i>delegates all of the work to libzmq. We could use
</I>&gt;<i>ThreadedSelectReactor and have it use ZMQ's select. I'm not sure if it
</I>&gt;<i>should use &quot;normal&quot; select everywhere else: because zmq's select is in
</I>&gt;<i>fact much better than select.select (it just behaves like
</I>&gt;<i>select.select in the sense that you give it three sets of fds and an
</I>&gt;<i>optional timeout; under the hood it's actually epoll or kqueue or
</I>&gt;<i>whatever) and it can handle plain old file descriptors just fine. So,
</I>&gt;<i>you'd have a TRS with either 1 zmq.select running on everything or 1
</I>&gt;<i>zmq.select running over Sockets and 1 select.select running over your
</I>&gt;<i>classic fds. Personally I kind of like the idea of zmq's select taking
</I>&gt;<i>over, but I don't know how well that works in practice.
</I>
A shortcoming of this approach is that much of the inefficiency of 
select(2) comes from its API.  If you have a select(2)-compatible API 
that's implemented in terms of epoll, you're still wasting a ton of 
effort that you could be skipping if you were using an epoll-compatible 
API instead.

But this is only an argument about performance, and likely no one is 
going to care about the poor performance of zmq.select anyway.
&gt;<i>
</I>&gt;<i>A potential option for Twisted, which some people don't quite like,
</I>&gt;<i>would be to have a listenZMQ and connectZMQ, analogous to
</I>&gt;<i>listenTCP/listenUDP/listenSSL and the respective connect*s. I think
</I>&gt;<i>this makes more sense to the ZeroMQ people (who think of ZeroMQ as a
</I>&gt;<i>layer &quot;next to&quot; TCP which happens to be implemented on top of TCP, on
</I>&gt;<i>top of which you build your stuff) than the Twisted people (who think
</I>&gt;<i>of ZeroMQ's protocol as yet another TCP-using protocol just like HTTP
</I>&gt;<i>for example). Having worked with both pieces of software, the more I
</I>&gt;<i>play with ZeroMQ the more I think listenZMQ/connectZMQ make sense.
</I>&gt;<i>ZeroMQ really tries to be one of those things and it shows. What
</I>&gt;<i>ZeroMQ wants to do is semantically much closer to the existing
</I>&gt;<i>connects and listens. I'm not just making this up: the ZeroMQ people
</I>&gt;<i>have reviewed this and this is really what ZeroMQ wants to be.
</I>
A shortcoming of this approach is that as a reactor method, you have to 
implement it for each reactor you want to support.  You covered this a 
bit earlier in your email, where you talked about GUI integration.  Do 
you want to maintain an implementation of {listen,connect}ZMQ for 
select(/whatever), Glib2, Gtk2, wxWidgets, Qt, and Windows?  That's a 
lot more work than just maintaining one implementation.
&gt;<i>
</I>&gt;<i>Another argument for making ZMQ special is that TCP is just one of the
</I>&gt;<i>things ZeroMQ works with. UNIX domain pipes, PGM reliable multicast,
</I>&gt;<i>UDP PGM encapsulation, and even inter-thread communication.
</I>
You got this one backwards.  This is an argument for not implementing 
ZMQ at the same level as TCP and UNIX sockets.  This is an argument for 
implementing it *on top of* those things.  Of course, the main benefit 
of implementing it on top of them is that you don't have to write a 
bunch of code to support each transport.  And the ZMQ people did that 
already.

Here's how it should work (modulo stupid factoring issues that aren't 
really related to ZMQ issues), given that there's a big C library that 
already implements a bunch of stuff that you don't want to re-implement:

    from twisted.internet.interfaces import IReactorFDSet

    class ZMQTransport(object):
        def __init__(self, reactor, zmqSocket, protocol):
            self._zmqSocket = zmqSocket
            self._transportPieces = []
            # On the next line, I use a method which I made up.  Maybe it
            # corresponds to some actual API ZMQ provides, maybe not, I
            # dunno.
            for fd in zmqSocket.allFileDescriptors():
                desc = _ZMQFileDescriptor(reactor, fd, zmqSocket)
                self._transportPieces.append(desc)

            self._protocol = protocol
            self._protocol.makeConnection(self)


    class _ZMQFileDescriptor(object):
        def __init__(self, reactor, fd, zmqSocket):
            if not IReactorFDSet.providedBy(reactor):
                raise RuntimeError(
                    &quot;This is the IReactorFDSet implementation; &quot;
                    &quot;use another reactor or another zmq transport.&quot;)

            self._reactor = reactor
            self._reactor.addReader(self)
            self._fd = fd
            self._zmqSocket = zmqSocket

        def doRead(self):
            # Another made up method
            zmqEvents = self._zmqSocket.nonBlockingReadFrom(self._fd)
            if zmqEvents:
                self._protocol.zmqEventsReceived(zmqEvents)

        def doWrite(self):
            # One more, for luck.
            finished = self._zmqSocket.nonBlockingWriteTo(self._fd)
            if finished:
                self._reactor.removeWriter(self)

        def fileno(self):
            return self._fd

        def sendZMQEvents(self, events):
            # Whatever the API is.
            self._zmqSocket.sendZMQEvents(events)
            self._reactor.addWriter(self)


    class ZMQProtocol(object):
        def makeConnection(self, zmqTransport):
            self.zmqTransport = zmqTransport

        def zmqEventsReceived(self, zmqEvents):
            pass


    def connectZMQ(reactor, addrinfo, factory):
        # Blah blah blah - somehow get to the point where you have a 
# ZMQ Socket.
        d = ...
        def cbConnectionSetup(socket):
            ZMQTransport(
                reactor, socket, factory.buildProtocol(addrinfo))
        d.addCallback(cbConnectionSetup)

    def main():
        from twisted.internet import reactor
        from twisted.internet.protocol import ClientFactory
        f = ClientFactory()
        f.protocol = ZMQProtocol
        connectZMQ(reactor, ('example.com', 1234), f)
        reactor.run()


Okay, so that came out a little longer than I planned, but turn about is 
fair play.  Anyway, this is a bog standard transport implementation. 
The only thing even remotely interesting is that it maps multiple file 
descriptors onto a single transport.  And that seems to be the
So, if the ZMQ library offers APIs like the ones used in this example, 
then you're all set.  With just a little more code, you can have an 
overlapped I/O version of this transport (for the one Twisted reactor 
that doesn't support IReactorFDSet).  And then you've got proper Twisted 
ZMQ support.

If it *doesn't* offer APIs like these, then I'd say it's missing some 
pretty critical APIs.  After all, if you can't drive it this way, your 
chances of being able to write reasonable unit tests for ZMQ-based code 
are somewhat diminished (not out the window, but it'll be annoying).

And I don't understand how you would implement something like ZMQ in a 
way that *didn't* make it easy to do this.  *Particularly* since they 
have support for several different event notification APIs.  So 
hopefully the worst case is that there are no APIs like these, but it's 
a minor oversight because the authors thought no one would want them, 
but they can be added trivially because they map directly onto how the 
underlying implementation works.
&gt;<i>
</I>&gt;<i>I know some Twisted people way smarter than me basically thought the
</I>&gt;<i>connectZMQ/listenZMQ thing was a mistake, but I'm not sure to what
</I>&gt;<i>extent that is because they were right and to what extent that was
</I>&gt;<i>because they didn't really know very much about ZeroMQ and just went
</I>&gt;<i>&quot;it works on top of TCP so that's not where it goes&quot;. To Twisted folks
</I>&gt;<i>that disagree: would you change your opinion of ZMQ was *really*
</I>&gt;<i>something that's side-by-side with TCP instead of being implemented on
</I>&gt;<i>top of it? Like, say, SCTP is? Does the fact that it can work on top
</I>&gt;<i>of a bunch of stuff that isn't TCP change that?
</I>
If ZMQ were supported in the kernel with new syscalls to interface with 
it, then it would be nonsensical to talk about implementing it on top of 
Twisted's existing TCP support.  You simply couldn't, because all of the 
code would have been pushed into the kernel where it can't be used any 
other way.  This doesn't mean it would be a good idea overall to have 
ZMQ supported at the same level as TCP, though: it just means there 
would be no other alternative (aside from not supporting it - like what 
Twisted for SCTP).

Whether or not it makes any sense to implement ZMQ in the kernel is 
something I have no opinion on, since I don't know nearly enough about 
the particular details of ZMQ.
&gt;<i>
</I>&gt;<i>Talking with the ZeroMQ people has been a positive experience: they
</I>&gt;<i>were very accessible and cooperative, and really just want a bigger
</I>&gt;<i>market for their software (who doesn't?) so I hope something useful
</I>&gt;<i>comes out of this :-)
</I>
Great!  Convince them to add the necessary APIs (if they don't exist 
already) from above and everything should be set. :)

Jean-Paul


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="054803.html">[Twisted-Python] Integrating Twisted with ZeroMQ
</A></li>
	<LI>Next message (by thread): <A HREF="054805.html">[Twisted-Python] Integrating Twisted with ZeroMQ
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#54804">[ date ]</a>
              <a href="thread.html#54804">[ thread ]</a>
              <a href="subject.html#54804">[ subject ]</a>
              <a href="author.html#54804">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
