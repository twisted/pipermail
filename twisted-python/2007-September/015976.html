<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Wrapping a Perspective Broker remote object	with a blocking API
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Wrapping%20a%20Perspective%20Broker%20remote%20object%0A%09with%20a%20blocking%20API&In-Reply-To=6ce0ac130709041145l3c633588ob5cfbe016b8f91dd%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015975.html">
   <LINK REL="Next"  HREF="015977.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Wrapping a Perspective Broker remote object	with a blocking API</H1>
    <B>Jean-Paul Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Wrapping%20a%20Perspective%20Broker%20remote%20object%0A%09with%20a%20blocking%20API&In-Reply-To=6ce0ac130709041145l3c633588ob5cfbe016b8f91dd%40mail.gmail.com"
       TITLE="[Twisted-Python] Wrapping a Perspective Broker remote object	with a blocking API">exarkun at divmod.com
       </A><BR>
    <I>Tue Sep  4 15:06:45 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="015975.html">[Twisted-Python] Wrapping a Perspective Broker remote object with	a blocking API
</A></li>
        <LI>Next message: <A HREF="015977.html">[Twisted-Python] Wrapping a Perspective Broker remote object with	a blocking API
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15976">[ date ]</a>
              <a href="thread.html#15976">[ thread ]</a>
              <a href="subject.html#15976">[ subject ]</a>
              <a href="author.html#15976">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, 4 Sep 2007 12:45:17 -0600, Brian Granger &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ellisonbg.net at gmail.com</A>&gt; wrote:
&gt;&gt;<i> &gt;This is a usage case that we run into regularly.  We have a lot of PB
</I>&gt;&gt;<i> &gt;based servers, but sometimes people want to use a client to them from
</I>&gt;&gt;<i> &gt;an interactive Python or IPython prompt.  At that point you have to
</I>&gt;&gt;<i> &gt;run the reactor in a different thread.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Not true, in fact.  See twisted/conch/stdio.py, for example.  I don't know
</I>&gt;&gt;<i> what the Twisted/IPython integration code ended up looking like (or if it
</I>&gt;&gt;<i> was ever taken to a satisfactory &quot;completion&quot; point) but I don't think it
</I>&gt;&gt;<i> is necessary to have multiple threads for that use case, either.
</I>&gt;<i>
</I>&gt;<i>I have, but this doesn't solve the problem as I recall.
</I>
There are definitely some problems it doesn't solve.  Maybe I'm not getting
the problem you have in mind.

&gt;<i>First, these
</I>&gt;<i>users want to be able to use PB clients from vanilla python
</I>&gt;<i>interpreters and IPython out of the box - not from within some other
</I>&gt;<i>process doing the tricks that are in conch/stdio.py.
</I>
stdio.py doesn't do anything with multiple processes (as I think you see,
based on what you said a couple sentences later, but just to be clear).

Another point to clarify - there is a difference between having a blocking
user interface and a blocking API.  In fact, they're different things
entirely - they don't relate to each other in any significant way.

Keeping this in mind, there's no reason either the standard CPython REPL or
IPython couldn't provide a blocking user interface to an asynchronous API,
without resorting to multiple processes or threads.  The implementation is
asynchronous, the user interface blocks.

Of course, actually implementing this for the CPython REPL poses some
challenges.  However, an API does exist which would allow it to poll Twisted
at regular intervals in order to allow Twisted to take care of any event
processing it needed to take care of.  Whether this would yield a high-
quality implementation or not, I'm not sure, but something should be possible.
The reason I wrote stdio.py instead of doing this is that I'd rather have
a REPL implemented in Python without having to jump through libreadline
hoops.  Plus I didn't know about the CPython polling feature at the time. ;)

IPython could do this even more easily, since I think some IPython developers
are actively interested in the feature, and there might be a chance of there
being some changes made to IPython in order to facilitate this.

I hope I have understood properly the use-case you have in mind and that the
above makes some sense.

&gt;<i>Am I not correct
</I>&gt;<i>that threads are needed in this case?  Second, what this module does
</I>&gt;<i>is actually make the terminal asynchronous, which is exactly the
</I>&gt;<i>opposite of what these users want.
</I>
stdio.py keeps everything asynchronous and throws Deferreds right in the
user's face.  But it does this because I'm a crazy guy and I love Deferreds.
It's equally possible to implement something like stdio.py, without using
threads or multiple processes, where the user experiences the interface
blocking until a result is available each time he would have otherwise seen
a Deferred.

&gt;<i>They *want* a synchronous terminal
</I>&gt;<i>and a blocking PB clients.  I hope I am not coming across as angry
</I>&gt;<i>about this - I'm not.
</I>
Not at all. :)

&gt;<i>To me the lesson is that as long as everything
</I>&gt;<i>is really asynchronous anything is possible within the constraints of
</I>&gt;<i>this asynchronous universe.  It's the multiple universe things that
</I>&gt;<i>makes life complicated (asyn + syn).
</I>
Does the notion of dividing things up so that user interface concerns are
dealt with separately from API concerns clear this up at all?  Do you still
think there's something here which can't be solved without threads?

(To be sure, there is something - if you have a blocking API and you want to
use it inside an event loop, then you may need to resort to threads, but I
don't *think* that's the case you're interested in here - correct me if I'm
wrong.)

&gt;&gt;<i> &gt;But, I have never seen a
</I>&gt;&gt;<i> &gt;method of putting a blocking API on top of such a client that was
</I>&gt;&gt;<i> &gt;_really_ thread safe.  I have seen a few approaches that seem to work,
</I>&gt;&gt;<i> &gt;but that are clearly non-thread safe.  I would love to see a robust
</I>&gt;&gt;<i> &gt;solution for this problem though - one that could be fully trusted.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why isn't a solution based on Twisted's thread-safe event-posting API
</I>&gt;&gt;<i> (reactor.callFromThread) and the thread-safe event-posting API of whatever
</I>&gt;&gt;<i> other thing is being integrated with &quot;really&quot; thread-safe?  Sure, you can
</I>&gt;&gt;<i> write programs which will deadlock as a result of application-level bugs
</I>&gt;&gt;<i> where one thread is blocked on a request and the other thread needs some
</I>&gt;&gt;<i> information from it before the request can be satisfied, but this is inherent
</I>&gt;&gt;<i> to wanting to drive an asynchronous API synchronously.  Aside from it, I
</I>&gt;&gt;<i> don't think there are any problems with what I described above.
</I>&gt;<i>
</I>&gt;<i>It probably is, but I have never seen an implementation that actually
</I>&gt;<i>does this.  Do you know of one?  The ones that I have seen - even
</I>&gt;<i>those which use callFromThread have not filled me with thoughts of
</I>&gt;<i>robustness, stability and thread safety.  I should look at this again
</I>&gt;<i>though.
</I>
Ah, well, I don't have any that I can point too and claim are robust and
bug free (or even bug lite).  But hey, the *idea* is simple enough. &gt;:)

&gt;<i>
</I>&gt;<i>Also, I should mention that in IPython this is not a show stopper for
</I>&gt;<i>us, but it does mean that we currently don't use PB in all of the
</I>&gt;<i>places we might otherwise.
</I>&gt;<i>
</I>
Is this because you want to have blocking APIs in order to implement
features in IPython or is it because you want to present an interface
to users which behaves in a blocking manner? (Sorry if this is beginning
to sound repetitive)

Jean-Paul


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015975.html">[Twisted-Python] Wrapping a Perspective Broker remote object with	a blocking API
</A></li>
	<LI>Next message: <A HREF="015977.html">[Twisted-Python] Wrapping a Perspective Broker remote object with	a blocking API
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15976">[ date ]</a>
              <a href="thread.html#15976">[ thread ]</a>
              <a href="subject.html#15976">[ subject ]</a>
              <a href="author.html#15976">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
