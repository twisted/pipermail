<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Twisted scalability with hundreds of outbound	(client) connections
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Twisted%20scalability%20with%20hundreds%20of%20outbound%0A%09%28client%29%20connections&In-Reply-To=1096230335.19062.22.camel%40sheriffpony">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008749.html">
   <LINK REL="Next"  HREF="008753.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Twisted scalability with hundreds of outbound	(client) connections</H1>
    <B>Phil Mayers</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Twisted%20scalability%20with%20hundreds%20of%20outbound%0A%09%28client%29%20connections&In-Reply-To=1096230335.19062.22.camel%40sheriffpony"
       TITLE="[Twisted-Python] Twisted scalability with hundreds of outbound	(client) connections">p.mayers at imperial.ac.uk
       </A><BR>
    <I>Sun Oct  3 09:26:15 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008749.html">[Twisted-Python] PATCH: twisted.web.client Basic/Digest	Authentication
</A></li>
        <LI>Next message: <A HREF="008753.html">[Twisted-Python] Twisted scalability with hundreds of outbound	(client) connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8752">[ date ]</a>
              <a href="thread.html#8752">[ thread ]</a>
              <a href="subject.html#8752">[ subject ]</a>
              <a href="author.html#8752">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Itamar Shtull-Trauring wrote:

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>I'm also slightly concerned about the number of function calls involved 
</I>&gt;&gt;<i>in jumping in and out of the reactor that many times a second (several 
</I>&gt;&gt;<i>thousand, if I can get it to go as fast as my previous code) given how 
</I>&gt;&gt;<i>expensive they are under Python. It would certainly be quicker to 
</I>&gt;&gt;<i>implement this inside the reactor.mainLoop.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Just have a single reactor.callLater(0, f), and f() then calls all the
</I>&gt;<i> functions you want done in that iteration.
</I>
Ok, just a quick note to people - I solved this as suggested, however 
reactor.callLater(0, func) does not work; because 0 always means *now*, 
you get the queuing problem:

class SNMP(protocol.DatagramProtocol):
     def datagramReceived(self, data, addr):
         pdu = self.decode(data)
         self.timeouts.remove(pdu.deferred)
         self.queue(pdu.deferred.callback, (pdu,))

     def queue(self, func, pargs):
         if not self.calls:
             # Schedule a receive at some later date
             reactor.callLater(0.001, self.dequeue)
         self.calls.append((func, pargs))

     def dequeue(self):
         if not self.calls:
             return
         func, pargs = self.calls.pop(0)
         # The problem is here - this function will almost certainly
         # be a protocol action that will generate another transmit PDU
         # With many clients, the many transmits can overflow the input
         # queue while we're spinning inside code
         func(*pargs)
         if self.calls:
             # To avoid the problem, wait &quot;delta&quot; (some small number)
             # rather than zero; this will ensure a select() happens
             # before the callLater
             reactor.callLater(0.001, self.dequeue)

class Agent:
     def __init__(self, host, proto):
         self.proto = proto
     def start(self):
         d = self.proto.query(self.host, 'get', oid1, oid2)
         d.addCallbacks(self.step2, self.error)
     def step2(self, pdu):
         # Do some stuff
         d = self.proto.query(self.host, 'get', self.whatnow[pdu])
         d.addCallbacks(self.step3, self.error)

proto = SNMP()
for hostname in sys.argv[1:]:
     a = Agent(hostname, proto)
     # Start up one at a time, to avoid startup surge
     proto.queue(a.start, None)
from twisted.internet import reactor
reactor.run()

I hope I'm explaining what's going on here - but if not, don't worry, 
the problem is more or less solved for me, thanks for the assistance. 
The only minor remaining niggle is that the static 0.001 value to 
callLater limits my theoretical max throughput to 1000 queries/sec. The 
only way to do without that parameter would be to execute a select() 
inside every function call in runUntilCurrent I think. As it happens, 
1000/sec is more than the box can do anyway, so it's not a problem at 
the moment!


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008749.html">[Twisted-Python] PATCH: twisted.web.client Basic/Digest	Authentication
</A></li>
	<LI>Next message: <A HREF="008753.html">[Twisted-Python] Twisted scalability with hundreds of outbound	(client) connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8752">[ date ]</a>
              <a href="thread.html#8752">[ thread ]</a>
              <a href="subject.html#8752">[ subject ]</a>
              <a href="author.html#8752">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
