<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] the good, the log, and the ugly
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20the%20good%2C%20the%20log%2C%20and%20the%20ugly&In-Reply-To=%3C0DBDE73F-CBE9-4BAD-B104-DBF483D2AB9F%40twistedmatrix.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="057928.html">
   <LINK REL="Next"  HREF="057885.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] the good, the log, and the ugly</H1>
    <B>Glyph</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20the%20good%2C%20the%20log%2C%20and%20the%20ugly&In-Reply-To=%3C0DBDE73F-CBE9-4BAD-B104-DBF483D2AB9F%40twistedmatrix.com%3E"
       TITLE="[Twisted-Python] the good, the log, and the ugly">glyph at twistedmatrix.com
       </A><BR>
    <I>Sat Mar 31 18:38:12 MDT 2012</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="057928.html">[Twisted-Python] the good, the log, and the ugly
</A></li>
        <LI>Next message (by thread): <A HREF="057885.html">[Twisted-Python] Job Opportunity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#57929">[ date ]</a>
              <a href="thread.html#57929">[ thread ]</a>
              <a href="subject.html#57929">[ subject ]</a>
              <a href="author.html#57929">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Mar 31, 2012, at 6:10 PM, Brian Warner wrote:

&gt;<i> On 3/30/12 5:49 PM, Glyph wrote:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> <A HREF="http://foolscap.lothar.com/docs/logging.html">http://foolscap.lothar.com/docs/logging.html</A> has details.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Indeed, Foolscap has informed many of my future wishes for Twisted
</I>&gt;&gt;<i> logging, especially its incident reporting and logport features. (I
</I>&gt;&gt;<i> wasn't aware of UMIDs but I have independently invented the same
</I>&gt;&gt;<i> thing.)
</I>&gt;<i> 
</I>&gt;<i> (actually, the &quot;UMID&quot; support consists of ignoring extra kwargs, and an
</I>&gt;<i> emacs macro which inserts umid=&quot;RANDOM&quot; at point. It works remarkably
</I>&gt;<i> well, and is a lot cheaper than having log.msg() capture the call stack
</I>&gt;<i> so you can figure out which copy of the otherwise-anonymous
</I>&gt;<i> log.msg(&quot;done&quot;) calls was invoked this time)
</I>
I was thinking more along the lines of something that would insert the output of &quot;python -c 'import uuid, sys; sys.stdout.write(str(uuid.uuid4()))'&quot;, but yeah, same general idea. (Why do you have to ignore extra kwargs?)

&gt;&gt;<i> Could we perhaps get some of foolscap logging's core features into
</I>&gt;&gt;<i> Twisted? We could have an AMP interface for subscribing to log streams
</I>&gt;&gt;<i> that would be slightly more low-fidelity (but, I would guess,
</I>&gt;&gt;<i> higher-performance) than the Foolscap one, but work based on the same
</I>&gt;&gt;<i> core mechanism which foolscap could then subscribe to.
</I>&gt;<i> 
</I>&gt;<i> Yeah, that'd be great. An AMP interface sounds lovely. I'd have to think
</I>&gt;<i> about potential gotchas, but I'm sure we can work them out. Foolscap's
</I>&gt;<i> remote protocol relies upon all the log.msg() arguments being
</I>&gt;<i> foolscap-serializable, which occasionally reveals places where we're
</I>&gt;<i> accidentally passing object instances into the log. (it uses
</I>&gt;<i> CopiedFailure a lot, so we'd need to come up with an AMP equivalent).
</I>&gt;<i> The stored-on-disk format just uses pickle, which I kinda regret, but it
</I>&gt;<i> should be pretty easy to replace that with something safer.
</I>
I was thinking that AMP would offer an AnyOf() argument type, which would be dynamic within a small set, with a fallback.  Within the context of logging, we'd support unicode/bytes/float/int (and maybe some more esoteric numeric tower stuff too, like decimals and fractions), and possibly lists and dicts of those same types (but not structures of structures, so we don't have to worry about backreferences).  Maybe tuples supported the same as lists.

The fallback would simply be &quot;repr() this thing&quot;, so if you log an object you still get something somewhat useful without potentially arbitrary serialization.

Foolscap could take the same data and just make a 

&gt;<i> There's also the notion of a &quot;log port&quot; (a foolscap object with a
</I>&gt;<i> remote_subscribe() method). Does AMP have any notion of object
</I>&gt;<i> references?
</I>
No, but I don't think we need such a notion.  If we did need it for some reason, AMP does have a notion of establishing new message streams over the same connection.  This message finally prompted me to file the ticket that I always think was already filed: &lt;<A HREF="http://twistedmatrix.com/trac/ticket/5587">http://twistedmatrix.com/trac/ticket/5587</A>&gt;.

&gt;<i> If not, I can see how you could call in and ask
</I>&gt;<i> (synchronously) for the current event log, but not how you'd provide a
</I>&gt;<i> &quot;callback object&quot; to which future events should be streamed. How does
</I>&gt;<i> pubsub work in AMP?
</I>
You just know that your peer knows how to respond to certain commands, and you send those commands.  For example,

from twisted.protocols.amp import Command, String, AMP
class Pub(Command):
    arguments = [(&quot;channel&quot;, String()), (&quot;event&quot;, String())]
class Sub(Command):
    arguments = [(&quot;channel&quot;, String())]
class Hub(AMP):
    @Sub.responder
    def sub(self, channel):
        self.factory.observers[channel].append(self)
    @Pub.responder
    def pub(self, channel, event):
        for observer in self.factory.observers[channel]:
            observer.callRemote(Pub, channel=channel, event=event)

Then your peer just has the same definition of Pub and has a @Pub.responder that does whatever they like.  (Eric Mangold was working on formalizing this process somewhat at the Twisted sprint.)

&gt;&gt;<i> I suspect that this would be useful to foolscap as well, because then
</I>&gt;&gt;<i> the code that foolscap calls into (for example, the web stuff for its
</I>&gt;&gt;<i> UIs) would be using the same logging convention.
</I>&gt;<i> 
</I>&gt;<i> Yeah, I'd love to get that factored out and let other people hack on it.
</I>&gt;<i> My web UI skills are laughable.
</I>
Actually I was saying that Twisted could provide the core functionality and Foolscap could still provide the web UI - but if you wanted to break things out even further, but I suppose this would also present an opportunity for some third party to plug in some web UI on the side of Twisted that was not necessarily related to Foolscap, which would be cool too.

-glyph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20120331/a548a7cf/attachment.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="057928.html">[Twisted-Python] the good, the log, and the ugly
</A></li>
	<LI>Next message (by thread): <A HREF="057885.html">[Twisted-Python] Job Opportunity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#57929">[ date ]</a>
              <a href="thread.html#57929">[ thread ]</a>
              <a href="subject.html#57929">[ subject ]</a>
              <a href="author.html#57929">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
