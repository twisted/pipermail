From thyrr at bb3.betterbox.net  Tue May  1 01:29:27 2001
From: thyrr at bb3.betterbox.net (Thyrr)
Date: Tue, 1 May 2001 00:29:27 -0500 (CDT)
Subject: [Twisted-Python] twisted.web split
In-Reply-To: <E14uHG2-0001DH-00@darjeeling>
Message-ID: <Pine.LNX.3.96.1010501001944.9748A-100000@bb3.betterbox.net>

How about splitting it into more files than that? It's a bit easier
generally to navigate and isolate problems, reuse for other things, and
update things. Maybe a file for CGI/epy code, a file for getting files and
such, a file for generating automatic directory listings, etc.

Just my suggestion (though I've only looked at Twisted Python for a few
days now, so maybe that's not a good way to do it?)

 - Thyrr at bb3.betterbox.net

On Mon, 30 Apr 2001, Moshe Zadka wrote:

> Hello, all.
> I talked a bit with glyph and radix about splitting twisted.web.
> It's over 1500 lines now, and I think it's becoming unmanageable.
> Here is how I propose it will be split:
> 
> - twisted/web/html.py -- HTML generation helpers
> - twisted/web/protocol.py -- Web protocols (HTTP and Gloop, currently)
> - twisted/web/resource.py -- Resources.
> 
> Specifically:
> 
> - twisted/web/resource.py
> 
> 	class Data(Resource):
> 	class Interface(Resource):
> 	class FileTransfer:
> 	class DirectoryListing(Interface):
> 	class File(Resource):
> 	class CGIDirectory(Resource):
> 	class ErrorPage(Interface):
> 	class NoResource(ErrorPage):
>         class ResourceIssue:
> 	class ResourceSubscription(Resource):
> 	class PythonScript(Resource):
> 	class CGIScript(Resource):
> 	class FilteredScript(CGIScript):
> 	class PHPScript(FilteredScript):
> 	class MethodDirectory(Interface):
> 	class UserDirectory(Interface):
> 
> - twisted/web/html.py
> 
> 	def escape(text):
> 	def PRE(text):
> 	def output(func, *args, **kw):
> 	def date_time_string(msSinceEpoch=None):
> 	def d(**z):
> 
> - twisted/web/protocol.py
> 
> 	class HTTP: (might move completely outside)
> 	class Request(http.HTTPRequestHandler):
> 	class CGIProcess(net.Process):
> 	class ResourcePublish(gloop.Handler):
> 	class ResourcePublisher(gloop.Server, authenticator.SessionManager):
> 	class HTTPHandler(net.GenericHandler):
> 	class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
> 	class HTTPClient(net.GenericClient, log.Logger):
> 	class HTTPCallback(HTTPClient):
> 	class ResourcePublisherClient(gloop.Client, log.Logger):
> 
> >From a simple grep I think I've covered everything.
> Anything else that might have slipped should be easy to put somewhere.
> 
> -- 
> "I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
> looking for someplace else to grab power."|YODA: No...no... no. Quicker,
>    -- Wichert Akkerman (on debian-private)|      easier, more seductive.
> For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org
> 
> 
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python
> 





From glyph at twistedmatrix.com  Tue May  1 03:12:46 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 1 May 2001 02:12:46 -0500
Subject: [Twisted-Python] twisted.web split
In-Reply-To: <Pine.LNX.3.96.1010501001944.9748A-100000@bb3.betterbox.net>
References: <Pine.LNX.3.96.1010501001944.9748A-100000@bb3.betterbox.net>
Message-ID: <0105010212460A.10809@helix>

On Tuesday 01 May 2001 00:29, you wrote:
> How about splitting it into more files than that?

Maybe...

> It's a bit easier generally to navigate and isolate problems,

I disagree.  It's easiest if there is one module that you have to look 
through that contains as much as possible, since any decent editor will allow 
you to browse the classes in that file. (Any *tolerable* editor will at least 
let you do a regular-expression search).  Most modern computers can fit a 
1.5k file into main memory, even in a visual editor, so size requirements are 
specious.  Having a billion modules where classes _might_ live is 
considerably worse.

> reuse for other things,

I don't like reuse, and I hope to actively discourage it (I'll explain this 
more thoroughly at another time.  This is yet another essay in the works for 
me...).  If you're talking about *use*, well then, all that you're discussing 
about "easier" means "from twisted.web.server import File" or "from 
twisted.web.static import File".  I don't see any meaninful ease-of-use in 
the name distinction...

> and update things.

Since I have done approximately 90% of the updates to this project at this 
point, I just think I'll say "no" to that one ;)

> Maybe a file for CGI/epy code, a file for getting files and
> such, a file for generating automatic directory listings, etc.

Segregating things along meaningful module boundaries is a useful division 
though, because it provides a meaningful way to expand that functionality, so 
I'll think about this.  The categories you describe might actually be good 
(web.dynamic(CGI/epy)/web.static(Files/Directory Listings) frex).

> Just my suggestion (though I've only looked at Twisted Python for a few
> days now, so maybe that's not a good way to do it?)

Not a bad comment though, especially the last part.  Thanks.

Although I tend to be quite argumentative on this topic (baaaaad experiences 
with python packages on my last project at work), I'd really like to see 
active discussion of how to break apart burgeoning modules into packages; 
it's an unpleasant problem as I've seen it so far, but with some consistently 
applied strategy I'm sure it could be a good thing.  Given that 
code-harvesting seems to be my predominant "engineering" philosophy, I have a 
feeling that this sort of refactoring will be highly common on this project, 
especially in the near future (as each "core" module (web, reality, net) 
expands).

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Tue May  1 16:46:02 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 01 May 2001 23:46:02 +0300
Subject: [Twisted-Python] smtp server -- pre-alpha version, please comment on design
Message-ID: <E14uh22-0002yz-00@darjeeling>

Hi, all!
twisted.mail so far has not been coming along nicely. However,
I now have some code which when tested will finally bring us to the
point where we can have a working e-mail system.

Well, not really -- we'll still need to handle *sending* e-mail, which
isn't as easy async as you may think... :(

Let me say a few general words about the way it works:
I wanted to have the same seperation of responsibilities that brings
us seperate handler/server/protocol-transformer to continue onto actually
saving e-mails. Towards this end, I've made the server responsible for
managing the list of domains, each of which is an object which can check
if it wants to accepts for certain localparts, and to save the e-mail.
This should bring us a higher level of testability, since we can have
dummy domains which just remember the e-mail messages saved, and then
we can bombard the handler with .handleData from us, and so on.

But, off to a better life and so on, here is the code for the pre-alpha
SMTP server:

from twisted.protocols import smtp

class VirtualSMTPHandler(smtp.SMTPHandler):

    seq = 0

    def validateTo(self, helo, destination):
        try:
            domain = string.split(destination, '@', 1)[1]
        except IndexError:
            return 0
        if not self.handler.server.domains.has_key(domain):
            return 0
        if not self.handler.server.domains[domain].exists(user):
            return 0
        return 1

    def handleMessage(self, helo, origin, recipients, message):
        for recipient in recipients:
            user, domain = string.split(destination, '@', 1)
            self.handler.server.domains[domain].save_message(user, message)


class SMTPNetHandler(net.GenericHandler):

    handler = None

    def handleData(self, data):
        if self.handler is None:
            self.handler = VirtualMaildirSMTPHandler(self)
        self.handler.handleData(data)

    def connectionLost(self, why):
        self.handler = None
        net.GenericHandler.connectionLost(self, why)


class VirtualSMTPServer(net.GenericServer):

    handler = SMTPNetHandler

    def __init__(self, *args, **kw):
        apply(net.GenericServer.__init__, (self,)+args, kw)
        self.domains = {}

    def addDomain(self, name, domain):
        self.domains[name] = domain



n = 0

class AbstractMaildirDomain:

    def __init__(self, root):
        self.root = root

    def user_directory(self, user):
        return None

    def exists(self, name):
        return self.user_directory(user) is not None

    def save_message(self, name, message):
        dir = self.user_directory(user)
        name = self._generateMaildirName() 
        filename = os.path.join(dir, 'new', name)
        fp = open(filename, 'w')
        try:
            fp.write(message)
        finally:
            fp.close()

    def _generateMaildirName(self):
        global n
        t = str(int(time.time()))
        s = socket.gethostname()
        p = os.getpid()
        n = n+1
        return '%s.%s_%s.%s' % (t, p, n, s)


class BounceDomain:

    def exists(self, name):
        return 0


class DirectoryExistanceMaildirDomain(AbstractMaildirDomain):

    def user_directory(self, name):
	dir = os.path.join(self.root, name)):
        if os.path.isdir(dir):
            return dir


class PostmasterMaildirDomain(AbstractMaildirDomain):

    def user_directory(self, name):
	dir = os.path.join(self.root, name)):
        if os.path.isdir(dir):
            return dir
        return os.path.join(self.root, 'postmaster')

# This wasn't in the original code, but is a nice example:

class SubdomainManager:

    def __init__(self, domains={}):
        self.domains = {}
        self.domains.update(domains)

    def addDomain(self, name, domain):
        self.domains[name] = domain

    def exists(self, user):
        if not '%' in user:
             return 0
        localpart, remote = string.split(user, '%', 1)
        if not self.domains.has_key(remote):
             return 0
        if not self.domains[remote].exists(localpart):
             return 0
        return 1

    def save_message(self, name, message):
        localpart, remote = string.split(user, '%', 1)
        return self.domains[remote].save_message(localpart, message)
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Wed May  2 05:23:44 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Wed, 02 May 2001 12:23:44 +0300
Subject: [Twisted-Python] <homer>Oooh, it's good news</homer>
Message-ID: <E14usrI-0004Dl-00@darjeeling>

1. All .protocols that I wrote from scratch have tests in test_twisted.
   .irc and .telnet are waiting for glyph.
2. twisted.pop3 now uses the POP3 protocol.
3. twisted.smtp now has rudimentary unit tests.

I think that finishes the twisted.mail goals for 0.8.5
By 0.9 I hope to have enough to support so you can just issue
a 

bin/mkmailsystem <root>

And know that you have a mail system that does not go outside the root,
and manages the mail. With some luck, maybe I'll even be able to add a
gloop server which integrates with a gloop-to-web gateway to have a web
interface for configuring domains. Anyone who did qmail knows what I'm
talking about -- every postmaster can go in, add users, remove users,
define policies, etc. That's probably post-0.9, though...

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From j.her at t-online.de  Wed May  2 16:18:34 2001
From: j.her at t-online.de (Juergen Hermann)
Date: Wed, 02 May 2001 22:18:34 +0200
Subject: [Twisted-Python] Docs
Message-ID: <14v33l-1i20ECC@fwd00.sul.t-online.com>

Glyph asked for the standard rant about using XML:

 - you can use the same set of source files to generate quite different
outputs (html, rdf, latex, paper, pdf, etc.), and the tools for this
come for free (linux, fbsd, etc. doco projects all use docbook)

 - you can have differing styles with the same output medium, compare
t
URLs:

	http://4suite.org/documents/4Suite/TODO

	http://twistedmatrix.com/users/jh.twistd/python/moin.cgi/DocBook
Test

 - docbook is a STANDARD way for SEMANTIC computer manual markup, i.e.
what you have to learn you can use elsewhere, including your resum?

 - all tools are available for python (guess what the above tw url is
generated with)

'nuf said.





From carmstro at dynup.net  Wed May  2 21:39:29 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 2 May 2001 21:39:29 -0400
Subject: [Twisted-Python] <homer>Oooh, it's good news</homer>
In-Reply-To: <E14usrI-0004Dl-00@darjeeling>; from moshez@zadka.site.co.il on Wed, May 02, 2001 at 12:23:44PM +0300
References: <E14usrI-0004Dl-00@darjeeling>
Message-ID: <20010502213929.A896@Fookidla.org>

On Wed, May 02, 2001 at 12:23:44PM +0300, Moshe Zadka wrote:
> 1. All .protocols that I wrote from scratch have tests in test_twisted.
>    .irc and .telnet are waiting for glyph.
> 2. twisted.pop3 now uses the POP3 protocol.
> 3. twisted.smtp now has rudimentary unit tests.
> 
> I think that finishes the twisted.mail goals for 0.8.5
> By 0.9 I hope to have enough to support so you can just issue
> a 
> 
> bin/mkmailsystem <root>
> 
> And know that you have a mail system that does not go outside the root,
> and manages the mail. With some luck, maybe I'll even be able to add a
> gloop server which integrates with a gloop-to-web gateway to have a web
> interface for configuring domains. Anyone who did qmail knows what I'm
> talking about -- every postmaster can go in, add users, remove users,
> define policies, etc. That's probably post-0.9, though...

You don't need to write a gloop-to-web gateway for a config interface - I'm
already working on a configuration interface. All you'll have to do is define
some standard functions in the classes that you want to be configurable and
it will be configurable for any UI that's implemented (currently only working
on web, but a reality configurator is something that I'm looking forward
to as well).


-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Thu May  3 03:53:00 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Thu, 3 May 2001 10:53:00 +0300
Subject: [Twisted-Python] SMTP Client Prototype
Message-ID: <200105030753.KAA01647@jabotinsky.lerner.co.il>

Hi!
Most of you already know how obsessed I am with e-mail...
Here is the latest thing -- a prototype for an SMTP client.
Later I just want to have an OutgoingQueue domain which can
be used to relay mail. The first stage, which I think is doable
by 0.9, is to have so-called smart host capability -- this would
save us the trouble of going after MX records ourselves, and 
still leave us with something very functional. 

SMTP_CODE = re.compile('(?P<code>\d\d\d)(?P<continuation>[- ])')

DO_HELO, DO_FROM, DO_TO, DO_DATA = range(3) 

class SMTPClientHandler(basic.LineReceiver):

    mode = DO_HELO
    hostname = 'localhost'
    lastCommand = None


    def handleLine(self, line):
        m = SMTP_CODE.match(line)
        if not m:
            raise SMTPError
        if m.groupdict()['continuation'] == ' ':
           self.handleCode(int(m.groupdict()['code']))


    def handleResponse(self, code):
        if self.lastCommand is None:
            if code != 250:
                self.loseConnection()
                return 0
        elif self.lastCommand == 'TO'
            if (code/100) == 2:
                self.successfulTo.append(self.lastTo)
            self.lastTo = None
        elif self.lastCommand == 'DATA':
            if code != 354:
                self.failMessage()
                self.mode = DO_FROM
        elif self.lastCommand == 'DID_DATA':
            if (code/100) == 2:
                self.doneMessage(self.successfulTo)
            else:
                self.failMessage()
            del self.successfulTo
        elif self.lastCommand == 'FROM':
            if (code/100) != 2:
                self.failMessage()
                self.mode = DO_FROM
        elif self.lastCommand == 'HELO':
            self.loseConnection()
            return 0
        return 1


    def handleCode(self, code):
        if not self.handleResponse(code):
            return
        if self.mode is DO_HELO:
            self.handler.write('HELO %s\r\n' % self.hostname)
            self.lastCommand = 'HELO'
        elif self.mode is DO_FROM:
            message = self.getActiveMessage()
            if message is None:
                return self.loseConnection()
            from_ = message.getFrom()
            self.mode = DO_TO
            self.recipients = message.getRecipients()
            self.sucessfulTo = []
            self.handler.write('MAIL FROM:<%s>\r\n' % from_)
            self.lastCommand = 'FROM'
        elif self.mode is DO_TO:
            if not self.recipients:
                self.lastCommand = 'DATA'
                self.handler.write('DATA\r\n')
            else:
                recipient = self.recipients.pop()
                self.lastCommand = 'TO'
                self.lastTo = recipient
                self.handler.write('RCPT TO:<%s>' % recipient)
        elif self.mode is DO_DATA:
             self.lastCommand = 'DID_DATA'
             self.sendMessage()




From moshez at zadka.site.co.il  Thu May  3 12:48:49 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Thu, 03 May 2001 19:48:49 +0300
Subject: [Twisted-Python] <homer>Oooh, it's good news</homer>
In-Reply-To: <20010502213929.A896@Fookidla.org>
References: <20010502213929.A896@Fookidla.org>, <E14usrI-0004Dl-00@darjeeling>
Message-ID: <E14vMHZ-0006jb-00@darjeeling>

On Wed, 2 May 2001 21:39:29 -0400, Chris Armstrong <carmstro at dynup.net> wrote:
 
> You don't need to write a gloop-to-web gateway for a config interface - I'm
> already working on a configuration interface. All you'll have to do is define
> some standard functions in the classes that you want to be configurable and
> it will be configurable for any UI that's implemented 

Sounds cool. Try to look how Zope does it, and take the good parts, and
throw away the bad parts. For example, I would like a 

.generateQuestions() --> Return a ConfigurationQuestions object.
.acceptAnswers(answers) --> Accept an ConfigurationAnswers object, and 
                            configure yourself.

Also, you probably also want to consider security -- e.g., I'd like to
have hierarchical permissions, so the site-admin can configure any domain,
but a postmaster for a certain domain can have permissions for a specific
domain. I don't mind dealing with security on my own, though, e.g.,
have methods

.acceptCredentials(name, password) --> Return a unique id, which
                                       is sent back with the answers.

> (currently only working
> on web, but a reality configurator is something that I'm looking forward
> to as well).

Cool. You mean, like, walk up to the dragon and tell him the password
to get inside the "configuration room"? ;-) 
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Fri May  4 11:57:22 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 04 May 2001 18:57:22 +0300
Subject: [Twisted-Python] mail support
Message-ID: <E14vhxK-0008UJ-00@darjeeling>

With the latest CVS version, we have passable SMTP/POP3 support.
If you want to use it, here's a short example:

http://moshez.org/mail.tgz

Unpack this in your toplevel TwistedPython directory.
It will create a file bin/mksmtpserver and a directory test.
Run "bin/mksmtpserver test"
And then run the resulting mail.spl
It will have an SMTP server on port 2000 which accepts mails only
for moshez at exmple.com. moshez's password is "moshez", and if you
connect to port 2001 via POP3 (only APOP auth is supported currently)
you will be able to retrieve those messages.
Naturally, this is a rough proof-of-concept currently... ;-)

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May  5 04:12:32 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 05 May 2001 11:12:32 +0300
Subject: [Twisted-Python] Mail has been refactored...again ;-)
Message-ID: <E14vxB2-00010Q-00@darjeeling>

Yes, I've finally gone after the dreaded mail refactoring. 
twisted.smtp and twisted.pop3 are no more, and in fact the whole SMTP/POP3
support is about 8 lines of that file. Most of the file is about *mail*
as a concept. Not that SMTP and POP3 concepts don't show through -- that
would be useless abstraction. E.g., domains understand that there's
a concept of challenge/response authentication for POP3, and that
SMTP first checks for a user's existance and then asks to save a message
for the user. I expect domains will grow support for more and more mail
concepts -- but that's cool.

The interesting part of bin/mksmtpserver (wrong name) is now:

domain = mail.MaildirDirdbmDomain(rootdir)
s = net.Selector()
t = mail.VirtualSMTPServer(smtp_portno, s)
t.domains['example.com'] = domain
t = mail.VirtualPOP3Server(pop_portno, s)
t.domains[''] = domain
dump(s, open("mail.spl",'wb'))

The interesting part is to note how the *same* domain is used both as 
SMTP incoming domain and as a place to pull out POP3 from. This really
should do wonders for ease of configuration.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May  5 06:41:52 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 05 May 2001 13:41:52 +0300
Subject: [Twisted-Python] Python is just Too Easy
Message-ID: <E14vzVY-0001Fs-00@darjeeling>

I know I continually promised that 0.8.5 will be the "hard to configure but
working SMTP/POP3 servers". Well, sorry...
I've checked in a nifty little utility called bin/mkmailserver
Unfortunately, there's no documentation yet, so here's a rough
explanation on how to use it:

use 
bin/mkmailserver create <smtp port> <pop3 port>

And you'll have a mail.spl which always answers "I don't know what
you're talking about".

To add support for a domain, run

bin/mkmailserver domain <smtp name> <pop3 name> <root dir>

What this means is that if you want to have a server that handles mail
for "example.com", but when pulling it via POP3 you just want to specify
the local part, use

bin/mkmailserver domain example.com '' <some directory>

The directory should exist and be empty, BTW.

Now you have a user-less domain -- so, it will still answer "I don't
know who that user is, sorry". Add a user using

bin/mkmailserver <pop3 domain> <user> <password>

Suppose that I want to add glyph to the POP3 domain above, I'll run

bin/mkmailserver '' glyph s3kr1t

Now, connecting to the SMTP server and sending mail to glyph at example.com,
it will be saved in the directory. If glyph then conencts to the POP3
server and authenticates (via APOP only!) with "s3kr1t",  then he'll
be able to retrieve that mail.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May  5 08:31:01 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 05 May 2001 15:31:01 +0300
Subject: [Twisted-Python] Brown-paperbag Bug in Mail Fixed
Message-ID: <E14w1DB-0001QE-00@darjeeling>

In conclusion, now it works with 3rd parties which implement
APOP (namely, Python's poplib).
Yay!

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Sun May  6 22:43:28 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 6 May 2001 21:43:28 -0500
Subject: [Twisted-Python] No Release Today
Message-ID: <01050621432803.00457@helix>

In my final round of testing 0.8.5 for release, I discovered some nasty 
release-critical bugs in moshe's refactoring of twisted.web; I'm surprised I 
didn't uncover these when I initially looked at it, but I couldn't do a 
release today with the code in such a half-working state.

Since I fixed it in my CVS tree, where most of the names of .net and related 
classes are different, I need to do some more stress testing; this shouldn't 
delay the release longer than tuesday; hopefully it'll only delay it one day.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Tue May  8 07:41:32 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 8 May 2001 06:41:32 -0500
Subject: [Twisted-Python] Remember: slower pizza's more luscious.
Message-ID: <01050806413204.00457@helix>

AUSTIN (AP) -- Twisted Matrix Laboratories today unveiled the 
much-anticipated and much-delayed most recent iteration of their "Twisted 
Python" product suite.  Equipped with more internet and more sticks than ever 
before, the power to destroy the sun, and a mail server, this release will 
"pose a significant threat to our competition, as soon as we figure out who 
we're competing with and for what", according to Evil Overlord Glyph 
Lefkowitz.

Despite the terrifying power and grace that this version exhibits, plans at 
the matrix's center are only to accelerate the pace of development. Chief 
Reality Engineer Allen Short commented, "By the time we reach our goals for 
version 1.0.0, the Illuminati -- one of our many `enterprise support' clients 
-- will be able to use this software to [censored] the [censored] with enough 
[censored] to [censored]!  Can you imagine that?"

Information about this software and twisted matrix enterprises, as well as 
the most recent version of the source code, is available at 

	http://twistedmatrix.com/

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |fnord] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Tue May  8 19:52:41 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 8 May 2001 18:52:41 -0500
Subject: [Twisted-Python] Another brown paper bug release.
Message-ID: <01050818524100.17572@helix>

I just put out 0.8.7, a bugfix release for .6, which was leaking resources 
until the webserver crashed, for a second time (while the release was on 
freshmeat's front page :-\).

There are still a number of known problems, which continue to baffle me:

twisted.protocols.http is buggy, especially _parse_command.  I don't know 
why, yet: it *looks* right...  There regular tracebacks in 
/var/www/twistd.log, and I'm pretty sure it's not because of a proliferation 
of buggy HTTP clients.  These didn't appear before.

POST doesn't work if you're in germany.  Nobody can see this problem except 
for J?rgen, and then only to twistedmatrix.com; however, I think that it's a 
real bug.  I am vaguely suspicious that this has something to do with 
protocols.basic.LineReceiver prematurely closing the process's connection, 
but I have absolutely *no* idea why.  CGIs work flawlessly for me, both GET 
and POST, and I've constructed some pretty pathological tests.

This whole incident indicates the need for a better testing procedure; now 
that people actually rely on twistedmatrix.com to do stuff, I think that the 
release process should take a few days in order to ensure that *all* aspects 
of the code are tested.  Proposals for something more formal will be gladly 
accepted :)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From j.her at t-online.de  Tue May  8 20:30:05 2001
From: j.her at t-online.de (Juergen Hermann)
Date: Wed, 09 May 2001 02:30:05 +0200
Subject: [Twisted-Python] http.py
Message-ID: <14xHqY-1UPo5AC@fwd00.sul.t-online.com>

class HTTPHandler(basic.LineReceiver):

    __length = 0
    __header = ''
    __first_line = 1

    def _parse_command(self, command):
        parts = string.split(command)
        if len(parts)<3:
            parts.append('HTTP/0.9') # isn't backwards compat great!
        if len(parts) != 3:
            self.sendError(405, 'Bad command')
            raise ValueError(str(parts))
        return parts

    def sendStatus(self, code, resp=''):
        self.transport.write('HTTP/1.0 %s %s\r\n' % (code, resp))

    def sendHeader(self, name, value):
        self.transport.write('%s: %s\r\n' % (name, value))

    def endHeaders(self):
        self.transport.write('\r\n')

    def sendError(self, code, resp=''):
        self.sendStatus(code, resp)
        self.endHeaders()

    def lineReceived(self, line):
        if self.__first_line:
            self.__first_line = 0
            command, request, version = self._parse_command(line)
            self.handleCommand(command, request, version)
            if version == 'HTTP/0.9':
                self.handleEndHeaders()
                self.callHandleEndContent()
        elif line == '':
            if self.__header:
                self.callHandleHeader(self.__header)
            self.__header = ''
            self.handleEndHeaders()
            if self.__length == 0:
                self.callHandleEndContent()
            else:
                self.setRawMode()
        elif line[0] in ' \t':
            self.__header = self.__header+'\n'+line
        else:
            if self.__header:
            	self.callHandleHeader(self.__header)
            self.__header = line


    def callHandleHeader(self, line):
        """Do pre-processing (for content-length) and then call
handleHeader
        for one header line."""
        assert line
        if string.find(string.lower(line), 'content-length: ') == 0:
            self.__length = int(string.strip(string.split(line, ':',
1)[1]))
        self.handleHeader(line)


    def callHandleEndContent(self):
        self.__first_line = 1
>>> be paranoid! and rawDataReceived will leave this != 0 in some cases!
        self.__length = 0
        self.__header = ''
<<<
        self.handleEndContent()


>>> the logic here is pretty fucked, if you ask me
>>> what if we send more bytes than specified in c-length?
>>> note that a post has exactly the speciality of a c-l != 0
>>> a get has not c-l or a cl of 0!
>>> is the setlinemode for keep-alive?
>>> if not, some "print 'extraneous bytes in request'" would be better

    def rawDataReceived(self, data):
        if len(data) < self.__length:
            self.handleContentChunk(data)
            self.__length = self.__length - len(data)
        else:
            self.handleContentChunk(data[:self.__length])
            self.callHandleEndContent()
>>> !!!
				# only pass NONEMPTY strings on
				if len(data) > self.__length:
                self.setLineMode(data[self.__length:])









From carmstro at dynup.net  Tue May  8 22:26:31 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Tue, 8 May 2001 22:26:31 -0400
Subject: [Twisted-Python] Another brown paper bug release.
In-Reply-To: <01050818524100.17572@helix>; from glyph@twistedmatrix.com on Tue, May 08, 2001 at 06:52:41PM -0500
References: <01050818524100.17572@helix>
Message-ID: <20010508222631.A824@Fookidla.org>

I think one good real-world test would be to actually run the frozen code
on twistedmatrix.com for a day before releasing. This would of course only
be a supplement to other harder tests, but as this incident shows, it would
be a useful one.

On Tue, May 08, 2001 at 06:52:41PM -0500, Glyph Lefkowitz wrote:
> This whole incident indicates the need for a better testing procedure; now 
> that people actually rely on twistedmatrix.com to do stuff, I think that the 
> release process should take a few days in order to ensure that *all* aspects 
> of the code are tested.  Proposals for something more formal will be gladly 
> accepted :)

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro




From moshez at zadka.site.co.il  Wed May  9 01:19:44 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Wed, 09 May 2001 08:19:44 +0300
Subject: [Twisted-Python] Another brown paper bug release.
In-Reply-To: <01050818524100.17572@helix>
References: <01050818524100.17572@helix>
Message-ID: <E14xMO0-0000gC-00@darjeeling>

On Tue, 8 May 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:

> This whole incident indicates the need for a better testing procedure; now 
> that people actually rely on twistedmatrix.com to do stuff, I think that the 
> release process should take a few days in order to ensure that *all* aspects 
> of the code are tested.  Proposals for something more formal will be gladly 
> accepted :)

Random note: web.Resource and friends and web.Request do not rely on an
internet connection: they rely on a handler which has a .server with some
properties and some other attributes. Creating such a handler is no problem
if we start from FileWrapper, add attributes, and create a server and
attach it to the handler ourselves.

So any *recorded and analysed* bug should be able to quickly become a test
case.
 
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Wed May  9 04:16:09 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 9 May 2001 03:16:09 -0500
Subject: [Twisted-Python] Another brown paper bug release.
In-Reply-To: <E14xMO0-0000gC-00@darjeeling>
References: <01050818524100.17572@helix> <E14xMO0-0000gC-00@darjeeling>
Message-ID: <01050903160901.17572@helix>

On Wednesday 09 May 2001 00:19, you wrote:

> Random note: web.Resource and friends and web.Request do not rely on an
> internet connection: they rely on a handler which has a .server with some
> properties and some other attributes. Creating such a handler is no problem
> if we start from FileWrapper, add attributes, and create a server and
> attach it to the handler ourselves.
>
> So any *recorded and analysed* bug should be able to quickly become a test
> case.

While this is true in theory, there are many practical concerns that can't be 
simulated by an automatic test case; the one outstanding bug is one of these. 
 Since twisted.web relies on external processes -- for server distribution, 
for CGI scripts -- race conditions may arise that are impossible to unit 
test.  So, we need some functional testing as well, to make sure that those 
sorts of conditions don't arise.

If anyone else can think of a way to get fork() into a unit test, I'd like to 
hear about it :).  But, even more than that, I am frequently surprised when I 
try to run "working" code on Windows or Jython and have it crash due to some 
undocumented incompatibility (or even a documented one that I just haven't 
read about).

I'm a big proponent of automated testing, though, so I'd love to be wrong.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From j.her at t-online.de  Wed May  9 20:47:56 2001
From: j.her at t-online.de (Juergen Hermann)
Date: Thu, 10 May 2001 02:47:56 +0200
Subject: [Twisted-Python] Handling of spurious \r\n
Message-ID: <14xebN-1O9o4eC@fwd00.sul.t-online.com>

glyph,

I changed the fix to ignore an empty line at the start of a http
request, as you suggested. At most ONE such line is ignored. And I
extended the test case with such a request.

Ciao, J?rgen






From grolgh at online.no  Thu May 10 15:02:37 2001
From: grolgh at online.no (grolgh)
Date: Thu, 10 May 2001 21:02:37 +0200
Subject: [Twisted-Python] neverending connection
Message-ID: <3AFC7DB2@epostleser.online.no>

Hello twisted.minions :)

This is my first mail on tp-ml; hello! I'm currently working on twisted.ftp 
and it's about 30% into acceptable working state. To hack it you need to press 
enter twice :) But I've run into a known problem.

I just noticed that TCPServer.loseConnection never trigs 
TCPServer.connectionLost. I think this is the famous 
never-ending-connection-bug, and I think the bug has its origin in 
selectable.doWrite.

I'll here present my current findings with it. Note that doSelect will run its 
selectable.connectionLost() if selectable's doRead or doWrite returns anything 
non-zero.
 
I'll take it step by step.
A call to loseConnection, will set __reap
Afterwards, __reap appears in doWrite which will write out its buffer and 
return CONNECTION_DONE
doSelect terminates the connection

Well, if we take a closer look at doWrite we find that it has several layers 
of if's before a CONNECTION_DONE is returned. Especially "if not self.unsent"! 
:/

Well, hope anyone finds this useful; and squash that horrible thing out. :)





From moshez at zadka.site.co.il  Fri May 11 09:53:15 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 11 May 2001 16:53:15 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
Message-ID: <E14yDM3-0005wV-00@darjeeling>

OK, let me first state some axioms:

1. Everything should be configurable the same way, from within twisted.

Glyph has mentioned that he's not familiar with what's in bin/ anymore: 
he just mktelnetserver, and configures from within the telnet server
everything. This is what should happen, except not limited to the telnet
server.

2. The configuration interface must not be ui specific.

This is obvious, right? Command line and web based aren't the only option.
No reason why we can't implement a special purpose client/server for configuring
twisted.

3. It should be easy to optimize the configuration for a ui

This is like the last one -- since we might deal with very good UIs, we
need to give them enough information for using all their abilities to
help us.

4. It should be very easy to make an object configurable.

This is very important -- the harder it is, the less it will be easy
to add *good* code to twisted. This is what may be the single most idiotic
thing in Zope (and DC is aware of it! and thinking of how to fix it!). Let's
learn from their mistakes: the less methods, the better. The more the
learning curve is gradual (not needing to learn a class/method/interface
before you need the functionality), the better.

OK, so what do we need to do about it?
Here's a rough proposition:

the configurable *interface*, which will be a class, but not a class
people should inherit from, will contain the following methods:

.getQuestions() --> return a dictionary: name of question, Question object
.getAnswer(name, answer) --> notify the application that an answer has been
                             given to a particular question
                             It can throw an InvalidAnswer exception with
                             a string for a reason. This is for 
                             application-level verification, and is discouraged.
.endAnswer() --> the "application" promises that no methods of the object
                 will be called between a series of .getAnswer()s and 
                 .endAnswer(). So, this means that if the UI got a bunch 
                 of answers, it will call .getAnswer() several times, and
                 then .endAnswer(). The UI will *check* for this method's
                 existance, and will not call it if it doesn't exist.

Question objects are meant to be open ended. 
They can contain a default.

Here is the general interface of the Question, that all objects conform
too:

.hasAnswer() --> boolean, whether the Question already contains an 
                 answer/default
.getValue() --> will only work if .hasAnswer() is true, returns the answer
.setValue(val) --> make .hasAnswer() true

Objects which can be created by the UI should have an __init__ which
can be called without arguments. If there is any initialization which
requires arguments, it should be done in endAnswer(). The UI also promises
not to call .endAnswer() for an object if there any questions which have
not been answered and do not have a default (.hasAnswer is false.)

Well, my proposal would not be complete if I didn't say what questions are
available. Keep in mind, though, that the set of questions is *open ended*.
That does not violate the light-and-lean guidelines, since a specific
Question class will only be used if the functionality is needed.

Without further ado:

class BooleanQuestion:
class IntQuestion: (can have .min and .max)
class FloatQuestion:
class StringQuestion: (can have .maxlength)
class LongStringQuestion: (same as above -- it's a hint to the ui)
class InterfaceQuestion: (specify interface, valid answers are objects)
class ArrayQuestion: (an array of the same kind of question)
class DictQuestion: (a dictionary mapping strings -> same kind of question)

example:

class Server: # note -- not inheriting from anything

    name = port = None

    def getQuestions(self):
        name = StringQuestion()
        if self.name is not None:
            name.setValue(self.name)
        port = IntQuestion()
        if self.port is not None:
            port.setValue(self.port)
        return {'port': port, 'name': name}

    def getAnswer(self, name, answer):
        # note: no need to use int(answer)
        # for port: an IntQuestion has an integer as a .getValue()
        setattr(self, name, answer)

Open questions:
* How do we connect classes to interfaces?
  Suggestion: each class has an attribute __implements__ containig a list
  of interfaces. Alternatively, an interface is really a list of 
  (callable, Questions) tuples, which are answered and passed to the callable.
  Modules with relevant classes register with the correct interface.
* How do we let objects created inside another object who their parent are?
  Suggestion: if an object from on Interface question has a method .setParent,
  call it with the parent as argument. This should be done by the Question
  object, so it knows how to call it for each object in a ListQuestion
* How do we let objects "title" a question?
  Suggestion: a question has a string argument on __init__ titling it.
* How do we allow the object to signify groupings of questions?
  Suggestion: this means the design is bad -- break down the object
  into smaller objects
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From carmstro at dynup.net  Fri May 11 12:36:24 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Fri, 11 May 2001 19:36:24 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <E14yDM3-0005wV-00@darjeeling>; from moshez@zadka.site.co.il on Fri, May 11, 2001 at 04:53:15PM +0300
Message-ID: <20010511123214.A3318@Fookidla.org>

[Ed.: I'm sending it on behalf of Chris since his mail server is down.
I have not edited the mail, and I will reply to it seperately]

Alright, I discussed this with moshe for a while on IRC, and here's my summary
of the discussion.

On Fri, May 11, 2001 at 04:53:15PM +0300, Moshe Zadka wrote:
> OK, let me first state some axioms:
> 
> 1. Everything should be configurable the same way, from within twisted.
> 
> Glyph has mentioned that he's not familiar with what's in bin/ anymore: 
> he just mktelnetserver, and configures from within the telnet server
> everything. This is what should happen, except not limited to the telnet
> server.

Yes, this is definitely good, and planned this way.

> 2. The configuration interface must not be ui specific.
> 
> This is obvious, right? Command line and web based aren't the only option.
> No reason why we can't implement a special purpose client/server for configuring
> twisted.

Again, this was planned. web UIs, reality UIs (you enter the magic box, there
is a web server floating here. You configure the web server.), GTK UIs are
all distant goals.

> 3. It should be easy to optimize the configuration for a ui
> 
> This is like the last one -- since we might deal with very good UIs, we
> need to give them enough information for using all their abilities to
> help us.
> 
> 4. It should be very easy to make an object configurable.
> 
> This is very important -- the harder it is, the less it will be easy
> to add *good* code to twisted. This is what may be the single most idiotic
> thing in Zope (and DC is aware of it! and thinking of how to fix it!). Let's
> learn from their mistakes: the less methods, the better. The more the
> learning curve is gradual (not needing to learn a class/method/interface
> before you need the functionality), the better.

I think this is also very important to end-user acceptance of TPy. If it's
got an easy-to-use and robust configurator, people will use it.

> OK, so what do we need to do about it?
> Here's a rough proposition:
> 
> the configurable *interface*, which will be a class, but not a class
> people should inherit from, will contain the following methods:
> 
> .getQuestions() --> return a dictionary: name of question, Question object

name change: getParamaters().

> .getAnswer(name, answer) --> notify the application that an answer has been
>                              given to a particular question
>                              It can throw an InvalidAnswer exception with
>                              a string for a reason. This is for 
>                              application-level verification, and is discouraged.

name change: setParamaters()
Also, throwing the exception is what's discouraged, not the actual use of the
method. :)

> .endAnswer() --> the "application" promises that no methods of the object
>                  will be called between a series of .getAnswer()s and 
>                  .endAnswer(). So, this means that if the UI got a bunch 
>                  of answers, it will call .getAnswer() several times, and
>                  then .endAnswer(). The UI will *check* for this method's
>                  existance, and will not call it if it doesn't exist.

name change: i'm not sure what, but endAnswer doesn't sound right.
What this is for is deferred calculation of answers. the not-calling-methods
thing needs to be thought about, so we don't have some weird bugs where TPy
goes completely haywire while configuring. (For instance, what if we're
configuring a web server through the web interface?)

> Question objects are meant to be open ended. 
> They can contain a default.
> 
> Here is the general interface of the Question, that all objects conform
> too:
> 
> .hasAnswer() --> boolean, whether the Question already contains an 
>                  answer/default
> .getValue() --> will only work if .hasAnswer() is true, returns the answer
> .setValue(val) --> make .hasAnswer() true
> 

name change: hasValue()?

> Objects which can be created by the UI should have an __init__ which
> can be called without arguments. If there is any initialization which
> requires arguments, it should be done in endAnswer(). The UI also promises
> not to call .endAnswer() for an object if there any questions which have
> not been answered and do not have a default (.hasAnswer is false.)

Ok, instead of __init__s that don't take arguments, we have klass.getInitArgs()
that is another set of questions that the user answers before the UI
instantiates the object (well, it'll have to be klass.__dict__['getInitArgs'](),
as glyph pointed out to me). Also, when we instantiate the object, we call
newObject.setParent(parent), as moshe talks about in the open questions at
the bottom of his mail.

> Well, my proposal would not be complete if I didn't say what questions are
> available. Keep in mind, though, that the set of questions is *open ended*.
> That does not violate the light-and-lean guidelines, since a specific
> Question class will only be used if the functionality is needed.
> 
> Without further ado:

name change for all of the following: *Parameter

> 
> class BooleanQuestion:
> class IntQuestion: (can have .min and .max)
> class FloatQuestion:
> class StringQuestion: (can have .maxlength)
> class LongStringQuestion: (same as above -- it's a hint to the ui)
> class InterfaceQuestion: (specify interface, valid answers are objects)
> class ArrayQuestion: (an array of the same kind of question)

moshe told me this was a thinko, so forget about array of questions :)

> class DictQuestion: (a dictionary mapping strings -> same kind of question)

I don't really get this one.


> example:
> 
> class Server: # note -- not inheriting from anything
> 
>     name = port = None
> 
>     def getQuestions(self):
>         name = StringQuestion()
>         if self.name is not None:
>             name.setValue(self.name)
>         port = IntQuestion()
>         if self.port is not None:
>             port.setValue(self.port)
>         return {'port': port, 'name': name}
> 
>     def getAnswer(self, name, answer):
>         # note: no need to use int(answer)
>         # for port: an IntQuestion has an integer as a .getValue()
>         setattr(self, name, answer)
> 
> Open questions:
> * How do we connect classes to interfaces?
>   Suggestion: each class has an attribute __implements__ containig a list
>   of interfaces. Alternatively, an interface is really a list of 
>   (callable, Questions) tuples, which are answered and passed to the callable.
>   Modules with relevant classes register with the correct interface.

I seem to remember some standardization of this that was proposed in a PEP.
Maybe we should use that standard for now, but of course just use our own
implementation of the implementation-checking stuff. (tongue twister, eh?)

> * How do we let objects created inside another object who their parent are?
>   Suggestion: if an object from on Interface question has a method .setParent,
>   call it with the parent as argument. This should be done by the Question
>   object, so it knows how to call it for each object in a ListQuestion

After thinking about this for a while, I decided it's a good idea. At first,
it seemed like an arbitrary fix to a problem, but when moshe brought up
how useful it would be when "moving" objects around.

> * How do we let objects "title" a question?
>   Suggestion: a question has a string argument on __init__ titling it.

that's simple enough.

> * How do we allow the object to signify groupings of questions?
>   Suggestion: this means the design is bad -- break down the object
>   into smaller objects

I'm not sure of my stance on this. I'll try to think of some examples and
discuss.


-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Fri May 11 12:49:17 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 11 May 2001 19:49:17 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <20010511123214.A3318@Fookidla.org>
References: <20010511123214.A3318@Fookidla.org>
Message-ID: <E14yG6P-0006FM-00@darjeeling>

On Fri, 11 May 2001 19:36:24 +0300, Chris Armstrong <carmstro at dynup.net> wrote:

<snipped agreement on the axioms>

> > .getAnswer(name, answer) --> notify the application that an answer has been
> >                              given to a particular question
> >                              It can throw an InvalidAnswer exception with
> >                              a string for a reason. This is for 
> >                              application-level verification, and is discouraged.
> 
> name change: setParamaters()

setParameter() sans the 's'. One call per parameter

> > .endAnswer() --> the "application" promises that no methods of the object
> >                  will be called between a series of .getAnswer()s and 
> >                  .endAnswer(). So, this means that if the UI got a bunch 
> >                  of answers, it will call .getAnswer() several times, and
> >                  then .endAnswer(). The UI will *check* for this method's
> >                  existance, and will not call it if it doesn't exist.
> 
> name change: i'm not sure what, but endAnswer doesn't sound right.
> What this is for is deferred calculation of answers. the not-calling-methods
> thing needs to be thought about, so we don't have some weird bugs where TPy
> goes completely haywire while configuring. (For instance, what if we're
> configuring a web server through the web interface?)

That's the classical example for why it's needed. Since the UI should
do something like that

for parameter in stuff_i_got:
    object.setParameter(...)
object.endParameters()

Then everything is fine.
That's a classical case of "if there's a doubt, there isn't a doubt": if the
UI is *not* sure it won't call other methods, it *should* call .endParameters()
It is *not* promised that there won't be multiple batches -- that's a QoI
issue.

> name change: [from .hasAnswer to] hasValue()?

Yep, definitely

> > Objects which can be created by the UI should have an __init__ which
> > can be called without arguments. If there is any initialization which
> > requires arguments, it should be done in endAnswer(). The UI also promises
> > not to call .endAnswer() for an object if there any questions which have
> > not been answered and do not have a default (.hasAnswer is false.)
> 
> Ok, instead of __init__s that don't take arguments, we have klass.getInitArgs()
> that is another set of questions that the user answers before the UI
> instantiates the object (well, it'll have to be klass.__dict__['getInitArgs'](),
> as glyph pointed out to me). 

No, we won't.
We'll have copy.copy(klass.initParameters). No need to make it a callable,
really.

> Also, when we instantiate the object, we call
> newObject.setParent(parent), as moshe talks about in the open questions at
> the bottom of his mail.

> name change for all of the following: *Parameter

Yes.

> > 
> > class BooleanQuestion:
> > class IntQuestion: (can have .min and .max)
> > class FloatQuestion:
> > class StringQuestion: (can have .maxlength)
> > class LongStringQuestion: (same as above -- it's a hint to the ui)
> > class InterfaceQuestion: (specify interface, valid answers are objects)
> > class ArrayQuestion: (an array of the same kind of question)
> 
> moshe told me this was a thinko, so forget about array of questions :)

I misunderstood radix. Let me clarify:
It's something like if you want to have a set of Servers in a selector:

ArrayParameter(InterfaceParameter(ServerInterface))

> > class DictQuestion: (a dictionary mapping strings -> same kind of question)
> 
> I don't really get this one.

Think of a web Resource which is a folder.

Then you can have

{'children': DictParameter(InterfaceParameter(WebResourceInterface)) }

[re __implements__]
> I seem to remember some standardization of this that was proposed in a PEP.
> Maybe we should use that standard for now, but of course just use our own
> implementation of the implementation-checking stuff. (tongue twister, eh?)

Python will not have *any* implementation of interface checking stuff.
Of course, we'll just take objects up on their __implements__ word,
not check through methods.

> > * How do we allow the object to signify groupings of questions?
> >   Suggestion: this means the design is bad -- break down the object
> >   into smaller objects
> 
> I'm not sure of my stance on this. I'll try to think of some examples and
> discuss.
 
I myself have misgivings on that. But maybe we can punt on it for now?
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Fri May 11 14:00:12 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 11 May 2001 21:00:12 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <E14yG6P-0006FM-00@darjeeling>
References: <E14yG6P-0006FM-00@darjeeling>, <20010511123214.A3318@Fookidla.org>
Message-ID: <E14yHD2-0006JM-00@darjeeling>

Thinking about how some UI for configuration would look like, namely command
line syntax, I have some rough sketch. I wrote this "as if" the configuration
interface I sketched earlier would actually exist. Note that the next UI
to come would force a refactoring to "general config ui utility functions"
and ui-specific functionality.

I hope this will concretize the discussion

First, some general words on how the ui will look like to the user:
the commands will be

> get <pickle file> <path>
> set <pickle file> <path> <string representation>
> array_add <pickle file> <path> <string representation>
> dict_add <pickle file> <path> <name> <string representation>

Wherever a parameter called "root" is mentioned, it will probably be
the pickle file. Note also that this is far for complete. And last
but not least, I didn't do the boring part of parsing the options
and dispatching to the functions -- fill this in from imagination.
Oh, and I obviously didn't test this wishful thinking code.

#command line configuration
def stringifyParameter(param):
    if isinstance(param, ArrayParameter):
        return "array of "+stringifyParameter(param.param)+'s'
    elif isinstance(param, DictParameter):
        return "folder of "+stringifyParameter(param.param)+'s'
    elif isinstance(param, StringParameter):
        return "string"
    elif isinstance(param, IntParameter):
        return "int"
    elif isinstance(param, InterfaceParameter):
        return param.interface.__name__

def convertString(type, s):
    if isinstance(type, ArrayParameter) or isinstance(type, DictParameter):
        raise ValueError("cannot set %s" % type.__class__.__name__)
    if isinstance(type, InterfaceParameter):
        obj = load(open(s))
        if type.interface not in obj.__implements__:
            raise ValueError(obj.__class__.__name__+" does not implement "+
                             type.__class__.__name__)
        return obj
    if isinstance(type, StringParameter):
        return s
    if isinstance(type, IntParameter):
        return int(s)
    raise ValueError("unrecognized type" % type.__class__.__name__)


def traverseObject(root, path):
    path = string.split(path, '.')
    name = path[-1]
    obj = root
    for part in path[:-1]:
        if isinstance(obj, ArrayParameter):
            obj = obj.getValue()[int(part)]
        elif isinstance(obj, DictParameter):
            obj = obj.getValue()[part]
        elif isinstance(obj, InterfaceParameter):
            obj = obj.getValue().getParameters()[part]
    param = obj.getParameters()[name]
    return param

def setOption(root, path, value):
    param = traverseObject(root, path)
    value = convertString(param, value)
    obj.setAnswer(name, value)
    if hasattr(obj, 'endAnswer'):
        obj.endAnswer()

def getOption(root, path):
    param = traverseObject(root, path)
    print stringifyParameter(param), param.getValue()

def appendToArray(root, path, value):
    param = traverseObject(root, path)
    assert isinstance(param, ArrayParameter)
    value = convertString(param.param, value)
    param.getValue().append(value)

def addToDict(root, path, name, value):
    param = traverseObject(root, path)
    assert isinstance(param, DictParameter)
    value = convertString(param.param, value)
    param.getValue()[name] = value
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From grolgh at online.no  Fri May 11 17:26:22 2001
From: grolgh at online.no (grolgh)
Date: Fri, 11 May 2001 23:26:22 +0200
Subject: [Twisted-Python] the magical port 0
Message-ID: <3B0098C9@epostleser.online.no>

Hello,

As you might know, binding to port 0, actually binds an unallocated port; but 
despite how useful this might be, twisted.net returns port 0 anyway.

The fix is easy, and that is to set port = skt.getsockname()[1] right after it 
has been binded.
I don't if this applies to win32, or any other platform, but I assume that it 
does.

I have not done this in CVS, but I hope someone with more insight into 
twisted.net could do it :)

phed
www.informative.f2s.com (be gone evil .zip-hating provider)





From glyph at twistedmatrix.com  Sat May 12 00:10:55 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Fri, 11 May 2001 23:10:55 -0500
Subject: [Twisted-Python] the magical port 0
In-Reply-To: <3B0098C9@epostleser.online.no>
References: <3B0098C9@epostleser.online.no>
Message-ID: <0105112310550B.17572@helix>

I looked at this, but I think the current approach is best.

Since servers are (optionally) persistent, the fact that server.port is 0 
tells you that the next time the server is brought in from a persistent 
store, it may be on a different port.

My suggestion for this application is to call through directly to 
server.socket.getsockname()[1] directly.

On Friday 11 May 2001 16:26, you wrote:
> Hello,
>
> As you might know, binding to port 0, actually binds an unallocated port;
> but despite how useful this might be, twisted.net returns port 0 anyway.
>
> The fix is easy, and that is to set port = skt.getsockname()[1] right after
> it has been binded.
> I don't if this applies to win32, or any other platform, but I assume that
> it does.
>
> I have not done this in CVS, but I hope someone with more insight into
> twisted.net could do it :)
>
> phed
> www.informative.f2s.com (be gone evil .zip-hating provider)
>
>
>
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Sat May 12 02:10:53 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sat, 12 May 2001 02:10:53 -0400
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <E14yG6P-0006FM-00@darjeeling>; from moshez@zadka.site.co.il on Fri, May 11, 2001 at 07:49:17PM +0300
References: <20010511123214.A3318@Fookidla.org> <E14yG6P-0006FM-00@darjeeling>
Message-ID: <20010512021053.A4013@Fookidla.org>

On Fri, May 11, 2001 at 07:49:17PM +0300, Moshe Zadka wrote:
> On Fri, 11 May 2001 19:36:24 +0300, Chris Armstrong <carmstro at dynup.net> wrote:
> > name change: setParamaters()
> setParameter() sans the 's'. One call per parameter

yes, that was a typo, I do know that there will be one call per parameter

> > goes completely haywire while configuring. (For instance, what if we're
> > configuring a web server through the web interface?)
> 
> That's the classical example for why it's needed. Since the UI should
> do something like that
> 
> for parameter in stuff_i_got:
>     object.setParameter(...)
> object.endParameters()
> 
> Then everything is fine.
> That's a classical case of "if there's a doubt, there isn't a doubt": if the
> UI is *not* sure it won't call other methods, it *should* call .endParameters()
> It is *not* promised that there won't be multiple batches -- that's a QoI
> issue.

Alright, I think I just misunderstood what you said about not executing
methods until endParameters() is called. I thought you meant the object
should be non-functional until endParamaters() is called. i realize now
how stupid of a thought that was. :)

> > instantiates the object (well, it'll have to be klass.__dict__['getInitArgs'](),
> > as glyph pointed out to me). 
> 
> No, we won't.
> We'll have copy.copy(klass.initParameters). No need to make it a callable,
> really.

Why? I don't understand. (I should make this [TM])

> > > class ArrayQuestion: (an array of the same kind of question)
> > 
> > moshe told me this was a thinko, so forget about array of questions :)
> 
> I misunderstood radix. Let me clarify:
> It's something like if you want to have a set of Servers in a selector:
> 
> ArrayParameter(InterfaceParameter(ServerInterface))

Uhh.. isn't that what ListParameter is for?

> Python will not have *any* implementation of interface checking stuff.
> Of course, we'll just take objects up on their __implements__ word,
> not check through methods.

Ok, I was thinking of PEP 0246.
(http://python.sourceforge.net/peps/pep-0246.html)

> > > * How do we allow the object to signify groupings of questions?
> > >   Suggestion: this means the design is bad -- break down the object
> > >   into smaller objects
> >
> > I'm not sure of my stance on this. I'll try to think of some examples and
> > discuss.
>
> I myself have misgivings on that. But maybe we can punt on it for now?

The only advantage I see of mutliple question sections (outside of one set
for instantiation and one for configuration) is a wizard-like interface,
and I'm not so sure that's good anyway. :)

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Sat May 12 03:03:34 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 12 May 2001 10:03:34 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <20010512021053.A4013@Fookidla.org>
References: <20010512021053.A4013@Fookidla.org>, <20010511123214.A3318@Fookidla.org> <E14yG6P-0006FM-00@darjeeling>
Message-ID: <E14yTR8-00073l-00@darjeeling>

On Sat, 12 May 2001 02:10:53 -0400, Chris Armstrong <carmstro at dynup.net> wrote:
 
> Alright, I think I just misunderstood what you said about not executing
> methods until endParameters() is called. I thought you meant the object
> should be non-functional until endParamaters() is called. i realize now
> how stupid of a thought that was. :)

Well, the object can afford to be non-functional until .endParameters()
is called -- after all, no methods will expose it.

> > No, we won't.
> > We'll have copy.copy(klass.initParameters). No need to make it a callable,
> > really.
> 
> Why? I don't understand. (I should make this [TM])

Because it will have a fixed template, which we then copy and change.

> Uhh.. isn't that what ListParameter is for?

There's no ListParameter, and it would be wrong to call it that.

> > Python will not have *any* implementation of interface checking stuff.
> > Of course, we'll just take objects up on their __implements__ word,
> > not check through methods.
> 
> Ok, I was thinking of PEP 0246.
> (http://python.sourceforge.net/peps/pep-0246.html)

Which is only about *specifying* interfaces -- not checking them

> The only advantage I see of mutliple question sections (outside of one set
> for instantiation and one for configuration) is a wizard-like interface,
> and I'm not so sure that's good anyway. :)

And it's hard too -- we won't implement it.
I'll take all this dialog and rewrite my original spec.
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May 12 03:32:25 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 12 May 2001 10:32:25 +0300
Subject: [Twisted-Python] Configuration, Final Spec
Message-ID: <E14yTt3-00078c-00@darjeeling>

Rewritten, standalone, spec

OK, let me first state some axioms:

1. Everything should be configurable the same way, from within twisted.

Glyph has mentioned that he's not familiar with what's in bin/ anymore:
he just mktelnetserver, and configures from within the telnet server
everything. This is what should happen, except not limited to the telnet
server.

2. The configuration interface must not be ui specific.

This is obvious, right? Command line and web based aren't the only option.
No reason why we can't implement a special purpose client/server for configurin
g
twisted.

3. It should be easy to optimize the configuration for a ui

This is like the last one -- since we might deal with very good UIs, we
need to give them enough information for using all their abilities to
help us.

4. It should be very easy to make an object configurable.

This is very important -- the harder it is, the less it will be easy
to add *good* code to twisted. This is what may be the single most idiotic
thing in Zope (and DC is aware of it! and thinking of how to fix it!). Let's
learn from their mistakes: the less methods, the better. The more the
learning curve is gradual (not needing to learn a class/method/interface
before you need the functionality), the better.

OK, so what do we need to do about it?
Here's a rough proposition:

the configurable *interface*, which will be a class, but not a class
people should inherit from, will contain the following methods:

.getParameters() --> return a dictionary: name of parameter, Parameter object
.setParameter(name, answer) --> notify the application that an answer has been
                             given to a particular question
                             It can throw an InvalidParameter exception with
                             a string for a reason. This is for
                             application-level verification. Note that 
                             application-level verification is discouraged.
.endParameters() --> the "application" promises that no methods of the object
                 will be called between a series of .setParameter()s and
                 .endParameters(). So, this means that if the UI got a bunch
                 of answers, it will call .setParameter() several times, and
                 then .endParameters(). The UI will *check* for this method's
                 existance, and will not call it if it doesn't exist.
.setParent(parent) --> if the object is created inside an InterfaceProperty
                       of some other object, module nested ArrayParameters
                       and DictParameters, .setParent will be called with
                       that object, *if it exists*.

Parameter objects are meant to be open ended.
They can contain a default.

Here is the general interface of the Question, that all objects conform
too:

.hasValue() --> boolean, whether the Parameter already contains an
                value
.getValue() --> will only work if .hasValue() is true, returns the answer
.setValue(val) --> make .hasValue() true
.title --> A string, the human-readable description of the property.

Objects which can be created by the UI should have an initParameters
attribute which should be a sequence of Parameters, which correspond
to the mandatory arguments of the __init__ method.

Well, my proposal would not be complete if I didn't say what parameters are
available. Keep in mind, though, that the set of parameters is *open ended*.
That does not violate the light-and-lean guidelines, since a specific
Parameter class will only be used if the functionality is needed.

Without further ado:

class BooleanParameter:
class IntParameter: (can have .min and .max)
class FloatParameter:
class StringParameter: (can have .maxlength)
class LongStringParameter: (same as above -- it's a hint to the ui)
class InterfaceParameter: (specify interface, valid answers are objects)
class ArrayParameter: (an array of the same kind of question)
class DictParameter: (a dictionary mapping strings -> same kind of question)

The constructor will always take a title as a first argument, and possibly
some more parameters if appropriate. I'm thinking of adding some generic 
methods, the most interesting one is traverse, which either returns
a Parameter or throws a ValueError("node parameter").

A class will be said to implement an interface if the interface class
is a member of the __implements__ attribute. We can refine it to saying
that the interface is a superclass of some member of __implements__:

def implements(klass, interface):
    for member in klass.__implements__:
        if issubclass(member, interface):
            return 1
    return 0

This leaves open the question of how classes register with the UI at all.
A possibly radical solution will be to have the UI scan through sys.modules,
and each class will be checked for the __implements__ attribute. A less
radical option is to have a register(klass) function which registers
it with the UI. register() can be used from within the module, if it is
an active participant, or from within an importing module.

example:

class Server: # note -- not inheriting from anything

    initParameters = (StringParameter("Server Name"), IntParameter("Port"))
    def __init__(self, name, port):
        self.name, self.port = name, port

    def getParameters(self):
        name = StringQuestion("Server Name")
        name.setValue(self.name)
        port = IntQuestion("Port")
        port.setValue(self.port)
        return {'port': port, 'name': name}

    def setParameter(self, name, answer):
        # note: no need to use int(answer)
        # for port: an IntQuestion has an integer as a .getValue()
        setattr(self, name, answer)

--
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Sat May 12 19:03:15 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sat, 12 May 2001 18:03:15 -0500
Subject: [Twisted-Python] Configuration, Final Spec
In-Reply-To: <E14yTt3-00078c-00@darjeeling>
References: <E14yTt3-00078c-00@darjeeling>
Message-ID: <0105121803150H.17572@helix>

On Saturday 12 May 2001 02:32, you wrote:
> Rewritten, standalone, spec

[ agreement with axioms ]

> OK, so what do we need to do about it?
> Here's a rough proposition:
>
> the configurable *interface*, which will be a class, but not a class
> people should inherit from, will contain the following methods:

IMHO, people *should* inherit from it, so that we can have some visibility on 
what implements it.  I agree that it should provide as little functionality 
as possible, however.

> .getParameters() --> return a dictionary: name of parameter, Parameter
> object .setParameter(name, answer) --> notify the application that an
> answer has been given to a particular question
>                              It can throw an InvalidParameter exception
> with a string for a reason. This is for
>                              application-level verification. Note that
>                              application-level verification is discouraged.
> .endParameters() --> the "application" promises that no methods of the
> object will be called between a series of .setParameter()s and
> .endParameters(). So, this means that if the UI got a bunch of answers, it
> will call .setParameter() several times, and then .endParameters(). The UI
> will *check* for this method's existance, and will not call it if it
> doesn't exist. .setParent(parent) --> if the object is created inside an
> InterfaceProperty of some other object, module nested ArrayParameters and
> DictParameters, .setParent will be called with that object, *if it exists*.

I don't understand this part of the design.

In my humble (but correct) opinion, it is *always* bad API design to force 
the caller to "promise" something.  (Sometimes, other design concerns 
mitigate this decision, but I don't see one here.  However, I have frequently 
joked about having a neon sign in my office, for design discussions, that 
says "IT IS NOT THE CALLER'S RESPONSIBILITY" in 10-foot-tall letters)

I would much rather see a .getParameters() -> dict / .setParameters(dict).  
It seems more symmetrical, and if you can "promise" that (A) setParameters 
may be called some number of times and (B) endParameters() will *always* be 
called afterwards, we can put that loop into the config side of the code.

Any reasons why it can't be done this way?

> Parameter objects are meant to be open ended.
> They can contain a default.
>
> Here is the general interface of the Question, that all objects conform
> too:

Of the "Parameter", I take it you mean? :)

> .hasValue() --> boolean, whether the Parameter already contains an
>                 value
> .getValue() --> will only work if .hasValue() is true, returns the answer
> .setValue(val) --> make .hasValue() true
> .title --> A string, the human-readable description of the property.
>
> Objects which can be created by the UI should have an initParameters
> attribute which should be a sequence of Parameters, which correspond
> to the mandatory arguments of the __init__ method.

Another interesting open question (although not one I'm sure this code has to 
address) is how to get the respective configuration interfaces to represent 
object identity.  (e.g. I want to mount the *same* web resource on /foo, on 
/bar)

> This leaves open the question of how classes register with the UI at all.
> A possibly radical solution will be to have the UI scan through
> sys.modules, and each class will be checked for the __implements__
> attribute. A less radical option is to have a register(klass) function
> which registers it with the UI. register() can be used from within the
> module, if it is an active participant, or from within an importing module.

There is a third option -- make Configurable a metaclass :)

However, I prefer the register(klass) way, both for clarity and efficiency.  
Explicit is better than implicit.

> example:
>
> class Server: # note -- not inheriting from anything
>
>     initParameters = (StringParameter("Server Name"), IntParameter("Port"))
>     def __init__(self, name, port):
>         self.name, self.port = name, port
>
>     def getParameters(self):
>         name = StringQuestion("Server Name")
>         name.setValue(self.name)
>         port = IntQuestion("Port")
>         port.setValue(self.port)
>         return {'port': port, 'name': name}
>
>     def setParameter(self, name, answer):
>         # note: no need to use int(answer)
>         # for port: an IntQuestion has an integer as a .getValue()
>         setattr(self, name, answer)

Your code has a bug in it, which is a good example of why I like to actually 
inherit from interfaces :).  You don't define "endParameters".

One more question -- why doesn't the Configurable interface class actually do 
some things, like data validation? It sounds like it'd be possible 
(isCorrectInput method on the Parameter classes, or somesuch...)

On the whole this looks like a good proposal, although I'm still not entirely 
sure what the final end-user experience of configuration will look like.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Sun May 13 01:31:32 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sun, 13 May 2001 08:31:32 +0300
Subject: [Twisted-Python] Configuration, Final Spec
In-Reply-To: <0105121803150H.17572@helix>
References: <0105121803150H.17572@helix>, <E14yTt3-00078c-00@darjeeling>
Message-ID: <E14yoTc-0008QP-00@darjeeling>

On Sat, 12 May 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:

> IMHO, people *should* inherit from it, so that we can have some visibility on 
> what implements it.  I agree that it should provide as little functionality 
> as possible, however.

No, people should put it in the __implements__ attribute.

> In my humble (but correct) opinion, it is *always* bad API design to force 
> the caller to "promise" something.  (Sometimes, other design concerns 
> mitigate this decision, but I don't see one here.  However, I have frequently 
> joked about having a neon sign in my office, for design discussions, that 
> says "IT IS NOT THE CALLER'S RESPONSIBILITY" in 10-foot-tall letters)
> 
> I would much rather see a .getParameters() -> dict / .setParameters(dict).  
> It seems more symmetrical, and if you can "promise" that (A) setParameters 
> may be called some number of times and (B) endParameters() will *always* be 
> called afterwards, we can put that loop into the config side of the code.
> 
> Any reasons why it can't be done this way?

Yes. In the usual case, where you don't need a .endParameters(), then the
code will be *much* clearer. You also missed the place where I say
".endParameters() will not be called if it doesn't exist".
See axiom 4 -- certainly

    def setParameter(self, name, value):
        setattr(self, name, value)

(which is the usual case)

Is much quicker then

    def setParameters(self, dict):
        for name, value in dict.items():
            setattr(self, name, value)

And another good reason -- this makes it much easier when doing 
application-level validation, to know what failed:

    # configuring RSA
    def setParameter(self, name, value):
        if not isPrime(value):
            raise ValueError("not prime")
        setattr(self, name, value)

> Another interesting open question (although not one I'm sure this code has to 
> address) is how to get the respective configuration interfaces to represent 
> object identity.  (e.g. I want to mount the *same* web resource on /foo, on 
> /bar)

This code isn't the one that should address it -- this is UI's responsibility.
Take *another* look at the way Zope does it.

> However, I prefer the register(klass) way, both for clarity and efficiency.  
> Explicit is better than implicit.

Indeed, I've decided I agree, for a different reason -- we do not want
spurious options for the user.

> Your code has a bug in it, which is a good example of why I like to actually 
> inherit from interfaces :).  You don't define "endParameters".

No it doesn't. It's permissible not to have .endParameters(), .setParent()
and .initParameters. The first two will not be called if they don't exist.

> One more question -- why doesn't the Configurable interface class actually do 
> some things, like data validation? It sounds like it'd be possible 
> (isCorrectInput method on the Parameter classes, or somesuch...)

I've thought about it, and decided against it -- since the UI needs to know
so much about the validation anyway, I prefer to putting the knowledge in
the UI. Sure, when we realized what is convinient for two UIs, we can have
some nice functions to help UIs -- but *outside* the Parameter class.
The classical example is that the UI might need to write the validation
code in JavaScript, for DHTML forms. Surely, a method written in Python
won't help...

> On the whole this looks like a good proposal, although I'm still not entirely 
> sure what the final end-user experience of configuration will look like.

Well, I've already gave an example of what it would look like with the
command line. Mutatis-mutandis, we can pretty much imagine how to translate
it into web-based. Of course, many options still remain, but I don't think
I care about UIs: I've specified enough information for the UI -- now
the UIs can compete. (We can have 10 different web-based UIs, and choose
among them)
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Sun May 13 03:54:56 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 13 May 2001 02:54:56 -0500
Subject: [Twisted-Python] Configuration, Final Spec
In-Reply-To: <E14yoTc-0008QP-00@darjeeling>
References: <0105121803150H.17572@helix> <E14yTt3-00078c-00@darjeeling> <E14yoTc-0008QP-00@darjeeling>
Message-ID: <0105130254560I.17572@helix>

On Sunday 13 May 2001 00:31, you wrote:
> On Sat, 12 May 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:
>
> > In my humble (but correct) opinion, it is *always* bad API design to
> > force the caller to "promise" something.  (Sometimes, other design
> > concerns mitigate this decision, but I don't see one here.  However, I
> > have frequently joked about having a neon sign in my office, for design
> > discussions, that says "IT IS NOT THE CALLER'S RESPONSIBILITY" in
> > 10-foot-tall letters)
> >
> > I would much rather see a .getParameters() -> dict /
> > .setParameters(dict). It seems more symmetrical, and if you can "promise"
> > that (A) setParameters may be called some number of times and (B)
> > endParameters() will *always* be called afterwards, we can put that loop
> > into the config side of the code.
> >
> > Any reasons why it can't be done this way?
>
> Yes. In the usual case, where you don't need a .endParameters(), then the
> code will be *much* clearer. You also missed the place where I say
> ".endParameters() will not be called if it doesn't exist".
> See axiom 4 -- certainly
[snipped examples]

But if you declare setParameters as a member of the Configurable class, then 
you don't have to write every UI to deal with the possible existance or 
non-existance of endParameters.

I am strongly opposed to any API which requires validation on the caller's 
behalf, for several reasons.  A practical concern is that using an RPC like 
gloop (e.g. an asynchronous one) it is impossible to tell if the object you 
are calling "has the attribute" endParameters or not.  You just have to call 
it and hope for the best.

If setParameters is defined in Configurable (the default implementation being 
a 2-line loop which does setParameter and then endParameter) then the extra 
work you're talking about for the configurable author can be avoided.

Having an API which requires a garuantee on the caller's behalf (the "caller" 
in this case being the UI) in a language where exceptions are as common as in 
Python makes handling of errors somewhat tricky.  After all, if setting a 
bunch of parameters is a non-atomic operation, then what do you do when one 
of your parameters is invalid, and raises an exception?  Does endParameters 
still have to get called?

It seems to me that setParameters is an atomic operation, which should 
validate, then test.  validateParameters could be a method as well, to do 
extra validation if parameters are dependant upon each other.  However, you 
can then clearly say that setParameter may never raise an exception: if the 
call to validateParameters succeeds, but setParameter fails, then you are in 
a known-to-be-inconsistent state and can display an appropriate error 
message.  However, if some of your setParameter calls raise exceptions and 
others do not, should endParameters be called anyway?  Does every UI need to 
handle exceptions itself?

> > Another interesting open question (although not one I'm sure this code
> > has to address) is how to get the respective configuration interfaces to
> > represent object identity.  (e.g. I want to mount the *same* web resource
> > on /foo, on /bar)
>
> This code isn't the one that should address it -- this is UI's
> responsibility. Take *another* look at the way Zope does it.

Zope confuses the hell out of me, both in the UI and the code :)... but I 
agree that this code probably shouldn't have to deal with that.

> > However, I prefer the register(klass) way, both for clarity and
> > efficiency. Explicit is better than implicit.
>
> Indeed, I've decided I agree, for a different reason -- we do not want
> spurious options for the user.

Yay, agreement! :)

> I've thought about it, and decided against it -- since the UI needs to know
> so much about the validation anyway, I prefer to putting the knowledge in
> the UI. Sure, when we realized what is convinient for two UIs, we can have
> some nice functions to help UIs -- but *outside* the Parameter class.
> The classical example is that the UI might need to write the validation
> code in JavaScript, for DHTML forms. Surely, a method written in Python
> won't help...

It's not to help out the UIs, it's to prevent setParameter from being called 
incorrectly.  There are several points of failure here --

 * the user typed something incorrect (presumably, your JavaScript example)
 * something bad came from the transport (WebUI.validate)
 * there is a bug in/bad data from the UI (Parameter.validate)
 * there is a bug in the configurable (exceptions caught by Configurable on 
setParameter)

and I think each one has to be treated differently.

> > On the whole this looks like a good proposal, although I'm still not
> > entirely sure what the final end-user experience of configuration will
> > look like.
>
> Well, I've already gave an example of what it would look like with the
> command line. Mutatis-mutandis, we can pretty much imagine how to translate
> it into web-based. Of course, many options still remain, but I don't think
> I care about UIs: I've specified enough information for the UI -- now
> the UIs can compete. (We can have 10 different web-based UIs, and choose
> among them)

It's for this reason that I'd like as much thought to be given to making UIs 
easy to write as to making Configurable objects easy to write.  I think I've 
changed my mind about Configurable not providing much functionality;  The 
Configurable and Parameter classes should encapsulate as much common behavior 
as possible.  (Although, I admit that there is probably not *much* common 
functionality.)  If they don't for some reason (and I am still not convinced 
any such reasons exist), the "config" module should at least contain it all, 
and as a core part of the interface, not as an additional utility library for 
GUIs.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Mon May 14 00:57:21 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 14 May 2001 07:57:21 +0300
Subject: [Twisted-Python] configuration usecases
Message-ID: <E14zAQ5-0003M2-00@darjeeling>

1. Selector
   -- a selector will have exactly one configurable parameter:
      an array of things which conform to the server interface,
      and an array of things which conform to the delayed interface
2. POP3 Server
   -- (optionally) a name, a port and something that conforms to the
   "dictionary" interface (.has_key, [], .get which are consistent)
   where the keys are strings, and the values are things that
   conform to the domain interface, and to the POP3 domain extensions
   (authenticateAPOPUser)
3. DomainDictionary
   -- contents, a mapping of strings to things conforming to the domain
   interface
4. MaildirDbmDomain
   -- add a user/password, remove a user, change a password
5. HTTPServer
   -- something conforming to the resource interface
6. FolderResource
   -- a mapping of strings to resources, and all those of DataResource
7. DataResource
   -- code (an int), headers (a mapping of strings to strings) and
   the data (a long-string)
8. TelnetServer
   -- username, password



-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Mon May 14 03:03:02 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Mon, 14 May 2001 02:03:02 -0500
Subject: [Twisted-Python] configuration usecases
In-Reply-To: <E14zAQ5-0003M2-00@darjeeling>
References: <E14zAQ5-0003M2-00@darjeeling>
Message-ID: <01051402030200.30472@helix>

On Sunday 13 May 2001 23:57, you wrote:
> 1. Selector
>    -- a selector will have exactly one configurable parameter:
>       an array of things which conform to the server interface,
>       and an array of things which conform to the delayed interface

I have to apologise for my design here.  We ought to be pickling (jellying? 
^_^) ServerSets, not Selectors.  (After all, a GTK selector is a different 
class than a regular selector, which means it's not possible to read in a 
selector to a GTK app, or merge two selectors together, without some 
hackery.)  Also, "Selector" conjures up images of Smalltalk and Objective C 
which are wholly inappropriate, as I was not aware of that use of terminology 
when I named it :)

So, to break down this use-case further, a user wishes to configure a set of 
servers.  They can perform one of 4 actions (keep in mind I'm thinking from 
the user/UI perspective, *not* the perspective of the actual config system 
code)

 * view a list of servers currently in the set
 * add a server to the set (this is a big one)
 * remove a server from the set
 * configure a server in that set

these correspond roughly to operations on dictionaries (assuming that 
ServerSets ; roughly,

--------
for servername, server in serverset.items():
    display(servername, server)
----
newServer = somehowCreateAServer()
servers[newServerName] = newServer
----
del servers[someServerName]
----
foo = servers[someServerName]
doConfiguration(foo)
--------


> 2. POP3 Server
>    -- (optionally) a name, a port and something that conforms to the
>    "dictionary" interface (.has_key, [], .get which are consistent)
>    where the keys are strings, and the values are things that
>    conform to the domain interface, and to the POP3 domain extensions
>    (authenticateAPOPUser)

I think that we're saying similiar things here, again -- dictionary 
operations.

> 3. DomainDictionary
>    -- contents, a mapping of strings to things conforming to the domain
>    interface

Again, a dictionary...

> 4. MaildirDbmDomain
>    -- add a user/password, remove a user, change a password

Looks similiar again, "change a password" being similiar to "configure a 
sub-element"... presumably when we have more kinds of users (e.g. the "run a 
shellscript" variety) this will be different.

Presumably a User is a username/password combo (changing the username may 
require some monkeying, since that's also the key that it's stored in the 
domain as); but may be arbitrarily complex, as users do more complex things 
(frex, a web-story-posting interface through email).

> 5. HTTPServer
>    -- something conforming to the resource interface

This again will probably need some restructuring.  Shouldn't inherit from 
TCPServer, etc.  So "add/remove a port to listen on" will probably be an 
additional case.

> 6. FolderResource
>    -- a mapping of strings to resources, and all those of DataResource

I don't see any reason why all of them have to be DataResources...?  "Any 
non-abstract subclass of Resource" seems more reasonable.

> 7. DataResource
>    -- code (an int), headers (a mapping of strings to strings) and
>    the data (a long-string)

I think we're missing FileResource. That encompasses a few other things (a 
mapping of file extensions to MIME-types and processor resources, for 
example), but again, that's just another hash of either strings or classes.

> 8. TelnetServer
>    -- username, password

Finally, a simple form interface, alone :)

Most of the things that we're talking about here have either an interface 
that specifies some attributes (e.g. a dictionary with a fixed set of string 
keys) or a dictionary which, as far as these cases are concerned, is always 
keyed by strings, and may have values which are either strings, classes, or 
instances of some fixed part of the inheritance (whether through __bases__ or 
__implements__) heirarchy, rooted at a particular class (or interface).

So, having contributed what I can to the discussion of use cases -- I don't 
see that the previous proposal solves this issue in an elegant way; it seems 
like all the things here that require a "dict" parameter are not well-served 
by the getParameters/setParameter interface; the app code will have to 
decompose a "set" of the DictParameter in question by doing a comparison of 
what was there before and what is there now, into a set of add/remove 
operations (in, I might add, indeterminate order).  Since most of both of our 
examples were these sorts of things, it doesn't seem well optimized for the 
common case; although I believe I'm missing something.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From grolgh at online.no  Mon May 14 07:44:38 2001
From: grolgh at online.no (Benjamin Bruheim)
Date: Mon, 14 May 2001 11:44:38 GMT
Subject: [Twisted-Python] userinfo, etc, for twisted.ftp
Message-ID: <jUsT.aNoTheR.mEsSaGe.iD.98984067820096@fi.mailreader.com>

Hepp,

twisted.ftp is now in an nearly usable state. There are some problems 
with
active ftp'ing (net.TCPClient does not exactly have the same interface
as net.TCPServer), but this is really an minor issue. And for those
who want to try it, use the bsd-ftp and remember to turn on binary
transfers! The client seems to modify the files to conform to ascii :)

ATM there is no auth'ing in twisted.ftp; and this is really the biggest
issue with it. So, I wonder, how should it perform auth? Where can it
find the homedir? And setting the access to the user?
Well, much of this information could be found in the sources already,
but I would like to know how much should be done unix-style or
twisted.style :)

phed



===================================================================
EASY and FREE access to your email anywhere: http://Mailreader.com/
===================================================================






From glyph at twistedmatrix.com  Mon May 14 14:18:53 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Mon, 14 May 2001 13:18:53 -0500
Subject: [Twisted-Python] ANN: The week ends, the week begins.
Message-ID: <01051413185300.30821@helix>

OUTER SPACE (AP) -- Broadcasting from his self-styled "satellite of fiery 
doom" in a superlunar orbit on Monday, Evil Overlord Glyph Lefkowitz declared 
that a new version of Twisted Python, 0.8.8, was ready for download.

In an interview, a bleary-eyed, haggard looking Glyph dismissed rumours that 
he had escaped to the orbital space-station in order to escape the rampaging 
mob of Twisted Python users angered over the uncharacteristically unstable 
state of the 0.8.5 and 6 releases, as well as those who had lost family 
members to Chief Reality Engineer Allen Short's so-called "bugfixing" spree.  
"Complete nonsense!", he quipped, "My fans are as loyal as ever."  Although, 
the wary Overlord was heard to inquire briefly after the interview about the 
status of the aforementioned rampaging mob.

Mr. Short was not available for comment.

----

In this release, you'll find better API documentation, an FTP server, and the 
new PB&J protocol/serialization suite.  (this the intended replacement for 
gloop, previously entitled `gloop2').  Go hit your favorite your url (that's 
http://twistedmatrix.com/, in case you forgot), and download some firey doom 
today! :)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Tue May  1 01:12:46 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 1 May 2001 02:12:46 -0500
Subject: [Twisted-Python] twisted.web split
In-Reply-To: <Pine.LNX.3.96.1010501001944.9748A-100000@bb3.betterbox.net>
References: <Pine.LNX.3.96.1010501001944.9748A-100000@bb3.betterbox.net>
Message-ID: <0105010212460A.10809@helix>

On Tuesday 01 May 2001 00:29, you wrote:
> How about splitting it into more files than that?

Maybe...

> It's a bit easier generally to navigate and isolate problems,

I disagree.  It's easiest if there is one module that you have to look 
through that contains as much as possible, since any decent editor will allow 
you to browse the classes in that file. (Any *tolerable* editor will at least 
let you do a regular-expression search).  Most modern computers can fit a 
1.5k file into main memory, even in a visual editor, so size requirements are 
specious.  Having a billion modules where classes _might_ live is 
considerably worse.

> reuse for other things,

I don't like reuse, and I hope to actively discourage it (I'll explain this 
more thoroughly at another time.  This is yet another essay in the works for 
me...).  If you're talking about *use*, well then, all that you're discussing 
about "easier" means "from twisted.web.server import File" or "from 
twisted.web.static import File".  I don't see any meaninful ease-of-use in 
the name distinction...

> and update things.

Since I have done approximately 90% of the updates to this project at this 
point, I just think I'll say "no" to that one ;)

> Maybe a file for CGI/epy code, a file for getting files and
> such, a file for generating automatic directory listings, etc.

Segregating things along meaningful module boundaries is a useful division 
though, because it provides a meaningful way to expand that functionality, so 
I'll think about this.  The categories you describe might actually be good 
(web.dynamic(CGI/epy)/web.static(Files/Directory Listings) frex).

> Just my suggestion (though I've only looked at Twisted Python for a few
> days now, so maybe that's not a good way to do it?)

Not a bad comment though, especially the last part.  Thanks.

Although I tend to be quite argumentative on this topic (baaaaad experiences 
with python packages on my last project at work), I'd really like to see 
active discussion of how to break apart burgeoning modules into packages; 
it's an unpleasant problem as I've seen it so far, but with some consistently 
applied strategy I'm sure it could be a good thing.  Given that 
code-harvesting seems to be my predominant "engineering" philosophy, I have a 
feeling that this sort of refactoring will be highly common on this project, 
especially in the near future (as each "core" module (web, reality, net) 
expands).

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Tue May  1 14:46:02 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Tue, 01 May 2001 23:46:02 +0300
Subject: [Twisted-Python] smtp server -- pre-alpha version, please comment on design
Message-ID: <E14uh22-0002yz-00@darjeeling>

Hi, all!
twisted.mail so far has not been coming along nicely. However,
I now have some code which when tested will finally bring us to the
point where we can have a working e-mail system.

Well, not really -- we'll still need to handle *sending* e-mail, which
isn't as easy async as you may think... :(

Let me say a few general words about the way it works:
I wanted to have the same seperation of responsibilities that brings
us seperate handler/server/protocol-transformer to continue onto actually
saving e-mails. Towards this end, I've made the server responsible for
managing the list of domains, each of which is an object which can check
if it wants to accepts for certain localparts, and to save the e-mail.
This should bring us a higher level of testability, since we can have
dummy domains which just remember the e-mail messages saved, and then
we can bombard the handler with .handleData from us, and so on.

But, off to a better life and so on, here is the code for the pre-alpha
SMTP server:

from twisted.protocols import smtp

class VirtualSMTPHandler(smtp.SMTPHandler):

    seq = 0

    def validateTo(self, helo, destination):
        try:
            domain = string.split(destination, '@', 1)[1]
        except IndexError:
            return 0
        if not self.handler.server.domains.has_key(domain):
            return 0
        if not self.handler.server.domains[domain].exists(user):
            return 0
        return 1

    def handleMessage(self, helo, origin, recipients, message):
        for recipient in recipients:
            user, domain = string.split(destination, '@', 1)
            self.handler.server.domains[domain].save_message(user, message)


class SMTPNetHandler(net.GenericHandler):

    handler = None

    def handleData(self, data):
        if self.handler is None:
            self.handler = VirtualMaildirSMTPHandler(self)
        self.handler.handleData(data)

    def connectionLost(self, why):
        self.handler = None
        net.GenericHandler.connectionLost(self, why)


class VirtualSMTPServer(net.GenericServer):

    handler = SMTPNetHandler

    def __init__(self, *args, **kw):
        apply(net.GenericServer.__init__, (self,)+args, kw)
        self.domains = {}

    def addDomain(self, name, domain):
        self.domains[name] = domain



n = 0

class AbstractMaildirDomain:

    def __init__(self, root):
        self.root = root

    def user_directory(self, user):
        return None

    def exists(self, name):
        return self.user_directory(user) is not None

    def save_message(self, name, message):
        dir = self.user_directory(user)
        name = self._generateMaildirName() 
        filename = os.path.join(dir, 'new', name)
        fp = open(filename, 'w')
        try:
            fp.write(message)
        finally:
            fp.close()

    def _generateMaildirName(self):
        global n
        t = str(int(time.time()))
        s = socket.gethostname()
        p = os.getpid()
        n = n+1
        return '%s.%s_%s.%s' % (t, p, n, s)


class BounceDomain:

    def exists(self, name):
        return 0


class DirectoryExistanceMaildirDomain(AbstractMaildirDomain):

    def user_directory(self, name):
	dir = os.path.join(self.root, name)):
        if os.path.isdir(dir):
            return dir


class PostmasterMaildirDomain(AbstractMaildirDomain):

    def user_directory(self, name):
	dir = os.path.join(self.root, name)):
        if os.path.isdir(dir):
            return dir
        return os.path.join(self.root, 'postmaster')

# This wasn't in the original code, but is a nice example:

class SubdomainManager:

    def __init__(self, domains={}):
        self.domains = {}
        self.domains.update(domains)

    def addDomain(self, name, domain):
        self.domains[name] = domain

    def exists(self, user):
        if not '%' in user:
             return 0
        localpart, remote = string.split(user, '%', 1)
        if not self.domains.has_key(remote):
             return 0
        if not self.domains[remote].exists(localpart):
             return 0
        return 1

    def save_message(self, name, message):
        localpart, remote = string.split(user, '%', 1)
        return self.domains[remote].save_message(localpart, message)
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Wed May  2 03:23:44 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Wed, 02 May 2001 12:23:44 +0300
Subject: [Twisted-Python] <homer>Oooh, it's good news</homer>
Message-ID: <E14usrI-0004Dl-00@darjeeling>

1. All .protocols that I wrote from scratch have tests in test_twisted.
   .irc and .telnet are waiting for glyph.
2. twisted.pop3 now uses the POP3 protocol.
3. twisted.smtp now has rudimentary unit tests.

I think that finishes the twisted.mail goals for 0.8.5
By 0.9 I hope to have enough to support so you can just issue
a 

bin/mkmailsystem <root>

And know that you have a mail system that does not go outside the root,
and manages the mail. With some luck, maybe I'll even be able to add a
gloop server which integrates with a gloop-to-web gateway to have a web
interface for configuring domains. Anyone who did qmail knows what I'm
talking about -- every postmaster can go in, add users, remove users,
define policies, etc. That's probably post-0.9, though...

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From j.her at t-online.de  Wed May  2 14:18:34 2001
From: j.her at t-online.de (Juergen Hermann)
Date: Wed, 02 May 2001 22:18:34 +0200
Subject: [Twisted-Python] Docs
Message-ID: <14v33l-1i20ECC@fwd00.sul.t-online.com>

Glyph asked for the standard rant about using XML:

 - you can use the same set of source files to generate quite different
outputs (html, rdf, latex, paper, pdf, etc.), and the tools for this
come for free (linux, fbsd, etc. doco projects all use docbook)

 - you can have differing styles with the same output medium, compare
t
URLs:

	http://4suite.org/documents/4Suite/TODO

	http://twistedmatrix.com/users/jh.twistd/python/moin.cgi/DocBook
Test

 - docbook is a STANDARD way for SEMANTIC computer manual markup, i.e.
what you have to learn you can use elsewhere, including your resum

 - all tools are available for python (guess what the above tw url is
generated with)

'nuf said.





From carmstro at dynup.net  Wed May  2 19:39:29 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Wed, 2 May 2001 21:39:29 -0400
Subject: [Twisted-Python] <homer>Oooh, it's good news</homer>
In-Reply-To: <E14usrI-0004Dl-00@darjeeling>; from moshez@zadka.site.co.il on Wed, May 02, 2001 at 12:23:44PM +0300
References: <E14usrI-0004Dl-00@darjeeling>
Message-ID: <20010502213929.A896@Fookidla.org>

On Wed, May 02, 2001 at 12:23:44PM +0300, Moshe Zadka wrote:
> 1. All .protocols that I wrote from scratch have tests in test_twisted.
>    .irc and .telnet are waiting for glyph.
> 2. twisted.pop3 now uses the POP3 protocol.
> 3. twisted.smtp now has rudimentary unit tests.
> 
> I think that finishes the twisted.mail goals for 0.8.5
> By 0.9 I hope to have enough to support so you can just issue
> a 
> 
> bin/mkmailsystem <root>
> 
> And know that you have a mail system that does not go outside the root,
> and manages the mail. With some luck, maybe I'll even be able to add a
> gloop server which integrates with a gloop-to-web gateway to have a web
> interface for configuring domains. Anyone who did qmail knows what I'm
> talking about -- every postmaster can go in, add users, remove users,
> define policies, etc. That's probably post-0.9, though...

You don't need to write a gloop-to-web gateway for a config interface - I'm
already working on a configuration interface. All you'll have to do is define
some standard functions in the classes that you want to be configurable and
it will be configurable for any UI that's implemented (currently only working
on web, but a reality configurator is something that I'm looking forward
to as well).


-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Thu May  3 01:53:00 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Thu, 3 May 2001 10:53:00 +0300
Subject: [Twisted-Python] SMTP Client Prototype
Message-ID: <200105030753.KAA01647@jabotinsky.lerner.co.il>

Hi!
Most of you already know how obsessed I am with e-mail...
Here is the latest thing -- a prototype for an SMTP client.
Later I just want to have an OutgoingQueue domain which can
be used to relay mail. The first stage, which I think is doable
by 0.9, is to have so-called smart host capability -- this would
save us the trouble of going after MX records ourselves, and 
still leave us with something very functional. 

SMTP_CODE = re.compile('(?P<code>\d\d\d)(?P<continuation>[- ])')

DO_HELO, DO_FROM, DO_TO, DO_DATA = range(3) 

class SMTPClientHandler(basic.LineReceiver):

    mode = DO_HELO
    hostname = 'localhost'
    lastCommand = None


    def handleLine(self, line):
        m = SMTP_CODE.match(line)
        if not m:
            raise SMTPError
        if m.groupdict()['continuation'] == ' ':
           self.handleCode(int(m.groupdict()['code']))


    def handleResponse(self, code):
        if self.lastCommand is None:
            if code != 250:
                self.loseConnection()
                return 0
        elif self.lastCommand == 'TO'
            if (code/100) == 2:
                self.successfulTo.append(self.lastTo)
            self.lastTo = None
        elif self.lastCommand == 'DATA':
            if code != 354:
                self.failMessage()
                self.mode = DO_FROM
        elif self.lastCommand == 'DID_DATA':
            if (code/100) == 2:
                self.doneMessage(self.successfulTo)
            else:
                self.failMessage()
            del self.successfulTo
        elif self.lastCommand == 'FROM':
            if (code/100) != 2:
                self.failMessage()
                self.mode = DO_FROM
        elif self.lastCommand == 'HELO':
            self.loseConnection()
            return 0
        return 1


    def handleCode(self, code):
        if not self.handleResponse(code):
            return
        if self.mode is DO_HELO:
            self.handler.write('HELO %s\r\n' % self.hostname)
            self.lastCommand = 'HELO'
        elif self.mode is DO_FROM:
            message = self.getActiveMessage()
            if message is None:
                return self.loseConnection()
            from_ = message.getFrom()
            self.mode = DO_TO
            self.recipients = message.getRecipients()
            self.sucessfulTo = []
            self.handler.write('MAIL FROM:<%s>\r\n' % from_)
            self.lastCommand = 'FROM'
        elif self.mode is DO_TO:
            if not self.recipients:
                self.lastCommand = 'DATA'
                self.handler.write('DATA\r\n')
            else:
                recipient = self.recipients.pop()
                self.lastCommand = 'TO'
                self.lastTo = recipient
                self.handler.write('RCPT TO:<%s>' % recipient)
        elif self.mode is DO_DATA:
             self.lastCommand = 'DID_DATA'
             self.sendMessage()




From moshez at zadka.site.co.il  Thu May  3 10:48:49 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Thu, 03 May 2001 19:48:49 +0300
Subject: [Twisted-Python] <homer>Oooh, it's good news</homer>
In-Reply-To: <20010502213929.A896@Fookidla.org>
References: <20010502213929.A896@Fookidla.org>, <E14usrI-0004Dl-00@darjeeling>
Message-ID: <E14vMHZ-0006jb-00@darjeeling>

On Wed, 2 May 2001 21:39:29 -0400, Chris Armstrong <carmstro at dynup.net> wrote:
 
> You don't need to write a gloop-to-web gateway for a config interface - I'm
> already working on a configuration interface. All you'll have to do is define
> some standard functions in the classes that you want to be configurable and
> it will be configurable for any UI that's implemented 

Sounds cool. Try to look how Zope does it, and take the good parts, and
throw away the bad parts. For example, I would like a 

.generateQuestions() --> Return a ConfigurationQuestions object.
.acceptAnswers(answers) --> Accept an ConfigurationAnswers object, and 
                            configure yourself.

Also, you probably also want to consider security -- e.g., I'd like to
have hierarchical permissions, so the site-admin can configure any domain,
but a postmaster for a certain domain can have permissions for a specific
domain. I don't mind dealing with security on my own, though, e.g.,
have methods

.acceptCredentials(name, password) --> Return a unique id, which
                                       is sent back with the answers.

> (currently only working
> on web, but a reality configurator is something that I'm looking forward
> to as well).

Cool. You mean, like, walk up to the dragon and tell him the password
to get inside the "configuration room"? ;-) 
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Fri May  4 09:57:22 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 04 May 2001 18:57:22 +0300
Subject: [Twisted-Python] mail support
Message-ID: <E14vhxK-0008UJ-00@darjeeling>

With the latest CVS version, we have passable SMTP/POP3 support.
If you want to use it, here's a short example:

http://moshez.org/mail.tgz

Unpack this in your toplevel TwistedPython directory.
It will create a file bin/mksmtpserver and a directory test.
Run "bin/mksmtpserver test"
And then run the resulting mail.spl
It will have an SMTP server on port 2000 which accepts mails only
for moshez at exmple.com. moshez's password is "moshez", and if you
connect to port 2001 via POP3 (only APOP auth is supported currently)
you will be able to retrieve those messages.
Naturally, this is a rough proof-of-concept currently... ;-)

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May  5 02:12:32 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 05 May 2001 11:12:32 +0300
Subject: [Twisted-Python] Mail has been refactored...again ;-)
Message-ID: <E14vxB2-00010Q-00@darjeeling>

Yes, I've finally gone after the dreaded mail refactoring. 
twisted.smtp and twisted.pop3 are no more, and in fact the whole SMTP/POP3
support is about 8 lines of that file. Most of the file is about *mail*
as a concept. Not that SMTP and POP3 concepts don't show through -- that
would be useless abstraction. E.g., domains understand that there's
a concept of challenge/response authentication for POP3, and that
SMTP first checks for a user's existance and then asks to save a message
for the user. I expect domains will grow support for more and more mail
concepts -- but that's cool.

The interesting part of bin/mksmtpserver (wrong name) is now:

domain = mail.MaildirDirdbmDomain(rootdir)
s = net.Selector()
t = mail.VirtualSMTPServer(smtp_portno, s)
t.domains['example.com'] = domain
t = mail.VirtualPOP3Server(pop_portno, s)
t.domains[''] = domain
dump(s, open("mail.spl",'wb'))

The interesting part is to note how the *same* domain is used both as 
SMTP incoming domain and as a place to pull out POP3 from. This really
should do wonders for ease of configuration.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May  5 04:41:52 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 05 May 2001 13:41:52 +0300
Subject: [Twisted-Python] Python is just Too Easy
Message-ID: <E14vzVY-0001Fs-00@darjeeling>

I know I continually promised that 0.8.5 will be the "hard to configure but
working SMTP/POP3 servers". Well, sorry...
I've checked in a nifty little utility called bin/mkmailserver
Unfortunately, there's no documentation yet, so here's a rough
explanation on how to use it:

use 
bin/mkmailserver create <smtp port> <pop3 port>

And you'll have a mail.spl which always answers "I don't know what
you're talking about".

To add support for a domain, run

bin/mkmailserver domain <smtp name> <pop3 name> <root dir>

What this means is that if you want to have a server that handles mail
for "example.com", but when pulling it via POP3 you just want to specify
the local part, use

bin/mkmailserver domain example.com '' <some directory>

The directory should exist and be empty, BTW.

Now you have a user-less domain -- so, it will still answer "I don't
know who that user is, sorry". Add a user using

bin/mkmailserver <pop3 domain> <user> <password>

Suppose that I want to add glyph to the POP3 domain above, I'll run

bin/mkmailserver '' glyph s3kr1t

Now, connecting to the SMTP server and sending mail to glyph at example.com,
it will be saved in the directory. If glyph then conencts to the POP3
server and authenticates (via APOP only!) with "s3kr1t",  then he'll
be able to retrieve that mail.

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May  5 06:31:01 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 05 May 2001 15:31:01 +0300
Subject: [Twisted-Python] Brown-paperbag Bug in Mail Fixed
Message-ID: <E14w1DB-0001QE-00@darjeeling>

In conclusion, now it works with 3rd parties which implement
APOP (namely, Python's poplib).
Yay!

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Sun May  6 20:43:28 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 6 May 2001 21:43:28 -0500
Subject: [Twisted-Python] No Release Today
Message-ID: <01050621432803.00457@helix>

In my final round of testing 0.8.5 for release, I discovered some nasty 
release-critical bugs in moshe's refactoring of twisted.web; I'm surprised I 
didn't uncover these when I initially looked at it, but I couldn't do a 
release today with the code in such a half-working state.

Since I fixed it in my CVS tree, where most of the names of .net and related 
classes are different, I need to do some more stress testing; this shouldn't 
delay the release longer than tuesday; hopefully it'll only delay it one day.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Tue May  8 05:41:32 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 8 May 2001 06:41:32 -0500
Subject: [Twisted-Python] Remember: slower pizza's more luscious.
Message-ID: <01050806413204.00457@helix>

AUSTIN (AP) -- Twisted Matrix Laboratories today unveiled the 
much-anticipated and much-delayed most recent iteration of their "Twisted 
Python" product suite.  Equipped with more internet and more sticks than ever 
before, the power to destroy the sun, and a mail server, this release will 
"pose a significant threat to our competition, as soon as we figure out who 
we're competing with and for what", according to Evil Overlord Glyph 
Lefkowitz.

Despite the terrifying power and grace that this version exhibits, plans at 
the matrix's center are only to accelerate the pace of development. Chief 
Reality Engineer Allen Short commented, "By the time we reach our goals for 
version 1.0.0, the Illuminati -- one of our many `enterprise support' clients 
-- will be able to use this software to [censored] the [censored] with enough 
[censored] to [censored]!  Can you imagine that?"

Information about this software and twisted matrix enterprises, as well as 
the most recent version of the source code, is available at 

	http://twistedmatrix.com/

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |fnord] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From glyph at twistedmatrix.com  Tue May  8 17:52:41 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Tue, 8 May 2001 18:52:41 -0500
Subject: [Twisted-Python] Another brown paper bug release.
Message-ID: <01050818524100.17572@helix>

I just put out 0.8.7, a bugfix release for .6, which was leaking resources 
until the webserver crashed, for a second time (while the release was on 
freshmeat's front page :-\).

There are still a number of known problems, which continue to baffle me:

twisted.protocols.http is buggy, especially _parse_command.  I don't know 
why, yet: it *looks* right...  There regular tracebacks in 
/var/www/twistd.log, and I'm pretty sure it's not because of a proliferation 
of buggy HTTP clients.  These didn't appear before.

POST doesn't work if you're in germany.  Nobody can see this problem except 
for Jrgen, and then only to twistedmatrix.com; however, I think that it's a 
real bug.  I am vaguely suspicious that this has something to do with 
protocols.basic.LineReceiver prematurely closing the process's connection, 
but I have absolutely *no* idea why.  CGIs work flawlessly for me, both GET 
and POST, and I've constructed some pretty pathological tests.

This whole incident indicates the need for a better testing procedure; now 
that people actually rely on twistedmatrix.com to do stuff, I think that the 
release process should take a few days in order to ensure that *all* aspects 
of the code are tested.  Proposals for something more formal will be gladly 
accepted :)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From j.her at t-online.de  Tue May  8 18:30:05 2001
From: j.her at t-online.de (Juergen Hermann)
Date: Wed, 09 May 2001 02:30:05 +0200
Subject: [Twisted-Python] http.py
Message-ID: <14xHqY-1UPo5AC@fwd00.sul.t-online.com>

class HTTPHandler(basic.LineReceiver):

    __length = 0
    __header = ''
    __first_line = 1

    def _parse_command(self, command):
        parts = string.split(command)
        if len(parts)<3:
            parts.append('HTTP/0.9') # isn't backwards compat great!
        if len(parts) != 3:
            self.sendError(405, 'Bad command')
            raise ValueError(str(parts))
        return parts

    def sendStatus(self, code, resp=''):
        self.transport.write('HTTP/1.0 %s %s\r\n' % (code, resp))

    def sendHeader(self, name, value):
        self.transport.write('%s: %s\r\n' % (name, value))

    def endHeaders(self):
        self.transport.write('\r\n')

    def sendError(self, code, resp=''):
        self.sendStatus(code, resp)
        self.endHeaders()

    def lineReceived(self, line):
        if self.__first_line:
            self.__first_line = 0
            command, request, version = self._parse_command(line)
            self.handleCommand(command, request, version)
            if version == 'HTTP/0.9':
                self.handleEndHeaders()
                self.callHandleEndContent()
        elif line == '':
            if self.__header:
                self.callHandleHeader(self.__header)
            self.__header = ''
            self.handleEndHeaders()
            if self.__length == 0:
                self.callHandleEndContent()
            else:
                self.setRawMode()
        elif line[0] in ' \t':
            self.__header = self.__header+'\n'+line
        else:
            if self.__header:
            	self.callHandleHeader(self.__header)
            self.__header = line


    def callHandleHeader(self, line):
        """Do pre-processing (for content-length) and then call
handleHeader
        for one header line."""
        assert line
        if string.find(string.lower(line), 'content-length: ') == 0:
            self.__length = int(string.strip(string.split(line, ':',
1)[1]))
        self.handleHeader(line)


    def callHandleEndContent(self):
        self.__first_line = 1
>>> be paranoid! and rawDataReceived will leave this != 0 in some cases!
        self.__length = 0
        self.__header = ''
<<<
        self.handleEndContent()


>>> the logic here is pretty fucked, if you ask me
>>> what if we send more bytes than specified in c-length?
>>> note that a post has exactly the speciality of a c-l != 0
>>> a get has not c-l or a cl of 0!
>>> is the setlinemode for keep-alive?
>>> if not, some "print 'extraneous bytes in request'" would be better

    def rawDataReceived(self, data):
        if len(data) < self.__length:
            self.handleContentChunk(data)
            self.__length = self.__length - len(data)
        else:
            self.handleContentChunk(data[:self.__length])
            self.callHandleEndContent()
>>> !!!
				# only pass NONEMPTY strings on
				if len(data) > self.__length:
                self.setLineMode(data[self.__length:])









From carmstro at dynup.net  Tue May  8 20:26:31 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Tue, 8 May 2001 22:26:31 -0400
Subject: [Twisted-Python] Another brown paper bug release.
In-Reply-To: <01050818524100.17572@helix>; from glyph@twistedmatrix.com on Tue, May 08, 2001 at 06:52:41PM -0500
References: <01050818524100.17572@helix>
Message-ID: <20010508222631.A824@Fookidla.org>

I think one good real-world test would be to actually run the frozen code
on twistedmatrix.com for a day before releasing. This would of course only
be a supplement to other harder tests, but as this incident shows, it would
be a useful one.

On Tue, May 08, 2001 at 06:52:41PM -0500, Glyph Lefkowitz wrote:
> This whole incident indicates the need for a better testing procedure; now 
> that people actually rely on twistedmatrix.com to do stuff, I think that the 
> release process should take a few days in order to ensure that *all* aspects 
> of the code are tested.  Proposals for something more formal will be gladly 
> accepted :)

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro




From moshez at zadka.site.co.il  Tue May  8 23:19:44 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Wed, 09 May 2001 08:19:44 +0300
Subject: [Twisted-Python] Another brown paper bug release.
In-Reply-To: <01050818524100.17572@helix>
References: <01050818524100.17572@helix>
Message-ID: <E14xMO0-0000gC-00@darjeeling>

On Tue, 8 May 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:

> This whole incident indicates the need for a better testing procedure; now 
> that people actually rely on twistedmatrix.com to do stuff, I think that the 
> release process should take a few days in order to ensure that *all* aspects 
> of the code are tested.  Proposals for something more formal will be gladly 
> accepted :)

Random note: web.Resource and friends and web.Request do not rely on an
internet connection: they rely on a handler which has a .server with some
properties and some other attributes. Creating such a handler is no problem
if we start from FileWrapper, add attributes, and create a server and
attach it to the handler ourselves.

So any *recorded and analysed* bug should be able to quickly become a test
case.
 
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Wed May  9 02:16:09 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Wed, 9 May 2001 03:16:09 -0500
Subject: [Twisted-Python] Another brown paper bug release.
In-Reply-To: <E14xMO0-0000gC-00@darjeeling>
References: <01050818524100.17572@helix> <E14xMO0-0000gC-00@darjeeling>
Message-ID: <01050903160901.17572@helix>

On Wednesday 09 May 2001 00:19, you wrote:

> Random note: web.Resource and friends and web.Request do not rely on an
> internet connection: they rely on a handler which has a .server with some
> properties and some other attributes. Creating such a handler is no problem
> if we start from FileWrapper, add attributes, and create a server and
> attach it to the handler ourselves.
>
> So any *recorded and analysed* bug should be able to quickly become a test
> case.

While this is true in theory, there are many practical concerns that can't be 
simulated by an automatic test case; the one outstanding bug is one of these. 
 Since twisted.web relies on external processes -- for server distribution, 
for CGI scripts -- race conditions may arise that are impossible to unit 
test.  So, we need some functional testing as well, to make sure that those 
sorts of conditions don't arise.

If anyone else can think of a way to get fork() into a unit test, I'd like to 
hear about it :).  But, even more than that, I am frequently surprised when I 
try to run "working" code on Windows or Jython and have it crash due to some 
undocumented incompatibility (or even a documented one that I just haven't 
read about).

I'm a big proponent of automated testing, though, so I'd love to be wrong.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From j.her at t-online.de  Wed May  9 18:47:56 2001
From: j.her at t-online.de (Juergen Hermann)
Date: Thu, 10 May 2001 02:47:56 +0200
Subject: [Twisted-Python] Handling of spurious \r\n
Message-ID: <14xebN-1O9o4eC@fwd00.sul.t-online.com>

glyph,

I changed the fix to ignore an empty line at the start of a http
request, as you suggested. At most ONE such line is ignored. And I
extended the test case with such a request.

Ciao, Jrgen






From grolgh at online.no  Thu May 10 13:02:37 2001
From: grolgh at online.no (grolgh)
Date: Thu, 10 May 2001 21:02:37 +0200
Subject: [Twisted-Python] neverending connection
Message-ID: <3AFC7DB2@epostleser.online.no>

Hello twisted.minions :)

This is my first mail on tp-ml; hello! I'm currently working on twisted.ftp 
and it's about 30% into acceptable working state. To hack it you need to press 
enter twice :) But I've run into a known problem.

I just noticed that TCPServer.loseConnection never trigs 
TCPServer.connectionLost. I think this is the famous 
never-ending-connection-bug, and I think the bug has its origin in 
selectable.doWrite.

I'll here present my current findings with it. Note that doSelect will run its 
selectable.connectionLost() if selectable's doRead or doWrite returns anything 
non-zero.
 
I'll take it step by step.
A call to loseConnection, will set __reap
Afterwards, __reap appears in doWrite which will write out its buffer and 
return CONNECTION_DONE
doSelect terminates the connection

Well, if we take a closer look at doWrite we find that it has several layers 
of if's before a CONNECTION_DONE is returned. Especially "if not self.unsent"! 
:/

Well, hope anyone finds this useful; and squash that horrible thing out. :)





From moshez at zadka.site.co.il  Fri May 11 07:53:15 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 11 May 2001 16:53:15 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
Message-ID: <E14yDM3-0005wV-00@darjeeling>

OK, let me first state some axioms:

1. Everything should be configurable the same way, from within twisted.

Glyph has mentioned that he's not familiar with what's in bin/ anymore: 
he just mktelnetserver, and configures from within the telnet server
everything. This is what should happen, except not limited to the telnet
server.

2. The configuration interface must not be ui specific.

This is obvious, right? Command line and web based aren't the only option.
No reason why we can't implement a special purpose client/server for configuring
twisted.

3. It should be easy to optimize the configuration for a ui

This is like the last one -- since we might deal with very good UIs, we
need to give them enough information for using all their abilities to
help us.

4. It should be very easy to make an object configurable.

This is very important -- the harder it is, the less it will be easy
to add *good* code to twisted. This is what may be the single most idiotic
thing in Zope (and DC is aware of it! and thinking of how to fix it!). Let's
learn from their mistakes: the less methods, the better. The more the
learning curve is gradual (not needing to learn a class/method/interface
before you need the functionality), the better.

OK, so what do we need to do about it?
Here's a rough proposition:

the configurable *interface*, which will be a class, but not a class
people should inherit from, will contain the following methods:

.getQuestions() --> return a dictionary: name of question, Question object
.getAnswer(name, answer) --> notify the application that an answer has been
                             given to a particular question
                             It can throw an InvalidAnswer exception with
                             a string for a reason. This is for 
                             application-level verification, and is discouraged.
.endAnswer() --> the "application" promises that no methods of the object
                 will be called between a series of .getAnswer()s and 
                 .endAnswer(). So, this means that if the UI got a bunch 
                 of answers, it will call .getAnswer() several times, and
                 then .endAnswer(). The UI will *check* for this method's
                 existance, and will not call it if it doesn't exist.

Question objects are meant to be open ended. 
They can contain a default.

Here is the general interface of the Question, that all objects conform
too:

.hasAnswer() --> boolean, whether the Question already contains an 
                 answer/default
.getValue() --> will only work if .hasAnswer() is true, returns the answer
.setValue(val) --> make .hasAnswer() true

Objects which can be created by the UI should have an __init__ which
can be called without arguments. If there is any initialization which
requires arguments, it should be done in endAnswer(). The UI also promises
not to call .endAnswer() for an object if there any questions which have
not been answered and do not have a default (.hasAnswer is false.)

Well, my proposal would not be complete if I didn't say what questions are
available. Keep in mind, though, that the set of questions is *open ended*.
That does not violate the light-and-lean guidelines, since a specific
Question class will only be used if the functionality is needed.

Without further ado:

class BooleanQuestion:
class IntQuestion: (can have .min and .max)
class FloatQuestion:
class StringQuestion: (can have .maxlength)
class LongStringQuestion: (same as above -- it's a hint to the ui)
class InterfaceQuestion: (specify interface, valid answers are objects)
class ArrayQuestion: (an array of the same kind of question)
class DictQuestion: (a dictionary mapping strings -> same kind of question)

example:

class Server: # note -- not inheriting from anything

    name = port = None

    def getQuestions(self):
        name = StringQuestion()
        if self.name is not None:
            name.setValue(self.name)
        port = IntQuestion()
        if self.port is not None:
            port.setValue(self.port)
        return {'port': port, 'name': name}

    def getAnswer(self, name, answer):
        # note: no need to use int(answer)
        # for port: an IntQuestion has an integer as a .getValue()
        setattr(self, name, answer)

Open questions:
* How do we connect classes to interfaces?
  Suggestion: each class has an attribute __implements__ containig a list
  of interfaces. Alternatively, an interface is really a list of 
  (callable, Questions) tuples, which are answered and passed to the callable.
  Modules with relevant classes register with the correct interface.
* How do we let objects created inside another object who their parent are?
  Suggestion: if an object from on Interface question has a method .setParent,
  call it with the parent as argument. This should be done by the Question
  object, so it knows how to call it for each object in a ListQuestion
* How do we let objects "title" a question?
  Suggestion: a question has a string argument on __init__ titling it.
* How do we allow the object to signify groupings of questions?
  Suggestion: this means the design is bad -- break down the object
  into smaller objects
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From carmstro at dynup.net  Fri May 11 10:36:24 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Fri, 11 May 2001 19:36:24 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <E14yDM3-0005wV-00@darjeeling>; from moshez@zadka.site.co.il on Fri, May 11, 2001 at 04:53:15PM +0300
Message-ID: <20010511123214.A3318@Fookidla.org>

[Ed.: I'm sending it on behalf of Chris since his mail server is down.
I have not edited the mail, and I will reply to it seperately]

Alright, I discussed this with moshe for a while on IRC, and here's my summary
of the discussion.

On Fri, May 11, 2001 at 04:53:15PM +0300, Moshe Zadka wrote:
> OK, let me first state some axioms:
> 
> 1. Everything should be configurable the same way, from within twisted.
> 
> Glyph has mentioned that he's not familiar with what's in bin/ anymore: 
> he just mktelnetserver, and configures from within the telnet server
> everything. This is what should happen, except not limited to the telnet
> server.

Yes, this is definitely good, and planned this way.

> 2. The configuration interface must not be ui specific.
> 
> This is obvious, right? Command line and web based aren't the only option.
> No reason why we can't implement a special purpose client/server for configuring
> twisted.

Again, this was planned. web UIs, reality UIs (you enter the magic box, there
is a web server floating here. You configure the web server.), GTK UIs are
all distant goals.

> 3. It should be easy to optimize the configuration for a ui
> 
> This is like the last one -- since we might deal with very good UIs, we
> need to give them enough information for using all their abilities to
> help us.
> 
> 4. It should be very easy to make an object configurable.
> 
> This is very important -- the harder it is, the less it will be easy
> to add *good* code to twisted. This is what may be the single most idiotic
> thing in Zope (and DC is aware of it! and thinking of how to fix it!). Let's
> learn from their mistakes: the less methods, the better. The more the
> learning curve is gradual (not needing to learn a class/method/interface
> before you need the functionality), the better.

I think this is also very important to end-user acceptance of TPy. If it's
got an easy-to-use and robust configurator, people will use it.

> OK, so what do we need to do about it?
> Here's a rough proposition:
> 
> the configurable *interface*, which will be a class, but not a class
> people should inherit from, will contain the following methods:
> 
> .getQuestions() --> return a dictionary: name of question, Question object

name change: getParamaters().

> .getAnswer(name, answer) --> notify the application that an answer has been
>                              given to a particular question
>                              It can throw an InvalidAnswer exception with
>                              a string for a reason. This is for 
>                              application-level verification, and is discouraged.

name change: setParamaters()
Also, throwing the exception is what's discouraged, not the actual use of the
method. :)

> .endAnswer() --> the "application" promises that no methods of the object
>                  will be called between a series of .getAnswer()s and 
>                  .endAnswer(). So, this means that if the UI got a bunch 
>                  of answers, it will call .getAnswer() several times, and
>                  then .endAnswer(). The UI will *check* for this method's
>                  existance, and will not call it if it doesn't exist.

name change: i'm not sure what, but endAnswer doesn't sound right.
What this is for is deferred calculation of answers. the not-calling-methods
thing needs to be thought about, so we don't have some weird bugs where TPy
goes completely haywire while configuring. (For instance, what if we're
configuring a web server through the web interface?)

> Question objects are meant to be open ended. 
> They can contain a default.
> 
> Here is the general interface of the Question, that all objects conform
> too:
> 
> .hasAnswer() --> boolean, whether the Question already contains an 
>                  answer/default
> .getValue() --> will only work if .hasAnswer() is true, returns the answer
> .setValue(val) --> make .hasAnswer() true
> 

name change: hasValue()?

> Objects which can be created by the UI should have an __init__ which
> can be called without arguments. If there is any initialization which
> requires arguments, it should be done in endAnswer(). The UI also promises
> not to call .endAnswer() for an object if there any questions which have
> not been answered and do not have a default (.hasAnswer is false.)

Ok, instead of __init__s that don't take arguments, we have klass.getInitArgs()
that is another set of questions that the user answers before the UI
instantiates the object (well, it'll have to be klass.__dict__['getInitArgs'](),
as glyph pointed out to me). Also, when we instantiate the object, we call
newObject.setParent(parent), as moshe talks about in the open questions at
the bottom of his mail.

> Well, my proposal would not be complete if I didn't say what questions are
> available. Keep in mind, though, that the set of questions is *open ended*.
> That does not violate the light-and-lean guidelines, since a specific
> Question class will only be used if the functionality is needed.
> 
> Without further ado:

name change for all of the following: *Parameter

> 
> class BooleanQuestion:
> class IntQuestion: (can have .min and .max)
> class FloatQuestion:
> class StringQuestion: (can have .maxlength)
> class LongStringQuestion: (same as above -- it's a hint to the ui)
> class InterfaceQuestion: (specify interface, valid answers are objects)
> class ArrayQuestion: (an array of the same kind of question)

moshe told me this was a thinko, so forget about array of questions :)

> class DictQuestion: (a dictionary mapping strings -> same kind of question)

I don't really get this one.


> example:
> 
> class Server: # note -- not inheriting from anything
> 
>     name = port = None
> 
>     def getQuestions(self):
>         name = StringQuestion()
>         if self.name is not None:
>             name.setValue(self.name)
>         port = IntQuestion()
>         if self.port is not None:
>             port.setValue(self.port)
>         return {'port': port, 'name': name}
> 
>     def getAnswer(self, name, answer):
>         # note: no need to use int(answer)
>         # for port: an IntQuestion has an integer as a .getValue()
>         setattr(self, name, answer)
> 
> Open questions:
> * How do we connect classes to interfaces?
>   Suggestion: each class has an attribute __implements__ containig a list
>   of interfaces. Alternatively, an interface is really a list of 
>   (callable, Questions) tuples, which are answered and passed to the callable.
>   Modules with relevant classes register with the correct interface.

I seem to remember some standardization of this that was proposed in a PEP.
Maybe we should use that standard for now, but of course just use our own
implementation of the implementation-checking stuff. (tongue twister, eh?)

> * How do we let objects created inside another object who their parent are?
>   Suggestion: if an object from on Interface question has a method .setParent,
>   call it with the parent as argument. This should be done by the Question
>   object, so it knows how to call it for each object in a ListQuestion

After thinking about this for a while, I decided it's a good idea. At first,
it seemed like an arbitrary fix to a problem, but when moshe brought up
how useful it would be when "moving" objects around.

> * How do we let objects "title" a question?
>   Suggestion: a question has a string argument on __init__ titling it.

that's simple enough.

> * How do we allow the object to signify groupings of questions?
>   Suggestion: this means the design is bad -- break down the object
>   into smaller objects

I'm not sure of my stance on this. I'll try to think of some examples and
discuss.


-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Fri May 11 10:49:17 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 11 May 2001 19:49:17 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <20010511123214.A3318@Fookidla.org>
References: <20010511123214.A3318@Fookidla.org>
Message-ID: <E14yG6P-0006FM-00@darjeeling>

On Fri, 11 May 2001 19:36:24 +0300, Chris Armstrong <carmstro at dynup.net> wrote:

<snipped agreement on the axioms>

> > .getAnswer(name, answer) --> notify the application that an answer has been
> >                              given to a particular question
> >                              It can throw an InvalidAnswer exception with
> >                              a string for a reason. This is for 
> >                              application-level verification, and is discouraged.
> 
> name change: setParamaters()

setParameter() sans the 's'. One call per parameter

> > .endAnswer() --> the "application" promises that no methods of the object
> >                  will be called between a series of .getAnswer()s and 
> >                  .endAnswer(). So, this means that if the UI got a bunch 
> >                  of answers, it will call .getAnswer() several times, and
> >                  then .endAnswer(). The UI will *check* for this method's
> >                  existance, and will not call it if it doesn't exist.
> 
> name change: i'm not sure what, but endAnswer doesn't sound right.
> What this is for is deferred calculation of answers. the not-calling-methods
> thing needs to be thought about, so we don't have some weird bugs where TPy
> goes completely haywire while configuring. (For instance, what if we're
> configuring a web server through the web interface?)

That's the classical example for why it's needed. Since the UI should
do something like that

for parameter in stuff_i_got:
    object.setParameter(...)
object.endParameters()

Then everything is fine.
That's a classical case of "if there's a doubt, there isn't a doubt": if the
UI is *not* sure it won't call other methods, it *should* call .endParameters()
It is *not* promised that there won't be multiple batches -- that's a QoI
issue.

> name change: [from .hasAnswer to] hasValue()?

Yep, definitely

> > Objects which can be created by the UI should have an __init__ which
> > can be called without arguments. If there is any initialization which
> > requires arguments, it should be done in endAnswer(). The UI also promises
> > not to call .endAnswer() for an object if there any questions which have
> > not been answered and do not have a default (.hasAnswer is false.)
> 
> Ok, instead of __init__s that don't take arguments, we have klass.getInitArgs()
> that is another set of questions that the user answers before the UI
> instantiates the object (well, it'll have to be klass.__dict__['getInitArgs'](),
> as glyph pointed out to me). 

No, we won't.
We'll have copy.copy(klass.initParameters). No need to make it a callable,
really.

> Also, when we instantiate the object, we call
> newObject.setParent(parent), as moshe talks about in the open questions at
> the bottom of his mail.

> name change for all of the following: *Parameter

Yes.

> > 
> > class BooleanQuestion:
> > class IntQuestion: (can have .min and .max)
> > class FloatQuestion:
> > class StringQuestion: (can have .maxlength)
> > class LongStringQuestion: (same as above -- it's a hint to the ui)
> > class InterfaceQuestion: (specify interface, valid answers are objects)
> > class ArrayQuestion: (an array of the same kind of question)
> 
> moshe told me this was a thinko, so forget about array of questions :)

I misunderstood radix. Let me clarify:
It's something like if you want to have a set of Servers in a selector:

ArrayParameter(InterfaceParameter(ServerInterface))

> > class DictQuestion: (a dictionary mapping strings -> same kind of question)
> 
> I don't really get this one.

Think of a web Resource which is a folder.

Then you can have

{'children': DictParameter(InterfaceParameter(WebResourceInterface)) }

[re __implements__]
> I seem to remember some standardization of this that was proposed in a PEP.
> Maybe we should use that standard for now, but of course just use our own
> implementation of the implementation-checking stuff. (tongue twister, eh?)

Python will not have *any* implementation of interface checking stuff.
Of course, we'll just take objects up on their __implements__ word,
not check through methods.

> > * How do we allow the object to signify groupings of questions?
> >   Suggestion: this means the design is bad -- break down the object
> >   into smaller objects
> 
> I'm not sure of my stance on this. I'll try to think of some examples and
> discuss.
 
I myself have misgivings on that. But maybe we can punt on it for now?
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Fri May 11 12:00:12 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Fri, 11 May 2001 21:00:12 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <E14yG6P-0006FM-00@darjeeling>
References: <E14yG6P-0006FM-00@darjeeling>, <20010511123214.A3318@Fookidla.org>
Message-ID: <E14yHD2-0006JM-00@darjeeling>

Thinking about how some UI for configuration would look like, namely command
line syntax, I have some rough sketch. I wrote this "as if" the configuration
interface I sketched earlier would actually exist. Note that the next UI
to come would force a refactoring to "general config ui utility functions"
and ui-specific functionality.

I hope this will concretize the discussion

First, some general words on how the ui will look like to the user:
the commands will be

> get <pickle file> <path>
> set <pickle file> <path> <string representation>
> array_add <pickle file> <path> <string representation>
> dict_add <pickle file> <path> <name> <string representation>

Wherever a parameter called "root" is mentioned, it will probably be
the pickle file. Note also that this is far for complete. And last
but not least, I didn't do the boring part of parsing the options
and dispatching to the functions -- fill this in from imagination.
Oh, and I obviously didn't test this wishful thinking code.

#command line configuration
def stringifyParameter(param):
    if isinstance(param, ArrayParameter):
        return "array of "+stringifyParameter(param.param)+'s'
    elif isinstance(param, DictParameter):
        return "folder of "+stringifyParameter(param.param)+'s'
    elif isinstance(param, StringParameter):
        return "string"
    elif isinstance(param, IntParameter):
        return "int"
    elif isinstance(param, InterfaceParameter):
        return param.interface.__name__

def convertString(type, s):
    if isinstance(type, ArrayParameter) or isinstance(type, DictParameter):
        raise ValueError("cannot set %s" % type.__class__.__name__)
    if isinstance(type, InterfaceParameter):
        obj = load(open(s))
        if type.interface not in obj.__implements__:
            raise ValueError(obj.__class__.__name__+" does not implement "+
                             type.__class__.__name__)
        return obj
    if isinstance(type, StringParameter):
        return s
    if isinstance(type, IntParameter):
        return int(s)
    raise ValueError("unrecognized type" % type.__class__.__name__)


def traverseObject(root, path):
    path = string.split(path, '.')
    name = path[-1]
    obj = root
    for part in path[:-1]:
        if isinstance(obj, ArrayParameter):
            obj = obj.getValue()[int(part)]
        elif isinstance(obj, DictParameter):
            obj = obj.getValue()[part]
        elif isinstance(obj, InterfaceParameter):
            obj = obj.getValue().getParameters()[part]
    param = obj.getParameters()[name]
    return param

def setOption(root, path, value):
    param = traverseObject(root, path)
    value = convertString(param, value)
    obj.setAnswer(name, value)
    if hasattr(obj, 'endAnswer'):
        obj.endAnswer()

def getOption(root, path):
    param = traverseObject(root, path)
    print stringifyParameter(param), param.getValue()

def appendToArray(root, path, value):
    param = traverseObject(root, path)
    assert isinstance(param, ArrayParameter)
    value = convertString(param.param, value)
    param.getValue().append(value)

def addToDict(root, path, name, value):
    param = traverseObject(root, path)
    assert isinstance(param, DictParameter)
    value = convertString(param.param, value)
    param.getValue()[name] = value
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From grolgh at online.no  Fri May 11 15:26:22 2001
From: grolgh at online.no (grolgh)
Date: Fri, 11 May 2001 23:26:22 +0200
Subject: [Twisted-Python] the magical port 0
Message-ID: <3B0098C9@epostleser.online.no>

Hello,

As you might know, binding to port 0, actually binds an unallocated port; but 
despite how useful this might be, twisted.net returns port 0 anyway.

The fix is easy, and that is to set port = skt.getsockname()[1] right after it 
has been binded.
I don't if this applies to win32, or any other platform, but I assume that it 
does.

I have not done this in CVS, but I hope someone with more insight into 
twisted.net could do it :)

phed
www.informative.f2s.com (be gone evil .zip-hating provider)





From glyph at twistedmatrix.com  Fri May 11 22:10:55 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Fri, 11 May 2001 23:10:55 -0500
Subject: [Twisted-Python] the magical port 0
In-Reply-To: <3B0098C9@epostleser.online.no>
References: <3B0098C9@epostleser.online.no>
Message-ID: <0105112310550B.17572@helix>

I looked at this, but I think the current approach is best.

Since servers are (optionally) persistent, the fact that server.port is 0 
tells you that the next time the server is brought in from a persistent 
store, it may be on a different port.

My suggestion for this application is to call through directly to 
server.socket.getsockname()[1] directly.

On Friday 11 May 2001 16:26, you wrote:
> Hello,
>
> As you might know, binding to port 0, actually binds an unallocated port;
> but despite how useful this might be, twisted.net returns port 0 anyway.
>
> The fix is easy, and that is to set port = skt.getsockname()[1] right after
> it has been binded.
> I don't if this applies to win32, or any other platform, but I assume that
> it does.
>
> I have not done this in CVS, but I hope someone with more insight into
> twisted.net could do it :)
>
> phed
> www.informative.f2s.com (be gone evil .zip-hating provider)
>
>
>
> _______________________________________________
> Twisted-Python mailing list
> Twisted-Python at twistedmatrix.com
> http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From carmstro at dynup.net  Sat May 12 00:10:53 2001
From: carmstro at dynup.net (Chris Armstrong)
Date: Sat, 12 May 2001 02:10:53 -0400
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <E14yG6P-0006FM-00@darjeeling>; from moshez@zadka.site.co.il on Fri, May 11, 2001 at 07:49:17PM +0300
References: <20010511123214.A3318@Fookidla.org> <E14yG6P-0006FM-00@darjeeling>
Message-ID: <20010512021053.A4013@Fookidla.org>

On Fri, May 11, 2001 at 07:49:17PM +0300, Moshe Zadka wrote:
> On Fri, 11 May 2001 19:36:24 +0300, Chris Armstrong <carmstro at dynup.net> wrote:
> > name change: setParamaters()
> setParameter() sans the 's'. One call per parameter

yes, that was a typo, I do know that there will be one call per parameter

> > goes completely haywire while configuring. (For instance, what if we're
> > configuring a web server through the web interface?)
> 
> That's the classical example for why it's needed. Since the UI should
> do something like that
> 
> for parameter in stuff_i_got:
>     object.setParameter(...)
> object.endParameters()
> 
> Then everything is fine.
> That's a classical case of "if there's a doubt, there isn't a doubt": if the
> UI is *not* sure it won't call other methods, it *should* call .endParameters()
> It is *not* promised that there won't be multiple batches -- that's a QoI
> issue.

Alright, I think I just misunderstood what you said about not executing
methods until endParameters() is called. I thought you meant the object
should be non-functional until endParamaters() is called. i realize now
how stupid of a thought that was. :)

> > instantiates the object (well, it'll have to be klass.__dict__['getInitArgs'](),
> > as glyph pointed out to me). 
> 
> No, we won't.
> We'll have copy.copy(klass.initParameters). No need to make it a callable,
> really.

Why? I don't understand. (I should make this [TM])

> > > class ArrayQuestion: (an array of the same kind of question)
> > 
> > moshe told me this was a thinko, so forget about array of questions :)
> 
> I misunderstood radix. Let me clarify:
> It's something like if you want to have a set of Servers in a selector:
> 
> ArrayParameter(InterfaceParameter(ServerInterface))

Uhh.. isn't that what ListParameter is for?

> Python will not have *any* implementation of interface checking stuff.
> Of course, we'll just take objects up on their __implements__ word,
> not check through methods.

Ok, I was thinking of PEP 0246.
(http://python.sourceforge.net/peps/pep-0246.html)

> > > * How do we allow the object to signify groupings of questions?
> > >   Suggestion: this means the design is bad -- break down the object
> > >   into smaller objects
> >
> > I'm not sure of my stance on this. I'll try to think of some examples and
> > discuss.
>
> I myself have misgivings on that. But maybe we can punt on it for now?

The only advantage I see of mutliple question sections (outside of one set
for instantiation and one for configuration) is a wizard-like interface,
and I'm not so sure that's good anyway. :)

-- 
Chris Armstrong                        carmstro at twistedmatrix.com
http://twistedmatrix.com/~carmstro     carmstro at dynup.net




From moshez at zadka.site.co.il  Sat May 12 01:03:34 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 12 May 2001 10:03:34 +0300
Subject: [Twisted-Python] Configuration: The Never Ending Story.
In-Reply-To: <20010512021053.A4013@Fookidla.org>
References: <20010512021053.A4013@Fookidla.org>, <20010511123214.A3318@Fookidla.org> <E14yG6P-0006FM-00@darjeeling>
Message-ID: <E14yTR8-00073l-00@darjeeling>

On Sat, 12 May 2001 02:10:53 -0400, Chris Armstrong <carmstro at dynup.net> wrote:
 
> Alright, I think I just misunderstood what you said about not executing
> methods until endParameters() is called. I thought you meant the object
> should be non-functional until endParamaters() is called. i realize now
> how stupid of a thought that was. :)

Well, the object can afford to be non-functional until .endParameters()
is called -- after all, no methods will expose it.

> > No, we won't.
> > We'll have copy.copy(klass.initParameters). No need to make it a callable,
> > really.
> 
> Why? I don't understand. (I should make this [TM])

Because it will have a fixed template, which we then copy and change.

> Uhh.. isn't that what ListParameter is for?

There's no ListParameter, and it would be wrong to call it that.

> > Python will not have *any* implementation of interface checking stuff.
> > Of course, we'll just take objects up on their __implements__ word,
> > not check through methods.
> 
> Ok, I was thinking of PEP 0246.
> (http://python.sourceforge.net/peps/pep-0246.html)

Which is only about *specifying* interfaces -- not checking them

> The only advantage I see of mutliple question sections (outside of one set
> for instantiation and one for configuration) is a wizard-like interface,
> and I'm not so sure that's good anyway. :)

And it's hard too -- we won't implement it.
I'll take all this dialog and rewrite my original spec.
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From moshez at zadka.site.co.il  Sat May 12 01:32:25 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sat, 12 May 2001 10:32:25 +0300
Subject: [Twisted-Python] Configuration, Final Spec
Message-ID: <E14yTt3-00078c-00@darjeeling>

Rewritten, standalone, spec

OK, let me first state some axioms:

1. Everything should be configurable the same way, from within twisted.

Glyph has mentioned that he's not familiar with what's in bin/ anymore:
he just mktelnetserver, and configures from within the telnet server
everything. This is what should happen, except not limited to the telnet
server.

2. The configuration interface must not be ui specific.

This is obvious, right? Command line and web based aren't the only option.
No reason why we can't implement a special purpose client/server for configurin
g
twisted.

3. It should be easy to optimize the configuration for a ui

This is like the last one -- since we might deal with very good UIs, we
need to give them enough information for using all their abilities to
help us.

4. It should be very easy to make an object configurable.

This is very important -- the harder it is, the less it will be easy
to add *good* code to twisted. This is what may be the single most idiotic
thing in Zope (and DC is aware of it! and thinking of how to fix it!). Let's
learn from their mistakes: the less methods, the better. The more the
learning curve is gradual (not needing to learn a class/method/interface
before you need the functionality), the better.

OK, so what do we need to do about it?
Here's a rough proposition:

the configurable *interface*, which will be a class, but not a class
people should inherit from, will contain the following methods:

.getParameters() --> return a dictionary: name of parameter, Parameter object
.setParameter(name, answer) --> notify the application that an answer has been
                             given to a particular question
                             It can throw an InvalidParameter exception with
                             a string for a reason. This is for
                             application-level verification. Note that 
                             application-level verification is discouraged.
.endParameters() --> the "application" promises that no methods of the object
                 will be called between a series of .setParameter()s and
                 .endParameters(). So, this means that if the UI got a bunch
                 of answers, it will call .setParameter() several times, and
                 then .endParameters(). The UI will *check* for this method's
                 existance, and will not call it if it doesn't exist.
.setParent(parent) --> if the object is created inside an InterfaceProperty
                       of some other object, module nested ArrayParameters
                       and DictParameters, .setParent will be called with
                       that object, *if it exists*.

Parameter objects are meant to be open ended.
They can contain a default.

Here is the general interface of the Question, that all objects conform
too:

.hasValue() --> boolean, whether the Parameter already contains an
                value
.getValue() --> will only work if .hasValue() is true, returns the answer
.setValue(val) --> make .hasValue() true
.title --> A string, the human-readable description of the property.

Objects which can be created by the UI should have an initParameters
attribute which should be a sequence of Parameters, which correspond
to the mandatory arguments of the __init__ method.

Well, my proposal would not be complete if I didn't say what parameters are
available. Keep in mind, though, that the set of parameters is *open ended*.
That does not violate the light-and-lean guidelines, since a specific
Parameter class will only be used if the functionality is needed.

Without further ado:

class BooleanParameter:
class IntParameter: (can have .min and .max)
class FloatParameter:
class StringParameter: (can have .maxlength)
class LongStringParameter: (same as above -- it's a hint to the ui)
class InterfaceParameter: (specify interface, valid answers are objects)
class ArrayParameter: (an array of the same kind of question)
class DictParameter: (a dictionary mapping strings -> same kind of question)

The constructor will always take a title as a first argument, and possibly
some more parameters if appropriate. I'm thinking of adding some generic 
methods, the most interesting one is traverse, which either returns
a Parameter or throws a ValueError("node parameter").

A class will be said to implement an interface if the interface class
is a member of the __implements__ attribute. We can refine it to saying
that the interface is a superclass of some member of __implements__:

def implements(klass, interface):
    for member in klass.__implements__:
        if issubclass(member, interface):
            return 1
    return 0

This leaves open the question of how classes register with the UI at all.
A possibly radical solution will be to have the UI scan through sys.modules,
and each class will be checked for the __implements__ attribute. A less
radical option is to have a register(klass) function which registers
it with the UI. register() can be used from within the module, if it is
an active participant, or from within an importing module.

example:

class Server: # note -- not inheriting from anything

    initParameters = (StringParameter("Server Name"), IntParameter("Port"))
    def __init__(self, name, port):
        self.name, self.port = name, port

    def getParameters(self):
        name = StringQuestion("Server Name")
        name.setValue(self.name)
        port = IntQuestion("Port")
        port.setValue(self.port)
        return {'port': port, 'name': name}

    def setParameter(self, name, answer):
        # note: no need to use int(answer)
        # for port: an IntQuestion has an integer as a .getValue()
        setattr(self, name, answer)

--
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org

-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Sat May 12 17:03:15 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sat, 12 May 2001 18:03:15 -0500
Subject: [Twisted-Python] Configuration, Final Spec
In-Reply-To: <E14yTt3-00078c-00@darjeeling>
References: <E14yTt3-00078c-00@darjeeling>
Message-ID: <0105121803150H.17572@helix>

On Saturday 12 May 2001 02:32, you wrote:
> Rewritten, standalone, spec

[ agreement with axioms ]

> OK, so what do we need to do about it?
> Here's a rough proposition:
>
> the configurable *interface*, which will be a class, but not a class
> people should inherit from, will contain the following methods:

IMHO, people *should* inherit from it, so that we can have some visibility on 
what implements it.  I agree that it should provide as little functionality 
as possible, however.

> .getParameters() --> return a dictionary: name of parameter, Parameter
> object .setParameter(name, answer) --> notify the application that an
> answer has been given to a particular question
>                              It can throw an InvalidParameter exception
> with a string for a reason. This is for
>                              application-level verification. Note that
>                              application-level verification is discouraged.
> .endParameters() --> the "application" promises that no methods of the
> object will be called between a series of .setParameter()s and
> .endParameters(). So, this means that if the UI got a bunch of answers, it
> will call .setParameter() several times, and then .endParameters(). The UI
> will *check* for this method's existance, and will not call it if it
> doesn't exist. .setParent(parent) --> if the object is created inside an
> InterfaceProperty of some other object, module nested ArrayParameters and
> DictParameters, .setParent will be called with that object, *if it exists*.

I don't understand this part of the design.

In my humble (but correct) opinion, it is *always* bad API design to force 
the caller to "promise" something.  (Sometimes, other design concerns 
mitigate this decision, but I don't see one here.  However, I have frequently 
joked about having a neon sign in my office, for design discussions, that 
says "IT IS NOT THE CALLER'S RESPONSIBILITY" in 10-foot-tall letters)

I would much rather see a .getParameters() -> dict / .setParameters(dict).  
It seems more symmetrical, and if you can "promise" that (A) setParameters 
may be called some number of times and (B) endParameters() will *always* be 
called afterwards, we can put that loop into the config side of the code.

Any reasons why it can't be done this way?

> Parameter objects are meant to be open ended.
> They can contain a default.
>
> Here is the general interface of the Question, that all objects conform
> too:

Of the "Parameter", I take it you mean? :)

> .hasValue() --> boolean, whether the Parameter already contains an
>                 value
> .getValue() --> will only work if .hasValue() is true, returns the answer
> .setValue(val) --> make .hasValue() true
> .title --> A string, the human-readable description of the property.
>
> Objects which can be created by the UI should have an initParameters
> attribute which should be a sequence of Parameters, which correspond
> to the mandatory arguments of the __init__ method.

Another interesting open question (although not one I'm sure this code has to 
address) is how to get the respective configuration interfaces to represent 
object identity.  (e.g. I want to mount the *same* web resource on /foo, on 
/bar)

> This leaves open the question of how classes register with the UI at all.
> A possibly radical solution will be to have the UI scan through
> sys.modules, and each class will be checked for the __implements__
> attribute. A less radical option is to have a register(klass) function
> which registers it with the UI. register() can be used from within the
> module, if it is an active participant, or from within an importing module.

There is a third option -- make Configurable a metaclass :)

However, I prefer the register(klass) way, both for clarity and efficiency.  
Explicit is better than implicit.

> example:
>
> class Server: # note -- not inheriting from anything
>
>     initParameters = (StringParameter("Server Name"), IntParameter("Port"))
>     def __init__(self, name, port):
>         self.name, self.port = name, port
>
>     def getParameters(self):
>         name = StringQuestion("Server Name")
>         name.setValue(self.name)
>         port = IntQuestion("Port")
>         port.setValue(self.port)
>         return {'port': port, 'name': name}
>
>     def setParameter(self, name, answer):
>         # note: no need to use int(answer)
>         # for port: an IntQuestion has an integer as a .getValue()
>         setattr(self, name, answer)

Your code has a bug in it, which is a good example of why I like to actually 
inherit from interfaces :).  You don't define "endParameters".

One more question -- why doesn't the Configurable interface class actually do 
some things, like data validation? It sounds like it'd be possible 
(isCorrectInput method on the Parameter classes, or somesuch...)

On the whole this looks like a good proposal, although I'm still not entirely 
sure what the final end-user experience of configuration will look like.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Sat May 12 23:31:32 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Sun, 13 May 2001 08:31:32 +0300
Subject: [Twisted-Python] Configuration, Final Spec
In-Reply-To: <0105121803150H.17572@helix>
References: <0105121803150H.17572@helix>, <E14yTt3-00078c-00@darjeeling>
Message-ID: <E14yoTc-0008QP-00@darjeeling>

On Sat, 12 May 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:

> IMHO, people *should* inherit from it, so that we can have some visibility on 
> what implements it.  I agree that it should provide as little functionality 
> as possible, however.

No, people should put it in the __implements__ attribute.

> In my humble (but correct) opinion, it is *always* bad API design to force 
> the caller to "promise" something.  (Sometimes, other design concerns 
> mitigate this decision, but I don't see one here.  However, I have frequently 
> joked about having a neon sign in my office, for design discussions, that 
> says "IT IS NOT THE CALLER'S RESPONSIBILITY" in 10-foot-tall letters)
> 
> I would much rather see a .getParameters() -> dict / .setParameters(dict).  
> It seems more symmetrical, and if you can "promise" that (A) setParameters 
> may be called some number of times and (B) endParameters() will *always* be 
> called afterwards, we can put that loop into the config side of the code.
> 
> Any reasons why it can't be done this way?

Yes. In the usual case, where you don't need a .endParameters(), then the
code will be *much* clearer. You also missed the place where I say
".endParameters() will not be called if it doesn't exist".
See axiom 4 -- certainly

    def setParameter(self, name, value):
        setattr(self, name, value)

(which is the usual case)

Is much quicker then

    def setParameters(self, dict):
        for name, value in dict.items():
            setattr(self, name, value)

And another good reason -- this makes it much easier when doing 
application-level validation, to know what failed:

    # configuring RSA
    def setParameter(self, name, value):
        if not isPrime(value):
            raise ValueError("not prime")
        setattr(self, name, value)

> Another interesting open question (although not one I'm sure this code has to 
> address) is how to get the respective configuration interfaces to represent 
> object identity.  (e.g. I want to mount the *same* web resource on /foo, on 
> /bar)

This code isn't the one that should address it -- this is UI's responsibility.
Take *another* look at the way Zope does it.

> However, I prefer the register(klass) way, both for clarity and efficiency.  
> Explicit is better than implicit.

Indeed, I've decided I agree, for a different reason -- we do not want
spurious options for the user.

> Your code has a bug in it, which is a good example of why I like to actually 
> inherit from interfaces :).  You don't define "endParameters".

No it doesn't. It's permissible not to have .endParameters(), .setParent()
and .initParameters. The first two will not be called if they don't exist.

> One more question -- why doesn't the Configurable interface class actually do 
> some things, like data validation? It sounds like it'd be possible 
> (isCorrectInput method on the Parameter classes, or somesuch...)

I've thought about it, and decided against it -- since the UI needs to know
so much about the validation anyway, I prefer to putting the knowledge in
the UI. Sure, when we realized what is convinient for two UIs, we can have
some nice functions to help UIs -- but *outside* the Parameter class.
The classical example is that the UI might need to write the validation
code in JavaScript, for DHTML forms. Surely, a method written in Python
won't help...

> On the whole this looks like a good proposal, although I'm still not entirely 
> sure what the final end-user experience of configuration will look like.

Well, I've already gave an example of what it would look like with the
command line. Mutatis-mutandis, we can pretty much imagine how to translate
it into web-based. Of course, many options still remain, but I don't think
I care about UIs: I've specified enough information for the UI -- now
the UIs can compete. (We can have 10 different web-based UIs, and choose
among them)
-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Sun May 13 01:54:56 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Sun, 13 May 2001 02:54:56 -0500
Subject: [Twisted-Python] Configuration, Final Spec
In-Reply-To: <E14yoTc-0008QP-00@darjeeling>
References: <0105121803150H.17572@helix> <E14yTt3-00078c-00@darjeeling> <E14yoTc-0008QP-00@darjeeling>
Message-ID: <0105130254560I.17572@helix>

On Sunday 13 May 2001 00:31, you wrote:
> On Sat, 12 May 2001, Glyph Lefkowitz <glyph at twistedmatrix.com> wrote:
>
> > In my humble (but correct) opinion, it is *always* bad API design to
> > force the caller to "promise" something.  (Sometimes, other design
> > concerns mitigate this decision, but I don't see one here.  However, I
> > have frequently joked about having a neon sign in my office, for design
> > discussions, that says "IT IS NOT THE CALLER'S RESPONSIBILITY" in
> > 10-foot-tall letters)
> >
> > I would much rather see a .getParameters() -> dict /
> > .setParameters(dict). It seems more symmetrical, and if you can "promise"
> > that (A) setParameters may be called some number of times and (B)
> > endParameters() will *always* be called afterwards, we can put that loop
> > into the config side of the code.
> >
> > Any reasons why it can't be done this way?
>
> Yes. In the usual case, where you don't need a .endParameters(), then the
> code will be *much* clearer. You also missed the place where I say
> ".endParameters() will not be called if it doesn't exist".
> See axiom 4 -- certainly
[snipped examples]

But if you declare setParameters as a member of the Configurable class, then 
you don't have to write every UI to deal with the possible existance or 
non-existance of endParameters.

I am strongly opposed to any API which requires validation on the caller's 
behalf, for several reasons.  A practical concern is that using an RPC like 
gloop (e.g. an asynchronous one) it is impossible to tell if the object you 
are calling "has the attribute" endParameters or not.  You just have to call 
it and hope for the best.

If setParameters is defined in Configurable (the default implementation being 
a 2-line loop which does setParameter and then endParameter) then the extra 
work you're talking about for the configurable author can be avoided.

Having an API which requires a garuantee on the caller's behalf (the "caller" 
in this case being the UI) in a language where exceptions are as common as in 
Python makes handling of errors somewhat tricky.  After all, if setting a 
bunch of parameters is a non-atomic operation, then what do you do when one 
of your parameters is invalid, and raises an exception?  Does endParameters 
still have to get called?

It seems to me that setParameters is an atomic operation, which should 
validate, then test.  validateParameters could be a method as well, to do 
extra validation if parameters are dependant upon each other.  However, you 
can then clearly say that setParameter may never raise an exception: if the 
call to validateParameters succeeds, but setParameter fails, then you are in 
a known-to-be-inconsistent state and can display an appropriate error 
message.  However, if some of your setParameter calls raise exceptions and 
others do not, should endParameters be called anyway?  Does every UI need to 
handle exceptions itself?

> > Another interesting open question (although not one I'm sure this code
> > has to address) is how to get the respective configuration interfaces to
> > represent object identity.  (e.g. I want to mount the *same* web resource
> > on /foo, on /bar)
>
> This code isn't the one that should address it -- this is UI's
> responsibility. Take *another* look at the way Zope does it.

Zope confuses the hell out of me, both in the UI and the code :)... but I 
agree that this code probably shouldn't have to deal with that.

> > However, I prefer the register(klass) way, both for clarity and
> > efficiency. Explicit is better than implicit.
>
> Indeed, I've decided I agree, for a different reason -- we do not want
> spurious options for the user.

Yay, agreement! :)

> I've thought about it, and decided against it -- since the UI needs to know
> so much about the validation anyway, I prefer to putting the knowledge in
> the UI. Sure, when we realized what is convinient for two UIs, we can have
> some nice functions to help UIs -- but *outside* the Parameter class.
> The classical example is that the UI might need to write the validation
> code in JavaScript, for DHTML forms. Surely, a method written in Python
> won't help...

It's not to help out the UIs, it's to prevent setParameter from being called 
incorrectly.  There are several points of failure here --

 * the user typed something incorrect (presumably, your JavaScript example)
 * something bad came from the transport (WebUI.validate)
 * there is a bug in/bad data from the UI (Parameter.validate)
 * there is a bug in the configurable (exceptions caught by Configurable on 
setParameter)

and I think each one has to be treated differently.

> > On the whole this looks like a good proposal, although I'm still not
> > entirely sure what the final end-user experience of configuration will
> > look like.
>
> Well, I've already gave an example of what it would look like with the
> command line. Mutatis-mutandis, we can pretty much imagine how to translate
> it into web-based. Of course, many options still remain, but I don't think
> I care about UIs: I've specified enough information for the UI -- now
> the UIs can compete. (We can have 10 different web-based UIs, and choose
> among them)

It's for this reason that I'd like as much thought to be given to making UIs 
easy to write as to making Configurable objects easy to write.  I think I've 
changed my mind about Configurable not providing much functionality;  The 
Configurable and Parameter classes should encapsulate as much common behavior 
as possible.  (Although, I admit that there is probably not *much* common 
functionality.)  If they don't for some reason (and I am still not convinced 
any such reasons exist), the "config" module should at least contain it all, 
and as a core part of the interface, not as an additional utility library for 
GUIs.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From moshez at zadka.site.co.il  Sun May 13 22:57:21 2001
From: moshez at zadka.site.co.il (Moshe Zadka)
Date: Mon, 14 May 2001 07:57:21 +0300
Subject: [Twisted-Python] configuration usecases
Message-ID: <E14zAQ5-0003M2-00@darjeeling>

1. Selector
   -- a selector will have exactly one configurable parameter:
      an array of things which conform to the server interface,
      and an array of things which conform to the delayed interface
2. POP3 Server
   -- (optionally) a name, a port and something that conforms to the
   "dictionary" interface (.has_key, [], .get which are consistent)
   where the keys are strings, and the values are things that
   conform to the domain interface, and to the POP3 domain extensions
   (authenticateAPOPUser)
3. DomainDictionary
   -- contents, a mapping of strings to things conforming to the domain
   interface
4. MaildirDbmDomain
   -- add a user/password, remove a user, change a password
5. HTTPServer
   -- something conforming to the resource interface
6. FolderResource
   -- a mapping of strings to resources, and all those of DataResource
7. DataResource
   -- code (an int), headers (a mapping of strings to strings) and
   the data (a long-string)
8. TelnetServer
   -- username, password



-- 
"I'll be ex-DPL soon anyway so I'm        |LUKE: Is Perl better than Python?
looking for someplace else to grab power."|YODA: No...no... no. Quicker,
   -- Wichert Akkerman (on debian-private)|      easier, more seductive.
For public key, finger moshez at debian.org  |http://www.{python,debian,gnu}.org




From glyph at twistedmatrix.com  Mon May 14 01:03:02 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Mon, 14 May 2001 02:03:02 -0500
Subject: [Twisted-Python] configuration usecases
In-Reply-To: <E14zAQ5-0003M2-00@darjeeling>
References: <E14zAQ5-0003M2-00@darjeeling>
Message-ID: <01051402030200.30472@helix>

On Sunday 13 May 2001 23:57, you wrote:
> 1. Selector
>    -- a selector will have exactly one configurable parameter:
>       an array of things which conform to the server interface,
>       and an array of things which conform to the delayed interface

I have to apologise for my design here.  We ought to be pickling (jellying? 
^_^) ServerSets, not Selectors.  (After all, a GTK selector is a different 
class than a regular selector, which means it's not possible to read in a 
selector to a GTK app, or merge two selectors together, without some 
hackery.)  Also, "Selector" conjures up images of Smalltalk and Objective C 
which are wholly inappropriate, as I was not aware of that use of terminology 
when I named it :)

So, to break down this use-case further, a user wishes to configure a set of 
servers.  They can perform one of 4 actions (keep in mind I'm thinking from 
the user/UI perspective, *not* the perspective of the actual config system 
code)

 * view a list of servers currently in the set
 * add a server to the set (this is a big one)
 * remove a server from the set
 * configure a server in that set

these correspond roughly to operations on dictionaries (assuming that 
ServerSets ; roughly,

--------
for servername, server in serverset.items():
    display(servername, server)
----
newServer = somehowCreateAServer()
servers[newServerName] = newServer
----
del servers[someServerName]
----
foo = servers[someServerName]
doConfiguration(foo)
--------


> 2. POP3 Server
>    -- (optionally) a name, a port and something that conforms to the
>    "dictionary" interface (.has_key, [], .get which are consistent)
>    where the keys are strings, and the values are things that
>    conform to the domain interface, and to the POP3 domain extensions
>    (authenticateAPOPUser)

I think that we're saying similiar things here, again -- dictionary 
operations.

> 3. DomainDictionary
>    -- contents, a mapping of strings to things conforming to the domain
>    interface

Again, a dictionary...

> 4. MaildirDbmDomain
>    -- add a user/password, remove a user, change a password

Looks similiar again, "change a password" being similiar to "configure a 
sub-element"... presumably when we have more kinds of users (e.g. the "run a 
shellscript" variety) this will be different.

Presumably a User is a username/password combo (changing the username may 
require some monkeying, since that's also the key that it's stored in the 
domain as); but may be arbitrarily complex, as users do more complex things 
(frex, a web-story-posting interface through email).

> 5. HTTPServer
>    -- something conforming to the resource interface

This again will probably need some restructuring.  Shouldn't inherit from 
TCPServer, etc.  So "add/remove a port to listen on" will probably be an 
additional case.

> 6. FolderResource
>    -- a mapping of strings to resources, and all those of DataResource

I don't see any reason why all of them have to be DataResources...?  "Any 
non-abstract subclass of Resource" seems more reasonable.

> 7. DataResource
>    -- code (an int), headers (a mapping of strings to strings) and
>    the data (a long-string)

I think we're missing FileResource. That encompasses a few other things (a 
mapping of file extensions to MIME-types and processor resources, for 
example), but again, that's just another hash of either strings or classes.

> 8. TelnetServer
>    -- username, password

Finally, a simple form interface, alone :)

Most of the things that we're talking about here have either an interface 
that specifies some attributes (e.g. a dictionary with a fixed set of string 
keys) or a dictionary which, as far as these cases are concerned, is always 
keyed by strings, and may have values which are either strings, classes, or 
instances of some fixed part of the inheritance (whether through __bases__ or 
__implements__) heirarchy, rooted at a particular class (or interface).

So, having contributed what I can to the discussion of use cases -- I don't 
see that the previous proposal solves this issue in an elegant way; it seems 
like all the things here that require a "dict" parameter are not well-served 
by the getParameters/setParameter interface; the app code will have to 
decompose a "set" of the DictParameter in question by doing a comparison of 
what was there before and what is there now, into a set of add/remove 
operations (in, I might add, indeterminate order).  Since most of both of our 
examples were these sorts of things, it doesn't seem well optimized for the 
common case; although I believe I'm missing something.

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




From grolgh at online.no  Mon May 14 05:44:38 2001
From: grolgh at online.no (Benjamin Bruheim)
Date: Mon, 14 May 2001 11:44:38 GMT
Subject: [Twisted-Python] userinfo, etc, for twisted.ftp
Message-ID: <jUsT.aNoTheR.mEsSaGe.iD.98984067820096@fi.mailreader.com>

Hepp,

twisted.ftp is now in an nearly usable state. There are some problems 
with
active ftp'ing (net.TCPClient does not exactly have the same interface
as net.TCPServer), but this is really an minor issue. And for those
who want to try it, use the bsd-ftp and remember to turn on binary
transfers! The client seems to modify the files to conform to ascii :)

ATM there is no auth'ing in twisted.ftp; and this is really the biggest
issue with it. So, I wonder, how should it perform auth? Where can it
find the homedir? And setting the access to the user?
Well, much of this information could be found in the sources already,
but I would like to know how much should be done unix-style or
twisted.style :)

phed



===================================================================
EASY and FREE access to your email anywhere: http://Mailreader.com/
===================================================================






From glyph at twistedmatrix.com  Mon May 14 12:18:53 2001
From: glyph at twistedmatrix.com (Glyph Lefkowitz)
Date: Mon, 14 May 2001 13:18:53 -0500
Subject: [Twisted-Python] ANN: The week ends, the week begins.
Message-ID: <01051413185300.30821@helix>

OUTER SPACE (AP) -- Broadcasting from his self-styled "satellite of fiery 
doom" in a superlunar orbit on Monday, Evil Overlord Glyph Lefkowitz declared 
that a new version of Twisted Python, 0.8.8, was ready for download.

In an interview, a bleary-eyed, haggard looking Glyph dismissed rumours that 
he had escaped to the orbital space-station in order to escape the rampaging 
mob of Twisted Python users angered over the uncharacteristically unstable 
state of the 0.8.5 and 6 releases, as well as those who had lost family 
members to Chief Reality Engineer Allen Short's so-called "bugfixing" spree.  
"Complete nonsense!", he quipped, "My fans are as loyal as ever."  Although, 
the wary Overlord was heard to inquire briefly after the interview about the 
status of the aforementioned rampaging mob.

Mr. Short was not available for comment.

----

In this release, you'll find better API documentation, an FTP server, and the 
new PB&J protocol/serialization suite.  (this the intended replacement for 
gloop, previously entitled `gloop2').  Go hit your favorite your url (that's 
http://twistedmatrix.com/, in case you forgot), and download some firey doom 
today! :)

-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     http://twistedmatrix.com/users/glyph




