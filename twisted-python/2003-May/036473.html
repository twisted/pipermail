<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] pcp.ProducerConsumerProxy.resumeProducing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20pcp.ProducerConsumerProxy.resumeProducing&In-Reply-To=%3C20030509015645.GA3694%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] pcp.ProducerConsumerProxy.resumeProducing</H1>
    <B>Eric C. Newton</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20pcp.ProducerConsumerProxy.resumeProducing&In-Reply-To=%3C20030509015645.GA3694%40localhost.localdomain%3E"
       TITLE="[Twisted-Python] pcp.ProducerConsumerProxy.resumeProducing">ecn at metaslash.com
       </A><BR>
    <I>Thu May  8 19:56:45 MDT 2003</I>
    <P><UL>
        
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36473">[ date ]</a>
              <a href="thread.html#36473">[ thread ]</a>
              <a href="subject.html#36473">[ subject ]</a>
              <a href="author.html#36473">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Linux RedHat 9.0
Twisted 1.0.4

In method resumeProducing of pcp.ProducerConsumerProxy, there's this
code:

        if self.producer is not None:
            bytesBuffered = reduce(operator.add,
                                   [len(s) for s in self._buffer], 0)
            # TODO: You can see here the potential for high and low
            # watermarks, where bufferSize would be the high mark when we
            # ask the upstream producer to pause, and we wouldn't have
            # it resume again until it hit the low mark.  Or if producer
            # is Pull, maybe we'd like to pull from it as much as necessary
            # to keep our buffer full to the low mark, so we're never caught
            # without something to send.
            if self.producerPaused and (bytesBuffered &lt; self.bufferSize):
                # Now that our buffer is empty,
                self.producerPaused = False
                self.producer.resumeProducing()
            elif self.outstandingPull:
                # I did not have any data to write in response to a pull,
                # so I'd better pull some myself.
                self.producer.resumeProducing()

At the condition:

            elif self.outstandingPull:

It's possible that the producer is sending data in big chunks, and we
are only writing them out in little chunks.  If so, we continue to add
bytes to the buffer and disregard the buffer limit.  I've changed the
line to this:

            elif self.outstandingPull and (bytesBuffered &lt; self.bufferSize):

and all is well.  Except maybe the code should be refactored (without
comments now):

	    if bytesBuffered &lt; self.bufferSize:
		if self.producerPaused or self.outstandingPull:
		    self.producer.resumeProducing()
		self.producerPaused = False

-Eric


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36473">[ date ]</a>
              <a href="thread.html#36473">[ thread ]</a>
              <a href="subject.html#36473">[ subject ]</a>
              <a href="author.html#36473">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
