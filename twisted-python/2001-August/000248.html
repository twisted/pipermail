<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Mail Relaying
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Mail%20Relaying&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000241.html">
   <LINK REL="Next"  HREF="000249.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Mail Relaying</H1>
    <B>Moshe Zadka</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Mail%20Relaying&In-Reply-To="
       TITLE="[Twisted-Python] Mail Relaying">m at moshez.org
       </A><BR>
    <I>Sun Aug 12 08:15:37 EDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000241.html">[Twisted-Python] Alternative method for thread-safe transport code
</A></li>
        <LI>Next message: <A HREF="000249.html">[Twisted-Python] Setting Up Us The Bomb^H^H^H^HMail server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#248">[ date ]</a>
              <a href="thread.html#248">[ thread ]</a>
              <a href="subject.html#248">[ subject ]</a>
              <a href="author.html#248">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Don't get your panties in a knot, this isn't ISP-class mail relaying
yet, just simple localhost-to-smarthost mail relaying. These classes
are supposed to work in tandem with a DomainPickler which leaves messages
for them to relay.

Without further ado, here it is:

from twisted.python import delayed
from twisted.mail import relay

class SMTPManagedRelay(relay.SMTPRelay):

    def __init__(self, messages, manager):
        SMTPRelay.__init__(self, messages)
        self.manager = manager

    def sentMail(self, addresses):
        SMTPRelay.sentMail(self, addresses)
	if addresses: 
	    self.manager.notifySuccess(self, self.messages[0][0])
	if addresses: 
	    self.manager.notifyFailure(self, self.messages[0][0])

    def connectionLost(self):
        self.manager.notifyDone(self)


class SmartHostSMTPRelayingManager:

    def __init__(self, directory, smartHostIP, maxConnections=1, 
                 maxMessagesPerConnection=10):
        self.directory = directory
	self.maxConnections = maxConnections
	self.maxMessagesPerConnection = maxMessagesPerConnection
	self.delayed = smartHostIP
	self.managed = {}
	self.relayingMessages = {}
	self.readDirectory()

    def notifySuccess(self, relay, message):
        message = os.path.basename(message)
	self.managed[relay].remove(message)
	self.messages[message] = 1
	del self.relayingMessages[message]

    notifyFailure = no.tifySuccess

    def notifyDone(self, relay):
        for message in self.managed[relay]:
	    self.notifyFailure(relay, message)
        del self.managed[relay]

    def __getstate__(self):
        dct = self.__dict__.copy()
	del dct['managed'], dct['relayingMessages'], dct['messages']
	return dct

    def __setstate__(self, state):
        self.__dict__.update(state)
	self.relayingMessages = {}
	self.managed = {}
	self.readDirectory()

    def readDirectory(self):
	self.messages = {}
	for message in os.listdir(self.directory):
	    if not self.relayingMessages.has_key(message):
	        self.messages[message] = 1

    def checkState(self):
	self.readDirectory() 
	if self.messages:
	    return
        if len(self.managed) &gt;= self.maxConnections:
	    return
	nextMessages = self.messages.keys()[:self.maxMessagesPerConnection]
        toRelay = []
	for message in nextMessages:
	    self.relayingMessages[message] = 1
	    del self.messages[message]
	    toRelay.append(os.path.join(self.directory, message))
        protocol = SMTPManagedRelay(toRelay, self)
	self.managed[protocol] = nextMessages
	transport = tcp.Client(smartHostIP, 25, protocol)


# It's difficult to pickle methods
# So just have a function call the method
def checkState(manager):
    manager.checkState()

def attachManagerToDelay(manager, delay, time):
    loop = delayed.Loop(delay, time, checkState, manager)
    loop.loop()



-- 
Moshe Zadka - <A HREF="http://moshez.geek">http://moshez.geek</A>
(if you're not cool, <A HREF="http://moshez.org">http://moshez.org</A> is still working)



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000241.html">[Twisted-Python] Alternative method for thread-safe transport code
</A></li>
	<LI>Next message: <A HREF="000249.html">[Twisted-Python] Setting Up Us The Bomb^H^H^H^HMail server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#248">[ date ]</a>
              <a href="thread.html#248">[ thread ]</a>
              <a href="subject.html#248">[ subject ]</a>
              <a href="author.html#248">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
