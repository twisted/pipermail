<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Question on using processes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Question%20on%20using%20processes&In-Reply-To=41129E5A.8070406%40dalchemy.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008302.html">
   <LINK REL="Next"  HREF="008306.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Question on using processes</H1>
    <B>Tim Allen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Question%20on%20using%20processes&In-Reply-To=41129E5A.8070406%40dalchemy.com"
       TITLE="[Twisted-Python] Question on using processes">screwtape at froup.com
       </A><BR>
    <I>Thu Aug  5 18:12:13 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008302.html">[Twisted-Python] Question on using processes
</A></li>
        <LI>Next message: <A HREF="008306.html">[Twisted-Python] Question on using processes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8303">[ date ]</a>
              <a href="thread.html#8303">[ thread ]</a>
              <a href="subject.html#8303">[ subject ]</a>
              <a href="author.html#8303">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 6 Aug 2004, at 06:53, Matt Feifarek wrote:
&gt;<i> I'm using twisted.internet.utils.getProcessOutput() to run commands 
</I>&gt;<i> from a reactor.
</I>&gt;<i>
</I>&gt;<i> I've pretty much got this working okay (with a few false starts 
</I>&gt;<i> related to how args are put together... you can't send in a big long 
</I>&gt;<i> string; you literally have to make a list of argument words... what a 
</I>&gt;<i> PITA).
</I>
This is due to Python's (and C's) Unix heritage. The kernel call to 
spawn a new process takes the full path to the executable, and an array 
of null-terminated strings which are the arguments. This can be quite 
tedious to set up in C, but shouldn't be too painful under Python. 
Contrast this behaviour with MS-DOS and Win32, whose 'new process' API 
takes a single string of command-line parameters, and passes that 
single string directly to the new process.

When you type a command with some parameters at the command line, how 
does the program wind up with a sequence of command-line parameters?

Under Unix, the shell (usually /bin/sh or compatible) reads through the 
command-line and does all its special parsing - adding environment 
variables, constructing pipes, breaking up the string into 
space-delimited chunks, doing backslash-escaping and so forth, it 
searches the PATH environment variable for the location of the named 
program, and winds up with a full executable path and an array of 
string parameters which it hands off to the kernel, and your process is 
started. Because most shells have a well-designed meta-character set, 
you can spawn pretty much any program you like with pretty much any 
command-line you like (except for embedded nulls, of course) grouped in 
any way you like.

Under DOS/Win32, the shell (usually CMD.EXE) takes the command-line you 
give, searches $PATH for the executable, and hands the executable's 
path and the command-line string off to the kernel. The program that's 
started is responsible for parsing the given string into a list of 
parameters, and of course they all do it slightly differently. Some 
don't let you use filenames with spaces, some let you use filenames 
with spaces but don't let you use filenames with quotes, and so forth.

For example, under Unix, I can use 'python -c' to make instant Python 
scripts:

	python -c 'print &quot;Hello, \&quot;World\&quot;&quot;'

Under Win32, I don't believe I can do the above step because CMD.EXE 
always treats double-quotes as delimiting a filename with spaces. I 
can't make a single commandline parameter that includes embedded 
quotes.

&gt;<i> Now, I've got a command that needs to pipe something through another 
</I>&gt;<i> command, something like this:
</I>&gt;<i>
</I>&gt;<i> /bin/cat foo.txt | /usr/bin/tail
</I>
The reason for this is that piping is set up and executed by the shell, 
not the kernel. What you really need (to solve both these problems) is 
a way to get the shell to do all the dirty work for you - and luckily, 
such a feature exists. For the above example, instead of executing 
/bin/cat and handing it the other parameters try executing /bin/sh and 
giving it the parameters ['-c', '/bin/cat foo.txt | /usr/bin/tail']



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008302.html">[Twisted-Python] Question on using processes
</A></li>
	<LI>Next message: <A HREF="008306.html">[Twisted-Python] Question on using processes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8303">[ date ]</a>
              <a href="thread.html#8303">[ thread ]</a>
              <a href="subject.html#8303">[ subject ]</a>
              <a href="author.html#8303">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
