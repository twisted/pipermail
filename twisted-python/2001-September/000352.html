<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] WebDAV in twisted.web.server
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20WebDAV%20in%20twisted.web.server&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000351.html">
   <LINK REL="Next"  HREF="000353.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] WebDAV in twisted.web.server</H1>
    <B>Benjamin Bruheim</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20WebDAV%20in%20twisted.web.server&In-Reply-To="
       TITLE="[Twisted-Python] WebDAV in twisted.web.server">grolgh at online.no
       </A><BR>
    <I>Sun Sep  9 12:23:55 EDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000351.html">[Twisted-Python] Time out on client connections
</A></li>
        <LI>Next message: <A HREF="000353.html">[Twisted-Python] WebDAV in twisted.web.server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#352">[ date ]</a>
              <a href="thread.html#352">[ thread ]</a>
              <a href="subject.html#352">[ subject ]</a>
              <a href="author.html#352">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

I have been taking a look on WebDAV, especially RFC 2518, &quot;HTTP Extension for Distributed Authoring -- WEBDAV&quot;. The extension concerns four areas, queries and manipulation of properties, handling of collections, locking and namespace operations. The two last areas are not crucial.
Each of these areas has its set of methods, which is dispatched the same way as 'GET' and 'PUT', but usually with a XML-file appended to the request.

The twisted.web architecture of resources is well suited for adding WebDAV. resource.Resource is fitting the term Resource as it is used in the RFC. And twisted.web.server.Request's way of handling requests/responses seems open-ended enough too add a xml-reader/writer that concates the reply with XML (mimed). I will here try to examine the changes that need to be done to twisted.web.server (and protocols.http). Barely nothing else is examined, or needed.
I will blend some explanations into my proposal in case my understanding of twisted.* is wrong :).
 
The methods 'GET', 'PUT', 'HEAD', etc, is not touched by WebDAV. These methods by definitions only concern 'files' (eg. GET retrieves the entity described by the URI).
The WebDAV-Resource '/foo/' is a Resource Collection, and '/foo/file' is a member of the collection. If '/foo/faa/file' exists, then the 'faa'-collection needs to exist because the resource-tree has to be consistent. The trailing slash tells if the files is a collection or not; this is not a rule so the server may correct the client with a MOVED_PERMANENTLY in the same way web.static does. The tree may however contain non-DAV-compliant resources, so there won't be a need to force DAV onto everything. If a putChild should be put into a collection is a discussion on its own :) (I will however mean that a DAVResource should be a good starting point for making everything DAV, by letting the stuff to go DAV inherit DAVResource)
 
Since resource is the dispatcher of methods, then WebDAV can be a simple twisted.web.resource. The request has arguments in the Header and this gets conviently passed to the assigned resource. The request may contain an XML with additional arguments as well. Request.process seems to handle the task well, except that its 'POST'-handler may be rewritten to collect the XML for most methods.
'GET' is done in the regular way, no XML, just send the entity the URI point at (for collections, send eg. the index.html. I don't know the case here, really). This is resource-stuff. All the action will be in resource.render (it will render the response XML, I guess).

Minor thing, yet: If a request take long time to accomplish (eg. MOVE 100M of data over wire) there is a reply 102 PROCESSING which tells the client to keep the line open and wait. I don't know how the details, but I guess a NOT_DONE_YET may stop the block :) The problems with this is that it will send a response later on, I guess this can be hacked in.

The changes that need to be done to protocols.http is simply adding the new error-codes, since that is all that is in it :) If we want to add namespace operations (MOVE, COPY) the http-client needs to be made DAV-compliant. Note that COPY/MOVE also can be done by FTP too ;)

The changes:
Request.resource: retrieve the XML in the request.
Handle the response 102 PROCESSING
protocols.http: Errorcodes
The conclusion:
Everything will happen in the DAV-Resource. :)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20010909/e6e39950/attachment.htm">http://twistedmatrix.com/pipermail/twisted-python/attachments/20010909/e6e39950/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000351.html">[Twisted-Python] Time out on client connections
</A></li>
	<LI>Next message: <A HREF="000353.html">[Twisted-Python] WebDAV in twisted.web.server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#352">[ date ]</a>
              <a href="thread.html#352">[ thread ]</a>
              <a href="subject.html#352">[ subject ]</a>
              <a href="author.html#352">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
