<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Usenix paper on event dispatch mechanisms
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Usenix%20paper%20on%20event%20dispatch%20mechanisms&In-Reply-To=%3C20010917204909.654EF381F%40darjeeling%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="032877.html">
   <LINK REL="Next"  HREF="032879.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Usenix paper on event dispatch mechanisms</H1>
    <B>Moshe Zadka</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Usenix%20paper%20on%20event%20dispatch%20mechanisms&In-Reply-To=%3C20010917204909.654EF381F%40darjeeling%3E"
       TITLE="[Twisted-Python] Usenix paper on event dispatch mechanisms">m at moshez.org
       </A><BR>
    <I>Mon Sep 17 14:49:09 MDT 2001</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="032877.html">[Twisted-Python] Usenix paper on event dispatch mechanisms
</A></li>
        <LI>Next message (by thread): <A HREF="032879.html">[Twisted-Python] Usenix paper on event dispatch mechanisms
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32878">[ date ]</a>
              <a href="thread.html#32878">[ thread ]</a>
              <a href="subject.html#32878">[ subject ]</a>
              <a href="author.html#32878">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 17 Sep 2001, Itamar Shtull-Trauring &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">lists at itamarst.org</A>&gt; wrote:

&gt;<i> Relevance:
</I>&gt;<i> Doing multiple accept() calls  instead of one (after a select() call 
</I>&gt;<i> tells you a new connection is available) can speed up your application 
</I>&gt;<i> considerably under high loads.
</I>
Initial benchmarks show that this is a promising avenue. I got speed-ups
between 10% and 50% depending on the load.

Here is the improved Port class:

&gt;<i>---------- snip ------------&lt;
</I>import fcntl
import FCNTL

class Port(abstract.FileDescriptor):
    &quot;&quot;&quot;I am a TCP server port, listening for connections.

    When a connection is accepted, I will call my factory's buildProtocol with
    the incoming connection as an argument, according to the specification
    described in twisted.protocols.protocol.Factory.

    If you wish to change the sort of transport that will be used, my
    `transport' attribute will be called with the signature expected for
    Server.__init__, so it can be replaced.
    &quot;&quot;&quot;

    transport = Server
    sessionno = 0
    unixsocket = None
    interface = ''
    backlog = 5

    def __init__(self, port, factory, backlog=5, interface=''):
        &quot;&quot;&quot;Initialize with a numeric port to listen on.
        &quot;&quot;&quot;
        self.port = port
        self.factory = factory
        self.backlog = backlog
        self.interface = interface

    def __repr__(self):
        return &quot;&lt;%s on %s&gt;&quot; % (self.factory.__class__, self.port)

    def createInternetSocket(self):
        &quot;&quot;&quot;(internal) create an AF_INET socket.
        &quot;&quot;&quot;
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
        fcntl.fcntl(s.fileno(), FCNTL.F_SETFL, os.O_NONBLOCK)
        return s

    def __getstate__(self):
        &quot;&quot;&quot;(internal) get my state for persistence
        &quot;&quot;&quot;
        dct = copy.copy(self.__dict__)
        try: del dct['socket']
        except: pass
        try: del dct['fileno']
        except: pass

        return dct

    def startListening(self):
        &quot;&quot;&quot;Create and bind my socket, and begin listening on it.

        This is called on unserialization, and must be called after creating a
        server to begin listening on the specified port.
        &quot;&quot;&quot;
        log.msg(&quot;%s starting on %s&quot;%(self.factory.__class__, self.port))
        if type(self.port) == types.StringType:
            skt = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            skt.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            skt.bind(self.port)
            # Make the socket readable and writable to the world.
            mode = os.stat(self.port)[0]
            os.chmod(self.port, mode | stat.S_IROTH | stat.S_IWOTH)
            self.unixsocket = 1
        else:
            skt = self.createInternetSocket()
            skt.bind( (self.interface, self.port) )
        skt.listen(self.backlog)
        self.connected = 1
        self.socket = skt
        self.fileno = self.socket.fileno
        self.startReading()

    def doRead(self):
        &quot;&quot;&quot;Called when my socket is ready for reading.

        This accepts a connection and callse self.protocol() to handle the
        wire-level protocol.
        &quot;&quot;&quot;
        try:
            for i in range(40):
                try:
                    skt,addr = self.socket.accept()
                except socket.error, e:
                    if e.args[0] == EWOULDBLOCK:
                        break
                    raise
                protocol = self.factory.buildProtocol(addr)
                s = self.sessionno
                self.sessionno = s+1
                transport = self.transport(skt, protocol, addr, self, s)
                protocol.makeConnection(transport, self)
        except:
            traceback.print_exc(file=log.logfile)

    def doWrite(self):
        &quot;&quot;&quot;Raises an AssertionError.
        &quot;&quot;&quot;
        assert 0, &quot;doWrite called on a %s&quot; % str(self.__class__)

    def loseConnection(self):
        &quot;&quot;&quot; Stop accepting connections on this port.

        This will shut down my socket and call self.connectionLost().
        &quot;&quot;&quot;
        # Since ports can't, by definition, write any data, we can just close
        # instantly (no need for the more complex stuff for selectables which
        # write)
        self.stopReading()
        self.connectionLost()

    def connectionLost(self):
        &quot;&quot;&quot;Cleans up my socket.
        &quot;&quot;&quot;
        log.msg('(Port %s Closed)' % self.port)
        abstract.FileDescriptor.connectionLost(self)
        self.connected = 0
        self.socket.close()
        if self.unixsocket:
            os.unlink(self.port)
        del self.socket
        del self.fileno

    def logPrefix(self):
        &quot;&quot;&quot;Returns the name of my class, to prefix log entries with.
        &quot;&quot;&quot;
        return str(self.factory.__class__)

&gt;<i>------------ snip ----------------&lt;
</I>
-- 
The Official Moshe Zadka FAQ: <A HREF="http://moshez.geek">http://moshez.geek</A>
The Official Moshe Zadka FAQ For Dummies: <A HREF="http://moshez.org">http://moshez.org</A>
Read the FAQ



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="032877.html">[Twisted-Python] Usenix paper on event dispatch mechanisms
</A></li>
	<LI>Next message (by thread): <A HREF="032879.html">[Twisted-Python] Usenix paper on event dispatch mechanisms
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32878">[ date ]</a>
              <a href="thread.html#32878">[ thread ]</a>
              <a href="subject.html#32878">[ subject ]</a>
              <a href="author.html#32878">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
