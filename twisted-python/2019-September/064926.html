<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] In memory cache in twisted
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20In%20memory%20cache%20in%20twisted&In-Reply-To=%3C11135650.vblT0CJW4X%40hyperion%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="064930.html">
   <LINK REL="Next"  HREF="064927.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] In memory cache in twisted</H1>
    <B>Maarten ter Huurne</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20In%20memory%20cache%20in%20twisted&In-Reply-To=%3C11135650.vblT0CJW4X%40hyperion%3E"
       TITLE="[Twisted-Python] In memory cache in twisted">maarten at treewalker.org
       </A><BR>
    <I>Thu Sep 26 21:39:59 MDT 2019</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="064930.html">[Twisted-Python] In memory cache in twisted
</A></li>
        <LI>Next message (by thread): <A HREF="064927.html">[Twisted-Python] In memory cache in twisted
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#64926">[ date ]</a>
              <a href="thread.html#64926">[ thread ]</a>
              <a href="subject.html#64926">[ subject ]</a>
              <a href="author.html#64926">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Friday, 27 September 2019 04:38:46 CEST Waqar Khan wrote:
&gt;<i> Hi,
</I>&gt;<i>   What's a good way to use a simple dictionary as a cache in twisted
</I>&gt;<i> framework?
</I>&gt;<i> Basically, I have this callback chain where I ultimately make a rest
</I>&gt;<i> call (in non-blocking way using treq) to fetch some data. But before
</I>&gt;<i> I make the call, I am using a dictionary to see if the value is
</I>&gt;<i> available or not. But, I have noticed that the event loop gets pretty
</I>&gt;<i> busy(sometimes, things get stuck and twisted server stops) as soon as
</I>&gt;<i> I add this logic.. Which is pretty much
</I>&gt;<i> 
</I>&gt;<i> @defer.inlinecallbacks
</I>&gt;<i> def fetch(key):
</I>&gt;<i>       if key in cache:
</I>&gt;<i>                return cache[key]
</I>&gt;<i>       # else call back to treq to fetch value
</I>&gt;<i>        cache[key] = value
</I>&gt;<i>        return value
</I>&gt;<i> 
</I>&gt;<i> This dict can grow to around 50k.. What's a good way to solve this
</I>&gt;<i> issue?
</I>
If it gets stuck, then the cause for that is probably in the part of the 
code you omitted. So it would help to elaborate on how the value is 
fetched exactly.

I can see two other problems with this caching mechanism though:

1. Items are never removed from the cache, so unless there is a limit to 
the number of different keys that can be used, the cache can grow 
indefinitely. You might want something like an LRU cache rather than a 
plain dictionary.

<A HREF="https://docs.python.org/3/library/functools.html#functools.lru_cache">https://docs.python.org/3/library/functools.html#functools.lru_cache</A>

2. If a lot of clients are requesting the same thing, you won't see any 
benefits from caching until the first request completes. So you could 
get a pattern like this:

T=0: key A requested, A is not cached, start fetch #1 of A
T=1: key A requested, A is not cached, start fetch #2 of A
T=2: key A requested, A is not cached, start fetch #3 of A
T=3: key A requested, A is not cached, start fetch #4 of A
T=4: key A requested, A is not cached, start fetch #5 of A
T=5: fetch #1 of A completes and is added to the cache
T=6: key A requested, A is cached, return value immediately

In this example, the value for A is fetched 5 times despite the caching  
mechanism. If the fetching takes a long time compared to the rate at 
which requests are coming in, this effect gets worse at a quadratic 
rate: the total time spent fetching is the number of requests that come 
in during the fetching of the first request times the duration of the 
fetch.

To avoid this, you could put a Deferred for the fetch operation in the 
cache or in a separate dictionary and if you get another request for the 
same key before the fetch completes, return that Deferred instead of 
starting another fetch.

Bye,
		Maarten




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="064930.html">[Twisted-Python] In memory cache in twisted
</A></li>
	<LI>Next message (by thread): <A HREF="064927.html">[Twisted-Python] In memory cache in twisted
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#64926">[ date ]</a>
              <a href="thread.html#64926">[ thread ]</a>
              <a href="subject.html#64926">[ subject ]</a>
              <a href="author.html#64926">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
