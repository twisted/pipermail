<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: gthreadless.py
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20gthreadless.py&In-Reply-To=df0180%24jfu%241%40sea.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011254.html">
   <LINK REL="Next"  HREF="011260.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: gthreadless.py</H1>
    <B>Stefano Masini</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20gthreadless.py&In-Reply-To=df0180%24jfu%241%40sea.gmane.org"
       TITLE="[Twisted-Python] Re: gthreadless.py">stefano at pragma2000.com
       </A><BR>
    <I>Tue Aug 30 02:47:28 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011254.html">[Twisted-Python] Re: gthreadless.py
</A></li>
        <LI>Next message: <A HREF="011260.html">[Twisted-Python] Re: gthreadless.py
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11258">[ date ]</a>
              <a href="thread.html#11258">[ thread ]</a>
              <a href="subject.html#11258">[ subject ]</a>
              <a href="author.html#11258">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 8/30/05, Nicola Larosa &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">nico at teknico.net</A>&gt; wrote:
&gt;<i> From v.2.0, inside the twisted/internet/defer.py there are one class,
</I>&gt;<i> waitForDeferred, and one function, deferredGenerator, that implement a
</I>&gt;<i> similar pseudo-synchronous style, but using standard generators instead of
</I>&gt;<i> greenlets.
</I>
I'm familiar with deferredGenerator. I've been using twisted full time
for two years and a half now and used deferredGenerator for quite a
lot too. That's why I reimplemented gthreadless! :)
 
&gt;<i> Furthermore, PEP 342 has been accepted for v.2.5:
</I>&gt;<i> 
</I>&gt;<i> Coroutines via Enhanced Generators
</I>&gt;<i> <A HREF="http://www.python.org/peps/pep-0342.html">http://www.python.org/peps/pep-0342.html</A>
</I>&gt;<i> 
</I>&gt;<i> its enhancements should further simplify such a coding style in Twisted.
</I>
The problem with generators and enhanced generators, as I've been
discussing with a few people at Europython, is that they allow you to
jump back and forth between two stack *frames*. Whereas greenlets
support jumping among *full* stacks. This means that from within a
@deferredGreenlet'ed function you can make calls to other functions
that call blockOn, while from a @deferredGenerator'ed function you
can't call a method that in turn calls waitForDeferred.
 
While this may seems quite a subtle difference, I think it is not if
you look at it from the perspective of code readability -- let alone
the 3 liner horrible hack that waitForDeferred forces you to, at least
until PEP 342, as we all know.
 
&gt;<i> However, a couple of recent blog entries show that this way of &quot;hiding&quot;
</I>&gt;<i> Deferreds raises some eyebrows within Twisted's inner circle:
</I>&gt;<i> 
</I>&gt;<i> Magical Concurrency Faeries or How I Learned To Stop Worrying and Love
</I>&gt;<i> Deferreds
</I>&gt;<i> <A HREF="http://www.livejournal.com/users/jcalderone/9531.html">http://www.livejournal.com/users/jcalderone/9531.html</A>
</I>&gt;<i> 
</I>&gt;<i> Knowing Santa Claus is Fake Doesn't Ruin Christmas
</I>&gt;<i> <A HREF="http://www.livejournal.com/users/glyf/40037.html">http://www.livejournal.com/users/glyf/40037.html</A>
</I>&gt;<i> 
</I>&gt;<i> Personally, I think that while explicitly specifying deferreds and
</I>&gt;<i> callbacks and errbacks can be quite verbose, and may sometimes obscure the
</I>&gt;<i> program flow, the comfort of seeing clearly the boundaries of each
</I>&gt;<i> uninterruptible execution unit makes it worthwhile.
</I>&gt;<i> 
</I>
Believe me. I'm not one of those users in the &quot;periphery of the
Twisted community&quot; thinking that asynchronous programming is too hard.
I've been writing network code for quite a while and I matured the
idea that threads get in your way back when I still didn't know
python.
What I'm only concerned about now is coding *style*. Making code
better looking, thus more easily maintainable.
I rewrote gthreadless because having a usable implementation allowed
rewriting parts of my existing (big) application in a much simpler
way. And let me stress this: *parts* of it. I think gthreadless should
only be used here and there, not everywhere. One should always keep
thinking of deferreds, and even inside a @deferredGreenlet'ed function
one should be very clear that blockOn() really only spits back a
deferred to the reactor. But at least, you can debug your function
without having to jump back and forth 40 lines at a time just to get
to the proper callback or errback. I think sometimes this verbosity
may get in the way of the pythonic spirit of keeping stuff simple.
 
Here is an example that makes justice to this approach. It involves
Perspective Broker. Think of writing a web frontend to an application
on the backend that exports functionality through pb. (the code may
not work, I'm just making it up now without testing it)
(I hope everybody is familiar with nevow.stan. If not, take a look at
it. It's worth.)
 
@deferredGreenlet
def renderPage(self):
    dataList = [ blockOn(self.backend.callRemote('getDataFromId', elementId))
                        for elementId in self.idList]
    return T.html[ T.body [ 'The result:', T.br, [ (txt, T.br) for txt
in dataList ] ] ]

Without gthreadless:

def renderPage(self):
    dataList = []
    def fetchDataRemotely(elementList):
        def cbFetch(elementData):
            dataList.append(elementData)
            if len(elementList) &gt; 0:
                return fetchDataRemotely(elementList[1:])
        return self.backend.callRemote('getDataFromId',
elementId).addCallback(cbFetch)
    def cb(crap):
        return T.html[ T.body [ 'The result:', T.br, [ (txt, T.br) for
txt in dataList ] ] ]
    return fetchDataRemotely(self.idList).addCallback(cb)

I hope everyone agrees that the level of complexity in *reading* and
*understanting* what the above code snippets do is not the same.
The above code could have actually been written the same way using
deferredGenerator and PEP 342, or in a slightly more verbose way
without PEP 342. But the example is simple. If instead of simply
callRemote() you had to use another method, that in turn needed
callRemote, maybe a couple of times (very possible if you use pb),
then greenlets would have been indispensable, in order to keep the
renderPage() the same as you saw.

Cheers,
stefano


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011254.html">[Twisted-Python] Re: gthreadless.py
</A></li>
	<LI>Next message: <A HREF="011260.html">[Twisted-Python] Re: gthreadless.py
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11258">[ date ]</a>
              <a href="thread.html#11258">[ thread ]</a>
              <a href="subject.html#11258">[ subject ]</a>
              <a href="author.html#11258">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
