<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: gthreadless.py
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20gthreadless.py&In-Reply-To=%3C4327422405083007362cc98f3a%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="043768.html">
   <LINK REL="Next"  HREF="043769.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: gthreadless.py</H1>
    <B>Stefano Masini</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20gthreadless.py&In-Reply-To=%3C4327422405083007362cc98f3a%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Re: gthreadless.py">stefano at pragma2000.com
       </A><BR>
    <I>Tue Aug 30 08:36:43 MDT 2005</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="043768.html">[Twisted-Python] Re: gthreadless.py
</A></li>
        <LI>Next message (by thread): <A HREF="043769.html">[Twisted-Python] Re: gthreadless.py
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#43770">[ date ]</a>
              <a href="thread.html#43770">[ thread ]</a>
              <a href="subject.html#43770">[ subject ]</a>
              <a href="author.html#43770">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 8/30/05, Christopher Armstrong &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">radeex at gmail.com</A>&gt; wrote:
&gt;<i> The effect that being able to call things that do context switches
</I>&gt;<i> without explicitly marking them as doing so is much farther reaching
</I>&gt;<i> than code readability. I consider it something of a feature that
</I>&gt;<i> deferredGenerator forces you to know when context switches will happen
</I>&gt;<i> at every level, and when I wrote gthreadless I was not intending it to
</I>&gt;<i> be used in a way that didn't require that same knowledge at every
</I>&gt;<i> level. And I don't think that this extra knowledge along the line
</I>&gt;<i> isn't detracting at all to readability, but instead helping it.
</I>
I can agree on this.

&gt;<i> And, just for onlookers, I'd like to point out that the code example
</I>&gt;<i> below is not showing the difference between non-explicit-greenlets and
</I>&gt;<i> explicit-defgen, but instead showing the difference between
</I>&gt;<i> explicit-greenlets and plain ond deferreds, which most of us in the
</I>
You are perfectly right.
After my first post the discussion went on privately between me and
Nicola, so I should post some of it here, since it contains exactly
such example.

I'll elaborate a bit on my first example, that was as follows (just to
remind and get started with the rest):

@deferredGreenlet
def renderPage(self):
  dataList = [ blockOn(self.backend.callRemote('getDataFromId', elementId))
                      for elementId in self.idList]
  return T.html[ T.body [ 'The result:', T.br, [ (txt, T.br) for txt
in dataList ] ] ]

I basically build a list of values obtained by performing subsequent
calls to callRemote(), everytime passing a parameter from a list.

Let's say that instead of a list of parameters we have a list of
objects, and I build the list of values by calling a method on each of
these objects. Like so:

def renderPage(self):
  dataList = [ element.getData() for element in self.elementList ]
  return T.html[ T.body [ 'The result:', T.br, [ (txt, T.br) for txt
in dataList ] ] ]

As you can see, I took out @deferredGreenlet for now, because it's not needed.
Let's say that self.elementList is made of objects defined like this:

class ElementObject(object):
   def getData(self):
       return 1

Indeed @deferredGreenlet is not needed because I'm not even using pb.

Now, let's say that in a new version of the software I introduce
objects that in order to obtain the result of getData() have to go and
query a remote server through pb. Things get more complicated now
because getData() would return a deferred, while other objects would
return a straight result. This difference is very uncomfortable to
live with because you don't know how to treat the result. The are two
ways out, and in both cases you have to change code you've already
written:
1) return defer.succeed(1) instead of return 1
2) defer.maybeDeferred(element.getData()) instead of element.getData()

In other words, as soon as a blocking method pops up among your
methods, you're forced to change and treat all of them as blocking,
even by making up deferred if needed.
In any case, you're also compelled to change the code of renderPage()
from synchronos style to asynchronous, unless you use waitForDeferred.

I often found myself propagating maybeDeferred's back up several
levels in my code, and I didn't like it, to tell the truth.

On the other hand, if you use greenlets, you can keep renderPage the
same exact way as I wrote it the first time, you just need to decorate
it with @deferredGreenlet. And those methods that perform blocking
calls, simply need to wrap the deferreds with blockOn, and that's it.

Yes, I agree on the following point: code that you though was non
blocking, now can all of a sudden become blocking. In this respect,
yes, a gthreadless implementation that would force you to decorate
every method along the way could help gaining awareness.

But let's think about it: why is it so bad that a method that was
supposed to be non blocking now becomes blocking? I can't think of
anything else than shared resources that now can get accessed
concurrently by other parts of code. Right?
But this problem persists with pure-deferred programming style too!
The problem of concurrent access to shared resources does not depend
on the programming model being synchronous or asynchronous, but simply
on the presence of blocking operations. You have to use locks if you
want to protect a shared resource while you block on a lengthy
operation, no matter what programming model you're using.

So, I hope this example makes my point a little more clear. As I was
saying with Nicola, I don't think gthreadless should be used
everywhere, like it was a solution to some horrible problem with
asynchronous programming. Using deferreds is just great and the
awareness you gain of the internals of your implementation by using
them is just irreplaceable.
But *some* code snippets just come out so much more naturally if you
write them using a synchronous model, that being able to mix the two
is just a terrific feature I think.

cheers,
stefano


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="043768.html">[Twisted-Python] Re: gthreadless.py
</A></li>
	<LI>Next message (by thread): <A HREF="043769.html">[Twisted-Python] Re: gthreadless.py
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#43770">[ date ]</a>
              <a href="thread.html#43770">[ thread ]</a>
              <a href="subject.html#43770">[ subject ]</a>
              <a href="author.html#43770">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
