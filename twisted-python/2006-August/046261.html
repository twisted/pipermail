<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] &quot;Injecting&quot; a callWhenRunning when the reactor is	already running?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20%22Injecting%22%20a%20callWhenRunning%20when%20the%20reactor%20is%0A%09already%20running%3F&In-Reply-To=%3C44CF8ABD.7040404%40ussonet.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="046260.html">
   <LINK REL="Next"  HREF="046264.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] &quot;Injecting&quot; a callWhenRunning when the reactor is	already running?</H1>
    <B>justind2 at ussonet.net</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20%22Injecting%22%20a%20callWhenRunning%20when%20the%20reactor%20is%0A%09already%20running%3F&In-Reply-To=%3C44CF8ABD.7040404%40ussonet.net%3E"
       TITLE="[Twisted-Python] &quot;Injecting&quot; a callWhenRunning when the reactor is	already running?">justind2 at ussonet.net
       </A><BR>
    <I>Tue Aug  1 11:09:17 MDT 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="046260.html">[Twisted-Python] How to tell when ReconnectingClientFactory gives up
</A></li>
        <LI>Next message (by thread): <A HREF="046264.html">[Twisted-Python] &quot;Injecting&quot; a callWhenRunning when the reactor	is already running?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46261">[ date ]</a>
              <a href="thread.html#46261">[ thread ]</a>
              <a href="subject.html#46261">[ subject ]</a>
              <a href="author.html#46261">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Here is a script I've made and am playing with to try to understand how 
things behave in Twisted. I'm using twistedsnmp but I think my problem 
here is my understanding of how to use the reactor (or lack there of).

I feel like I'm misunderstanding some fundamentals, but I may just be 
hard-headed.

I'm not even sure if this makes sense. I've noticed that unless 
reactor.callWhenRunning(return_def,df) is ran prior to calling 
reactor.run() the return_def will never be ran.

I'm not really sure how to phrase the question, because it may be the 
wrong one.. so here goes...

Is there a way to get the reactor to acknowledge a new &quot;callWhenRunning&quot; 
after the reactor.run()?


I've included my bad code and working code, the difference is in the 
&quot;bad code&quot; I launch a thread that tries every 5 seconds (after 
reactor.run()) to do what the &quot;working code&quot; does only once before.

Any help would be appreciated.


BAD CODE BELOW:

from twisted.internet import reactor
from twisted.internet import task
from twistedsnmp import snmpprotocol, agentproxy
from twisted.internet.defer import TimeoutError
import pprint
import logging
import thread
import time

logging.getLogger().setLevel(logging.INFO)

ips = 
['10.0.16.2','10.0.16.18','10.0.16.34','10.0.16.66','10.0.16.82','10.0.16.98','10.0.16.114','10.0.16.130']

devices = {}

logging.info('Building device dictionary')
for ip in ips:
    devices[ip] = {}
    devices[ip]['oids_to_poll'] = {}
    devices[ip]['oids_to_poll']['sysDescr'] = '.1.3.6.1.2.1.1.0'
    devices[ip]['oids_to_poll']['uptime'] = '.1.3.6.1.2.1.1.3.0'
logging.info('Device dictionary built')

   
def successful_response(result):
    logging.info(str(result))
    return result

def errored_response(err):
    if err.trap(TimeoutError):
        logging.error(&quot;timeout error&quot;)
        #### dont return the error because it will be handeled if you do
    else:
        logging.error(&quot;error&quot; + str(err))
        return err

def return_def(df):
    return df


def process_devices():
    logging.info(&quot;proccess_devices thread has been launched&quot;)
    while True:
        time.sleep(5)
        for device in devices.keys():
            #### first build the proxy
            try:
                logging.info(&quot;building proxy for device:&quot; + str(device))
                port = snmpprotocol.port()
                proxy = agentproxy.AgentProxy(device, 161, 
community='public',snmpVersion='v2',protocol=port.protocol,)
            except:
                logging.exception(&quot;exception occured while building proxy&quot;)
            else:
                ##### now that the proxy is buil send the request for 
the oids to poll
                if devices.has_key(device):
                    try:
                        oid_descriptions = 
devices[device]['oids_to_poll'].keys()
                    except:
                        pass
                    else:
                        try:
                            oids = []
                            for oid_description in oid_descriptions:
                                
oids.append(devices[device]['oids_to_poll'][oid_description])
                        except:
                            pass
                        else:
                            ##### you have built the list of oids to 
poll now build the deffered and return it
                            logging.info(&quot;building defferred for 
device:&quot; + str(device))
                            df = proxy.get(oids, timeout=0.25, retryCount=3)
                            df.addCallback(successful_response)
                            df.addErrback(errored_response)
                            logging.info(&quot;launching callWhenRunning for 
device:&quot; + str(device))
                            reactor.callWhenRunning(return_def,df)

thread.start_new(process_devices,())
logging.info(&quot;starting reactor&quot;)
reactor.run()



WORKING CODE (not necessarily good):

from twisted.internet import reactor
from twisted.internet import task
from twistedsnmp import snmpprotocol, agentproxy
from twisted.internet.defer import TimeoutError
import pprint
import logging
import time

logging.getLogger().setLevel(logging.INFO)

ips = 
['10.0.16.2','10.0.16.18','10.0.16.34','10.0.16.66','10.0.16.82','10.0.16.98','10.0.16.114','10.0.16.130']

devices = {}

logging.info('Building device dictionary')
for ip in ips:
    devices[ip] = {}
    devices[ip]['oids_to_poll'] = {}
    devices[ip]['oids_to_poll']['sysDescr'] = '.1.3.6.1.2.1.1.0'
    devices[ip]['oids_to_poll']['uptime'] = '.1.3.6.1.2.1.1.3.0'
logging.info('Device dictionary built')

   
def successful_response(result):
    logging.info(str(result))
    return result

def errored_response(err):
    if err.trap(TimeoutError):
        logging.error(&quot;timeout error&quot;)
        #### dont return the error because it will be handeled if you do
    else:
        logging.error(&quot;error&quot; + str(err))
        return err

def return_def(df):
    return df


def process_devices():
    logging.info(&quot;proccess_devices thread has been launched&quot;)
        for device in devices.keys():
            #### first build the proxy
            try:
                logging.info(&quot;building proxy for device:&quot; + str(device))
                port = snmpprotocol.port()
                proxy = agentproxy.AgentProxy(device, 161, 
community='public',snmpVersion='v2',protocol=port.protocol,)
            except:
                logging.exception(&quot;exception occured while building proxy&quot;)
            else:
                ##### now that the proxy is buil send the request for 
the oids to poll
                if devices.has_key(device):
                    try:
                        oid_descriptions = 
devices[device]['oids_to_poll'].keys()
                    except:
                        pass
                    else:
                        try:
                            oids = []
                            for oid_description in oid_descriptions:
                                
oids.append(devices[device]['oids_to_poll'][oid_description])
                        except:
                            pass
                        else:
                            ##### you have built the list of oids to 
poll now build the deffered and return it
                            logging.info(&quot;building defferred for 
device:&quot; + str(device))
                            df = proxy.get(oids, timeout=0.25, retryCount=3)
                            df.addCallback(successful_response)
                            df.addErrback(errored_response)
                            logging.info(&quot;launching callWhenRunning for 
device:&quot; + str(device))
                            reactor.callWhenRunning(return_def,df)

process_devices()
logging.info(&quot;starting reactor&quot;)
reactor.run()














</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="046260.html">[Twisted-Python] How to tell when ReconnectingClientFactory gives up
</A></li>
	<LI>Next message (by thread): <A HREF="046264.html">[Twisted-Python] &quot;Injecting&quot; a callWhenRunning when the reactor	is already running?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46261">[ date ]</a>
              <a href="thread.html#46261">[ thread ]</a>
              <a href="subject.html#46261">[ subject ]</a>
              <a href="author.html#46261">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
