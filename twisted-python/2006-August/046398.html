<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Multicast XMLRPC
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=%3C20060825221340.1717.332837840.divmod.quotient.31247%40ohm%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="046395.html">
   <LINK REL="Next"  HREF="046399.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Multicast XMLRPC</H1>
    <B>glyph at divmod.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=%3C20060825221340.1717.332837840.divmod.quotient.31247%40ohm%3E"
       TITLE="[Twisted-Python] Multicast XMLRPC">glyph at divmod.com
       </A><BR>
    <I>Fri Aug 25 16:13:40 MDT 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="046395.html">[Twisted-Python] Multicast XMLRPC
</A></li>
        <LI>Next message (by thread): <A HREF="046399.html">[Twisted-Python] Multicast XMLRPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46398">[ date ]</a>
              <a href="thread.html#46398">[ thread ]</a>
              <a href="subject.html#46398">[ subject ]</a>
              <a href="author.html#46398">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 25 Aug 2006 16:33:52 -0400, &quot;Chaz.&quot; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">eprparadocs at gmail.com</A>&gt; wrote:
&gt;<i><A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
</I>
&gt;&gt;<i>I'm still not really clear on what the application is.
</I>&gt;<i>
</I>&gt;<i>The application is a massively scalable data storage system.
</I>
Okay!  Now I know what you're getting at :).

&gt;<i>This is not a &quot;home application&quot; but an enterprise and/or SSP application. 
</I>&gt;<i>Most likely it sits behind a firewall and if remote offices need to access 
</I>&gt;<i>it, they will get access via VPN portals.
</I>&gt;<i>
</I>&gt;<i>I guess this is sort of a topology! Doh. All I know is that I have multicast 
</I>&gt;<i>and with some effort broadcast support.
</I>
OK, that makes more sense.

&gt;&gt;<i>At any rate, producing a functioning multiunicast prototype with, e.g. PB, 
</I>&gt;&gt;<i>would be the easiest way to get started if you need to fall back to that 
</I>&gt;&gt;<i>sort of topology anyway in the case where a multicast solution doesn't 
</I>&gt;&gt;<i>work.  Then you can collect data and determine how much bandwidth is going 
</I>&gt;&gt;<i>to be saved in a realistic scenario...
</I>&gt;<i>
</I>&gt;<i>So I can use PB with multicast support? How would I deal with all the target 
</I>&gt;<i>machines getting responses back&gt;
</I>
My point here was really not anything about PB specifically.  Using PB with multicast would require some tricks; you'd have to have a different Broker implementation, probably, and a datagram-based API.  You could still use the underlying message serialization format though.

&gt;<i>I had thought of the hub-and-spoke model and I designed the system that way, 
</I>&gt;<i>originally. But I have to respond to instantaneous demands which caused me 
</I>&gt;<i>to change the design of the system. Each of the servers can run as both 
</I>&gt;<i>servers (providing a service to a client app) and an end point (providing 
</I>&gt;<i>storage features). So a hub-and-spoke architecture are really out of the 
</I>&gt;<i>picture for me (at least I can't see an easy way).
</I>
I don't see that it's out of the picture - your network topology allows you to fairly effortlessly connect between machines (no need for NAT traversal or &quot;home servers&quot; or any of that garbage: just give an IP on the intranet) - just include the &quot;hub&quot; and &quot;spoke&quot; code in the same process, and then any process can act as a hub... dynamic load-balancing is never easy, but it is certainly a possibility.

&gt;<i>I could probably do a self-organizing overlay network on top of the machines 
</I>&gt;<i>taking advantage of how they are connected together (the real physical 
</I>&gt;<i>topology) but even that presents me with an issue: I want the system to sort 
</I>&gt;<i>of be self-configuring. As such I don't have a way to auto-detect connection 
</I>&gt;<i>speeds.
</I>
You can detect connection speeds on the fly; just start doing some work, gather statistics on each connection, and reconfigure if it's not going fast enough.  No need for clock synchronization.

&gt;&gt;&gt;<i>Today the underlying transport and tomorrow the marshallings.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>It still seems to me like this is backwards.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The application can be complete, end-to-end, if you start marshalling data 
</I>&gt;&gt;<i>and sending it over a simplistic (but possibly too-expensive) mechanism. 
</I>&gt;&gt;<i>(...)
</I>&gt;<i>That is certainly one way. I tend to think all my hard problems are going to 
</I>&gt;<i>be transport issues and work up the stack. I have had a share of algorithm 
</I>&gt;<i>issues too; nothing is quite obvious when you have a 1000 or 10,000 machines 
</I>&gt;<i>to deal with!
</I>
Working up the stack is difficult because you can't measure the working system at any point to decide what you need to optimize.  I prefer to work downwards.  If your highest level of code can remain unchanged while you refactor the underlying layers, then you can run the same tests for the same high-level code with different underlying layers to get an idea of their relative performance.  If you start optimizing at the bottom of the stack before the top is done, then you can easily end up with something which is optimized in the wrong direction, and which requires rewriting when the top layer is done anyway.

I guess this doesn't really have much bearing on your other questions though.

&gt;&gt;&gt;<i>Now let me address the issue of TCP. It is a pretty heavy protocol to use. 
</I>
&gt;&gt;<i>I still don't know what you mean by &quot;resources&quot;, and as compared to what. 
</I>
&gt;<i>By resources I mean memory and time. Granted on a 1GB system with 3 GB of 
</I>&gt;<i>virtual, memory isn't a big deal, most of the times. But I have seen memory 
</I>&gt;<i>leaks kill this sucker more times than I care to recall. Once I ran the 
</I>&gt;<i>application for a few days and saw all my swap being used! It was very 
</I>&gt;<i>subtle memory leak in one of the libraries (in fact one library leak 
</I>&gt;<i>consumed 584M in less than one hour!).
</I>
I notice you don't specifically refer to features of TCP here, but instead of the perils of writing any software at all in C/C++ :).  Of course, Python can have memory leaks, but I wouldn't base your architecture around bugs in libraries which will hopefully be unnecessary in the future :).

&gt;<i>Yes, I completely forgot that I would see them all in parallel. I tend to 
</I>&gt;<i>overlook Twisted's state machine architecture when I think of solutions. I 
</I>&gt;<i>am getting better but not quite there yet...
</I>
It might not solve your problem.  But Twisted may be doing quite a lot more work in &quot;parallel&quot; than you're used to.  I can't really say, but I'd be curious to hear about it if you measure it.

&gt;&gt;<i> (Threads are bad)
</I>&gt;<i>Yes...see my mea culpa above....it is hard to stop thinking in terms of 
</I>&gt;<i>threads and processes!
</I>
Yeah, it took me a while to get out of that habit when I started writing Twisted in the first place :).  (The thing that preceded it was a blocking, multithreaded abomination.)

&gt;<i>Do the games use TCP or UDP? I would have thought they save state about each 
</I>&gt;<i>of the players in the server and use UDP for message passing. I thought that 
</I>&gt;<i>was part of the reason most game developers where interested in STUN?
</I>
They ... vary.  A general rule of thumb is that they use TCP (or something like it) for control messages and data transfer, and then an *unreliable* most-recent-first UDP protocol for transmitting information about physical position, orientation and movement.  Game protocols are incredibly involved because they're typically communicating information about a dozen systems at once.  Game performance is different than typical application performance because quite often you only care about the most recent state of something, and you can happily throw away any old messages.

The games that are interested in STUN are not MMPs; the reason they are using it is to establish P2P connections so that players don't have to receive their updates from a central server, and you don't need to configure your firewall to play.

&gt;<i>Bandwidth is a very important issue in this system. No one would run this on 
</I>&gt;<i>their network if it could bring down their network (or congest it so badly 
</I>&gt;<i>...the old packet-storm issue).
</I>
This is another good reason to use TCP.  There are congestion control mechanisms for TCP; you would have to implement something yourself for UDP.

&gt;<i>As I mentioned earlier, if I was to do normal heartbeat messages with N 
</I>&gt;<i>machines, I have N! messages moving around. So long as N is small - a few 
</I>&gt;<i>hundred machines (and I have built machines in the telecom world that have 
</I>&gt;<i>had 100 machines), the load on the network is reasonable. But once you have 
</I>&gt;<i>1000 machines, you have a 1,000,000 messages flying around. Through the work 
</I>&gt;<i>I did I got the number down to 2,000! And over 15 seconds, that isn't too 
</I>&gt;<i>bad.
</I>
Why N! messages?  Using a naive hub-and-spoke model it seems like it would just be 2N.  It's only if every node needs to know about every other node that you get up to N!... why would you need that?


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="046395.html">[Twisted-Python] Multicast XMLRPC
</A></li>
	<LI>Next message (by thread): <A HREF="046399.html">[Twisted-Python] Multicast XMLRPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46398">[ date ]</a>
              <a href="thread.html#46398">[ thread ]</a>
              <a href="subject.html#46398">[ subject ]</a>
              <a href="author.html#46398">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
