<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Multicast XMLRPC
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=20060826214328.1717.1085775059.divmod.quotient.31946%40ohm">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013897.html">
   <LINK REL="Next"  HREF="013868.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Multicast XMLRPC</H1>
    <B>Chaz.</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=20060826214328.1717.1085775059.divmod.quotient.31946%40ohm"
       TITLE="[Twisted-Python] Multicast XMLRPC">eprparadocs at gmail.com
       </A><BR>
    <I>Sat Aug 26 19:25:40 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="013897.html">[Twisted-Python] Multicast XMLRPC
</A></li>
        <LI>Next message: <A HREF="013868.html">[Twisted-Python] Not subclassing internet.TCPServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13898">[ date ]</a>
              <a href="thread.html#13898">[ thread ]</a>
              <a href="subject.html#13898">[ subject ]</a>
              <a href="author.html#13898">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
&gt;<i> On Sat, 26 Aug 2006 10:14:48 -0400, &quot;Chaz.&quot; &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">eprparadocs at gmail.com</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Right now I am trying to find a solution to an interesting problem: 
</I>&gt;&gt;<i> how to find a file without knowing exactly where it exists in the 
</I>&gt;&gt;<i> network. You have to do this to make the system scale nicely.
</I>&gt;<i> 
</I>&gt;&gt;<i> Basically each node holds information about the files (aka objects) it 
</I>&gt;&gt;<i> stores. I do this so that I don't have a central database any where 
</I>&gt;&gt;<i> (this allows the system to scale differently. With a central database 
</I>&gt;&gt;<i> I would have that set of servers scale differently than the storage 
</I>&gt;&gt;<i> nodes).
</I>&gt;<i> 
</I>&gt;&gt;<i> Now I can build a set of machines that are the distributed database 
</I>&gt;&gt;<i> machines - each storing something - and querying them for where the 
</I>&gt;&gt;<i> file lives; this would narrow the machines I have to directly talk to, 
</I>&gt;&gt;<i> but it feels wrong. This is sort of a variation of the hub-and-spoke 
</I>&gt;&gt;<i> that Glyph talked about. But having said that I am trying to determine 
</I>&gt;&gt;<i> if I can get away from that and just go to a very unstructured 
</I>&gt;&gt;<i> environment (without intermediate database nodes).
</I>&gt;<i> 
</I>&gt;<i> This sounds an awful lot like a distributed hashtable.  It does 
</I>&gt;<i> implicitly use an overlay network, but not a hub-and-spoke overlay network.
</I>&gt;<i> 
</I>&gt;<i> I'm not intimately familiar with the algorithms involved, so rather than 
</I>&gt;<i> try to describe them, I'll just refer you to the relatively nice 
</I>&gt;<i> wikipedia page on the topic:
</I>&gt;<i> 
</I>&gt;<i>    <A HREF="http://en.wikipedia.org/wiki/Distributed_hash_table">http://en.wikipedia.org/wiki/Distributed_hash_table</A>
</I>&gt;<i> 
</I>&gt;<i> There is also a project in Python (not Twisted though) which may serve 
</I>&gt;<i> as an example:
</I>&gt;<i> 
</I>&gt;<i>    <A HREF="http://thecircle.org.au/">http://thecircle.org.au/</A>
</I>&gt;<i> 
</I>&gt;<i> Are these ideas useful?  Have you looked at them before?
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i> 
</I>
As I understand DHT the concept is to create a hash identifier, 
partition it into &quot;chunks&quot;, and use the chunks to locate the file. It is 
an interesting idea and certainly one approach. I am keeping it in my 
back pocket.  There are many reasons I don't like this approach.

First, with a poorly segmented hash, you can have a few levels of 
indirection before reaching the file. You can see this in a lot of p2p 
file sharing system. I would like to see if I can overcome this 
performance penalty (another problem is DHT works well in a very sparse 
environment, so the hash keys have to be pretty big. That means more 
intermediate nodes).

The second issue is one unique to data storage systems: I need to have 
multiple copies of the file around. So I had thought if I do a DHT I 
will just keep copies all along the path. That should solve the problem 
of access quickly and copies.

The third issue - and this one I had more difficulty grasping - is that 
once an intermediate node disappears, its contents have to be passed on 
to someone else. Also the link from the prior node to this one (the one 
going away) has to be adjusted. What is the problem? It is quite 
possible that the node would have millions of files on it, hence copying 
it is impossible. That means I have to keep exact copies at multiple 
sites, at the same time (definitely smaller than the entire space of all 
the peers).

But the real problem is that in a network of 1000s of machines it is 
quite possible the the two I am using to store indices on can disappear 
at the same time (granted small, but still a problem). So I opted to 
look at another approach, the one that I started talking about - using 
broadcast or multicast with some sort of RPC-like mechanism and light 
weight protocol applied over a lot of machines.

This approach hasn't been well researched, almost being excluded out of 
hand. I decided it was at least worth investigating. It solves some 
problems like scalability and easy management. The downside is that I 
have to worry about building a lightweight protocol and handle RPC like 
AT LEAST ONCE semantics instead of EXACTLY ONCE.

Glyph, thanks for the references. I will definitely look up 'thecircle' 
stuff. That one I didn't know about!

Peace,
Chaz



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013897.html">[Twisted-Python] Multicast XMLRPC
</A></li>
	<LI>Next message: <A HREF="013868.html">[Twisted-Python] Not subclassing internet.TCPServer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13898">[ date ]</a>
              <a href="thread.html#13898">[ thread ]</a>
              <a href="subject.html#13898">[ subject ]</a>
              <a href="author.html#13898">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
