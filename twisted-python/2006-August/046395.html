<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Multicast XMLRPC
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=%3C44EF5EB0.2080309%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="046393.html">
   <LINK REL="Next"  HREF="046398.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Multicast XMLRPC</H1>
    <B>Chaz.</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=%3C44EF5EB0.2080309%40gmail.com%3E"
       TITLE="[Twisted-Python] Multicast XMLRPC">eprparadocs at gmail.com
       </A><BR>
    <I>Fri Aug 25 14:33:52 MDT 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="046393.html">[Twisted-Python] Multicast XMLRPC
</A></li>
        <LI>Next message (by thread): <A HREF="046398.html">[Twisted-Python] Multicast XMLRPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46395">[ date ]</a>
              <a href="thread.html#46395">[ thread ]</a>
              <a href="subject.html#46395">[ subject ]</a>
              <a href="author.html#46395">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
&gt;<i> On Fri, 25 Aug 2006 14:43:43 -0400, &quot;Chaz.&quot; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">eprparadocs at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> Perhaps the simple way to say this is that I need to do group 
</I>&gt;&gt;<i> communications that support RPC semantics with minimal overhead.
</I>&gt;<i> 
</I>&gt;<i> I'm still not really clear on what the application is.
</I>&gt;<i> 
</I>
The application is a massively scalable data storage system. I plan on 
releasing it into the open source community within the next month or so. 
I've been working on it for almost two years now. Twisted and Python 
have made easier work of it from my first implementation (C/C++).

&gt;&gt;<i> You ask about the network topology; all I can say is that it supports 
</I>&gt;&gt;<i> the normal communication means: unicast, broadcast and maybe multicast.
</I>&gt;<i> 
</I>&gt;<i> Heh.  &quot;Normal&quot; communication means?  After writing a P2P layer and 
</I>&gt;<i> working on a SIP implementation, I have come to understand that the only 
</I>&gt;<i> &quot;normal&quot; communication available is an *outgoing*, *unencrypted* HTTP 
</I>&gt;<i> request on port 80... ;-)
</I>&gt;<i> 
</I>&gt;<i> More seriously, if you're writing an application for distributing 
</I>&gt;<i> compute nodes to home computers, multicast is a non-starter.  If it's an 
</I>&gt;<i> intranet, then maybe it's feasible.  Or, if you're on Internet 2 for 
</I>&gt;<i> some reason.  (Is anybody actually on internet 2 these days?)
</I>&gt;<i> 
</I>This is not a &quot;home application&quot; but an enterprise and/or SSP 
application. Most likely it sits behind a firewall and if remote offices 
need to access it, they will get access via VPN portals.

I guess this is sort of a topology! Doh. All I know is that I have 
multicast and with some effort broadcast support.

&gt;<i> At any rate, producing a functioning multiunicast prototype with, e.g. 
</I>&gt;<i> PB, would be the easiest way to get started if you need to fall back to 
</I>&gt;<i> that sort of topology anyway in the case where a multicast solution 
</I>&gt;<i> doesn't work.  Then you can collect data and determine how much 
</I>&gt;<i> bandwidth is going to be saved in a realistic scenario...
</I>&gt;<i>
</I>
So I can use PB with multicast support? How would I deal with all the 
target machines getting responses back&gt;

&gt;&gt;<i> I am being intentionally vague since I don't want to have any specific 
</I>&gt;&gt;<i> network architecture.
</I>&gt;<i> 
</I>&gt;<i> If you want to support arbitrary network architecture, you _definitely_ 
</I>&gt;<i> can't use multicast, at all.  Even determining if *unicast* datagrams 
</I>&gt;<i> work on an arbitrary network is a hard problem.
</I>
As I said the entire system sits behind a firewall and remote sites will 
use VPN to get to the system. This gives me multicast and broadcast (so 
long as everything is on the same subnet, even remote sites).
&gt;<i> 
</I>&gt;&gt;<i> I don't want to use overlay networks, if at all possible. While they 
</I>&gt;&gt;<i> are nice, I would prefer something a little more direct (though that 
</I>&gt;&gt;<i> might not be possible). The reason? Direct operations are faster.
</I>&gt;<i> 
</I>&gt;<i> Sometimes.  If your topology involves an extremely well-connected 
</I>&gt;<i> overlay hub peer and a bunch of intermittently or poorly connected edge 
</I>&gt;<i> peers, direct operations can be significantly slower.  While I'm not a 
</I>&gt;<i> big fan of IRC's network architecture, the math on what happens if every 
</I>&gt;<i> client is responsible for all of their own messages on a channel of 1000 
</I>&gt;<i> people is really eye-opening.
</I>&gt;<i> 
</I>
I had thought of the hub-and-spoke model and I designed the system that 
way, originally. But I have to respond to instantaneous demands which 
caused me to change the design of the system. Each of the servers can 
run as both servers (providing a service to a client app) and an end 
point (providing storage features). So a hub-and-spoke architecture are 
really out of the picture for me (at least I can't see an easy way).

I could probably do a self-organizing overlay network on top of the 
machines taking advantage of how they are connected together (the real 
physical topology) but even that presents me with an issue: I want the 
system to sort of be self-configuring. As such I don't have a way to 
auto-detect connection speeds.

I had thought of using a clock-synchronization algorithm to figure out 
bandwidth throttling but I thought it better to leave that to another 
day (or days). I also don't want the user (or owner of this beast) to 
have to manually configure that stuff.


&gt;&gt;<i> I don't particular care if it is PB, XML-RPC or SOAP as the 
</I>&gt;&gt;<i> marshalling mechanism. I mention them since they allow me to solve one 
</I>&gt;&gt;<i> problem at a time. I would like to build the solution a piece at a 
</I>&gt;&gt;<i> time to do some measurements and testing. Today the underlying 
</I>&gt;&gt;<i> transport and tomorrow the marshallings.
</I>&gt;<i> 
</I>&gt;<i> It still seems to me like this is backwards.
</I>&gt;<i> 
</I>&gt;<i> The application can be complete, end-to-end, if you start marshalling 
</I>&gt;<i> data and sending it over a simplistic (but possibly too-expensive) 
</I>&gt;<i> mechanism.  Then, you can replace the transport as necessary later.  
</I>&gt;<i> Preserving the semantics of the marshalling between things as radically 
</I>&gt;<i> different as XMLRPC and PB would be very hard; but as you've said, the 
</I>&gt;<i> semantics of your transport must remain identical.
</I>
That is certainly one way. I tend to think all my hard problems are 
going to be transport issues and work up the stack. I have had a share 
of algorithm issues too; nothing is quite obvious when you have a 1000 
or 10,000 machines to deal with!

&gt;<i> 
</I>&gt;&gt;<i> Now let me address the issue of TCP. It is a pretty heavy protocol to 
</I>&gt;&gt;<i> use. It takes a lot of resources on the sender and target and can take 
</I>&gt;&gt;<i> some time to establish a connection. Opening a 1000 or more sockets 
</I>&gt;&gt;<i> consumes a lot of resources in the underlying OS and in the Twisted 
</I>&gt;&gt;<i> client!
</I>&gt;<i> 
</I>&gt;<i> I still don't know what you mean by &quot;resources&quot;, and as compared to 
</I>&gt;<i> what.  In my experience all the alternatives to TCP end up consuming an 
</I>&gt;<i> equivalent amount of RAM and CPU time... although in some cases you 
</I>&gt;<i> might save on bandwidth.
</I>&gt;<i> 
</I>
By resources I mean memory and time. Granted on a 1GB system with 3 GB 
of virtual, memory isn't a big deal, most of the times. But I have seen 
memory leaks kill this sucker more times than I care to recall. Once I 
ran the application for a few days and saw all my swap being used! It 
was very subtle memory leak in one of the libraries (in fact one library 
leak consumed 584M in less than one hour!).

&gt;&gt;<i> If I use TCP and stick to the serial, synchronized semantics of RPC, 
</I>&gt;&gt;<i> doing one call at a time, I have only a few ways to solve the problem. 
</I>&gt;&gt;<i> Do one call at a time, repeat N times, and that could take quite a while.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure what you mean by &quot;at a time&quot;.  The operations can be quite 
</I>&gt;<i> effectively parallelized, both by TCP and by Twisted talking to the OS: 
</I>&gt;<i> if you keep a list of all your open connections and do the naive thing, 
</I>&gt;<i> i.e., for each heartbeat:
</I>&gt;<i> 
</I>&gt;<i>    for connection in connections:
</I>&gt;<i>        connection.sendPing(timeout=30).addErrback(connection.uhOh)
</I>&gt;<i> 
</I>&gt;<i> the initial loop will not take very long even with a very large number 
</I>&gt;<i> of connections, and Twisted will send out traffic as network conditions 
</I>&gt;<i> permit.
</I>&gt;<i> 
</I>&gt;<i> Most importantly, you do not need to wait for any of the calls to 
</I>&gt;<i> complete to issue more calls, regardless of whether they're unicast or 
</I>&gt;<i> multicast.  This same API could be refactored internally to group 
</I>&gt;<i> together peers in the same multicast group and coalesce their pings; but 
</I>&gt;<i> you still need to do the same complexity order of work, because you have 
</I>&gt;<i> to track each peer's response individually.
</I>
Yes, I completely forgot that I would see them all in parallel. I tend 
to overlook Twisted's state machine architecture when I think of 
solutions. I am getting better but not quite there yet...

&gt;<i> 
</I>&gt;<i> Finally, if all you're concerned with is clients dying, you can remove 
</I>&gt;<i> Python from the equation entirely and let the TCP stack do its thing: 
</I>&gt;<i> set SO_KEEPALIVE on all your sockets [in Twisted-ese: 
</I>&gt;<i> self.transport.setTcpKeepAlive(True)] and just wait for connectionLost 
</I>&gt;<i> to be called when a ping fails.  No user-space work _at all_, and 
</I>&gt;<i> probably pretty minimal bandwidth usage.
</I>&gt;<i> 
</I>&gt;&gt;<i> I could do M spawnProcesses and have each do N/M RPC calls.
</I>&gt;<i> 
</I>&gt;<i> Yow.  That definitely doesn't make sense unless you have a massively SMP 
</I>&gt;<i> box.
</I>&gt;<i> 
</I>&gt;&gt;<i> Or I could use M threads and do it that way.
</I>&gt;<i> 
</I>&gt;<i> ... and that would basically _never_ make sense, under any conditions.  
</I>&gt;<i> Python's GIL negates any SMP benefits, Twisted won't send network 
</I>&gt;<i> messages from threads anyway, and it would be substantially more complex.
</I>
Yes...see my mea culpa above....it is hard to stop thinking in terms of 
threads and processes!

&gt;<i> 
</I>&gt;&gt;<i> Granted I have M sockets open at a time, it is possible for this to 
</I>&gt;&gt;<i> take quite a while to execute. Performance would be terrible (and yes 
</I>&gt;&gt;<i> I want an approach that has good to very good performance. After all 
</I>&gt;&gt;<i> who would want poor to terrible performance?)
</I>&gt;<i> 
</I>&gt;<i> &quot;performance 'would be' terrible&quot; sounds like premature optimization to 
</I>&gt;<i> me.  At least, I have lots of experience with systems where this 
</I>&gt;<i> performance was more than good enough.  Huge massively multiplayer games 
</I>&gt;<i> use such systems and manage to deal with tens of thousands of concurrent 
</I>&gt;<i> clients per game node with (relative) ease, over the public internet, 
</I>&gt;<i> with good performance, and without breaking the bank on bandwidth.
</I>&gt;<i> 
</I>
Do the games use TCP or UDP? I would have thought they save state about 
each of the players in the server and use UDP for message passing. I 
thought that was part of the reason most game developers where 
interested in STUN?


&gt;&gt;<i> So I divided the problem down to two parts. One, can I reduce the 
</I>&gt;&gt;<i> amount of traffic on the invoking side of the RPC request? Second, is 
</I>&gt;&gt;<i> how to deal with the response. Obviously I have to deal with the issue 
</I>&gt;&gt;<i> of failure, since RPC semantics require EXACTLY-ONCE.
</I>&gt;<i> 
</I>&gt;<i> If you're concerned about bandwidth *as a resource of its own* then this 
</I>&gt;<i> is perhaps a legitimate concern.  But if you're concerned about reducing 
</I>&gt;<i> bandwidth as a means to increase the real-time performance of the system 
</I>&gt;<i> I don't think that it's actually going to save you a lot.  You save some 
</I>&gt;<i> bandwidth, but then you move a bunch of request/response tracking out of 
</I>&gt;<i> hardware and into Python.  Unless your new algorithm is more efficient 
</I>&gt;<i> by a large margin, and N is very big indeed (100,000 is not &quot;big&quot;, 
</I>&gt;<i> especially when you can partition it using techniques like overlay 
</I>&gt;<i> networks).
</I>
Bandwidth is a very important issue in this system. No one would run 
this on their network if it could bring down their network (or congest 
it so badly ...the old packet-storm issue).

Minimizing bandwidth usage is only one way to deal with performance. A 
congested network will drop packets (requiring retransmission, etc), so 
I try to minimize the impact on the network.

&gt;<i> 
</I>&gt;&gt;<i> That leads me to the observation that on an uncongested ethernet (...)
</I>&gt;<i> 
</I>&gt;<i> &quot;uncongested ethernet&quot; implies something very concrete about your 
</I>&gt;<i> network topology.  Certainly it implies that you have enough spare 
</I>&gt;<i> bandwith that you don't need to be compressing every byte.  Want to 
</I>&gt;<i> expound? :)
</I>&gt;<i> 
</I>Well a congested network is about 1/2 the bandwidth; so I can expect 
about 5Mb/sec on a 10M ethernet, etc. So the idea would be keep traffic 
to a minimum.

As I mentioned earlier, if I was to do normal heartbeat messages with N 
machines, I have N! messages moving around. So long as N is small - a 
few hundred machines (and I have built machines in the telecom world 
that have had 100 machines), the load on the network is reasonable. But 
once you have 1000 machines, you have a 1,000,000 messages flying 
around. Through the work I did I got the number down to 2,000! And over 
15 seconds, that isn't too bad.

&gt;&gt;<i> Hope this helps cast the problem...I didn't mean to sound terse before 
</I>&gt;&gt;<i> I just figured everyone had already thought about the problem and knew 
</I>&gt;&gt;<i> the issues.
</I>&gt;<i> 
</I>&gt;<i> I still really don't know what the problem at hand is.  I gather it has 
</I>&gt;<i> something to do with sending a lot of traffic to a lot of peers but that 
</I>&gt;<i> is still a description of an implementation technique, not a problem.  
</I>&gt;<i> Are you making toast?  Doing distributed testing?  Sequencing genomes?  
</I>&gt;<i> Cracking encryption?  Writing some kind of monster distributed 
</I>&gt;<i> enterprise calendar server?  (I'm still not sure what you meant by 
</I>&gt;<i> &quot;communicating groups&quot;, above.)  Is the &quot;problem&quot; in this case to 
</I>&gt;<i> develop a generic infrastructure for some wider set of problems, like an 
</I>&gt;<i> open-source implementation of a MapReduce daemon?  If so, what are the 
</I>&gt;<i> initial problems it's expected to be applied to?  What does all this 
</I>&gt;<i> data, other than hearbteats, that you're slinging around *represent*?
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i> 
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="046393.html">[Twisted-Python] Multicast XMLRPC
</A></li>
	<LI>Next message (by thread): <A HREF="046398.html">[Twisted-Python] Multicast XMLRPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46395">[ date ]</a>
              <a href="thread.html#46395">[ thread ]</a>
              <a href="subject.html#46395">[ subject ]</a>
              <a href="author.html#46395">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
