<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Direct access to main server class
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Direct%20access%20to%20main%20server%20class&In-Reply-To=17650.63523.224952.251277%40terry.jones.tc">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013900.html">
   <LINK REL="Next"  HREF="013902.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Direct access to main server class</H1>
    <B>Jean-Paul Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Direct%20access%20to%20main%20server%20class&In-Reply-To=17650.63523.224952.251277%40terry.jones.tc"
       TITLE="[Twisted-Python] Direct access to main server class">exarkun at divmod.com
       </A><BR>
    <I>Mon Aug 28 11:01:55 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="013900.html">[Twisted-Python] Direct access to main server class
</A></li>
        <LI>Next message: <A HREF="013902.html">[Twisted-Python] Direct access to main server class
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13901">[ date ]</a>
              <a href="thread.html#13901">[ thread ]</a>
              <a href="subject.html#13901">[ subject ]</a>
              <a href="author.html#13901">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 28 Aug 2006 16:05:23 +0200, Terry Jones &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">terry at jon.es</A>&gt; wrote:
&gt;<i>Here's a hopefully not-too-dumb question...
</I>&gt;<i>
</I>&gt;<i>I have a class that provides a service that I plan to make accessible via
</I>&gt;<i>Twisted. I wrote the class and various unit tests. So I could formerly do
</I>&gt;<i>simple things like:
</I>&gt;<i>
</I>&gt;<i>    import unittest
</I>&gt;<i>
</I>&gt;<i>    class myTest:
</I>&gt;<i>       def setUp():
</I>&gt;<i>           self.c = MyClass()
</I>&gt;<i>
</I>&gt;<i>       def tearDown():
</I>&gt;<i>           self.c.close()
</I>&gt;<i>
</I>&gt;<i>       def testX():
</I>&gt;<i>           self.assert_(self.c.X() == 4)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I recently added users, passwords, and permissions to the system. So now
</I>&gt;<i>many method calls need a requesting user object passed to them, and check
</I>&gt;<i>that the user has permission to carry out the action. I added simple
</I>&gt;<i>twisted.cred class to provide realms, avatars, portal with checkers, etc.
</I>
Aside from the rest of your question and my response, this sounds inside
out.  The general idea is that the user object itself has methods which
implement the actions which the protocol allows to be taken.  If a user
lacks permission to perform a particular action, or has restrictions on
the particulars with which they may invoke that action, or whatever other
logic may be necessary on a per-user basis, that is represented by a
different implementation of the login interface.

It may not necessarily be the case that factoring your code as I've just
described would be better than what you are doing now, but if you haven't
considered it before, it may be worth doing so now.

&gt;<i>
</I>&gt;<i>In the myApp.tac file, I create an instance of my top-level class (MyClass
</I>&gt;<i>above). In the case of providing access to my service via Nevow, I
</I>&gt;<i>instantiate a NevowSite and pass it the portal. That is all, I think, as it
</I>&gt;<i>should be.
</I>&gt;<i>
</I>&gt;<i>But now I'm left wondering what happens to the old unit testing code. It
</I>&gt;<i>obviously cannot just create a MyClass instance. The unit testing code
</I>&gt;<i>should be using the service by authenticating itself just like any other
</I>&gt;<i>client. But I'm not sure how best to do that. The unit test code wants to
</I>&gt;<i>perform all manner of tests, and preferably this would be done by just
</I>&gt;<i>making available the instance of MyClass created in my app's .tac file,
</I>&gt;<i>allowing the test code to call its methods. But somehow that no longer
</I>&gt;<i>feels quite right - the connection is in fact local, but it's coming in
</I>&gt;<i>somehow through twisted.cred.
</I>&gt;<i>
</I>&gt;<i>I hope I'm being more or less clear about my dilemma, and I suppose this
</I>&gt;<i>must be a situation people have to deal with all the time.
</I>
It's a little fuzzy.  Let me see if I can accurately summarize.

   Your server is started up from a .tac file.

   The .tac file creates some objects and gives them particular
   relationships.

   The relationships created in the .tac file are necessary for correct
   operation of the server.

   The unit tests have no way to run the code in the .tac file in order
   to duplicate these relationships.

If these statements are accurate, I would suggest moving some code out of
the .tac file into a real module, from whence your unit tests can import
and use it.

&gt;<i>
</I>&gt;<i>Two solutions come to mind:
</I>&gt;<i>
</I>&gt;<i>  1) Fake it. Call directly into my code to make myself an authenticated
</I>&gt;<i>     user object, and then start passing it in to methods on my own
</I>&gt;<i>     class. This is ugly though, plus if the service is already running
</I>&gt;<i>     it's a bad solution because it goes behind the back of twisted and
</I>&gt;<i>     asks for trouble.
</I>
This actually sounds a little like what I described above.  What makes you
say it is ugly?  To me, it sounds like organizing your code so that you
can test it a unit at a time.  The tests which do this are testing the
behavior of your code when authentication has already succeeded.  You should
also have tests for your authentication code, of course - but that's a
separate unit.

&gt;<i>
</I>&gt;<i>  2) Make all the methods of my class available via RPC and have all the
</I>&gt;<i>     unit test code use them. This seems like a major pain, though I
</I>&gt;<i>     suppose it would work.
</I>
In the past I have done this, and I have regretted it.  This kind of test
is unnecessarily expensive to run and unnecessarily difficult to debug.

&gt;<i>
</I>&gt;<i>I'd much rather just have the unit test code connect as a special local
</I>&gt;<i>user and get back the instance of MyClass created by my .tac file and call
</I>&gt;<i>its methods. Is that easy to do?
</I>
If you move the code responsible for instantiating MyClass out of the .tac
file into a real module, then it is easy :)  Otherwise it may as well be
impossible.

&gt;<i>
</I>&gt;<i>OK, sorry for another typically long posting....
</I>
No problem.  I hope this was of some help.

Jean-Paul


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013900.html">[Twisted-Python] Direct access to main server class
</A></li>
	<LI>Next message: <A HREF="013902.html">[Twisted-Python] Direct access to main server class
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13901">[ date ]</a>
              <a href="thread.html#13901">[ thread ]</a>
              <a href="subject.html#13901">[ subject ]</a>
              <a href="author.html#13901">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
