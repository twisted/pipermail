<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Multicast XMLRPC
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=%3C44EF80CB.3080601%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="046398.html">
   <LINK REL="Next"  HREF="046400.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Multicast XMLRPC</H1>
    <B>Chaz.</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Multicast%20XMLRPC&In-Reply-To=%3C44EF80CB.3080601%40gmail.com%3E"
       TITLE="[Twisted-Python] Multicast XMLRPC">eprparadocs at gmail.com
       </A><BR>
    <I>Fri Aug 25 16:59:23 MDT 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="046398.html">[Twisted-Python] Multicast XMLRPC
</A></li>
        <LI>Next message (by thread): <A HREF="046400.html">[Twisted-Python] Multicast XMLRPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46399">[ date ]</a>
              <a href="thread.html#46399">[ thread ]</a>
              <a href="subject.html#46399">[ subject ]</a>
              <a href="author.html#46399">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please forgive the top post...I just felt it better this time since the 
discussion has become one of heartbeat.

Well if you look at things like the linux clustering software the 
approach they take is brain dead - each machine pings all the others. If 
you had 2 machines, you would have 2 pings per cycle. With 3 machines, 
you would have 6 and so on.

If you do put an overlay network on top of the physical topology you 
would definitely have something different. And a hub-and-spoke layout 
would give you much more than 2N.

What I did was combine two approaches into a single mechanism. I use 
&quot;gossip&quot; to pass around the state of system as I know it (actually the 
changes in state). I use a probabilistic approach to find the machine to 
poll - I pick one randomly. If that machine doesn't answer I pick P 
other machines asking them to poll the original machine and tell me what 
  they found (with the idea it might be congestion between me and the 
original machine). I find this approach converges to the true state of 
the system within a few polling cycles.

Why do I need to know the state of all the machines? Actually the system 
does &quot;self-repair&quot; and &quot;self-healing&quot;. When a node goes down and comes 
back up each node will check the information it knows about the node. 
Some nodes will recognize that the machine that just came back has to 
hold certain data, and tell it. That's the 5 cent answer.

Chaz.


<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
&gt;<i> On Fri, 25 Aug 2006 16:33:52 -0400, &quot;Chaz.&quot; &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">eprparadocs at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> I'm still not really clear on what the application is.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The application is a massively scalable data storage system.
</I>&gt;<i> 
</I>&gt;<i> Okay!  Now I know what you're getting at :).
</I>&gt;<i> 
</I>&gt;&gt;<i> This is not a &quot;home application&quot; but an enterprise and/or SSP 
</I>&gt;&gt;<i> application. Most likely it sits behind a firewall and if remote 
</I>&gt;&gt;<i> offices need to access it, they will get access via VPN portals.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I guess this is sort of a topology! Doh. All I know is that I have 
</I>&gt;&gt;<i> multicast and with some effort broadcast support.
</I>&gt;<i> 
</I>&gt;<i> OK, that makes more sense.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> At any rate, producing a functioning multiunicast prototype with, 
</I>&gt;&gt;&gt;<i> e.g. PB, would be the easiest way to get started if you need to fall 
</I>&gt;&gt;&gt;<i> back to that sort of topology anyway in the case where a multicast 
</I>&gt;&gt;&gt;<i> solution doesn't work.  Then you can collect data and determine how 
</I>&gt;&gt;&gt;<i> much bandwidth is going to be saved in a realistic scenario...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So I can use PB with multicast support? How would I deal with all the 
</I>&gt;&gt;<i> target machines getting responses back&gt;
</I>&gt;<i> 
</I>&gt;<i> My point here was really not anything about PB specifically.  Using PB 
</I>&gt;<i> with multicast would require some tricks; you'd have to have a different 
</I>&gt;<i> Broker implementation, probably, and a datagram-based API.  You could 
</I>&gt;<i> still use the underlying message serialization format though.
</I>&gt;<i> 
</I>&gt;&gt;<i> I had thought of the hub-and-spoke model and I designed the system 
</I>&gt;&gt;<i> that way, originally. But I have to respond to instantaneous demands 
</I>&gt;&gt;<i> which caused me to change the design of the system. Each of the 
</I>&gt;&gt;<i> servers can run as both servers (providing a service to a client app) 
</I>&gt;&gt;<i> and an end point (providing storage features). So a hub-and-spoke 
</I>&gt;&gt;<i> architecture are really out of the picture for me (at least I can't 
</I>&gt;&gt;<i> see an easy way).
</I>&gt;<i> 
</I>&gt;<i> I don't see that it's out of the picture - your network topology allows 
</I>&gt;<i> you to fairly effortlessly connect between machines (no need for NAT 
</I>&gt;<i> traversal or &quot;home servers&quot; or any of that garbage: just give an IP on 
</I>&gt;<i> the intranet) - just include the &quot;hub&quot; and &quot;spoke&quot; code in the same 
</I>&gt;<i> process, and then any process can act as a hub... dynamic load-balancing 
</I>&gt;<i> is never easy, but it is certainly a possibility.
</I>&gt;<i> 
</I>&gt;&gt;<i> I could probably do a self-organizing overlay network on top of the 
</I>&gt;&gt;<i> machines taking advantage of how they are connected together (the real 
</I>&gt;&gt;<i> physical topology) but even that presents me with an issue: I want the 
</I>&gt;&gt;<i> system to sort of be self-configuring. As such I don't have a way to 
</I>&gt;&gt;<i> auto-detect connection speeds.
</I>&gt;<i> 
</I>&gt;<i> You can detect connection speeds on the fly; just start doing some work, 
</I>&gt;<i> gather statistics on each connection, and reconfigure if it's not going 
</I>&gt;<i> fast enough.  No need for clock synchronization.
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> Today the underlying transport and tomorrow the marshallings.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It still seems to me like this is backwards.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The application can be complete, end-to-end, if you start marshalling 
</I>&gt;&gt;&gt;<i> data and sending it over a simplistic (but possibly too-expensive) 
</I>&gt;&gt;&gt;<i> mechanism. (...)
</I>&gt;&gt;<i> That is certainly one way. I tend to think all my hard problems are 
</I>&gt;&gt;<i> going to be transport issues and work up the stack. I have had a share 
</I>&gt;&gt;<i> of algorithm issues too; nothing is quite obvious when you have a 1000 
</I>&gt;&gt;<i> or 10,000 machines to deal with!
</I>&gt;<i> 
</I>&gt;<i> Working up the stack is difficult because you can't measure the working 
</I>&gt;<i> system at any point to decide what you need to optimize.  I prefer to 
</I>&gt;<i> work downwards.  If your highest level of code can remain unchanged 
</I>&gt;<i> while you refactor the underlying layers, then you can run the same 
</I>&gt;<i> tests for the same high-level code with different underlying layers to 
</I>&gt;<i> get an idea of their relative performance.  If you start optimizing at 
</I>&gt;<i> the bottom of the stack before the top is done, then you can easily end 
</I>&gt;<i> up with something which is optimized in the wrong direction, and which 
</I>&gt;<i> requires rewriting when the top layer is done anyway.
</I>&gt;<i> 
</I>&gt;<i> I guess this doesn't really have much bearing on your other questions 
</I>&gt;<i> though.
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> Now let me address the issue of TCP. It is a pretty heavy protocol 
</I>&gt;&gt;&gt;&gt;<i> to use. 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> I still don't know what you mean by &quot;resources&quot;, and as compared to 
</I>&gt;&gt;&gt;<i> what. 
</I>&gt;<i> 
</I>&gt;&gt;<i> By resources I mean memory and time. Granted on a 1GB system with 3 GB 
</I>&gt;&gt;<i> of virtual, memory isn't a big deal, most of the times. But I have 
</I>&gt;&gt;<i> seen memory leaks kill this sucker more times than I care to recall. 
</I>&gt;&gt;<i> Once I ran the application for a few days and saw all my swap being 
</I>&gt;&gt;<i> used! It was very subtle memory leak in one of the libraries (in fact 
</I>&gt;&gt;<i> one library leak consumed 584M in less than one hour!).
</I>&gt;<i> 
</I>&gt;<i> I notice you don't specifically refer to features of TCP here, but 
</I>&gt;<i> instead of the perils of writing any software at all in C/C++ :).  Of 
</I>&gt;<i> course, Python can have memory leaks, but I wouldn't base your 
</I>&gt;<i> architecture around bugs in libraries which will hopefully be 
</I>&gt;<i> unnecessary in the future :).
</I>&gt;<i> 
</I>&gt;&gt;<i> Yes, I completely forgot that I would see them all in parallel. I tend 
</I>&gt;&gt;<i> to overlook Twisted's state machine architecture when I think of 
</I>&gt;&gt;<i> solutions. I am getting better but not quite there yet...
</I>&gt;<i> 
</I>&gt;<i> It might not solve your problem.  But Twisted may be doing quite a lot 
</I>&gt;<i> more work in &quot;parallel&quot; than you're used to.  I can't really say, but 
</I>&gt;<i> I'd be curious to hear about it if you measure it.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> (Threads are bad)
</I>&gt;&gt;<i> Yes...see my mea culpa above....it is hard to stop thinking in terms 
</I>&gt;&gt;<i> of threads and processes!
</I>&gt;<i> 
</I>&gt;<i> Yeah, it took me a while to get out of that habit when I started writing 
</I>&gt;<i> Twisted in the first place :).  (The thing that preceded it was a 
</I>&gt;<i> blocking, multithreaded abomination.)
</I>&gt;<i> 
</I>&gt;&gt;<i> Do the games use TCP or UDP? I would have thought they save state 
</I>&gt;&gt;<i> about each of the players in the server and use UDP for message 
</I>&gt;&gt;<i> passing. I thought that was part of the reason most game developers 
</I>&gt;&gt;<i> where interested in STUN?
</I>&gt;<i> 
</I>&gt;<i> They ... vary.  A general rule of thumb is that they use TCP (or 
</I>&gt;<i> something like it) for control messages and data transfer, and then an 
</I>&gt;<i> *unreliable* most-recent-first UDP protocol for transmitting information 
</I>&gt;<i> about physical position, orientation and movement.  Game protocols are 
</I>&gt;<i> incredibly involved because they're typically communicating information 
</I>&gt;<i> about a dozen systems at once.  Game performance is different than 
</I>&gt;<i> typical application performance because quite often you only care about 
</I>&gt;<i> the most recent state of something, and you can happily throw away any 
</I>&gt;<i> old messages.
</I>&gt;<i> 
</I>&gt;<i> The games that are interested in STUN are not MMPs; the reason they are 
</I>&gt;<i> using it is to establish P2P connections so that players don't have to 
</I>&gt;<i> receive their updates from a central server, and you don't need to 
</I>&gt;<i> configure your firewall to play.
</I>&gt;<i> 
</I>&gt;&gt;<i> Bandwidth is a very important issue in this system. No one would run 
</I>&gt;&gt;<i> this on their network if it could bring down their network (or congest 
</I>&gt;&gt;<i> it so badly ...the old packet-storm issue).
</I>&gt;<i> 
</I>&gt;<i> This is another good reason to use TCP.  There are congestion control 
</I>&gt;<i> mechanisms for TCP; you would have to implement something yourself for UDP.
</I>&gt;<i> 
</I>&gt;&gt;<i> As I mentioned earlier, if I was to do normal heartbeat messages with 
</I>&gt;&gt;<i> N machines, I have N! messages moving around. So long as N is small - 
</I>&gt;&gt;<i> a few hundred machines (and I have built machines in the telecom world 
</I>&gt;&gt;<i> that have had 100 machines), the load on the network is reasonable. 
</I>&gt;&gt;<i> But once you have 1000 machines, you have a 1,000,000 messages flying 
</I>&gt;&gt;<i> around. Through the work I did I got the number down to 2,000! And 
</I>&gt;&gt;<i> over 15 seconds, that isn't too bad.
</I>&gt;<i> 
</I>&gt;<i> Why N! messages?  Using a naive hub-and-spoke model it seems like it 
</I>&gt;<i> would just be 2N.  It's only if every node needs to know about every 
</I>&gt;<i> other node that you get up to N!... why would you need that?
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i> 
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="046398.html">[Twisted-Python] Multicast XMLRPC
</A></li>
	<LI>Next message (by thread): <A HREF="046400.html">[Twisted-Python] Multicast XMLRPC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46399">[ date ]</a>
              <a href="thread.html#46399">[ thread ]</a>
              <a href="subject.html#46399">[ subject ]</a>
              <a href="author.html#46399">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
