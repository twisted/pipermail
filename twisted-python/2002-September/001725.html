<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] thoughts on a reactor feature
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20thoughts%20on%20a%20reactor%20feature&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001716.html">
   <LINK REL="Next"  HREF="001723.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] thoughts on a reactor feature</H1>
    <B>Bruce Mitchener</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20thoughts%20on%20a%20reactor%20feature&In-Reply-To="
       TITLE="[Twisted-Python] thoughts on a reactor feature">bruce at cubik.org
       </A><BR>
    <I>Tue Sep 24 02:25:31 EDT 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="001716.html">[Twisted-Python] thoughts on a reactor feature
</A></li>
        <LI>Next message: <A HREF="001723.html">[Twisted-Python] Enterprise Row Objects
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1725">[ date ]</a>
              <a href="thread.html#1725">[ thread ]</a>
              <a href="subject.html#1725">[ subject ]</a>
              <a href="author.html#1725">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Glyph,

Glyph Lefkowitz wrote:
&gt;<i> On Mon, 23 Sep 2002 12:54:22 -0600, Bruce Mitchener &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">bruce at cubik.org</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>One would be have an interface to POSIX clocks and track the amount of 
</I>&gt;&gt;<i>time spent between calls out of reactor.run() and report anything that 
</I>&gt;&gt;<i>takes over a specified threshold of time to execute.
</I>&gt;<i> 
</I>&gt;<i> If I understand your proposal correctly, I think this could be implemented
</I>&gt;<i> quite simply by writing a Python wrapper around the reactor, that would wrap
</I>&gt;<i> each protocol and protocol factory being passed to it in something that would
</I>&gt;<i> catch events and time their execution.  This should work for just about any
</I>&gt;<i> reactor.  With a few extra features, it might even be good for measuring their
</I>&gt;<i> differences.  Would you need a wrapper around POSIX clocks more robust than
</I>&gt;<i> time.clock()?
</I>
time.clock() looks like it'd work well enough so long as the accuracy is 
good enough.  (clock_gettime() deals in nanoseconds.)

Wrapping the reactor in Python seems harder.  This could also be a usage 
of the metrics gathering interfaces that I'd mentioned yesterday. 
That'd be far simpler than wrapping the reactor, intercepting 
everything, and providing a new iteration function to catch all of the 
calls out of the reactor while it processed the queued calls.

And .. this should be something that is easy to use, easy to turn on, 
and readily available.  We have primitive facilities for this sort of 
thing in the server tech that I use at work and the only reason that 
they're not more advanced is that I didn't want to spend the time (and 
add the risk) on refactoring our interpreter.  They greatly simplified 
diagnosing server performance issues that popped up.

That would still leave printing out an identifier that indicates what it 
was that just ran for more than the allowed amount of time.  I'll have 
to experiment a bit inside the reactor in the time day or so if I have 
time for Twisted and see what types of things we can reasonably print 
from there.

&gt;<i> (I think this could also compare time.clock() to time.time() to see if
</I>&gt;<i> potentially blocking calls were being made.)
</I>
That might be interesting, but not sure that time.time() is of similar 
resolution as the values that I want.  But if I do end up wrapping 
clock_gettime() in a C module, then I could also wrap the function for 
getting wall time in addition to CPU time and per-thread CPU time.  Not 
a problem at all. :)

&gt;&gt;<i>Another is to implement some sort of stack trace sampling where you
</I>&gt;&gt;<i>periodically take a stack trace when a utility program is running and you've
</I>&gt;&gt;<i>noted periods of long latency.
</I>&gt;<i> 
</I>&gt;<i> This I don't know how to do; possibly it's doable with Python's
</I>&gt;<i> debugger/profiler hooks?  I'm not quite clear on how you do the &quot;noting&quot; -- is
</I>&gt;<i> this a message that the user sends to Twisted or is it something that the
</I>&gt;<i> profiler performs some heuristic to get?
</I>
Well, the bit above with the time.clock() is probably enough for now.

It'd be nice to be able to do more introspection on thread pools, but 
that can probably wait a bit.

  - Bruce



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001716.html">[Twisted-Python] thoughts on a reactor feature
</A></li>
	<LI>Next message: <A HREF="001723.html">[Twisted-Python] Enterprise Row Objects
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1725">[ date ]</a>
              <a href="thread.html#1725">[ thread ]</a>
              <a href="subject.html#1725">[ subject ]</a>
              <a href="author.html#1725">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
