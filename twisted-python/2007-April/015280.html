<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Advice on Debugging Stackless/Twisted Problem	involving Deferreds
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Advice%20on%20Debugging%20Stackless/Twisted%20Problem%0A%09involving%20Deferreds&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015279.html">
   <LINK REL="Next"  HREF="015281.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Advice on Debugging Stackless/Twisted Problem	involving Deferreds</H1>
    <B>Andrew Francis</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Advice%20on%20Debugging%20Stackless/Twisted%20Problem%0A%09involving%20Deferreds&In-Reply-To="
       TITLE="[Twisted-Python] Advice on Debugging Stackless/Twisted Problem	involving Deferreds">andrewfr_ice at yahoo.com
       </A><BR>
    <I>Tue Apr 24 15:49:47 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="015279.html">[Twisted-Python] WANTED: Conch use-cases!
</A></li>
        <LI>Next message: <A HREF="015281.html">[Twisted-Python] Advice on Debugging Stackless/Twisted Problem	involving Deferreds
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15280">[ date ]</a>
              <a href="thread.html#15280">[ thread ]</a>
              <a href="subject.html#15280">[ subject ]</a>
              <a href="author.html#15280">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Colleagues:

I am try to debug a problem involving Stackless and
Twisted (once again). I don't see why Twisted and
Stackless cannot inter-operate. I enclosed an example
to illustrate the problem. I use Twisted 2.5 and
Stackless 2.5 3.1b3 on Windows XP.

The goal of the enclosed programme is to suspend and
resume Stackless tasklets making network calls without
blocking the entire Stackless Python application.
Under the hood, Twisted is used. The problem is that
programme prematurely terminates - the deferred
connected to client.getPage() is never called. 

I want to figure out exactly what is going on (in the
past I have gone on wild goose chases involving
threads and reactors).

Using print statements and pdb (I find it rough using
pdb with Stackless Python), the Twisted symptoms are:

1) ConnectTCP is successfully called. However the
actual call is never made (i.e., I monitored my Apache
web server's access.log). As a side note, I haven't
quite figured out how the HTTPClientFactory interacts
with the Twisted reactor. 
 
2) The deferred is never called.

3) Twisted seems to stop in MainLoop(), I am not sure
where.

4) No errors are generated.

The Stackless symptoms are:

A) The programme terminates, implying all the tasklets
except the main tasklet are blocked (or disappeared).

B) (Connected to A) All the channels are waiting for
writers (I look at the channel.__reduce__()).

Any insights would help. At this point, I like to
focus my attention on the Twisted side since this is
where my knowledge is the weakest. I am still reading
Twisted code. I am trying to get Manhole running but I
am having problems with the gtk library. 

It would help greatly if it could be pointed out where
I should place set_trace()/break points and print
statements to see what is happening to the deferred
call. If someone is set up for both Twisted and
Stackless and run the example, that would be super!

On the Stackless side, what am I missing? I haven't
detected any TaskletExit exceptions being thrown. I
was thinking deadlock, but this seems unlikely. Is
there a way to conduct a post-mortem on tasklets?

Hopefully I have made a silly mistake...

Cheers,
Andrew


~~~

#!/usr/bin/env python
&quot;&quot;&quot;
TestProcessor.py
April 24th, 2007

The purpose of this programme is to suspend a request
handler,
make a series of calls involving deferreds, and resume
the
request handler. This test does not work.

The main tasklet makes a series of synchronous
API calls : the first is to wait for a http request.
The second
is to get a web page. The last is to send a http
reply.

Under the hood, a tasklet &quot;the processor&quot; suspends and
resumes
tasklets waiting for IO events.

The programme works fine for:

def execute(self):
    self.processor.getWebPage()

(the programme will just run)

and

def execute(self):
    self.processor.getHttpRequest()
    self.processor.sendHttpResponse()

(use a HTML form with method POST)

However when 

def execute(self):
    self.processor.getHttpRequest()
    self.processor.getWebPage()
    self.processor.sendHttpResponse()

combination are done, something bad happens and the
programme
ends pre-maturely

&quot;&quot;&quot;

from twisted.internet.defer                          
import Deferred
from twisted.python.failure                          
import Failure
from twisted.internet                                
import reactor
from twisted.web                                     
import client
from twisted.web                                     
import http
import stackless
import pdb
import time
import sys

MESSAGE = {0 : &quot;client_response&quot;,
           1 : &quot;receive_response&quot;,
           2 : &quot;reply_response&quot; }

CLIENT_RESPONSE = 0
RECEIVE_RESPONSE = 1
REPLY_RESPONSE = 2

message = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello
world&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;


def pump():
    while (1):
      stackless.schedule()
    
    
class Response(object):
    def __init_(self):
        return


class Request(object):
    def __init__(self):
        return
    
&quot;&quot;&quot;
run Twisted in its own tasklet
&quot;&quot;&quot;
def twistedReactor():
    reactor.run()


&quot;&quot;&quot;
a housekeeping data structure to hide how tasklets are
suspended and resumed. For now, we use channels. Not
sure
how easy it is to replace this with
capture/remove/insert
&quot;&quot;&quot;
class Activity(object):
    def __init__(self):
        self.channel = stackless.channel()
        return

    def __repr__(self):
        return str(self.channel.__reduce__())
    
    def resume(self, response):
        self.channel.send(response)
            
    def suspend(self):
        print &quot;[suspending]&quot;
        return self.channel.receive()
    



&quot;&quot;&quot;
The Twisted Web server
&quot;&quot;&quot;
class Server(object):
    
    &quot;&quot;&quot;
    Twisted sends network events to the processor via
    a channel
    &quot;&quot;&quot;
    def execute(self, port, requestChannel):
        MyRequestHandler.requestChannel =
requestChannel
        reactor.listenTCP(port, MyHttpFactory())
        return


class MyRequestHandler(http.Request):
    
    def process(self):
            
        print &quot;request handler :&quot;,
stackless.getcurrent()    
        myChannel = stackless.channel()
        
        response = Response()
        response.type = RECEIVE_RESPONSE
        response.path = self.path
        response.channel = myChannel
        response.body = self.content
        
        &quot;&quot;&quot;
        send information back to the processor about
the
        HTTP request. Include a private channel so the
        processor can send back a reply
        &quot;&quot;&quot;
        MyRequestHandler.requestChannel.send(response)
        
        &quot;&quot;&quot;
        send the reply to the client
        &quot;&quot;&quot;
        reply = myChannel.receive()
        self.write(reply.message)
        self.finish()
        
        &quot;&quot;&quot;
        tell the processor that request handler has
        finished
        &quot;&quot;&quot;
        ack = Response()
        ack.type = REPLY_RESPONSE
        ack.body = None
        ack.requestId = reply.requestId
        
        MyRequestHandler.requestChannel.send(ack)
        return
        
        
class MyHttp(http.HTTPChannel):
    requestFactory = MyRequestHandler
    
    
class MyHttpFactory(http.HTTPFactory):
    protocol = MyHttp
    
    
&quot;&quot;&quot;
The ClientConnection represents a deferred Twisted
call
&quot;&quot;&quot;
class ClientConnection(object):
    
    &quot;&quot;&quot;
    include a requestId so the processor can associate
completed
    messages with outstanding requests
    &quot;&quot;&quot;
    def __init__(self, channel, address, requestId):
        self.address = address
        self.channel = channel
        self.requestId = requestId
        return
    
    def __handleResponse__(self, pageData):
        print &quot;__handleResponse__ started&quot;
        
        print &quot;deferred tasklet :&quot;,
stackless.getcurrent()
        
        response = Response()
        response.requestId = self.requestId
        response.type = CLIENT_RESPONSE
        response.body = pageData
        
        self.channel.send(response)
        print &quot;__handleResponse__ finished&quot;
        return
    
    #ignore errors for now
    def __handleError__(self, failure):
        print &quot;__handleError__&quot;
        return
    
    def connect(self):
       
client.getPage(self.address).addCallback(self.__handleResponse__).addErrback(self.__handleError__)
    
        return


&quot;&quot;&quot;
The TestTasklet makes a series of calls to the
processor
&quot;&quot;&quot;
class TestTasklet(object):
    def __init__(self, processor):
        self.processor = processor
        return
    
    &quot;&quot;&quot;
    note - don't care about what is returned.
    &quot;&quot;&quot;
    def execute(self):
        try:
            &quot;&quot;&quot;
            the processor ensures that one call must
            complete before the other starts. Besides
            they all run in the same tasklet.
            &quot;&quot;&quot;
            self.processor.getHttpRequest(&quot;/&quot;)
           
self.processor.getWebPage('<A HREF="http://localhost'">http://localhost'</A>)
            self.processor.sendHttpResponse(message)
        except  :
            print sys.exc_info()
        return


class TestProcessor(object):
    
    def __init__(self, channel):
        self.flag = True
        self.channel = channel
        self.tasklets = {}
        self.requests = {}
        self.requestId = 0
        self.serverChannel = None
        self.receiveActivity = None
        return
    
    
    &quot;&quot;&quot;
    just return the tasklet associated with the
getHttpRequest()
    &quot;&quot;&quot;
    def __match__(self):
        return self.receiveActivity
    
    
    def __getTaskletEntry__(self):
        tasklet = stackless.getcurrent()
        if not self.tasklets.has_key(tasklet):
            self.tasklets[tasklet] = Activity()
        return self.tasklets[tasklet]
           
           
    #associate a request with a tasklet
    #for now don't worry about set_atomic
    def __addRequest__(self, activity):
        self.requestId = self.requestId + 1
        print &quot;[requestId &quot; + str(self.requestId) +
&quot;]&quot;
        self.requests[self.requestId] = activity
        return self.requestId
           
           
    #get a request       
    def __getRequest__(self, requestId):
        print &quot;[resuming request &quot; + str(requestId) +
&quot;]&quot;
        return self.requests[requestId]
    
           
    def __removeRequest__(self, requestId):
        del self.requests[requestId]
           
           
    &quot;&quot;&quot;
    API 
    &quot;&quot;&quot;
    def getHttpRequest(self, path):
        print &quot;getHttpRequest started&quot;
        #pdb.set_trace()
        activity = self.__getTaskletEntry__()
        requestId = self.__addRequest__(activity)
        self.receiveActivity = (requestId, activity)
        result = activity.suspend()
        self.serverChannel = result.channel
        self.__removeRequest__(requestId)
        print &quot;getHttpRequest finished&quot;
        return result
    
    
    def getWebPage(self, address):
        print &quot;getWebPage started&quot;
        #pdb.set_trace()
        activity = self.__getTaskletEntry__()
        requestId = self.__addRequest__(activity)
        ClientConnection(self.channel, address,
requestId).connect()
        result = activity.suspend()
        self.__removeRequest__(requestId)
        print &quot;getWebPage finished&quot;
        return result
    
    
    def sendHttpResponse(self, message):
        print &quot;sendHttpResponse started&quot;
        activity = self.__getTaskletEntry__()
        requestId = self.__addRequest__(activity)
        request = Request()
        request.message = message
        request.requestId = requestId
        self.serverChannel.send(request)
        result = activity.suspend()
        self.__removeRequest__(requestId)
        print &quot;sendHttpResponse finished&quot;
        return 
    
    
    &quot;&quot;&quot;
    Event processing 
    &quot;&quot;&quot;
    def processEvents(self):
        while (self.flag):
            response = self.channel.receive()
            
            if response.type == RECEIVE_RESPONSE:
                &quot;&quot;&quot;
                for now just blindly match any HTTP
request
                &quot;&quot;&quot;
                requestId, activity = self.__match__()
                response.requestId = requestId
            
            &quot;&quot;&quot;
            get the tasklet associated with the event
            and resume it, giving it a result in the
process
            &quot;&quot;&quot;
            activity =
self.__getRequest__(response.requestId)
            activity.resume(response)
            
        print &quot;finished processing&quot;    
        return
    
try:    
    print &quot;test starting&quot;    
    channel = stackless.channel()
    #stackless.tasklet(pump)()
    processor = TestProcessor(channel)
    print &quot;processor&quot;,
stackless.tasklet(processor.processEvents)()
    print &quot;TaskTasklet&quot;,
stackless.tasklet(TestTasklet(processor).execute)()
    print &quot;Server&quot;,
stackless.tasklet(Server().execute)(8000, channel)
    print &quot;reactor tasklet: &quot;,
stackless.tasklet(twistedReactor)()
except:
    print sys.exc_info()
    reactor.stop()
    
&quot;&quot;&quot;
should run indefinitely
&quot;&quot;&quot;
while (stackless.getruncount() &gt; 1):
    stackless.schedule()

print &quot;this is the channel count and blocked
tasklets:&quot;, channel.__reduce__()

print &quot;dump request table&quot;

for activityObject in processor.requests.values():
    print activityObject

print &quot;dump RH channel&quot;
print processor.receiveActivity






__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
<A HREF="http://mail.yahoo.com">http://mail.yahoo.com</A> 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015279.html">[Twisted-Python] WANTED: Conch use-cases!
</A></li>
	<LI>Next message: <A HREF="015281.html">[Twisted-Python] Advice on Debugging Stackless/Twisted Problem	involving Deferreds
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15280">[ date ]</a>
              <a href="thread.html#15280">[ thread ]</a>
              <a href="subject.html#15280">[ subject ]</a>
              <a href="author.html#15280">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
