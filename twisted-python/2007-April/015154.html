<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Synchronization techniques
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Synchronization%20techniques&In-Reply-To=6ce0ac130704041025g3092ffb9wbb6de6a9dbefcbad%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015152.html">
   <LINK REL="Next"  HREF="015157.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Synchronization techniques</H1>
    <B>glyph at divmod.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Synchronization%20techniques&In-Reply-To=6ce0ac130704041025g3092ffb9wbb6de6a9dbefcbad%40mail.gmail.com"
       TITLE="[Twisted-Python] Synchronization techniques">glyph at divmod.com
       </A><BR>
    <I>Wed Apr  4 14:17:04 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="015152.html">[Twisted-Python] Synchronization techniques
</A></li>
        <LI>Next message: <A HREF="015157.html">[Twisted-Python] Synchronization techniques
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15154">[ date ]</a>
              <a href="thread.html#15154">[ thread ]</a>
              <a href="subject.html#15154">[ subject ]</a>
              <a href="author.html#15154">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On 05:25 pm, <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ellisonbg.net at gmail.com</A> wrote:
&gt;<i>The issue brought up in this thread is one that we (the IPython dev
</I>&gt;<i>team) has thought about a lot.  There are really two questions about
</I>&gt;<i>having true synchronization primitives (something like d.waitFor() or
</I>&gt;<i>blockOn(d)):
</I>&gt;<i>
</I>&gt;<i>1.  Can they be implemented in python/twisted in a reliable and robust 
</I>&gt;<i>way?
</I>
The real question here doesn't involve the words &quot;in python/twisted&quot; :).
&gt;<i>2.  Should you use them in your code?
</I>
&gt;<i>Unfortunately, the answer to (1) seems to be no - at least not without
</I>&gt;<i>completely refactoring the core of twisted to support this capability
</I>&gt;<i>from the ground level.  The tempting way of doing it currently is to
</I>&gt;<i>call reactor.iterate() to spin the event loop at a particular point.
</I>&gt;<i>We have code in IPython that does this:
</I>&gt;<i>
</I>&gt;<i><A HREF="http://projects.scipy.org/ipython/ipython/browser/ipython/branches/saw/ipython1/kernel/blockon.py">http://projects.scipy.org/ipython/ipython/browser/ipython/branches/saw/ipython1/kernel/blockon.py</A>
</I>&gt;<i>[DON'T USE THIS CODE!]
</I>&gt;<i>
</I>&gt;<i>For very simple things this code works just fine.
</I>
I think you mean, &quot;in some cases this code appears to work&quot;.  Working 
&quot;just fine&quot; implies that it is robust and supported.  This is an 
actively deprecated programming style and there are numerous known 
problems (besides the ones you've already documented here) with doing 
it.
&gt;<i>d = functionThatReturnsADeferred()
</I>&gt;<i>r = blockOn(d)          # spin the reactor until d fires.
</I>&gt;<i>
</I>&gt;<i>The problem is that if you start to use blockOn in various places in
</I>&gt;<i>your code, a single call to blockOn (which calls reactor.iterate())
</I>&gt;<i>could trigger other calls to blockOn (which will attempt to call
</I>&gt;<i>reactor.iterate() again).  The twisted reactor is simply not designed
</I>&gt;<i>to be doubly iterated like this - it leads to all sorts of really
</I>&gt;<i>weird problems that are _impossible_ to track down.
</I>
These &quot;weird&quot; problems are the entirely predictable result of violating 
every assumption that code makes about its run-time environment when it 
is written and tested.  An analogous operation would be to write C code 
to forcibly delete Python objects rather than go through the garbage 
collector because you *really know*, *just this one time*, that you want 
to free that memory.  If you're careful to never touch that object 
again, you might be able to avoid a segfault, but I think most people 
would agree that all bets are off at that point.

This might seem like an exaggerated problem, but I have actually seen 
code like that more than once written by dyed-in-the-wool C programmers 
who didn't &quot;get&quot; how Python's object model worked.  It's the same with 
dyed-in-the-wool non-concurrent programmers approaching concurrent 
systems for the first time.
&gt;<i>This is why people are saying &quot;it can't be done.&quot;  I should mention
</I>&gt;<i>that it might be possible to implement these things in stackless.
</I>
If you were to implement these things in stackless, you would still have 
to deal with the inherently problematic issue of apparently &quot;sequential&quot; 
code being run recursively when it does not expect to be.  In order to 
prevent this, you would likely have a completely different programming 
model where something properly event-driven, like Twisted itself, were 
scheduling &quot;user code&quot; which was written using a different programming 
style.

For certain problems such things are a good approach.  For example, in 
AI code with extremely deeply nested ad-hoc decision trees modeled as if 
statements and for loops, the cost of stack ripping becomes high both 
conceptually and performance-wise, and it is more natural to model 
individual agents as individual control flows (or &quot;cooperative 
threads&quot;).  This sort of code, though, would be written in a style more 
like Erlang, with almost no shared state at all.  Part of Twisted's 
appeal is that it makes mutable state-sharing between disparate systems 
straightforward.  In other words, it is a different programming model 
for a different set of problems that would require a different pile of 
infrastructure.

It may well be possible to implement such a layer on top of Twisted, but 
there is a curious thing that takes place when people begin to tackle 
this problem.  Pretty much everyone eventually comes to the realization 
that this isn't a good idea for their problem domain, and what they 
*actually* want is to wish away the difficulties associated with 
concurrency and pretend that they can &quot;just block&quot; and everything will 
be OK.  The ones who really, really need it (like people dealing with 
the aforementioned AI problems) already know their requirements and 
quietly go ahead and implement what they need, without any hand-wringing 
about how hard programming with Deferreds is or how they'd really like 
to block on one.
&gt;<i>So what about (2)?  Ignoring the fact that such constructs can't be
</I>&gt;<i>implemented reliably (let's imagine they could be), should you want to
</I>&gt;<i>use them?  I think the answer is this:
</I>
&gt;<i>The design of Twisted reflects the realities of an asynchronous, event
</I>&gt;<i>driven world where things can and do go wrong when you least expect
</I>&gt;<i>it.  The error handling decision tree of Deferreds are a reflection of
</I>&gt;<i>this reality.  If you try to make this stuff go away (we have tried ma
</I>&gt;<i>ny times - we are slow learners and very stubborn) you will be
</I>&gt;<i>punished and there will be &quot;weeping and gnashing of teeth.&quot;  This
</I>&gt;<i>punishment will take the form of buggy code that is difficult to
</I>&gt;<i>maintain and extend.
</I>
It sounds like we broadly agree here :).
&gt;<i>With all that said, I have encountered a few highly unusual cases
</I>&gt;<i>where I really did want blockOn to exist.  These cases had the
</I>&gt;<i>characteristic that they couldn't be done any other way in Twisted.
</I>&gt;<i>The answer in this case is to ditch twisted and use a tool that is
</I>&gt;<i>better suited to the problem.  But in my experience these cases only
</I>&gt;<i>pop up about 0.00001% of the time.
</I>
I am very curious about your 0.00001% case.  Not that I don't believe 
such cases exist, but in every case but one (twisted ticket #2545) the 
issue has actually been a documentation problem with Twisted, where it 
wasn't clear how to do something the &quot;normal&quot; way with Deferreds and 
such.  I'd like to know if there is another such doc bug we should be 
filing :).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20070404/de501080/attachment.htm">http://twistedmatrix.com/pipermail/twisted-python/attachments/20070404/de501080/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015152.html">[Twisted-Python] Synchronization techniques
</A></li>
	<LI>Next message: <A HREF="015157.html">[Twisted-Python] Synchronization techniques
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15154">[ date ]</a>
              <a href="thread.html#15154">[ thread ]</a>
              <a href="subject.html#15154">[ subject ]</a>
              <a href="author.html#15154">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
