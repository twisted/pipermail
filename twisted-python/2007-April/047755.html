<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Foolscap-0.1.1 released
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Foolscap-0.1.1%20released&In-Reply-To=%3C874pnketln.fsf%40lothar.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="047732.html">
   <LINK REL="Next"  HREF="047648.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Foolscap-0.1.1 released</H1>
    <B>Brian Warner</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Foolscap-0.1.1%20released&In-Reply-To=%3C874pnketln.fsf%40lothar.com%3E"
       TITLE="[Twisted-Python] Foolscap-0.1.1 released">warner at lothar.com
       </A><BR>
    <I>Thu Apr 12 23:22:44 MDT 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="047732.html">[Twisted-Python] Foolscap-0.1.1 released
</A></li>
        <LI>Next message (by thread): <A HREF="047648.html">[Twisted-Python] 3 questions about async,	threading and dynamic protocol selection
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47755">[ date ]</a>
              <a href="thread.html#47755">[ thread ]</a>
              <a href="subject.html#47755">[ subject ]</a>
              <a href="author.html#47755">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>kgi &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">iacovou at gmail.com</A>&gt; writes:

&gt;<i> Thanks for the latest release; Foolscap is turning out to be very powerful
</I>&gt;<i> and pleasant to use. I appreciate all your work.
</I>
Thanks!

&gt;<i> 1. I'm trying to create an UnauthenticatedTub that listens on a 
</I>&gt;<i> system-assigned port (that is, on &quot;tcp:0&quot;). (I do this because I pass the 
</I>&gt;<i> underlying Referenceable to a remote server, and the random port is just a 
</I>&gt;<i> convenience to assist in debugging).
</I>&gt;<i>
</I>&gt;<i> tub = UnauthenticatedTub()
</I>&gt;<i> l = tub.listenOn(&quot;tcp:0&quot;)
</I>&gt;<i> tub.setLocation(&quot;localhost:%d&quot; % l.getPortnum() )
</I>&gt;<i> url = tub.registerReference(myserver, &quot;my-service&quot;)
</I>&gt;<i> print &quot;the object is available at:&quot;, url
</I>&gt;<i>
</I>&gt;<i> tub.startService()
</I>&gt;<i> reactor.run()
</I>
&gt;<i> However, when code like this runs, it falls foul of the &quot;assert 
</I>&gt;<i> self.s.running&quot; at pb.py:73 (in getPortnum()).
</I>&gt;<i>
</I>&gt;<i> This seems to imply that the reactor needs to be running before we can
</I>&gt;<i> actually assign a port, so we can't call setLocation() or
</I>&gt;<i> registerReference() until this is done.
</I>
Close.. it requires that the Tub has been started, which is a slightly weaker
requirement than the reactor being running. If you rearrange the order of
operations to do:

 tub = UnauthenticatedTub()
 tub.startService()
 l = tub.listenOn(&quot;tcp:0&quot;)
 tub.setLocation(&quot;localhost:%d&quot; % l.getPortnum() )
 url = tub.registerReference(myserver, &quot;my-service&quot;)
 print &quot;the object is available at:&quot;, url

 reactor.run()

Then you should find that it starts working ok.

Port numbers are allocated as soon as the Tub service is started, and isn't
&quot;slow&quot; (in the sense that it requires multiple turns of the reactor to
complete). The Tub is not supposed to do any network IO until it is started,
so it won't allocate the port until that point, but it doesn't really need to
be post-reactor.run().

(incidentally, if you need to know when the reactor has started for other
reasons, you can use reactor.callWhenRunning(cb))

The current version of Foolscap doesn't quite honor this &quot;don't start until I
tell you to&quot; rule: if you do getReference() before startService(), it will
cheerfully initiate outbound network connections anyways. This will be fixed
at some point.

&gt;<i> 2. I sent an email a while back about a possible bug I found; the archived 
</I>&gt;<i> version is here:
</I>&gt;<i>
</I>&gt;<i>   <A HREF="http://twistedmatrix.com/pipermail/twisted-python/2007-March/014914.html">http://twistedmatrix.com/pipermail/twisted-python/2007-March/014914.html</A>
</I>
Yeah, sorry about not responding to that.. things got busy that month :).

(to be honest there are probably a number of issues with Copyable, as I
haven't personally used it nearly as much as the rest of Foolscap.)

Reading over your note, I think your analysis is exactly right.
Copyable.slice() is obligated to set self.streamable before any child objects
might get seralized, which means before the first yield(). I'll fix this
tonight. I wonder why the unit tests didn't catch it..

thanks!
 -Brian


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="047732.html">[Twisted-Python] Foolscap-0.1.1 released
</A></li>
	<LI>Next message (by thread): <A HREF="047648.html">[Twisted-Python] 3 questions about async,	threading and dynamic protocol selection
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47755">[ date ]</a>
              <a href="thread.html#47755">[ thread ]</a>
              <a href="subject.html#47755">[ subject ]</a>
              <a href="author.html#47755">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
