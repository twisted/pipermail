<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Synchronization techniques
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Synchronization%20techniques&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015148.html">
   <LINK REL="Next"  HREF="015153.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Synchronization techniques</H1>
    <B>Paul G</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Synchronization%20techniques&In-Reply-To="
       TITLE="[Twisted-Python] Synchronization techniques">paul-lists at perforge.com
       </A><BR>
    <I>Wed Apr  4 13:34:32 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="015148.html">[Twisted-Python] Synchronization techniques
</A></li>
        <LI>Next message: <A HREF="015153.html">[Twisted-Python] Re: Synchronization techniques
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15150">[ date ]</a>
              <a href="thread.html#15150">[ thread ]</a>
              <a href="subject.html#15150">[ subject ]</a>
              <a href="author.html#15150">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Daniel Miller wrote:
-- snip --
&gt;<i> So anyway, I rewrote my server-side library to do it the twisted way
</I>&gt;<i> and return deferred's instead trying rig up some way of waiting for
</I>&gt;<i> them. I still think it would be super useful to be able to pseudo-
</I>&gt;<i> block on a deferred (i.e. allow the reactor to process other events
</I>&gt;<i> while waiting for the deferred). It is very annoying to have to
</I>&gt;<i> rewrite many layers of code when twisted is introduced into a
</I>&gt;<i> program. I did find gthreadless.py, and maybe that would do it.
</I>&gt;<i> Unfortunately discussion on that seems to have been dropped some time
</I>&gt;<i> ago...
</I>
you can still use that method *if* you're willing to patch your cpython with 
the stackless changes and live with the requirement that this be done on all 
cpythons your code is going to run on. short of that, or using evil bytecode 
hacks, it's not really possible to implement - you need the ability to save, 
switch and restore stacks plus call into the middle of a function. while 
this can be done with generators, it is virtually equivalent to splitting 
your functions into a top/bottom half and is not directly supported, so it 
ends up looking ugly. if pypy ever gets to the point where it's usable in 
production (has the required c extensions ported and runs close in speed to 
cpython on non-trivial code), syntactic support for such usage could be 
added. please note that if you hadn't wanted to take advantage of being in 
an event loop, you could have easily stuck your code - unchanged - into a 
thread pool (via apis helpfully provided by twisted) and just written a few 
lines of code to adapt the interfaces.

this has little to do with twisted, which - imo - does a wonderful job of 
making the (for some, abeit not me personally) difficult execution flow 
model palatable and clear. twisted might be a very good framework, but it 
isn't an async fairy that sneaks into your room at night and - if you've 
been good - rewrites your code to be all twisty and eventful and leaves a 
quarter under your pillow.

with all that said, the sooner you start thinking of a program as a series 
of events being emitted and handled, the better for you and your twisted 
code - everything will become very natural at that point instead of looking 
like an idiosyncracy. while there are a few languages, like erlang for 
example, that express event loops with cooperative threading syntax 
(processes, messages and futures), i'm of the opinion that it's actually 
harmful to hide the event loop details from people who haven't started 
thinking that way yet - they should be simply syntactic sugar for when 
you've already grokked the model. it's inherently impossible to write good 
concurrent code without this insight, including preemptiver multithreading 
code as well. writing preemption and smp safe mt code boils down to 
understanding the chain of processing each 'event', where such event is 
access to shared data, goes through and the interaction between two or more 
such events descending down this chain - this is the only effective way i've 
found to think about memory barriers and cache coherency for example. just 
like grokking functional programming, grokking this will make you (the 
impersonal pronoun version) a better programmer (fwiw, it's made functional 
programming easier to get for me personally).

cheers,
-p 



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015148.html">[Twisted-Python] Synchronization techniques
</A></li>
	<LI>Next message: <A HREF="015153.html">[Twisted-Python] Re: Synchronization techniques
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15150">[ date ]</a>
              <a href="thread.html#15150">[ thread ]</a>
              <a href="subject.html#15150">[ subject ]</a>
              <a href="author.html#15150">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
