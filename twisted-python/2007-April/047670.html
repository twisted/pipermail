<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Synchronization techniques
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Synchronization%20techniques&In-Reply-To=%3CF929DDF9-5640-4DC6-9D41-AFA878B4C412%40keystonewood.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="047659.html">
   <LINK REL="Next"  HREF="047671.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Synchronization techniques</H1>
    <B>Daniel Miller</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Synchronization%20techniques&In-Reply-To=%3CF929DDF9-5640-4DC6-9D41-AFA878B4C412%40keystonewood.com%3E"
       TITLE="[Twisted-Python] Synchronization techniques">daniel at keystonewood.com
       </A><BR>
    <I>Wed Apr  4 22:25:12 MDT 2007</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="047659.html">[Twisted-Python] Synchronization techniques
</A></li>
        <LI>Next message (by thread): <A HREF="047671.html">[Twisted-Python] Synchronization techniques
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47670">[ date ]</a>
              <a href="thread.html#47670">[ thread ]</a>
              <a href="subject.html#47670">[ subject ]</a>
              <a href="author.html#47670">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Apr 4, 2007, at 1:43 PM, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:

&gt;<i> On 04:35 pm, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">daniel at keystonewood.com</A> wrote:
</I>&gt;<i> &gt;On Apr 3, 2007, at 8:42 PM, Itamar Shtull-Trauring wrote:
</I>&gt;<i> &gt;&gt;On Tue, 2007-04-03 at 17:07 -0400, Daniel Miller wrote:
</I>&gt;<i> &gt;&gt;&gt;&gt;twisted.internet.defer.DeferredLock and some of the related  
</I>&gt;<i> classes
</I>&gt;<i> &gt;&gt;&gt;&gt;are
</I>&gt;<i> &gt;&gt;&gt;&gt;what you ought to be using.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;Unfortunately that only gets me half way there.  
</I>&gt;<i> DeferredLock.acquire
</I>&gt;<i> &gt;&gt;&gt;() returns a deferred. How do I return the result of a deferred  
</I>&gt;<i> from
</I>&gt;<i> &gt;&gt;&gt;a PB remote_xxx() function?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Just return the Deferred from the remote_xxx() function.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Thanks, I didn't know I could return a deferred from a PB  
</I>&gt;<i> remote_xxx ()
</I>&gt;<i> &gt;method. That detail doesn't seem to be documented in the   
</I>&gt;<i> Perspective Broker
</I>&gt;<i> &gt;documentation, which I have read quite a few  times.
</I>&gt;<i>
</I>&gt;<i> The PB documentation is not too great.  Perhaps this paper would be  
</I>&gt;<i> helpful to you, if you haven't seen it:
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://www.lothar.com/tech/papers/PyCon-2003/pb-pycon/pb.html#auto7">http://www.lothar.com/tech/papers/PyCon-2003/pb-pycon/pb.html#auto7</A>
</I>&gt;<i>
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     In addition, the remote method can itself return a Deferred  
</I>&gt;<i> instead of an
</I>&gt;<i>     actual return value. When that Deferreds fires, the data given  
</I>&gt;<i> to the
</I>&gt;<i>     callback will be serialized and returned to the original caller.
</I>&gt;<i>     &quot;&quot;&quot;
</I>
Thanks, I had not read that before, and that does explain it.  
Although it's such a short note that it could be easily missed. It  
would be much better to have a code example.

&gt;<i>
</I>&gt;<i> &gt; Maybe this could be
</I>&gt;<i> &gt;highlighted in the &quot;Complete Example&quot; [0]  section of the PB usage
</I>&gt;<i> &gt;documentation? The examples use the  TwistedQuotes application,  
</I>&gt;<i> and the
</I>&gt;<i> &gt;IQuoter.getQuote() method always  returns a string (at least I  
</I>&gt;<i> couldn't find
</I>&gt;<i> &gt;any implementations that  return a deferred).
</I>&gt;<i>
</I>&gt;<i> Please feel free to write some patches for the documentation, or  
</I>&gt;<i> open a doc bug describing this issue in more detail.  It's  
</I>&gt;<i> definitely an under-documented feature of PB.
</I>
I'll try to do that sometime soon.

&gt;<i>
</I>&gt;<i> &gt;However, that would require
</I>&gt;<i> &gt;rewriting most if not  all implementations of IQuoter to return  
</I>&gt;<i> deferred's
</I>&gt;<i> &gt;and/or the code  that calls IQuoter.getQuote(), which demonstrates  
</I>&gt;<i> the viral
</I>&gt;<i> &gt;nature of  twisted when used in conjunction with other libraries.
</I>&gt;<i>
</I>&gt;<i> I don't think that would really be the terrible burden that you  
</I>&gt;<i> suggest, considering the relatively small amount of tutorial  
</I>&gt;<i> documentation that implements or calls IQuoter.  One could also  
</I>&gt;<i> propose a separate interface, IDeferredQuoter, to make the  
</I>&gt;<i> distinction clearer.
</I>
Well of course it's no big deal to change IQuoter, but that specific  
case wasn't really my point. My point is that in the real world it's  
a BAD THING to have to rewrite perfectly good/working/tested code  
just because we want to use twisted. But this is exactly what  
happened to me when twisted was introduced into my project.

&gt;<i>
</I>&gt;<i> &gt;So anyway, I rewrote my server-side library to do it the twisted  
</I>&gt;<i> way  and
</I>&gt;<i> &gt;return deferred's instead trying rig up some way of waiting for   
</I>&gt;<i> them. I
</I>&gt;<i> &gt;still think it would be super useful to be able to pseudo- block on a
</I>&gt;<i> &gt;deferred (i.e. allow the reactor to process other events  while  
</I>&gt;<i> waiting for
</I>&gt;<i> &gt;the deferred). It is very annoying to have to  rewrite many layers  
</I>&gt;<i> of code
</I>&gt;<i> &gt;when twisted is introduced into a  program. I did find  
</I>&gt;<i> gthreadless.py, and
</I>&gt;<i> &gt;maybe that would do it.  Unfortunately discussion on that seems to  
</I>&gt;<i> have been
</I>&gt;<i> &gt;dropped some time  ago...
</I>&gt;<i>
</I>&gt;<i> I'm afraid that the feature you want doesn't make any sense and is,  
</I>&gt;<i> in a broad sense, impossible.
</I>
Maybe it's impossible for you to see things the way I see them  
because you have become drunk on Twisted Kool-Aide. In my specific  
case I am running twisted in a single-threaded environment with a  
single synchronized resource where each request that needs to access  
that resource must gain an exclusive lock before doing anything with  
it (a classic locking scenario). This is not &quot;I'm being lazy and I do  
not want to learn how to use Deferreds.&quot; Rather, it is a requirement  
that is dictated by the system with which I am communicating (it does  
not support concurrent access through the API provided by the  
vendor). Thus, my code would be much simpler (both to write and  
maintain) if I had blockOn(), and it would not have any risk of dead  
lock or other such concurrency bugs. You might ask why I bother to  
use Twisted? -- Perspective Broker is the most elegant way I could  
find to call remote methods in Python. If it were abstracted from  
Twisted to become a fully synchronous library I would use that  
instead, but at this point it seems that if I want PB I am stuck with  
Twisted too.

In short, this feature does &quot;make sense&quot; in my environment. Whether  
it's possible or not is another matter entirely.

&gt;<i>  There are some things like it which might be possible - for  
</I>&gt;<i> example, <A HREF="http://twistedmatrix.com/trac/ticket/2545">http://twistedmatrix.com/trac/ticket/2545</A> - but the  
</I>&gt;<i> reactor is not reentrant and in some sense could not be made  
</I>&gt;<i> reentrant.
</I>&gt;<i>
</I>&gt;<i> Consider this innocuous looking block of code:
</I>&gt;<i>
</I>&gt;<i>     from twisted.internet.protocol import Protocol
</I>&gt;<i>     from make_believe import magicallyBlockOn
</I>&gt;<i>
</I>&gt;<i>     class MagicalProtocol(Protocol):
</I>&gt;<i>         def dataReceived(self, data):
</I>&gt;<i>             commands = (self.buf + data).split()
</I>&gt;<i>             self.buf = commands[-1]
</I>&gt;<i>             for command in commands[:-1]:
</I>&gt;<i>                 if command == 'QUIT':
</I>&gt;<i>                     self.transport.loseConnection()
</I>&gt;<i>                     return
</I>&gt;<i>                 else:
</I>&gt;<i>                     # Deferreds are hard, let's go shopping
</I>&gt;<i>                     page = magicallyBlockOn(getPage(&quot;<A HREF="http://">http://</A> 
</I>&gt;<i> example.com/%s&quot; %
</I>&gt;<i>                                                     (command,)))
</I>&gt;<i>                     self.transport.write(&quot;SIZE:&quot;+len(page))
</I>
You're &quot;Deferreds are hard&quot; comment is an insult. You make it sound  
like I don't want to think. If I didn't want to think I wouldn't be  
be a software developer.

This code obviously won't work because the getPage() has to wait and  
another dataReceived() call could come in with a QUIT command while  
the first one is still waiting for getPage(). Instead you'd need to  
accumulate the data in a buffer and then do your command processing  
logic after all data has been received--that is, if you want to use  
blockOn(getPage(...))--it probably wouldn't be the smartest way to do  
this because it would be nice to start getting pages before we  
receive all of the data. But this is just one case that doesn't work  
with blockOn(). I've never said that it would magically make every  
case easier, it just makes some less complicated cases very much  
simpler.

Everything I've read about this issue suggests that the twisted  
developers just don't want to give people what they want because it  
would allow them to shoot themselves in the foot (for example, by  
using blockOn() in a multi-threaded environment or in inappropriate  
places such as the example above). But this is Python and we're  
consenting adults. With the proper warnings a feature like this could  
make twisted much more palatable for people with large existing  
projects that do not wish to rewrite entire sections of code just to  
work with deferreds. It would allow people to get the easiest thing  
working as quickly as possible, and then go back and write the  
optimal deferred implementation later when performance/blocking/etc.  
becomes an issue.

Most people that would use blockOn() would probably use it in an  
entirely synchronous fashion where there would only be one deferred  
being processed at any given time. In these cases blockOn() would  
work just fine (if inefficiently). From your point of view that  
probably totally defeats the purpose of using twisted, but as I have  
pointed out above there are other useful features in twisted beside  
its deferred mechanism (PB).

The concept that I am thinking of seems entirely possible, although I  
am sure it would require rewriting existing reactor implementations.  
However, in the long run that seems like a small cost if twisted  
could be more widely adopted because it would play nicer with  
existing non-async code.

&gt;<i>
</I>&gt;<i> If you were using Deferreds to track the result of the 'getPage'  
</I>&gt;<i> operation, you could cancel the callbacks that write to the  
</I>&gt;<i> transport in connectionLost.  However, with magical blocking, one  
</I>&gt;<i> dataReceived method might be interleaved with another.  That means  
</I>&gt;<i> that every time through the loop, you have to check to see if the  
</I>&gt;<i> transport has already been disconnected - the code as presented  
</I>&gt;<i> here is buggy and will spuriously fail depending on the order of  
</I>&gt;<i> the connection being lost and the remote page being retrieved.
</I>&gt;<i>
</I>&gt;<i> In this example I've been careful to accumulate all the buffer- 
</I>&gt;<i> management and parsing logic at the top of the method, before any  
</I>&gt;<i> potential re-entrancy can happen, but other code (most everything  
</I>&gt;<i> in Twisted's existing protocol implementations, not to mention just  
</I>&gt;<i> about all application code) would not be so lucky.
</I>&gt;<i>
</I>&gt;<i> It might be quite feasible to implement a microthreaded runtime  
</I>&gt;<i> environment that lived on _top_ of Twisted and explicitly accounted  
</I>&gt;<i> for issues like these, but that would not really be substantially  
</I>&gt;<i> different than 2.5+inlineCallbacks.
</I>&gt;<i>
</I>&gt;<i> &gt;For the record, I've included updated versions of the previously   
</I>&gt;<i> posted
</I>&gt;<i> &gt;code below. I'd be happy if someone pointed out if I'm doing   
</I>&gt;<i> anything wrong
</I>&gt;<i> &gt;(with respect to twisted) in this code.
</I>&gt;<i>
</I>&gt;<i> Nothing immediately jumps out at me.
</I>
Thanks for the review.

~ Daniel




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="047659.html">[Twisted-Python] Synchronization techniques
</A></li>
	<LI>Next message (by thread): <A HREF="047671.html">[Twisted-Python] Synchronization techniques
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47670">[ date ]</a>
              <a href="thread.html#47670">[ thread ]</a>
              <a href="subject.html#47670">[ subject ]</a>
              <a href="author.html#47670">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
