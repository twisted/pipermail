<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] twisted.web and MySQLdb
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20twisted.web%20and%20MySQLdb&In-Reply-To=20031029062817.23143.qmail%40green.zadka.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006226.html">
   <LINK REL="Next"  HREF="006200.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] twisted.web and MySQLdb</H1>
    <B>Rene Dudfield</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20twisted.web%20and%20MySQLdb&In-Reply-To=20031029062817.23143.qmail%40green.zadka.com"
       TITLE="[Twisted-Python] twisted.web and MySQLdb">illumen at yahoo.com
       </A><BR>
    <I>Wed Oct 29 02:50:56 EST 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="006226.html">[Twisted-Python] twisted.web and MySQLdb
</A></li>
        <LI>Next message: <A HREF="006200.html">[Twisted-Python] Serving web pages: Using frames, and re-rendering one frame's con	tent from a separate frame, and colors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6215">[ date ]</a>
              <a href="thread.html#6215">[ thread ]</a>
              <a href="subject.html#6215">[ subject ]</a>
              <a href="author.html#6215">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Moshe Zadka wrote:

&gt;<i>I won't reply to your question here, I'm sure someone more competent
</I>&gt;<i>than me can do so.
</I>&gt;<i>I will take a minute to note that for some reason, the instinct of
</I>&gt;<i>web developers has been to immediately write applications in the
</I>&gt;<i>LAMP model. While twisted.web is a perfectly good substitute for
</I>&gt;<i>A, and can indeed be used this way, it is much more capable.
</I>&gt;<i>
</I>&gt;<i>LAMP -- Linux Apache MySQL PHP [each of those has variants]
</I>&gt;<i>
</I>&gt;<i>Linux (and most other things in the &quot;L&quot; place, such as FreeBSD) has
</I>&gt;<i>an incredibly fast fork() operation. This leads people to write their
</I>&gt;<i>web code with the process-per-page model. Apache optimizes this by
</I>&gt;<i>preforking, making such code actually scalable enough to deliver good
</I>&gt;<i>response times. However, suddenly there is a problem: since different
</I>&gt;<i>processes are likely to deal with the same user, memory becomes fragile.
</I>&gt;<i>It is unsafe to put things in memory: processes switch users, get born
</I>&gt;<i>and die too often. In Linux, and most other Unices, file locking has
</I>&gt;<i>been a thorny issue. So instead of putting data in files, where the
</I>&gt;<i>subtle semantics of locking and concurrency should be dealt with,
</I>&gt;<i>data tends to end up in the database. That means *all* data. Sessions.
</I>&gt;<i>Temporary &quot;show this message when the user finished his redirect loop&quot;.
</I>&gt;<i>Etc. etc. Once all the data is in MySQL, which is the easiest database to
</I>&gt;<i>set up, it becomes natural for the average page to be a &quot;glorified select&quot;.
</I>&gt;<i>PHP was designed for this exact scenario: take a select table and spruce
</I>&gt;<i>it up with HTML.
</I>&gt;<i>
</I>&gt;<i>Unfortunately, what LAMP deals to is exactly to this: inevitably, all
</I>&gt;<i>pages are just spruced up select-tables. This makes programming somewhat
</I>&gt;<i>unnatural unless you're programming a database viewer.
</I>&gt;<i>
</I>&gt;<i>With twisted.web, you don't have these problems. It is easy to keep data
</I>&gt;<i>in files, because locking is not an issue. It is easy to cache data in memory
</I>&gt;<i>because everything is served from a single process. If you need to attach
</I>&gt;<i>state to a user's session, you can just keep an object in the session.
</I>&gt;<i>This means programming twisted.web should be a lot more like writing
</I>&gt;<i>a GUI application, and a lot less like writing select-with-HTML.
</I>&gt;<i>You should probably reconsider whether you really want MySQL. It adds
</I>&gt;<i>complexity to your application, and the gain is usually small. Putting
</I>&gt;<i>persistent data in files, and using liberal caching schemes, also plays
</I>&gt;<i>on the core advantage of Linux (and similar) -- it uses the incredibly
</I>&gt;<i>optimized caching algorithms.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>RANDOM NOTES ON THIS TOPIC:

Single process has problems too:
- if something blocks or stalls down comes your whole app.  This can 
happen in multi proccess too of course.
- you don't use the operating systems privileges.  You invent your own 
which is often broken and needs to be rewritten a few times.

Of course both of these can happen with your LAMP too.  If the db goes 
down or whatever.  But I guess multiprocess is more resiliant.

Some people find select statements easier.  Often you can do something 
in a line or two which is cumbersum in python.

Berkley db databases are nice to use.  They are quite optimized, and can 
emulate python dictionaries quite nicely.  Then there is zopedb which is 
an option.

Another feature databases have over files is transactions(comming soon 
to a FS near you!).  Making sure stuff is written to files reliably is 
quite difficult.

Databases are accessable from database viewers!  This is handy since 
random python object viewers are not so good :)  You can access 
databases easily from other languages, whereas python objects are harder 
to do.  I guess jelly/xmlrpc/soap helps here if you want to use those.

Databases also handle large volumes of data efficiently(or try to).  
Keeping everything in files is fine as long as you lay it out nicely and 
you have plenty of time to optimize each new query.  However the 
advantages/disadvantages of dbs are discussed to death all over the 
place, and I have nothing new to add.

Be nice to be able to use python objects as memory mapped files.  I 
guess it may be possible.  It has been done with numeric arrays, and 
with c++ objects.  This can be faster than reading files in linux too.

A lot of web pages can be cached into static files which improves 
performance by a lot.  Chucking squid, or apache as proxy in front of 
your normal webserver(s) can be a large help if you are careful.


Have fun!



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006226.html">[Twisted-Python] twisted.web and MySQLdb
</A></li>
	<LI>Next message: <A HREF="006200.html">[Twisted-Python] Serving web pages: Using frames, and re-rendering one frame's con	tent from a separate frame, and colors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6215">[ date ]</a>
              <a href="thread.html#6215">[ thread ]</a>
              <a href="subject.html#6215">[ subject ]</a>
              <a href="author.html#6215">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
