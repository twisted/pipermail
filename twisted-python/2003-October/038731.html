<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] twisted.web and MySQLdb
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20twisted.web%20and%20MySQLdb&In-Reply-To=%3C3F9FEC48.7020403%40yahoo.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="038749.html">
   <LINK REL="Next"  HREF="038748.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] twisted.web and MySQLdb</H1>
    <B>Rene Dudfield</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20twisted.web%20and%20MySQLdb&In-Reply-To=%3C3F9FEC48.7020403%40yahoo.com%3E"
       TITLE="[Twisted-Python] twisted.web and MySQLdb">illumen at yahoo.com
       </A><BR>
    <I>Wed Oct 29 09:35:20 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="038749.html">[Twisted-Python] twisted.web and MySQLdb
</A></li>
        <LI>Next message (by thread): <A HREF="038748.html">[Twisted-Python] twisted.web and MySQLdb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38731">[ date ]</a>
              <a href="thread.html#38731">[ thread ]</a>
              <a href="subject.html#38731">[ subject ]</a>
              <a href="author.html#38731">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

adding more random thoughts below on LAMP sucking, and spitting.


Glyph Lefkowitz wrote:

&gt;<i> Nathan Seven wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Hmmmm I would qualify that- I dont think the
</I>&gt;&gt;<i> filesystem is the place to be handling dynamic data. 
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The filesystem is a fine place.
</I>&gt;<i>
</I>&gt;<i> For example, in the Prevayler persistence model, you just write 
</I>&gt;<i> logfiles to disk, and synchronize your state at a checkpoint.  For 
</I>&gt;<i> highly dynamic applications, especially ones which require failover, 
</I>&gt;<i> (You can re-play the transaction log live, after all) this works quite 
</I>&gt;<i> well.
</I>&gt;<i>
</I>&gt;&gt;<i> Databases were created *specifically* for this
</I>&gt;&gt;<i> purpose.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I think that databases were specifically designed to store accounting 
</I>&gt;<i> information, actually.
</I>&gt;<i>
</I>&gt;&gt;<i> Sure, storing all your static blobs in your
</I>&gt;&gt;<i> database is a really quick way to grind shit to a
</I>&gt;&gt;<i> halt, but locking and concurrency?
</I>&gt;&gt;<i> If you're doing things properly, and your http server
</I>&gt;&gt;<i> is just serving static objects, then these are
</I>&gt;&gt;<i> non-issues.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Databases can be amazingly slow, especially if you have a lot of 
</I>&gt;<i> updates to do.  (Even a very fast database can be made slow by I/O 
</I>&gt;<i> bottlenecks if you are trying to make it remote for scalability 
</I>&gt;<i> reasons.)  This has an easy solution: you can cache everything!  Of 
</I>&gt;<i> course, then you need to be able to easily access the cache from all 
</I>&gt;<i> of the machines, because it may have been updated.  Now you have 
</I>&gt;<i> problems with coherency.  Then you need to lock the cache, because it 
</I>&gt;<i> could have been updated, and then you need to read from it.
</I>&gt;<i>
</I>&gt;<i> Pretty soon you're talking to your caching server as if it were a 
</I>&gt;<i> database.  This is _great_ if you are Livejournal:
</I>&gt;<i>
</I>&gt;&gt;<i> Yeah- through my line of work I deal with a *lot* of
</I>&gt;&gt;<i> different infrastructures.  Everything from &quot;Joe's BBQ
</I>&gt;&gt;<i> Sauce Garage&quot; to Amazon.  Literally the only
</I>&gt;&gt;<i> organization I can think of that can keep anything
</I>&gt;&gt;<i> coherent with MySQL is Livejournal- and then I believe
</I>&gt;&gt;<i> only because Brad seems to be a cache-god with
</I>&gt;&gt;<i> memcached and such.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> because then you don't have to worry about computation, mutable data, 
</I>&gt;<i> etc - you're basically just storing data and then spitting it back 
</I>&gt;<i> out, and you don't care if the timestamps are a little off.
</I>&gt;<i>
</I>&gt;<i> This is the important point about LAMP and Twisted:
</I>&gt;<i>
</I>&gt;<i> There are applications which can connect to HTTP which are not blogs.
</I>&gt;<i>
</I>&gt;<i> If you are writing a multiplayer game which wants to support lots of 
</I>&gt;<i> concurrent users, you can't afford to spawn a thread and do a database 
</I>&gt;<i> request every time a player picks something up.  
</I>
New versions of linux have very quick threads.  Also different apps have 
different speeds for threads.  Small programs (say less than 100 
kilobytes) which are entirely static are lots faster than multi megabyte 
processes which dynamically load things.  Threads and processes also can 
easily use multiple cpus. 

Of course there are other reasons people don't like threads.

http for games?  If your game is sensitive to latency and you can help 
it, avoid http for games.  Http gives you much more latency than a db.  
So does a centralised server for that matter.  In a two player game you 
can half your latency by talking directly to each other.  Assuming you 
both aren't behind a non configurable firewall, or a proxy server.  http 
is good as a backup protocol though.  Because some fascists don't allow 
anything but access to the internet except through a proxy.  Or maybe 
you are playing a game in a web browser :)

Note that some dbs have async interfaces(eg postgres).  So you wouldn't 
need a thread.


btw, anyone know if sendfile is in (or going to be in python soon)?
<A HREF="http://mail.python.org/pipermail/python-dev/2002-March/021498.html">http://mail.python.org/pipermail/python-dev/2002-March/021498.html</A>

&gt;<i> (Python is quite slow enough already, thanks.)  You can't just use a 
</I>&gt;<i> cache because the data changes _all the time_, and you have to care 
</I>&gt;<i> about it from everywhere that you care about your data.  Working with 
</I>&gt;<i> your objects directly in memory is close to the only option.
</I>
What about berkley dbs?  I think bsddb3 was 3-4 times slower than a 
python dict in general.  They are very quick, and you don't need to lock 
them.  You can use transactions.  Locking can kill performance.

Quickness depends on memory, and data sets really.  These are 
approximate speedinesses of python dictionary like things for different 
data sizes and memory:
say 700MB of memory:

200 MB key value data - python dicts, kjDicts, berklydb3 on disk db.
400 MB key value data - kjDicts(as python dicts use more memory and 
begin swapping), berkley db3-4 on disk, python dicts.
 &gt; 2 gigs of key value data - berkley db3-4 on disk, kjDicts(the kjdict 
starts swapping before here), python dicts.

Of course deleting large python dicts is *really* slow.  I used to kill 
my python processes with kill -9 so that I didn't have to wait for the 
reference counting garbage collecting beast to do lots of free()s on the 
dicts memory.  kjDicts and bsddb dbs were faster for deleting.

Some people do use RDBMS for large online games.  Check out 
gamasutra.com for some articles.  Seems they have lots of fun 
performance problems.

Compressing the hash would be nice.  Maybe memory mapped files on a 
compressed file system would be quick for this ;) 

Distributed hashes would also be nice!  Any good distruted hashes for 
python?

I think memory is one of the first things that kill apache 
performance(when using preforking).  Especially when it has massive php 
compiled in!  You can get big speed boosts by using different apache 
configs for different request types(even on the same machine).  Eg set 
one up for static files(eg images), and one for your bloated php.

&gt;<i>
</I>&gt;<i> If you're writing a real-time financial data system, you do want to 
</I>&gt;<i> use a database, but you want to very carefully control your access to 
</I>&gt;<i> it. Certainly, you don't want to equate 'web hit' with 'database 
</I>&gt;<i> query', as the LAMP model is wont to do.
</I>&gt;<i>
</I>&gt;<i> Or maybe you're writing an application that has to operate as a 
</I>&gt;<i> client-side proxy, and you don't have the leisure of a DBA at every 
</I>&gt;<i> desk, so you can't require that an RDBMS gets set up with each 
</I>&gt;<i> installation.  This might require some hackish workarounds with the 
</I>&gt;<i> filesystem that you'd rather not do, but nevertheless, it's better 
</I>&gt;<i> than having the user editing pg_hba.conf themselves.
</I>&gt;<i>
</I>SQLlite and berkley db are good for easy to bundle dbs.

One good thing about LAMP though is that lots of servers have it 
installed, and it can be quite cheap to use as a platform.

As you say, not everything is a blog.  There are too many different 
factors for a one size fits all 'this way is best' solution.  Besides 
everyone knows twisted rules ;)


Have fun!



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="038749.html">[Twisted-Python] twisted.web and MySQLdb
</A></li>
	<LI>Next message (by thread): <A HREF="038748.html">[Twisted-Python] twisted.web and MySQLdb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#38731">[ date ]</a>
              <a href="thread.html#38731">[ thread ]</a>
              <a href="subject.html#38731">[ subject ]</a>
              <a href="author.html#38731">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
