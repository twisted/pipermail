<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] newbie: groking flows
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20newbie%3A%20groking%20flows&In-Reply-To=25160AB2660F8B449892B0EB9C29C165CE5612%40ex-sea-is2.cobaltgroup.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005973.html">
   <LINK REL="Next"  HREF="005974.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] newbie: groking flows</H1>
    <B>Clark C. Evans</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20newbie%3A%20groking%20flows&In-Reply-To=25160AB2660F8B449892B0EB9C29C165CE5612%40ex-sea-is2.cobaltgroup.com"
       TITLE="[Twisted-Python] newbie: groking flows">cce at clarkevans.com
       </A><BR>
    <I>Thu Oct  9 15:14:30 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="005973.html">[Twisted-Python] newbie: groking flows
</A></li>
        <LI>Next message: <A HREF="005974.html">[Twisted-Python] guard.UsernamePasswordWrapper errback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5975">[ date ]</a>
              <a href="thread.html#5975">[ thread ]</a>
              <a href="subject.html#5975">[ subject ]</a>
              <a href="author.html#5975">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Oct 08, 2003 at 07:21:02PM -0700, Nesbitt, Steve wrote:
|<i> During the regeneration process, which
</I>|<i> can take multiple seconds, all lookup and additional regeneration requests
</I>|<i> should block until completion of the regeneration. Once completed, blocked
</I>|<i> requests should resume.
</I>|<i> 
</I>|<i> Based on my reading I think this is what should do:
</I>|<i> 1) Periodically during a lookup call a flow.Cooperate event to allow other
</I>|<i> lookup events from other requests to be handled.
</I>
Right.

|<i> 2) To avoid a regeneration event in the midst of a lookup, I should make
</I>|<i> sure that a flow.Cooperate event is *not* issued at any time during a
</I>|<i> critical part of the lookup process ( In other words one can consider the
</I>|<i> code executed between two flow.Cooperate statements as a transaction)
</I>
Right.

|<i> 3) When I start a regeneration event I should wrap the regeneration method
</I>|<i> in a flow.Block controller.
</I>
flow.Block is primarly there for testing; I should remove it from
the public interface.  Basically, it does just that, it blocks
*everything* -- which is, of course, not what you want.

You should instead use flow.Deferred( &lt;generator&gt; ) to create
your data flows, when you run flow.Deferred it:

  1. schedules your generator to be run using reactor.callLater(0, ...)
     so, flow.Deferred returns almost immediately and does not run
     your code till the current code finishes running;

  2. for each time you return flow.Cooperate, it reschedules your
     generator to be executed later, ie, reactor.callLater(0, ...)

  3. after your generator finishes, the deferred that was created
     by flow.Deferred runs its callbacks; you should probably install
     an error handler here, ie  flow.Deferred(&lt;generator)&gt;.addErrback(...)

I hope this helps.

...

|<i> 1) Is my basic understanding correct? In particular am I guaranteed correct
</I>|<i> behavior using the above outline?
</I>
You are close; s/flow.Block/flow.Deferred/

|<i> 2) Am I correct in believing that wrapping a method in flow.Block actually
</I>|<i> executes the method? That is, the statement flow.Block( foo( bar ) )
</I>|<i>    executes foo.bar immediately?
</I>
Not immediately, but close enough (it is put on the reactor's queue
to be executed shortly)

|<i> 3) How do I access the results of flow.Block( foo( bar ) )? In particular
</I>|<i> how do I see the return result or any exceptions tr\hrown by foo?
</I>
def good(results):
    print &quot;good&quot;, results
def bad(failure):
    print &quot;bad&quot;, failure

d = flow.Deferred()
d.addCallback(good)
d.addErrback(bad)


...

If you _really_ want to use flow.Block, then flow.Block executes
the function immediately and returns a list containing the results.

|<i> 4) Am I correct in believing that while flow.Block( foo(bar) ) is executing
</I>|<i> any incoming requests will be prevented from executing?
</I>
For flow.Block, yes.  For flow.Deferred, no.

|<i> 5) Is it possible to defer a blocking method? This covers the scenario where
</I>|<i> two regeneration events occur within the same time frame.
</I>
Yes, use flow.Deferred  

To handle your case where there is a &quot;regeneration&quot; happening,
suppose you have a object 'gList' which gets regenerated periodically.
Your generator could do...

   def gen():
       while gList.generating():
           yield flow.Cooperate()
       # access the gList that is not generating

Best,

Clark 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005973.html">[Twisted-Python] newbie: groking flows
</A></li>
	<LI>Next message: <A HREF="005974.html">[Twisted-Python] guard.UsernamePasswordWrapper errback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5975">[ date ]</a>
              <a href="thread.html#5975">[ thread ]</a>
              <a href="subject.html#5975">[ subject ]</a>
              <a href="author.html#5975">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
