<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Consistent interfaces to	asynchronous	partially-available services	using	Deferreds and	state	machines (was Re: Another approach to allowing	__init__	to	work with Deferreds)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Consistent%20interfaces%20to%0A%09asynchronous%09partially-available%20services%09using%09Deferreds%20and%0A%09state%09machines%20%28was%20Re%3A%20Another%20approach%20to%20allowing%09__init__%0A%09to%09work%20with%20Deferreds%29&In-Reply-To=%3C18953.24553.54020.283769%40jon.es%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="052117.html">
   <LINK REL="Next"  HREF="052119.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Consistent interfaces to	asynchronous	partially-available services	using	Deferreds and	state	machines (was Re: Another approach to allowing	__init__	to	work with Deferreds)</H1>
    <B>Terry Jones</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Consistent%20interfaces%20to%0A%09asynchronous%09partially-available%20services%09using%09Deferreds%20and%0A%09state%09machines%20%28was%20Re%3A%20Another%20approach%20to%20allowing%09__init__%0A%09to%09work%20with%20Deferreds%29&In-Reply-To=%3C18953.24553.54020.283769%40jon.es%3E"
       TITLE="[Twisted-Python] Consistent interfaces to	asynchronous	partially-available services	using	Deferreds and	state	machines (was Re: Another approach to allowing	__init__	to	work with Deferreds)">terry at jon.es
       </A><BR>
    <I>Tue May 12 05:39:21 MDT 2009</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="052117.html">[Twisted-Python] Consistent interfaces to asynchronous	partially-available services	using	Deferreds and state	machines (was Re: Another approach to allowing	__init__ to	work with Deferreds)
</A></li>
        <LI>Next message (by thread): <A HREF="052119.html">[Twisted-Python] Consistent interfaces to	asynchronous	partially-available services	using	Deferreds and	state	machines (was Re: Another approach to allowing	__init__	to	work with Deferreds)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#52118">[ date ]</a>
              <a href="thread.html#52118">[ thread ]</a>
              <a href="subject.html#52118">[ subject ]</a>
              <a href="author.html#52118">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Glyph

&gt;&gt;&gt;&gt;&gt;<i> &quot;glyph&quot; == glyph  &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A>&gt; writes:
</I>&gt;<i> On 11 May, 04:19 pm, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">terry.jones at gmail.com</A> wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt;I posted to this list back in Nov 2008 with subject:
</I>&gt;<i> &gt;A Python metaclass for Twisted allowing __init__ to return a Deferred
</I>&gt;<i> 
</I>&gt;<i> Let me try rephrasing your use-case here, for two reasons: one, I want to
</I>&gt;<i> make sure I fully understand it, and two, I feel like the language this is
</I>&gt;<i> couched in (hacks about __init__ and Deferreds and
</I>&gt;<i> metaclass/mixin/decorator [ab]use) are detracting from the real core
</I>&gt;<i> use-case here.
</I>
OK, fair enough. I'm happy to work upwards from my concrete problems to a
solution to a more general problem.

&gt;<i> You have a utility object which you want to create immediately and make
</I>&gt;<i> immediately available to various pieces of calling code.  However, an
</I>&gt;<i> instance of this class represents a shared interface to an external,
</I>&gt;<i> asynchronous resource, to which you must establish a connection, and so
</I>&gt;<i> you don't immediately have a connection when the class is created.
</I>
Yes, though I don't know why you use the word &quot;shared&quot;. Perhaps because a
created instance might be passed to several other pieces of code that all
use it?

&gt;<i> However, you want to contain all this complexity behind a nice facade,
</I>&gt;<i> and tell all the callers &quot;just call these (Deferred-returning) methods
</I>&gt;<i> and you will get sensible results no matter what state the connection is
</I>&gt;<i> in&quot;.
</I>
Yes.

And as I mentioned in my later mail to Drew, a nice property of keeping the
complexity behind the interface is that when a vanilla class that is being
used in the manner you describe, is changed from being reliably in a single
state to having multiple states, the caller is not aware of that and does
not have to change how it instantiates or uses instances of the class.

&gt;<i> If my assessment of your use-case is flawed, please say so
</I>
Nope, that's about perfect.

&gt;<i> To skip ahead to the end: the answer is that you want a state-machine.
</I>&gt;<i> And it is quite sad to me that Twisted doesn't have a nice, standard,
</I>&gt;<i> full-featured state-machine class that we use for everything like this,
</I>&gt;<i> because members of the Twisted team have implemented at least half a
</I>&gt;<i> dozen of these, probably a lot more, in various applications.  I am like
</I>&gt;<i> 90% sure that there's a ticket in the tracker for this, but I couldn't
</I>&gt;<i> find it by searching around a bit.  I hope exarkun or jml or radix will
</I>&gt;<i> have a better memory of this than I do.
</I>
I'll be interested to hear.

I've omitted a big chunk of your reply here - that I agree with and which
recaps what went down in the original thread and comments on Drew's
suggestion.

&gt;<i> But, although I still think this is generally good practice, it doesn't
</I>&gt;<i> solve the underlying problem I think you're really getting at:
</I>&gt;<i> consistency and convenience in the face of Deferred-ness.
</I>
I still like your approach (using a class method to hand you a fully
initialized instance), but didn't find it appropriate for my situation. The
main problem was that I was writing code in an __init__ method of a class
that was already in use by other code, including being called from the
__init__ method of other classes. Your solution is fine if you're in a
context where you can properly deal with deferreds. If you're not (e.g.,
you're in an __init__ method) then calling something that creates you an
instance of another class via a deferred just leaves you with the same
problem. I hope that's making sense.

Is the underlying problem &quot;consistency and convenience in the face of
Deferred-ness&quot;? You could look at it that way (and I'm happy to). My
__init__ case seems to be well summarized by my original comment:

    this is a general problem of the synchronous world (in which __init__
    is supposed to prepare a fully-fledged class instance and cannot return
    a deferred) meeting the asynchronous world in which we would like to
    (and must) use deferreds.

If Python allowed me to return a deferred from __init__, my problem would
vanish.  That's not going to happen though, I know :-)

Yours would remain though, and as you say, it's more general.

&gt;<i> Applications have to handle Deferreds from the connection's methods
</I>&gt;<i> anyway, and there's no reason to force them to all have code to handle at
</I>&gt;<i> least two (one for the connection, one for the actual application-level
</I>&gt;<i> message), where one would do fine.
</I>
I'm not 100% sure that I follow this, but I think so.

&gt;<i> &gt;Anyway.... fast forward 6 months and I've hit the same problem again.
</I>&gt;<i> &gt;It's with existing code, in which I would like an __init__ to call
</I>&gt;<i> &gt;something that (now, due to changes elsewhere) returns a deferred. So I
</I>&gt;<i> &gt;started thinking again, and came up with a much cleaner way to do the
</I>&gt;<i> &gt;alternate approach via a class mixin:
</I>&gt;<i> 
</I>&gt;<i> I think I like this a bit better than your earlier approaches.  It's
</I>&gt;<i> automatic, its semantics are pretty clear, and it doesn't require any abuse
</I>&gt;<i> of __init__'s implicit contract; your instance *is* in a fully valid state
</I>&gt;<i> when it's created, it's just a different state than the state that it's in
</I>&gt;<i> later.  However, you can still call all the same methods and get the same
</I>&gt;<i> results.
</I>
Yes, those are the advantages. And the different state will, in most use
cases (I claim), be quite fleeting. It's that short-term not-quite-ready
window that the temporary state accounts for. And if the not-quite-ready
happens to not be short, then providing functionality like this (not
necessarily my implementation) is even more important.

I mention all this, for clarity, not for you - I know you already know -
but for others who might be reading along now or later.

&gt;<i> It still has one major flaw given your earlier example of a database
</I>&gt;<i> connection (as I described above): it doesn't handle errors very well.
</I>
Right.

&gt;<i> In particular - and this is why you really need a state machine - it
</I>&gt;<i> doesn't handle the case where errors start happening *later*.
</I>
OK, more on this below.

&gt;<i> It's also got a few implementation issues that you might not be aware of
</I>&gt;<i> though - and you seem to appreciate a lot of detail in these responses,
</I>&gt;<i> so I'll just look at it line by line, code-review style.
</I>
Yes, that's great, and thanks.

&gt;<i> I apologize in advance if this sounds like I'm being hypercritical - I
</I>&gt;<i> realize you may have omitted certain details to keep this brief for
</I>&gt;<i> discussion and so may have been aware of most of these problems.  Again,
</I>&gt;<i> even if you fully understood all of these details I am sure there are
</I>&gt;<i> many readers who didn't though :)
</I>
Some I'm aware of and skipped, others not.  I never know how much detail to
provide / go into, or if I'm bugging people on the list, etc.

&gt;<i> &gt;    from twisted.internet import defer
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    class deferredInitMixin(object):
</I>&gt;<i> &gt;        def wrap(self, d, *wrappedMethods):
</I>&gt;<i> 
</I>&gt;<i> Just as a point of convenience, I would have automatically determined this
</I>&gt;<i> list of method names by using a decorator or something.  Having it as a
</I>&gt;<i> static list in the method invocation seems to me like it would be very easy
</I>&gt;<i> to forget to add or remove a method from the list, and it would make diffs
</I>&gt;<i> that touched a user of this class always have two hunks for adding a
</I>&gt;<i> method; one at the method definition site, one at the call to wrap().
</I>
I started out trying to write this using decorators. But I didn't really
see how to do it. I was using two - one for __init__ and one for the
wrapped functions. I also tried with decorators and a super class. In the
end I saw a simple way to do it with the mixin, so went for that. I'd be
happier with a decorator solution for the reasons you mention.

&gt;<i> Also, it's not really clear to me how cooperative invocations of wrap() are
</I>&gt;<i> meant to work with inheritance.  Using a decorator on methods which were
</I>&gt;<i> intended to be deferred wouldn't fully solve that problem (you've still got
</I>&gt;<i> to sort out what order methods get restored in, or if there are multiple
</I>&gt;<i> calls to wrap() in different places in the inheritance tree which methods
</I>&gt;<i> go with which Deferreds) but it would at least provide a convenient
</I>&gt;<i> starting place to put that information.
</I>
Yes....

&gt;<i> &gt;            self.waiting = []
</I>&gt;<i> &gt;            self.stored = {}
</I>&gt;<i> 
</I>&gt;<i> I'd make these attributes private if I were you.  I am pretty sure that
</I>&gt;<i> you don't ever want application code poking around in there :).
</I>
Right. A bad habit of mine. I did at least think of this afterwards :-)

&gt;<i> &gt;            def restore(_):
</I>&gt;<i> &gt;                for method in self.stored:
</I>&gt;<i> &gt;                    setattr(self, method, self.stored[method])
</I>&gt;<i> 
</I>&gt;<i> The reference you're cleaning up here has some edge-cases.  For example,
</I>&gt;<i> if some other code comes along and grabs what it thinks is a regular
</I>&gt;<i> bound method from your instance, and then invokes it after the Deferred
</I>&gt;<i> has completed, it will still have the original method.
</I>
You mean it will still have the wrapped method, I think. Agreed that's a
problem. I was originally going to look at d.called in the mixin class to
short-circuit the wrapped behavior if the deferred had fired. I should do
something like that, else the deferred from the wrapper will never fire -
which is what I think you're saying.

&gt;<i> There are also some less severe, but potentially very confusing issues
</I>&gt;<i> with making every instance of your class always participate in a
</I>&gt;<i> bazillion circular references.
</I>
I don't think I fully understand this. The instance of my class only has
wrapped functions for a (typically?) very short time. I don't see the
circular references, but OTOH I haven't thought about that at all...

&gt;<i> By itself, this isn't really worth worrying about (Python added a garbage
</I>&gt;<i> collector for a reason, after all) but it has historically been
</I>&gt;<i> problematic in areas like making debugging memory leaks tricky.
</I>&gt;<i> Especially when the circular references run through stack frames which
</I>&gt;<i> refer to Deferreds :).  So if you do dynamically replace a method on a
</I>&gt;<i> class, it's better to clean it up with delattr() than a subsequent
</I>&gt;<i> setattr().
</I>
You mean &quot;then&quot; a subsequent setattr, right?

And thanks, I didn't know that at all.

&gt;<i> This wrapper doesn't preserve function metadata
</I>
Right - that was something I deliberately left out. I've even used
t.p.u.mergeFunctionMetadata in the past :-)

&gt;<i> I think some other decorator libraries have cuter / easier to use
</I>&gt;<i> implementations of the same thing, this problem is not unique to
</I>&gt;<i> Twisted).
</I>
There's also functools.update_wrapper

&gt;<i> &gt;            d.addCallback(restore)
</I>&gt;<i> 
</I>&gt;<i> Here, on the final line, we come to the more serious problem of this
</I>&gt;<i> approach: there's no error handling.  If the underlying Deferred
</I>&gt;<i> encounters an errback, then all methods of this class will forever return
</I>&gt;<i> Deferreds that never fire.
</I>
Ah yes :-)

Side note: I recently escaped from a fundamentalist religious organization
amongst whose axioms are &quot;There Are No Accidents&quot;, and &quot;Everything Happens
For A Reason&quot;. Accordingly, they code in a version of Python that doesn't
even have exceptions, and use a fork of Twisted in which deferreds don't
have an errback chain.

Ahem. You're right. At the very least I should add an errback that errbacks
the waiting calls, probably restores the methods, and returns the failure.
That's not a full solution, but it's better.

&gt;<i> Of course you could chalk up a failed connect Deferred to a failed
</I>&gt;<i> startup and just reboot the process, but that pollutes your callers with
</I>&gt;<i> knowledge of whether they're calling methods during startup.
</I>
Yes. There's also the question of what failure to pass to them, suppose I
do errback them (which I think I should).

&gt;<i> More importantly and realistically though - there's something that
</I>&gt;<i> happens *later* which is never covered.  What happens when we *lose* the
</I>&gt;<i> connection to the database?  Assuming a sensible underlying interface,
</I>&gt;<i> everybody starts getting errbacked Deferreds, but in most systems like
</I>&gt;<i> this you want some recovery facility.  And then you're not talking about
</I>&gt;<i> just interesting behavior of __init__, but potentially of every method on
</I>&gt;<i> the entire class.
</I>
Yes, and now we're into more interesting territory, where your state
machine solution would be nice to have.

&gt;<i> As I mentioned above, we've implemented this mechanism in other projects.
</I>&gt;<i> One of them is Axiom.  Axiom has a batch-processing service which is a
</I>&gt;<i> process pool that starts on demand, and tries to present a consistent
</I>&gt;<i> interface to its callers regardless of what state the actual processes are
</I>&gt;<i> in.  (This was written in no small part because we were using libraries
</I>&gt;<i> which were flaky and unreliable and wanted to isolate their usage behind a
</I>&gt;<i> nice facade which wouldn't freak out if they segfaulted.)
</I>&gt;<i> 
</I>&gt;<i> You can see a usage of our library here, which I believe meshes with your
</I>&gt;<i> use-case:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://divmod.org/trac/browser/trunk/Axiom/axiom/batch.py?rev=15165#L709">http://divmod.org/trac/browser/trunk/Axiom/axiom/batch.py?rev=15165#L709</A>
</I>
OK, I'll go check this out. I'd have done it already but commenting on it
here would make this reply even longer.

&gt;<i> I was originally going to include it inline here, but it turned out to be
</I>&gt;<i> &gt;100 lines of code to get the whole idea across, so I put it up here:
</I>&gt;<i> 
</I>&gt;<i>     <A HREF="http://divmod.org/trac/browser/sandbox/glyph/modality.py?rev=17275">http://divmod.org/trac/browser/sandbox/glyph/modality.py?rev=17275</A>
</I>&gt;<i> 
</I>&gt;<i> This is still missing a lot of details, like for example handling truly
</I>&gt;<i> failed connections (i.e. invalid credentials), timeouts and backoff,
</I>&gt;<i> redirects, etc.  Still, I hope it's somewhat obvious how you would add
</I>&gt;<i> additional methods beyond &quot;bork()&quot; to that example.
</I>
Yes. It looks clean and nice. But I'll have to spend time reading it again
and thinking about it to say more.

&gt;<i> It would be possible, I think, to implement a layer on top of epsilon.modal
</I>&gt;<i> which would provide this pattern exactly so that you just need to plug in
</I>&gt;<i> your retransmission and connection rules rather than doing it for every
</I>&gt;<i> different application and protocol; that would be really cool.
</I>
Yeah, I'd use it :-)

&gt;<i> epsilon.modal is missing a few useful features, and has a few bugs.  I'm
</I>&gt;<i> hoping that by drawing attention to it we can get some contributions from
</I>&gt;<i> people who are enthusiastic about abstractions like this (hi, Terry! ;-))
</I>
Glyph, hi!

&gt;<i> &gt;I quite like this approach. (...) It's nice because you don't reply with
</I>&gt;<i> &gt;an error and there's no need for locking or other form of coordination -
</I>&gt;<i> &gt;the work you need done is already in progress, so you get back a fresh
</I>&gt;<i> &gt;deferred and everything goes swimmingly.
</I>&gt;<i> 
</I>&gt;<i> IMHO this is a very important property.  The high-level abstract API should
</I>&gt;<i> really have fewer failure modes and differing states for its callers to
</I>&gt;<i> know about than the lower-level one - really that's the whole point :-).
</I>
Yes, agreed.

&gt;<i> &gt;Comments welcome / wanted.
</I>&gt;<i> 
</I>&gt;<i> Enough comments for you? ;-)
</I>
Yep, and thanks for taking so much time and going into detail. I'll no
doubt continue to think about this. And I'll go look at epsilon.modal.

Terry


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="052117.html">[Twisted-Python] Consistent interfaces to asynchronous	partially-available services	using	Deferreds and state	machines (was Re: Another approach to allowing	__init__ to	work with Deferreds)
</A></li>
	<LI>Next message (by thread): <A HREF="052119.html">[Twisted-Python] Consistent interfaces to	asynchronous	partially-available services	using	Deferreds and	state	machines (was Re: Another approach to allowing	__init__	to	work with Deferreds)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#52118">[ date ]</a>
              <a href="thread.html#52118">[ thread ]</a>
              <a href="subject.html#52118">[ subject ]</a>
              <a href="author.html#52118">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
