<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] help using deferred
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20help%20using%20deferred&In-Reply-To=%3C9cce290a0905111049j693150deye98c0129a977f070%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="052107.html">
   <LINK REL="Next"  HREF="052112.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] help using deferred</H1>
    <B>Luigi Conte</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20help%20using%20deferred&In-Reply-To=%3C9cce290a0905111049j693150deye98c0129a977f070%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] help using deferred">luigiandcosolutions at gmail.com
       </A><BR>
    <I>Mon May 11 11:49:19 MDT 2009</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="052107.html">[Twisted-Python] help using deferred
</A></li>
        <LI>Next message (by thread): <A HREF="052112.html">[Twisted-Python] help using deferred
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#52111">[ date ]</a>
              <a href="thread.html#52111">[ thread ]</a>
              <a href="subject.html#52111">[ subject ]</a>
              <a href="author.html#52111">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2009/5/11 Jean-Paul Calderone &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">exarkun at divmod.com</A>&gt;

&gt;<i> On Mon, 11 May 2009 16:55:40 +0200, Luigi Conte &lt;
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">luigiandcosolutions at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt;I'm sure you're saying only good things but I'm so inexpert in twisted
</I>&gt;<i> that
</I>&gt;<i> &gt;I can't understand very well what to do.
</I>&gt;<i> &gt;I'll try to explain all that I want to do and how I did it wrongly:
</I>&gt;<i> &gt;first I have to call the connect method from the api and it returns a
</I>&gt;<i> &gt;deferred so I do:
</I>&gt;<i> &gt;in conn_to_ctrl i have:
</I>&gt;<i> &gt;d = api.connect(...)
</I>&gt;<i> &gt;return d
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;now I do some operations with config files to call many times the start
</I>&gt;<i> &gt;method from the api (I have to start many virtual machines) and the
</I>&gt;<i> &gt;api.start returns a deferred so what have I to do now?
</I>&gt;<i> &gt;I do so:
</I>&gt;<i> &gt;in examinecfg i have:
</I>&gt;<i> &gt;# tha same d that i used to add api.connect!
</I>&gt;<i> &gt;self.d.addCallback(api.start, (method_args))
</I>&gt;<i> &gt;return d
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Then I have to call the disconnect method from the api. But i tried to
</I>&gt;<i> print
</I>&gt;<i> &gt;out something to fallow the executing but I only see printing the first
</I>&gt;<i> &gt;method that call the connection. after that the process ends.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;In the main I have:
</I>&gt;<i> &gt;defer = conn_to_ctrl()
</I>&gt;<i> &gt;or have I to add to defer also the examinecfg?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;thank you very much
</I>&gt;<i>
</I>&gt;<i> I'm not sure what you're doing wrong.  It's hard to understand mixed up
</I>&gt;<i> snippets and fragments of code.  Please:
</I>&gt;<i>
</I>&gt;<i>  - don't top post
</I>&gt;<i>  - share complete, runnable examples (preferably minimal, too)
</I>&gt;<i>  - share the failure you're seeing - possibly including a traceback, or a
</I>&gt;<i>    description of the behavior that the program exhibits when you run it,
</I>&gt;<i>    and an explanation of how this differs from what you want
</I>&gt;<i>
</I>&gt;<i> Jean-Paul
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>
Ok I'll try to explain what the api provides to me and what I want to do
with it:
mothods provided by api that I want to use:
1) connection

    def connect(self, ctrl_host, ctrl_port, user, passwd):
        &quot;&quot;&quot;Connect to an Usher control server.
        @param ctrl_host: fqdn where Usher controller is running
        @type ctrl_host: string
        @param ctrl_port: port number Usher controller is listening on
        @type ctrl_port: int
        @param user: username of user connecting to Usher controller
        @type user: string
        @param passwd: password of user connecting to Usher controller
        @type passwd: string
        return: Deferred which returns and L{UsherResult}
        rtype: twisted.internet.defer.Deferred
        &quot;&quot;&quot;
        # serialize access to connect
        if not self.connect_lock.acquire(False):
            raise UsherEx, &quot;Connection Pending&quot;
        if self.factory:
            self.disconnect()
        # reset vms
        self.vms = {}
        # reset passwd to None until we're connected
        self.passwd = None
        self.factory = APIFactory()
        self.factory.api = self
        # connect to server
        reactor.connectSSL(ctrl_host, ctrl_port, self.factory,
            ssl.ClientContextFactory())
        d = self.factory.login(credentials.UsernamePassword(user, passwd),
            client=self)
        d.addErrback(self._handle_err, misc.whoami())
        d.addCallback(self._connected_to_ctrl, ctrl_host, ctrl_port, user,
            passwd)
        return d

2) start single vm

    def start(self, cluster=None, prefix='', vmlist=None, count=None,
first=None, last=None, dregex=None,  dlist=None, dryrun=False, eid=None,
**kw):
        &quot;&quot;&quot;Start a VM or set of VMs
        @param cluster: Name of cluster to which VMs should belong
        @type cluster: string
        @param prefix: prefix to prepend to VM names
        @type prefix: string
        @param vmlist: list of strings of VMs to start
        @type vmlist: list of strings
        @param count: Number of consecutive VMs to start
        @type count: int
        @param first: Lowest number of VM to start
        @type first: int
        @param last: Highest number of VM to start
        @type last: int
        @param dregex: regular expression to match against destination LNM
names
        @type dregex: list of strings
        @param dlist: list of strings to match against destination LNM names
        @type dlist: list of strings
        @param dryrun: Show what would have happened if the command had been
run without the dryrun command (at the instant that the dryrun command was
run of course)
        @type dryrun: bool
        @param eid: mechanism for admin user to be able to specify an
alternate username for forming suffix for regex
        @type eid: string
        @param kw: Extra arguments passed to controller for use by plugins
or LNM.  Any keywords starting with 'vm_' are added to VM's uargs
parameter.  Note, the controller actually checks for two kw arguments: ram
and ip_addrs.  Though these are, strictly speaking, VM parameters, they're
considered important enough that the controller checks for them.
        @type kw: dict

        @return: Deferred which returns an L{UsherResult}
        @rtype: twisted.internet.defer.Deferred
        @raise UsherNotConnected: Raised when not connected to Usher
Controller
        @raise UsherPBDeadRefEx: Raised when capability for Usher Controller
goes stale.  Must reconnect when this happens
        @raise UsherInvalidInputEx: Raised when an invalid input or
combination of parameters is received.
       &quot;&quot;&quot;

        # make sure we're connected
        if not self.aref:
            raise UsherNotConnectedEx
        # combine these to reduce params
        if ((first and first &lt; 0) or (last and last &lt; 0) or (count and count
&lt;
            0)):
            raise UsherInvalidInputEx(&quot;first, last, and count must be
non-negative&quot;)
        vmrange = (first,last,count)
        # arg check
        self._arg_check(vmlist, vmrange)
        # get final destination list
        dlist = self._namecomplete(dlist, suffix=self.suffix)
        self._check_lnmlist(dlist)
        dregex = self._regex_append(dregex, dlist)
        dlist = self._regex_filter(dregex, self.lnms.keys())
        # complete names (if necessary) in the vmlist
        vmlist = self._namecomplete(vmlist, cluster, eid)
        # check that the vms specified don't already exist
self._check_vmlist(vmlist, isin=True)
        vmlist = self._get_vm_names_to_start(vmlist, cluster, prefix,
vmrange, eid)
        # controller handles eid from kw, so add it
        if eid:
            kw['eid'] = eid
        if dryrun:
            d = UsherResult('dryrun', msg = 'started:' + linesep +
                    linesep.join(vmlist))
            return d
        try:
            if vmlist:
                d = self.aref.callRemote(&quot;start&quot;, vmlist, dlist, **kw)
                d.addErrback(self._handle_err, misc.whoami())
            else:
                raise UsherInvalidInputEx( &quot;No VMs started.  No unique VMs
specified in command&quot;)
            return d
        except pb.DeadReferenceError, ex: raise UsherPBDeadRefEx

in my script I have to use connect method and then I have to do some
operations first of calling the start method
1) start connection

    def startConnection(self):
        d = my_api.connect(self.ctrl_ip, self.ctrl_port, self.user,
self.pwd)
        d.addCallback(self.postConnection)
        d.addErrback(twisted.python.log.err)
        print &quot;Connection added&quot;
        return d
2) operation before starting a virtual machine:
def newVMCfg(self, new_vms_cfg):
       #...
       #some operations
       #if condition valid I try to start the virtual machine
                        # is this the correct way to pass args to the start
method?
                        d = self.d.addCallback(self.startVM,(new_vm,
self.lnms[i])
                        print &quot;started vm %s&quot;%new_vm
        return d

in the main process I call them as:
d = startConnection()
d.addCallback(newVMCfg, arg)

Is it correct? Because the process stops at the first method called: I see
only &quot;connection added&quot;.
Thank you for your help!!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20090511/cdc0700d/attachment.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="052107.html">[Twisted-Python] help using deferred
</A></li>
	<LI>Next message (by thread): <A HREF="052112.html">[Twisted-Python] help using deferred
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#52111">[ date ]</a>
              <a href="thread.html#52111">[ thread ]</a>
              <a href="subject.html#52111">[ subject ]</a>
              <a href="author.html#52111">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
