<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Improving spawnProcess and friends
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Improving%20spawnProcess%20and%20friends&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013693.html">
   <LINK REL="Next"  HREF="013695.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Improving spawnProcess and friends</H1>
    <B>Nuutti Kotivuori</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Improving%20spawnProcess%20and%20friends&In-Reply-To="
       TITLE="[Twisted-Python] Re: Improving spawnProcess and friends">naked at iki.fi
       </A><BR>
    <I>Wed Jul 19 17:25:01 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="013693.html">[Twisted-Python] Improving spawnProcess and friends
</A></li>
        <LI>Next message: <A HREF="013695.html">[Twisted-Python] Re: Improving spawnProcess and friends
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13694">[ date ]</a>
              <a href="thread.html#13694">[ thread ]</a>
              <a href="subject.html#13694">[ subject ]</a>
              <a href="author.html#13694">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
&gt;<i> On Wed, 19 Jul 2006 11:09:35 +0300, Nuutti Kotivuori &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">naked at iki.fi</A>&gt; wrote:
</I>&gt;&gt;<i> I'd like to write an improvement to spawnProcess - but I thought I
</I>&gt;&gt;<i> should check with the devs here first to get comments and to see if it
</I>&gt;&gt;<i> would be something that could be merged to the mainline at some point.
</I>&gt;<i>
</I>&gt;<i> Thanks :).
</I>&gt;<i>
</I>&gt;<i> It's probably worth mentioning these:
</I>&gt;<i> <A HREF="http://twistedmatrix.com/trac/ticket/1218">http://twistedmatrix.com/trac/ticket/1218</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/trac/ticket/950">http://twistedmatrix.com/trac/ticket/950</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/trac/ticket/1478">http://twistedmatrix.com/trac/ticket/1478</A>
</I>&gt;<i> as long as we're talking about this API.
</I>
Hopefully all of those will get fixed while we are at it.

&gt;&gt;<i> The primary thing I want to do is to improve the childFDs
</I>&gt;&gt;<i> handling. Instead of the childFDs being a dictionary, I'd like to make
</I>&gt;&gt;<i> it be an object that is set up beforehand.
</I>&gt;<i>
</I>&gt;<i> I'd like to see a proposed API for setting up this object.  A
</I>&gt;<i> different way of doing this (which I think I prefer) would be to add
</I>&gt;<i> a feature to ProcessProtocol rather than modifying the behavior of
</I>&gt;<i> the childFDs argument.  After all, it's generally a particular
</I>&gt;<i> process protocol that wants to be able to communicate on various
</I>&gt;<i> channels.  This way it would be possible - although not necessarily
</I>&gt;<i> easy - to allow your ProcessProtocol object to have a few of its
</I>&gt;<i> methods called post-fork, but pre-exec.
</I>
Hmmh. Well, firstly, actually I don't think I explained the object
idea properly. My original idea there was just to use the object as a
holder for the configuration - and nothing more. A syntax extension to
allow a nicely readable way of specifying childFDs instead of mappings
from integer to tuple of lists or whatever a complex set up like that
would end up being. But, now I'm not sure if I want the object at all
there.

I'm not sure if I understand what you are saying, though - atleast not
in a concrete way. I agree that generally a particular process
protocol is coded to explicitly read and write in certain
communication channels - so it is reasonable that the process protocol
would specify these communication channels.

However, I'm not sure I like the idea of methods firing from
ProcessProtocol post-fork but pre-exec. We are living on the child
side there - and calling any methods from the transport, reactor or
many other places would be a bad idea. I'd like the parts that get
executed on the child side be very well defined and generally not
supplied by the user.

&gt;&gt;<i> In addition to the current functionality of duplicating one of the
</I>&gt;&gt;<i> parent's fds and providing simple pipes, I'd like to add features to
</I>&gt;&gt;<i> configure arbitrary PTYs to be set up, for socketpairs to be set up
</I>&gt;&gt;<i> and to allow the duplication of some pipe into multiple child fds. To
</I>&gt;&gt;<i> clarify a bit, I'd like for a way to be able to start a process and
</I>&gt;&gt;<i> say that a socketpair should be created, it should be dup'd to fd 0
</I>&gt;&gt;<i> and fd 1 on the child and a pipe should be created for reading and it
</I>&gt;&gt;<i> should be dup'd to fd 2 on the child. The same with PTYs as well, so
</I>&gt;&gt;<i> this change would unify Process and PTYProcess.
</I>&gt;<i>
</I>&gt;&gt;<i> Also, I would want to make it possible for each created reader,
</I>&gt;&gt;<i> writer, PTY, socketpair, whatever to have a separate protocol. That
</I>&gt;&gt;<i> is, I want to be able to say that this PTY should be handled by my
</I>&gt;&gt;<i> protocol here that inherits from LineReceiver - instead of having to
</I>&gt;&gt;<i> implement all of those in the ProcessProtocol.
</I>&gt;<i>
</I>&gt;<i> I believe that putting this into spawnProcess is operating at the
</I>&gt;<i> wrong layer of abstraction.  The feature you're describing is highly
</I>&gt;<i> useful though, so providing a utility implementation of
</I>&gt;<i> ProcessProtocol that allows you to hook up regular protocols to
</I>&gt;<i> various FDs would be very good.  IMHO ProcessProtocol looks
</I>&gt;<i> deceptively like a regular protocol, and probably its dataReceived
</I>&gt;<i> and connectionLost methods should be (softly) deprecated.  The right
</I>&gt;<i> way to write a ProcessProtocol is to override childDataReceived,
</I>&gt;<i> childConnectionLost and processEnded.  A ProcessProtocol that could
</I>&gt;<i> hook up _arbitrary_ FDs as input and output to a Protocol would be
</I>&gt;<i> incredibly useful but it would be a good start just to have a
</I>&gt;<i> better-defined way to deal with separating process control from
</I>&gt;<i> protocol logic; so useful it might even be worth putting this
</I>&gt;<i> functionality on the base ProcessProtocol.
</I>
Yes - the outReceived, errReceived, write, writeSequence, closeStdin,
closeStdout, closeStderr etc. methods seem to be a cause of a lot of
grief. It would be nice if childDataReceived, childConnectionLost,
processEnded, transport.writeToChild, transport.closeChildFD,
transport.signalProcess would be the only thing to worry about.

I was thinking about having the process readers and writers directly
connected to separate Protocols - and having those readers and writers
be the transports for those Protocols. And ProcessProtocol would kind
of just miss out on the communication that is happening and basically
be just a holder for signalProcess and processEnded.

Were you thinking of building the forwarding logic into
ProcessProtocol so that the readers and writers talk to the
ProcessProtocol which then forwards the commands onwards to different
Protocols? If so, what would be the transport for those Protocols? I'd
like for them to be able to say transport.loseConnection() to close
the communication channel they are using? If so, atleast some kind of
new transport forwarding these is needed. Or would they have the
readers and writers as transports - and those readers and writers just
communicate to them through the processProtocol. I'm not sure I'd like
an asymmetric set up like that.

&gt;<i> It seems like a good first step here would be refactoring the
</I>&gt;<i> various flavors of file descriptor (including the mess in
</I>&gt;<i> _pollingfile and _dumbwin32proc) so that they can be easily and
</I>&gt;<i> portably invoked by users wanting to create out-of-band (non
</I>&gt;<i> stdin/stdout) channels of communication between their processes.  I
</I>&gt;<i> think it would be best if these channels could have a &quot;flavor
</I>&gt;<i> requirement&quot; specified (i.e. pipe, socketpair, PTY), but also have a
</I>&gt;<i> general stream-based transport API that would work the same from a
</I>&gt;<i> high-level application's point of view on Windows and Mac and Linux;
</I>&gt;<i> for example, use pipes if available, numeric unix sockets if not,
</I>&gt;<i> localdomain sockets if that's not available either, depending on
</I>&gt;<i> platform.
</I>&gt;<i>
</I>&gt;<i> All of this is leaning towards making 0,1,2 as un-special as
</I>&gt;<i> possible, which I like very much.  That also implies that you'll
</I>&gt;<i> need to clean up stdio.StandardIO, and instead add an API like
</I>&gt;<i> reactor.connectParentFD(factory, fileno, flavor=None).  On my first
</I>&gt;<i> read through I started trying to describe a way to communicate the
</I>&gt;<i> expected list of file descriptors and their settings to the child
</I>&gt;<i> process but that seems best left up to the application.
</I>
Okay, I didn't get most of the stuff here. I need more explanation to
understand what's going on. I remember fighting with stdio.StandardIO
at some point, so cleaning that up sounds something that should be
done.

When I'm narrowly looking at this process spawning stuff, I see a
communication channel as a single object that has three places it does
its magic at.

There is the setupPrefork() stage which is called at first, before
anything special is done. This does not return anything, it just does
stuff, if necessary. Then we fork. On the child side we call
setupChild(). This will do all the things necessary for setting up a
communication channel for the child process to use, and it will return
that a single filedescriptor (a file descriptor is just about the only
reasonable thing to survive an exec, so there is no need for variance
here). On the parent side we call setupParent(). This will set up the
communication channel on the parent side, and it will return a
transport that is capable of reading and/or writing the channel.

As an example, for ReadPipe(), setupPrefork() would call os.pipe() and
mark down the read and write file descriptors. Then setupChild() would
close the read fd and return the write fd. And setupParent() would
close the write fd and set up a ProcessReader handing the read fd.

Another example, say ReadNamedPipe('/tmp/namedpipe'), setupPrefork()
would call mknod to create the named pipe if necessary, but would open
no file descriptors. Then setupChild() would open the pipe for writing
and return the fd. And setupParent() would open the pipe for reading
and set up a ProcessReader handling the fd.

&gt;&gt;<i> Backwards compatibility would be obtained by still allowing the dict
</I>&gt;&gt;<i> type in childFDs and just mapping them to the new object inside
</I>&gt;&gt;<i> spawnProcess. Also the custom protocols would be optional and the
</I>&gt;&gt;<i> default protocol would just call childDataReceived and
</I>&gt;&gt;<i> childConnectionLost on the ProcessProtocol.
</I>&gt;<i>
</I>&gt;<i> This is why I'd strongly prefer the logic remain in ProcessProtocol.
</I>&gt;<i> There should be _one_ location for dealing with the state of a
</I>&gt;<i> running subprocess and its shared FD map; the ProcessProtocol seems
</I>&gt;<i> the logical place.  We could hide it all inside the reactor, but I
</I>&gt;<i> am pretty sure that important aspects will forget to be exposed.
</I>
I'm still not entirely sure what you mean here. The Process object
(the &quot;transport&quot; or so) would hold the *state* of the running
subprocess and all its communication channels. The ProcessProtocol
would contain the stuff *dealing* with the state. And the initial
configuration of what to set up would either come from spawnProcess
(Process object initializer arguments) or from ProcessProtocol somehow
- or actually both.

It is obvious that ProcessProtocol can't be responsible for all the
configuration the Process needs - it shouldn't, for example, say the
name of the executable being executed. And I don't think it should be
responsible for the chdirs, chroots and such either - those should be
changeable at execution time without touching the
ProcessProtocol. Just as it is possible to change the address a TCP
connection is made without changing the Protocol of that
connection. But I do think it could be responsible for the FD mapping
for the process, since that is intimately tied with the logic of the
ProcessProtocol.

&gt;&gt;<i> The other feature I would like to implement while mucking around
</I>&gt;&gt;<i> with the process module is the preexec_fn feature of the subprocess
</I>&gt;&gt;<i> module. That is, a function that gets executed just before the
</I>&gt;&gt;<i> child is exec'd. There can probably be other uses for this as well,
</I>&gt;&gt;<i> but the main usage for this would be a chroot call. I'm considering
</I>&gt;&gt;<i> if it should be a list of functions executed in order - since there
</I>&gt;&gt;<i> might be a need to do a chroot, a chdir and another chroot or
</I>&gt;&gt;<i> something similar - but of course the user can just supply a
</I>&gt;&gt;<i> function that does that.
</I>&gt;<i>
</I>&gt;<i> This gives me another good idea.  Right now there's a bunch of stuff
</I>&gt;<i> that happens in the guts of the process module; chdir, setuid, fdmap
</I>&gt;<i> setup.  Most of this could be factored into an UNIX-specific
</I>&gt;<i> ProcessProtocol, centralized in &quot;beforeFork&quot; and &quot;beforeExec&quot;
</I>&gt;<i> methods.  I'm not really sure how to best clearly expose that
</I>&gt;<i> non-portable features are required when invoking spawnProcess, but
</I>&gt;<i> the obvious idea is that if
</I>&gt;<i> IUNIXProcessProtocol.providedBy(yourProtocol), barf on Windows,
</I>&gt;<i> Jython (if they ever do another release and we add support for it
</I>&gt;<i> again), etc.  Then you could explicitly subclass either
</I>&gt;<i> UNIXProcessProtocol if you explicitly needed nonportable features
</I>&gt;<i> (which would still allow you to use them on UNIX;
</I>&gt;<i> UNIXProcessProtocol == ProcessProtocol, on platforms which support
</I>&gt;<i> it); but subclassing ProcessProtocol would select a more
</I>&gt;<i> platform-appropriate method.
</I>&gt;<i>
</I>&gt;<i> Originally I thought that the process-communication logic would be
</I>&gt;<i> specific to a reactor, which is why it's factored as it is; after a
</I>&gt;<i> few years of working with process spawning closely though it is
</I>&gt;<i> clear to me that differences are entirely a feature of the OS and
</I>&gt;<i> not of the reactor.
</I>
Most of this went past me as well.

If the setup stuff like chdir, setuid, fdmap, etc. is factored into an
UNIX-specific ProcessProtocol, then how are those configured when
spawning the process? I'd hate to have to make a new ProcessProtocol
or chance one every time I wanted to spawn an executable in a
different path.

I have no idea what so ever on what is the best way to expose the
non-portability of many of the things. As it stands now, some
communication channels obviously are non-portable - and in my mind
it's perfectly fine that SocketPair() throws an exception on
instantiation if the platform doesn't support it ;-)

In general I see it such that creating processes is such an OS
specific thing that there are more differences than not. The feature
sets are just too disjoint. So I see this thing as just allowing the
user to pick the features he wants and if they can't be supported, we
can boom.

&gt;<i> Well, I liked your ideas, and then they made me think of some ideas
</I>&gt;<i> that I liked even more :).  I hope that you'll continue to work on
</I>&gt;<i> this.  Please feel free to copy and paste chunks of this (both your
</I>&gt;<i> ideas and mine) into a ticket.
</I>
I created an issue #1939 for this and added some of the conversation
here there.

&gt;<i> I'm working on at least 3 projects right now which use process
</I>&gt;<i> spawning and these changes would improve all of them; although only
</I>&gt;<i> one will be running long enough to actually see any of these
</I>&gt;<i> implemented, I'm still pretty excited about the idea.
</I>
Running long enough? I intend to be finished by the night ;-)

Well, not really, but I do hope to finish this whole thing rather fast
and not let it linger.

On that note, I created my first try at some of the features. It's
filled with FIXMEs, no documentation, bad class names and no specific
test cases. But, it provides a compatible API and the process test
suite passes with it.

What it does is that it defines a set of communication channel helper
objects. Right now there's PassthroughFD, ReadPipe, WritePipe, PTY and
SocketPair. SocketPair is not implemented.

The API for using these is *really* convoluted now, but it does
support all the features.

The childFDs dictionary in its native form now should contain:

  { &lt;name&gt;: (&lt;helper instance&gt;, &lt;list or tuple of fd numbers&gt;) }

The name part is what the communication channel will be known with in
the ProcessProtocol. That is, the thing returned in childDataReceived
and childConnectionLost etc. The helper instance is an instance of one
of the helper classes. The list or tuple of fd numbers is the child
file descriptor numbers the channel should be ultimately mapped
to. Additionally, a name of '_defaultWriter' specifies the target name
transport.write() calls should write to. There are a few shorthands:

 { &lt;name&gt;: &lt;helper instance&gt; } is mapped to:
 { &lt;name&gt;: (&lt;helper instance&gt;, (&lt;name&gt;,)) }

 { &lt;name&gt;: 'r' } is mapped to:
 { &lt;name&gt; (ReadPipe(), (&lt;name&gt;,)) }

 { &lt;name&gt;: &lt;int&gt; } is mapped to:
 { &lt;name&gt;: (PassthroughFD(&lt;int&gt;), (&lt;name&gt;,)) }

So, to achieve a behaviour that is similar to the old PTYProcess
behaviour, you can say:

 { '_defaultWriter': 1,
   1: (PTY(), (0, 1, 2)) }

That is, make a PTY helper creating a new PTY, name it 1 in the
ProcessProtocol and map it to file descriptors 0, 1 and 2 on the
child. Also, make the default write method write to helper named 1.

This way, the outReceived() method is called on the ProcessProtocol
when data is received from the PTY - and transport.write() will write
data to the PTY.

I shall ponder these things for a while - and start implementing the
next phase when I have a good idea on what it should be.

-- Naked




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013693.html">[Twisted-Python] Improving spawnProcess and friends
</A></li>
	<LI>Next message: <A HREF="013695.html">[Twisted-Python] Re: Improving spawnProcess and friends
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13694">[ date ]</a>
              <a href="thread.html#13694">[ thread ]</a>
              <a href="subject.html#13694">[ subject ]</a>
              <a href="author.html#13694">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
