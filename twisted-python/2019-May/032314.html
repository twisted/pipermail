<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] finding out what's blocking the reactor
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20finding%20out%20what%27s%20blocking%20the%20reactor&In-Reply-To=%3C58afcc24-a2dd-da9e-8b69-b411a8e91be8%40thieprojects.ch%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="032313.html">
   <LINK REL="Next"  HREF="032309.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] finding out what's blocking the reactor</H1>
    <B>Werner Thie</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20finding%20out%20what%27s%20blocking%20the%20reactor&In-Reply-To=%3C58afcc24-a2dd-da9e-8b69-b411a8e91be8%40thieprojects.ch%3E"
       TITLE="[Twisted-Python] finding out what's blocking the reactor">werner at thieprojects.ch
       </A><BR>
    <I>Wed May 15 14:22:29 MDT 2019</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="032313.html">[Twisted-Python] finding out what's blocking the reactor
</A></li>
        <LI>Next message (by thread): <A HREF="032309.html">[Twisted-Python] finding out what's blocking the reactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32314">[ date ]</a>
              <a href="thread.html#32314">[ thread ]</a>
              <a href="subject.html#32314">[ subject ]</a>
              <a href="author.html#32314">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Aloha

the code below has proven to be a life saver together with manhole. It
might be a bit outdated but I usually create a manhole access allowing
me to inspect the server from within then using dumpObjects to look at
the sea of objects in the running process.

Even only watching the inner workings of a server is quite fun and
illuminating.

Werner

exc =[
&quot;function&quot;,
&quot;type&quot;,
&quot;list&quot;,
&quot;dict&quot;,
&quot;tuple&quot;,
&quot;wrapper_descriptor&quot;,
&quot;module&quot;,
&quot;method_descriptor&quot;,
&quot;member_descriptor&quot;,
&quot;instancemethod&quot;,
&quot;builtin_function_or_method&quot;,
&quot;frame&quot;,
&quot;classmethod&quot;,
&quot;classmethod_descriptor&quot;,
&quot;_Environ&quot;,
&quot;MemoryError&quot;,
&quot;_Printer&quot;,
&quot;_Helper&quot;,
&quot;getset_descriptor&quot;,
&quot;weakref&quot;
]
inc =[
]
prev ={}
#delta - print delta between current and previous run
#limit - only print object count bigger than limit
#inc - include named objects in the dump
#exc - exclude named obects in the dump
defdumpObjects(delta=True, limit=0, include=inc, exclude=[]):
globalprev
ifinclude !=[] andexclude !=[]:
print'cannot use include and exclude at the same time'
return
print'working with:'
print' delta: ', delta
print' limit: ', limit
print' include: ', include
print' exclude: ', exclude
objects ={}
gc.collect()
oo =gc.get_objects()
foro inoo:
ifgetattr(o, &quot;__class__&quot;, None):
name =o.__class__.__name__
if((exclude ==[] andinclude ==[]) or\
(exclude !=[] andname notinexclude) or\
(include !=[] andname ininclude)):
objects[name] =objects.get(name, 0) +1
## if more:
## print o
pk =prev.keys()
pk.sort()
names =objects.keys()
names.sort()
forname innames:
iflimit ==0orobjects[name] &gt;limit:
ifnotprev.has_key(name):
prev[name] =objects[name]
dt =objects[name] -prev[name]
ifdelta ordt !=0:
print'%0.6d-- %0.6d-- '%(dt, objects[name]), name
prev[name] =objects[name]
defgetObjects(oname):
&quot;&quot;&quot;
gets an object list with all the named objects out of the sea of
gc'ed objects
&quot;&quot;&quot;
olist =[]
objects ={}
gc.collect()
oo =gc.get_objects()
foro inoo:
ifgetattr(o, &quot;__class__&quot;, None):
name =o.__class__.__name__
if(name ==oname):
olist.append(o)
returnolist
On 5/15/19 02:19, Maarten ter Huurne wrote:
&gt;<i> On Wednesday, 15 May 2019 13:11:29 CEST Scott, Barry wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> In my experience gc is low level noise only.
</I>&gt;&gt;<i> Our work load is very heavy and its never been an issue.
</I>&gt;<i> It depends entirely on how many objects you have. With a few GBs worth 
</I>&gt;<i> of relatively small objects, a full garbage collection cycle can take 
</I>&gt;<i> over a minute. But in normal circumstances, the overhead indeed isn't 
</I>&gt;<i> relevant.
</I>&gt;<i>
</I>&gt;<i> Bye,
</I>&gt;<i> 		Maarten
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20190515/d3e9841f/attachment.html&gt;
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="032313.html">[Twisted-Python] finding out what's blocking the reactor
</A></li>
	<LI>Next message (by thread): <A HREF="032309.html">[Twisted-Python] finding out what's blocking the reactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32314">[ date ]</a>
              <a href="thread.html#32314">[ thread ]</a>
              <a href="subject.html#32314">[ subject ]</a>
              <a href="author.html#32314">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
