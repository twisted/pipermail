<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Experimenting with tubes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Experimenting%20with%20tubes&In-Reply-To=%3CBCF85B9A-9BA6-4444-95C6-B79AB1493D9C%40twistedmatrix.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="061116.html">
   <LINK REL="Next"  HREF="028619.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Experimenting with tubes</H1>
    <B>Glyph</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Experimenting%20with%20tubes&In-Reply-To=%3CBCF85B9A-9BA6-4444-95C6-B79AB1493D9C%40twistedmatrix.com%3E"
       TITLE="[Twisted-Python] Experimenting with tubes">glyph at twistedmatrix.com
       </A><BR>
    <I>Thu Aug 21 01:36:52 MDT 2014</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="061116.html">[Twisted-Python] Experimenting with tubes
</A></li>
        <LI>Next message (by thread): <A HREF="028619.html">[Twisted-Python] Who's doing the merges for reviewed and blessed pull requests at twisted/nevow?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#61119">[ date ]</a>
              <a href="thread.html#61119">[ thread ]</a>
              <a href="subject.html#61119">[ subject ]</a>
              <a href="author.html#61119">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Aug 19, 2014, at 3:58 PM, Jan Pobrislo &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ccx at webprojekty.cz</A>&gt; wrote:

&gt;<i> On Thu, 14 Aug 2014 14:29:56 -0700
</I>&gt;<i> Glyph Lefkowitz &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at twistedmatrix.com</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> On Aug 11, 2014, at 6:51 AM, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">ccx at webprojekty.cz</A> wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> Hello, I've been playing with the new tubes that are being
</I>&gt;&gt;&gt;<i> implemented:
</I>&gt;&gt;&gt;<i> <A HREF="http://comments.gmane.org/gmane.comp.python.twisted/27248">http://comments.gmane.org/gmane.comp.python.twisted/27248</A>
</I>&gt;&gt;&gt;<i> <A HREF="https://twistedmatrix.com/trac/ticket/1956">https://twistedmatrix.com/trac/ticket/1956</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Thanks so much for taking the time to play with it, and taking some
</I>&gt;&gt;<i> time to write feedback.
</I>&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> Here are few things that I did with it. I won't publish the full
</I>&gt;&gt;&gt;<i> code now, as in it's current shape it could implode eyeballs of
</I>&gt;&gt;&gt;<i> twisted devs and possibly make them summon some of the elder gods,
</I>&gt;&gt;&gt;<i> but I'll see if I can produce something less vile as I merge the
</I>&gt;&gt;&gt;<i> ongoing changes to the tubes branch.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I'd be interested to see the code nevertheless.  If you had to do
</I>&gt;&gt;<i> eyeball-imploding antics to get Tubes to work well for your use-case,
</I>&gt;&gt;<i> being able to have a look at that would help us evaluate whether
</I>&gt;&gt;<i> those antics were required by the code, encouraged by misfeatures of
</I>&gt;&gt;<i> the API design, or just issues with lack of documentation.
</I>&gt;<i> 
</I>&gt;<i> It's mostly me not really documenting anything, not writing tests and
</I>&gt;<i> littering it with debug statements (which will go away as soon as I
</I>&gt;<i> find time to improve my debugging module so it can monkeypatch them).
</I>
You should be able to debug tubes mostly with composition to analyze flows.  If you can't do what you want with that, we should talk :-).

&gt;<i> <A HREF="http://wpr.cz/ccx/bzr/tubes7/">http://wpr.cz/ccx/bzr/tubes7/</A> for my changes only
</I>&gt;<i> <A HREF="http://wpr.cz/ccx/bzr/tubes7-merge-2/">http://wpr.cz/ccx/bzr/tubes7-merge-2/</A> for changes on top of the bzr
</I>&gt;<i> mirror of the svn branch
</I>&gt;<i> 
</I>&gt;<i> example usage:
</I>&gt;<i> <A HREF="http://wpr.cz/ccx/paste/2014-08-19/2/">http://wpr.cz/ccx/paste/2014-08-19/2/</A>
</I>&gt;<i> <A HREF="http://wpr.cz/ccx/paste/2014-08-19/3/">http://wpr.cz/ccx/paste/2014-08-19/3/</A>
</I>&gt;<i> <A HREF="http://wpr.cz/ccx/paste/2014-08-19/4/">http://wpr.cz/ccx/paste/2014-08-19/4/</A>
</I>&gt;<i> <A HREF="http://wpr.cz/ccx/paste/2014-08-19/5/">http://wpr.cz/ccx/paste/2014-08-19/5/</A>
</I>
I think I don't understand the purpose of all of these.  Particularly, what is the purpose of TypedTube, since Tube already supports specification of input and output types?

&gt;&gt;&gt;<i> So far I wrote relatively simple app that read logfiles, parse them
</I>&gt;&gt;&gt;<i> and insert what they got out of them into a database.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> If it's actually reading a file, another nice to-do would be an
</I>&gt;&gt;<i> IFount provider that provides the contents of a file with appropriate
</I>&gt;&gt;<i> flow control, and maybe a thread or process in the background to do
</I>&gt;&gt;<i> the file I/O.  Another thing you could contribute to the branch,
</I>&gt;&gt;<i> possibly?  :-)  How did you implement this?
</I>&gt;<i> 
</I>&gt;<i> At the moment I don't mind the blockingness of the calls. I did write a
</I>&gt;<i> ThreadReader and ThreadWriter though for my earlier tubes-alike with
</I>&gt;<i> Queue-based loop.
</I>&gt;<i> 
</I>&gt;<i> What is more interesting challenge (and we discussed this earlier on
</I>&gt;<i> irc) would be generic async file api. I suggested implementing 9p2000
</I>&gt;<i> back then and I still think it is a good starting point... but nothing
</I>&gt;<i> I have spare time for at the moment.
</I>
The point is not to use a specific implementation.  Rather, the point is to get a single well-documented entry-point within Twisted for asynchronously reading a file so that people can start using it.  Frankly this entrypoint could be a total lie and actually do the I/O synchronously on the main thread, as long as it could be transparently upgraded to being the truth without exposing the change to applications in the future :-).  If we make everyone implement their own read-a-file fount, then there's no hope that future Twisted maintenance could improve their performance.

&gt;&gt;<i> I'm not sure I totally understand the case that you're describing
</I>&gt;&gt;<i> right now.  Can you perhaps contribute a unit test which demonstrates
</I>&gt;&gt;<i> why this line of code is necessary?
</I>&gt;<i> 
</I>&gt;<i> I'd love to, alas I'll be bit preocuppied with some more urgent matters
</I>&gt;<i> for following week or two. The short version is &quot;flowStopped just
</I>&gt;<i> didn't get passed through the series otherwise&quot;.
</I>
I hope I'll have some time later in the week to investigate this. 

&gt;&gt;<i> Are you running into &lt;<A HREF="https://twistedmatrix.com/trac/ticket/7546">https://twistedmatrix.com/trac/ticket/7546</A>&gt;?
</I>&gt;<i> 
</I>&gt;<i> Most probably, as far as I can tell from the vague description.
</I>
Well, you'll be glad to know that's also on my to-do list :-).

&gt;&gt;<i> That ... definitely sounds kind of gross.  As does actually setting
</I>&gt;&gt;<i> the nextFount attribute directly on the fan.Out.
</I>&gt;<i> 
</I>&gt;<i> Indeed. The point of the experiment was not produce nice code but to
</I>&gt;<i> see if there are any major pitfalls using the tubes API.
</I>
As long as it's clear that this is not really necessary :).

&gt;&gt;<i> twisted.web.client.Agent has a solution to this where there's a
</I>&gt;&gt;<i> multi-failure object that aggregates multiple errors into one thing.
</I>&gt;&gt;<i> I think we have to do something similar.  Unfortunately this is a
</I>&gt;&gt;<i> very confusing interface in addition to being poorly documented and
</I>&gt;&gt;<i> relies on private classes that expose ostensibly public attributes.
</I>&gt;&gt;<i> We need to very carefully document this within fan.In.
</I>&gt;<i> 
</I>&gt;<i> Some nice abstraction of multiple failures would be indeed handy. I'm
</I>&gt;<i> pretty sure DeferredList could use one too.
</I>
Yeah, uh, maybe.  Also DeferredList should go away and be replaced with something that doesn't inherit from Deferred, and instead is just a function that returns a new regular-old-Deferred, since the subclassing is entirely unnecessary.  But I digress.

&gt;&gt;&gt;<i> As for data representation that I choose to pass between each tube
</I>&gt;&gt;&gt;<i> I've started with simple namedtuples and following that I've built
</I>&gt;&gt;&gt;<i> a simple &quot;datatype&quot; class somewhat reminiscent of
</I>&gt;&gt;&gt;<i> <A HREF="https://github.com/hynek/characteristic">https://github.com/hynek/characteristic</A>
</I>&gt;&gt;&gt;<i> which I learned of few moments after I finished polishing my own
</I>&gt;&gt;&gt;<i> implementation. What I have there is added layer above namedtuples
</I>&gt;&gt;&gt;<i> that autogenerate zope Interfaces (so I can have adaptation), do
</I>&gt;&gt;&gt;<i> field type and value validation/adaptation and possibly (as a
</I>&gt;&gt;&gt;<i> future extension) provide easy way to make them into AMP commands
</I>&gt;&gt;&gt;<i> so the series can be split into communicating processes as needed.
</I>&gt;&gt;&gt;<i> (What would be interesting imo is something like ampoule for tubes,
</I>&gt;&gt;&gt;<i> or perhaps a ThreadTube and SubprocessTube for performing blocking
</I>&gt;&gt;&gt;<i> operations)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I think it's likely we'll acquire a dependency on Characteristic
</I>&gt;&gt;<i> sometime soon, I have promised to look at the issues on
</I>&gt;&gt;<i> &lt;<A HREF="https://github.com/hynek/characteristic/pull/13">https://github.com/hynek/characteristic/pull/13</A>&gt; and try to address
</I>&gt;&gt;<i> them already :).
</I>&gt;<i> 
</I>&gt;<i> What makes me ponder is how to work with multiple types of messages
</I>&gt;<i> being passed through. Traditionally in twisted one would use different
</I>&gt;<i> methods for handling each one, eg. IRCClient has userJoined, userLeft,
</I>&gt;<i> and so on. If we keep tubes as they are with a single received() method
</I>&gt;<i> then somehow we need to be able to tell those messages apart,
</I>&gt;<i> deconstruct them and mainly document them and test for proper handling
</I>&gt;<i> of all cases.
</I>
Dispatching from a single &quot;received&quot; message to multiple distinct methods based on type is a pretty well solved problem in Python :-).  There is a whole class of design patterns for this which we could apply to Tubes.  I don't think we need this in the first release though; it's easy to implement yourself, there are a few different styles which might be a good idea that we'll need to try out, and many of the examples in the documentation that we've written so far don't require them.

&gt;<i> Instinctively I started looking for algebraic data types, but making
</I>&gt;<i> those work on python is high-level metaprogramming magic and that
</I>&gt;<i> either implies python3.3+ or AST rewriting:
</I>&gt;<i> <A HREF="https://github.com/lihaoyi/macropy">https://github.com/lihaoyi/macropy</A>
</I>
Yeesh.

&gt;<i> Perhaps what would be bearable is AST-based checker (integrated into
</I>&gt;<i> testcases perhaps) that would do exhaustiveness and field name checking
</I>&gt;<i> for such complex data - so all users of a tube/fount producing some
</I>&gt;<i> type woud be flagged whenever the type signature of it changes.
</I>
Is this really a substantial enough advantage over, say, a dictionary with types as keys and callables as values, that it would be worth the (frankly insane-sounding) level of complexity involved in its implementation?

&gt;<i> Other possible resolution is to mantain the multi-method approach and
</I>&gt;<i> make tubes into pausing mechanism only. I think it could work somewhat
</I>&gt;<i> like:
</I>&gt;<i> 
</I>&gt;<i> @pauseable
</I>&gt;<i> def lineReceived(line):
</I>&gt;<i>    ...
</I>&gt;<i>    # get reference object of specified interface
</I>&gt;<i>    # and wait until it is unpaused
</I>&gt;<i>    (yield IIRCClient).userJoined(...)
</I>&gt;<i> 
</I>&gt;<i> The first obvious downside of this approach that I see is that we now
</I>&gt;<i> need proxy objects for generic fan-in/out.
</I>
Yeah, I, uh, don't quite understand what you're getting at here.

&gt;&gt;&gt;<i> Also maybe of note is the implementation of Pipes in Async library
</I>&gt;&gt;&gt;<i> for OCaml which I've been examining lately. What they seem to do
</I>&gt;&gt;&gt;<i> there is that they push values downstream and the function called
</I>&gt;&gt;&gt;<i> in each processing step may return deferred signifying a pause is
</I>&gt;&gt;&gt;<i> requested until this deferred is fired. For those interested in the
</I>&gt;&gt;&gt;<i> details you can refer to:
</I>&gt;&gt;&gt;<i> <A HREF="https://ocaml.janestreet.com/ocaml-core/111.25.00/doc/async/#Std.Pipe">https://ocaml.janestreet.com/ocaml-core/111.25.00/doc/async/#Std.Pipe</A>
</I>&gt;&gt;&gt;<i> and the relevant section of Real World OCaml book (available
</I>&gt;&gt;&gt;<i> online).
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Creating a token for every single call to .receive() makes life
</I>&gt;&gt;<i> hard.  Deferred could go to some trouble to be a cheaper token to
</I>&gt;&gt;<i> pass around (especially on PyPy) but doing it this way is also
</I>&gt;&gt;<i> error-prone as a mistaken error-handler in the Deferred chain means
</I>&gt;&gt;<i> that the default behavior of buggy code un-hooks your loop and leaves
</I>&gt;&gt;<i> idle data sources that will never be cleaned up.
</I>&gt;<i> 
</I>&gt;<i> How does current approach prevent that? From what I see unhandled
</I>&gt;<i> exception in non-well written drain can do the very much same. Tubes
</I>&gt;<i> are handled specially so it can be prevented there.
</I>
That's exactly the point - applications should very rarely need to create new drains or founts, they should be working mostly in terms of tubes, fan.In, fan.Out, protocol founts and drains, and process founts and drains.

But in the case of a buggy drain, protocol founts and tubes can be written to handle the error _and cleanly shut down the whole flow_.

In the Streams (i.e. every-read-returns-a-Deferred) approach, you don't know who your caller is except that they might have added a callback to you.  There's no way to propagate other notifications or inspect the chain for debugging in case of errors.

&gt;&gt;<i> I worked quite a bit with the 'Streams' interface in web2 on Calendar
</I>&gt;&gt;<i> Server, and my conclusion there is that while this is better than
</I>&gt;&gt;<i> nothing (it was very nice to be able to just return a Stream rather
</I>&gt;&gt;<i> than cobble together something that returned NOT_DONE_YET every time)
</I>&gt;&gt;<i> it was (A) slow and (B) error prone.  Tubes are designed specifically
</I>&gt;&gt;<i> to avoid this error.  Although you can return Deferreds internally,
</I>&gt;&gt;<i> no consumer ever needs to write the callback-loop that calls .read()
</I>&gt;&gt;<i> again from a callback on .read().
</I>&gt;<i> 
</I>&gt;<i> I agree that something like tubes is needed, but it can be a
</I>&gt;<i> upper-level layer over something simple as flow-signalling callbacks.
</I>&gt;<i> 
</I>&gt;<i> Anyway, linked mostly for inspiration.
</I>&gt;<i> 
</I>&gt;<i> What I'd really like to see though is some rationale for current design
</I>&gt;<i> choices of tubes - eg. list of reasons the previous attempts failed and
</I>&gt;<i> how does each next address the issues. :-)
</I>
Hmm.  It's tough to document these, because there was a lot of experimenting in tubes, a lot of backtracking, some influence from other projects and a lot of parallel invention.  Trying to outline all the things we tried and why they did or didn't work would be extremely time-consuming for us and probably pretty confusing and unhelpful for the reader.

What would you be looking to get from such a write-up?

-g
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20140821/78136e2b/attachment-0002.html&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="061116.html">[Twisted-Python] Experimenting with tubes
</A></li>
	<LI>Next message (by thread): <A HREF="028619.html">[Twisted-Python] Who's doing the merges for reviewed and blessed pull requests at twisted/nevow?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#61119">[ date ]</a>
              <a href="thread.html#61119">[ thread ]</a>
              <a href="subject.html#61119">[ subject ]</a>
              <a href="author.html#61119">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
