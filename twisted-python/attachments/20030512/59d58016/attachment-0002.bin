diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/admin/accepttests.py Twisted/admin/accepttests.py
--- Twisted.orig/admin/accepttests.py	2003-05-04 08:53:26.000000000 +0200
+++ Twisted/admin/accepttests.py	2003-05-05 13:10:55.000000000 +0200
@@ -310,7 +310,17 @@
                 "               same situation as above)",
                 "  * USER: your UNIX username.")
     else:
-        runAllTests()
+        if block:
+            argv = sys.argv[2:]
+        else:
+            argv = sys.argv[1:]
+
+        if argv:
+            argv.reverse()
+            while argv:
+                globals()[argv.pop()]()
+        else:
+            runAllTests()
 
 if __name__ == '__main__':
     main()
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/mail/mail.py Twisted/twisted/mail/mail.py
--- Twisted.orig/twisted/mail/mail.py	2003-05-12 16:16:03.000000000 +0200
+++ Twisted/twisted/mail/mail.py	2003-05-12 15:24:50.000000000 +0200
@@ -60,7 +60,7 @@
     def exists(self, user):
         """No user exists in a BounceDomain -- always return 0
         """
-        return defer.succeed(None)
+        return defer.fail(smtp.SMTPBadRcpt(user))
     
     def authenticateUserAPOP(self, user, digest):
         return None
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/mail/maildir.py Twisted/twisted/mail/maildir.py
--- Twisted.orig/twisted/mail/maildir.py	2003-05-12 16:16:04.000000000 +0200
+++ Twisted/twisted/mail/maildir.py	2003-05-12 15:38:47.000000000 +0200
@@ -22,6 +22,7 @@
 from twisted.protocols import pop3, smtp
 from twisted.persisted import dirdbm
 from twisted.mail import mail
+from twisted.internet import defer
 
 
 _n = 0
@@ -73,7 +74,7 @@
         if self.userDirectory(user.dest.local) is not None:
             return defer.succeed(user)
         else:
-            return defer.succeed(None)
+            return defer.fail(smtp.SMTPBadRcpt(user))
 
     def startMessage(self, user):
         """Save a message for a given user
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/mail/protocols.py Twisted/twisted/mail/protocols.py
--- Twisted.orig/twisted/mail/protocols.py	2003-05-12 16:16:04.000000000 +0200
+++ Twisted/twisted/mail/protocols.py	2003-05-12 15:39:58.000000000 +0200
@@ -18,7 +18,7 @@
 
 # twisted imports
 from twisted.protocols import pop3, smtp
-from twisted.internet import protocol
+from twisted.internet import protocol, defer
 
 # system imports
 import string
@@ -29,8 +29,8 @@
     
     def validateTo(self, user):
         if not self.service.domains.has_key(user.dest.domain):
-            return defer.succeed(None)
-        return  self.service.domains[user.dest.domain].exists(user)
+            return defer.fail(smtp.SMTPBadRcpt(user))
+        return self.service.domains[user.dest.domain].exists(user)
 
     def startMessage(self, users):
         ret = []
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/mail/relay.py Twisted/twisted/mail/relay.py
--- Twisted.orig/twisted/mail/relay.py	2003-05-12 16:16:04.000000000 +0200
+++ Twisted/twisted/mail/relay.py	2003-05-12 15:26:06.000000000 +0200
@@ -42,7 +42,7 @@
         """
         if self.willRelay(user.protocol):
             return defer.succeed(user)
-        return defer.succeed(None)
+        return defer.fail(smtp.SMTPBadRcpt(user))
 
     def willRelay(self, protocol):
         """Check whether we agree to relay
@@ -68,6 +68,7 @@
 class SMTPRelayer(smtp.SMTPClient):
 
     def __init__(self, messagePaths):
+        smtp.SMTPClient.__init__(self,smtp.DNSNAME)
         self.messages = []
         self.names = []
         for message in messagePaths:
@@ -92,8 +93,13 @@
     def getMailData(self):
         return self.messages[0][2]
 
-    def sentMail(self, addresses):
-        if addresses:
+    def sentMail(self, code, resp, numOk, addresses, log):
+        """Since we only use one recipient per envelope, this
+        will be called with 0 or 1 addresses. We probably want
+        to do something with the error message if we failed.
+        """
+        if code in xrange(200,300):
+            # At least one, i.e. all, recipients successfully delivered
             os.remove(self.names[0]+'-D')
             os.remove(self.names[0]+'-H')
         del self.messages[0]
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/mail/relaymanager.py Twisted/twisted/mail/relaymanager.py
--- Twisted.orig/twisted/mail/relaymanager.py	2003-05-12 16:16:04.000000000 +0200
+++ Twisted/twisted/mail/relaymanager.py	2003-05-12 15:39:23.000000000 +0200
@@ -83,13 +83,13 @@
     #    log.msg("managed -- got %s" % line)
     #    relay.SMTPRelayer.lineReceived(self, line)
 
-    def sentMail(self, addresses):
+    def sentMail(self, code, resp, numOk, addresses, log):
         """called when e-mail has been sent
 
         we will always get 0 or 1 addresses.
         """
         message = self.names[0]
-        if addresses: 
+        if code in xrange(200,300):
             self.manager.notifySuccess(self.factory, message)
         else: 
             self.manager.notifyFailure(self.factory, message)
@@ -347,6 +347,6 @@
             t = time.time() - self.badMXs[answer]
             if t > 0:
                 del self.badMXs[answer]
-                deferrd.callback(answer)
+                deferred.callback(answer)
                 return
         deferred.callback(answers[0])
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/protocols/basic.py Twisted/twisted/protocols/basic.py
--- Twisted.orig/twisted/protocols/basic.py	2003-01-12 00:40:41.000000000 +0100
+++ Twisted/twisted/protocols/basic.py	2003-01-23 11:40:02.000000000 +0100
@@ -161,18 +161,16 @@
             except ValueError:
                 if len(self.__buffer) > self.MAX_LENGTH:
                     line, self.__buffer = self.__buffer, ''
-                    self.lineLengthExceeded(line)
-                    return
+                    return self.lineLengthExceeded(line)
                 break
             else:
                 linelength = len(line)
                 if linelength > self.MAX_LENGTH:
                     line, self.__buffer = self.__buffer, ''
-                    self.lineLengthExceeded(line)
-                    return
-                self.lineReceived(line)
-                if self.transport.disconnecting:
-                    return
+                    return self.lineLengthExceeded(line)
+                why = self.lineReceived(line)
+                if why or self.transport.disconnecting:
+                    return why
         else:
             data, self.__buffer = self.__buffer, ''
             if data:
@@ -209,13 +207,13 @@
     def sendLine(self, line):
         """Sends a line to the other end of the connection.
         """
-        self.transport.write(line + self.delimiter)
+        return self.transport.write(line + self.delimiter)
 
     def lineLengthExceeded(self, line):
         """Called when the maximum line length has been reached.
         Override if it needs to be dealt with in some special way.
         """
-        self.transport.loseConnection()
+        return self.transport.loseConnection()
 
 
 class Int32StringReceiver(protocol.Protocol):
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/protocols/smtp.py Twisted/twisted/protocols/smtp.py
--- Twisted.orig/twisted/protocols/smtp.py	2003-05-12 16:16:17.000000000 +0200
+++ Twisted/twisted/protocols/smtp.py	2003-05-12 15:48:30.000000000 +0200
@@ -20,17 +20,144 @@
 # Twisted imports
 from twisted.protocols import basic
 from twisted.internet import protocol, defer, reactor
-from twisted.python import log, components
+from twisted.python import log, components, linelog
 from twisted.python.compat import isinstance, StringTypes
 
 # System imports
-import time, string, re, base64, types
-import MimeWriter, tempfile
+import time, string, re, base64, types, socket, os, random
+import MimeWriter, tempfile, rfc822
 import warnings
+from cStringIO import StringIO
 
 class SMTPError(Exception):
     pass
 
+class SMTPClientError(SMTPError):
+    def __init__(self, code, resp, log=None):
+        self.code = code
+        self.resp = resp
+        self.log = log
+
+    def __str__(self):
+        if self.code > 0:
+            res = ["%.3d %s" % (self.code, self.resp)]
+        else:
+            res = [self.resp]
+        if self.log:
+            res.append('')
+            res.append(self.log)
+        return '\n'.join(res)
+
+class SMTPConnectError(SMTPClientError):
+    pass
+
+class SMTPProtocolError(SMTPClientError):
+    pass
+
+class SMTPDeliveryError(SMTPClientError):
+    pass
+
+class SMTPServerError(SMTPError):
+    def __init__(self, code, resp):
+        self.code = code
+        self.resp = resp
+
+    def __str__(self):
+        return "%.3d %s" % (self.code, self.resp)
+
+class SMTPAddressError(SMTPServerError):
+    def __init__(self, addr, code, resp):
+        SMTPServerError.__init__(self, code, resp)
+        self.addr = Address(addr)
+
+    def __str__(self):
+        return "%.3d <%s>... %s" % (self.code, self.addr, self.resp)
+    
+class SMTPBadRcpt(SMTPAddressError):
+    def __init__(self, addr, code=550,
+                 resp='Cannot receive for specified address'):
+        SMTPAddressError.__init__(self, addr, code, resp)
+
+class SMTPBadSender(SMTPAddressError):
+    def __init__(self, addr, code=550, resp='Sender not acceptable'):
+        SMTPAddressError.__init__(self, addr, code, resp)
+
+DNSNAME = socket.getfqdn() # Cache the hostname
+
+def rfc822date(timeinfo=None,local=1):
+    """
+    Format an RFC-2822 compliant date string.
+
+    Arguments: timeinfo    (optional) A sequence as returned by
+                           time.localtime() or time.gmtime(). Default
+                           is now.
+               local       (optional) Indicates if the supplied time
+                           is local or universal time, or if no time
+                           is given, whether now should be local or
+                           universal time. Default is local, as
+                           suggested (SHOULD) by rfc-2822.
+
+    Returns: A string representing the time and date in RFC-2822 format.
+    """
+    if not timeinfo:
+        if local:
+            timeinfo = time.localtime()
+        else:
+            timeinfo = time.gmtime()
+    if local:
+        if timeinfo[8]:
+            # DST
+            tz = -time.altzone
+        else:
+            tz = -time.timezone
+            
+        (tzhr, tzmin) = divmod(abs(tz), 3600)
+        tzhr *= int(abs(tz)/tz)
+        (tzmin, tzsec) = divmod(tzmin, 60)
+    else:
+        (tzhr, tzmin) = (0,0)
+
+    return "%s, %02d %s %04d %02d:%02d:%02d %+03d%02d" % (
+        ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][timeinfo[6]],
+        timeinfo[2],
+        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
+         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][timeinfo[1] - 1],
+        timeinfo[0], timeinfo[3], timeinfo[4], timeinfo[5],
+        tzhr, tzmin)
+
+def messageid(uniq=None):
+    """Return a globally unique random string in RFC 2822 Message-ID format
+
+    <datetime.pid.random@host.dom.ain>
+
+    Optional uniq string will be added to strenghten uniqueness if given.
+    """
+    datetime = time.strftime('%Y%m%d%H%M%S', time.gmtime())
+    pid = os.getpid()
+    rand = random.randrange(2**31L-1)
+    if uniq is None:
+        uniq = ''
+    else:
+        uniq = '.' + uniq
+
+    return '<%s.%s.%s%s@%s>' % (datetime, pid, rand, uniq, DNSNAME)
+
+def quoteaddr(addr):
+    """Turn an email address, possibly with realname part etc, into
+    a form suitable for and SMTP envelope.
+    """
+
+    if isinstance(addr, Address):
+        return '<%s>' % str(addr)
+    
+    res = rfc822.parseaddr(addr)
+
+    if res == (None, None):
+        # It didn't parse, use it as-is
+        return '<%s>' % str(addr)
+    else:
+        return '<%s>' % str(res[1])
+
 COMMAND, DATA = range(2)
 
 class NDeferred:
@@ -57,7 +184,6 @@
 class AddressError(SMTPError):
     "Parse error in address"
 
-
 # Character classes for parsing addresses
 atom = r"[-A-Za-z0-9!\#$%&'*+/=?^_`{|}~]"
 
@@ -76,6 +202,13 @@
     atomre = re.compile(atom) # match any one atom character
 
     def __init__(self, addr):
+        if isinstance(addr, User):
+            addr = addr.dest
+        if isinstance(addr, Address):
+            self.__dict__ = addr.__dict__.copy()
+            return
+        elif not isinstance(addr, StringTypes):
+            addr = str(addr)
         self.local = ''
         self.domain = ''
         self.addrstr = addr
@@ -153,10 +286,10 @@
         self.dest = Address(destination)
         self.helo = helo
         self.protocol = protocol
-        if isinstance(orig, StringTypes):
-            self.orig = Address(orig)
-        else:
+        if isinstance(orig, Address):
             self.orig = orig
+        else:
+            self.orig = Address(orig)
 
     def __getstate__(self):
         """Helper for pickle.
@@ -274,6 +407,8 @@
     def do_HELO(self, rest):
         peer = self.transport.getPeer()[1]
         self.__helo = (rest, peer)
+        self.__from = None
+        self.__to = []
         self.sendCode(250, '%s Hello %s, nice to meet you' % (self.host, peer))
 
     def do_QUIT(self, rest):
@@ -311,15 +446,44 @@
             self.sendCode(553, str(e))
             return
             
-        self.validateFrom(self.__helo, addr, self._fromValid,
-                          self._fromInvalid)
+        try:
+            self.validateFrom(self.__helo, addr).addCallbacks(
+                self._cbFromValidate, self._ebValidate)
+        except TypeError:
+            if self.validateFrom.func_code.co_argcount == 5:
+                warnings.warn(
+                    'File "%s", line %d, in %s\n'
+                    '  %s.validateFrom call syntax has changed!\n'
+                    '  Please update your code!' %
+                    (self.validateFrom.func_code.co_filename,
+                     self.validateFrom.func_code.co_firstlineno,
+                     self.validateFrom.func_code.co_name,
+                     self.__class__.__name__),
+                    category=DeprecationWarning,stacklevel=2)
+                self.validateFrom(self.__helo, addr, self._cbFromValidate,
+                                  self._fromInvalid)
+            else:
+                raise
+
+    def _fromInvalid(self, from_, code=550, msg='No mail for you!'):
+        "For compatibility"
+        self.sendCode(code,msg)
 
-    def _fromValid(self, from_, code=250, msg='From address accepted'):
+    def _cbFromValidate(self, from_, code=250, msg='Sender address accepted'):
+        try:
+            from_, code, msg = from_
+        except TypeError:
+            pass
         self.__from = from_
         self.sendCode(code, msg)
 
-    def _fromInvalid(self, from_, code=550, msg='No mail for you!'):
-        self.sendCode(code,msg)
+    def _ebValidate(self, failure):
+        if failure.check(SMTPServerError):
+            self.sendCode(failure.value.code, failure.value.resp)
+        else:
+            self.sendCode(
+                451,
+                'Requested action aborted: local error in processing')
 
     def do_RCPT(self, rest):
         if not self.__from:
@@ -335,22 +499,41 @@
         except AddressError, e:
             self.sendCode(553, str(e))
             return
-            
-        self.validateTo(user).addCallbacks(self._cbValidate, self._ebValidate)
 
-    def _cbValidate(self, to, code=250, msg='Address recognized'):
+        try:
+            self.validateTo(user).addCallbacks(
+                self._cbToValidate, self._ebValidate)
+        except TypeError:
+            if self.validateTo.func_code.co_argcount == 4:
+                warnings.warn(
+                    'File "%s", line %d, in %s\n'
+                    '  %s.validateTo call syntax has changed!\n'
+                    '  Please update your code!' %
+                    (self.validateTo.func_code.co_filename,
+                     self.validateTo.func_code.co_firstlineno,
+                     self.validateTo.func_code.co_name,
+                     self.__class__.__name__),
+                    category=DeprecationWarning,stacklevel=2)
+                self.validateTo(user, self._cbToValidate, self._toInvalid)
+            else:
+                raise
+
+    def _toInvalid(self, to, code=550,
+                   msg='Cannot receive for specified address'):
+        "For compatibility"
+        self.sendCode(code, msg)
+
+    def _cbToValidate(self, to, code=250, msg='Address recognized'):
         if to is not None:
+            try:
+                to, code, msg = to
+            except TypeError:
+                pass
             self.__to.append(to)
             self.sendCode(code, msg)
         else:
             self.sendCode(550, 'Cannot receive for specified address')
 
-    def _ebValidate(self, failure):
-        self.sendCode(
-            451,
-            'Requested action aborted: local error in processing'
-        )
-
     def do_DATA(self, rest):
         if self.__from is None or not self.__to:  
             self.sendCode(503, 'Must have valid receiver and originator')
@@ -359,10 +542,17 @@
         helo, origin, recipients = self.__helo, self.__from, self.__to
         self.__from = None
         self.__to = []
-        self.__messages = self.startMessage(recipients)
+        try:
+            self.__messages = self.startMessage(recipients)
+        except SMTPServerError, e:
+            self.sendCode(e.code, e.resp)
+            self.mode = COMMAND
+            return
         self.__inheader = self.__inbody = 0
-        for message in self.__messages:
-            message.lineReceived(self.receivedHeader(helo, origin, recipients))
+        rcvdhdr = self.receivedHeader(helo, origin, recipients)
+        if rcvdhdr:
+            for message in self.__messages:
+                message.lineReceived(rcvdhdr)
         self.sendCode(354, 'Continue')
 
     def connectionLost(self, reason):
@@ -425,28 +615,16 @@
     def _messageNotHandled(self, _):
         self.sendCode(550, 'Could not send e-mail')
 
-    def rfc822date(self):
-        timeinfo = time.localtime()
-        if timeinfo[8]:
-            # DST
-            tz = -time.altzone
-        else:
-            tz = -time.timezone
-            
-        return "%s %+2.2d%2.2d" % (
-            time.strftime("%a, %d %b %Y %H:%M:%S", timeinfo),
-            tz / 3600, (tz / 60) % 60)
-
     # overridable methods:
     def receivedHeader(self, helo, origin, recipents):
         return "Received: From %s ([%s]) by %s; %s" % (
-            helo[0], helo[1], self.host, self.rfc822date())
+            helo[0], helo[1], self.host, rfc822date())
     
-    def validateFrom(self, helo, origin, success, failure):
+    def validateFrom(self, helo, origin):
         if not helo:
-            failure(origin,503,"Who are you? Say HELO first");
-            return
-        success(origin)
+            return defer.fail(SMTPBadSender(origin, 503,
+                                     "Who are you? Say HELO first"))
+        return defer.succeed(origin)
 
     def validateTo(self, user):
         return defer.succeed(user)
@@ -459,85 +637,160 @@
     """Factory for SMTP."""
 
     # override in instances or subclasses
-    domain = "localhost"
+    domain = DNSNAME
     timeout = 600
 
     protocol = SMTP
 
-
 class SMTPClient(basic.LineReceiver):
     """SMTP client for sending emails."""
 
-    def __init__(self, identity):
+    def __init__(self, identity, logsize=10):
         self.identity = identity
+        self.toAddressesResult = []
+        self.successAddresses = []
+        self._from = None
+        self.resp = []
+        self.code = -1
+        self.lastfailed = 0
+        self.log = linelog.LineLog(logsize)
+
+    def sendLine(self, line):
+        "Logging sendLine"
+        self.log.append('>>> ' + line)
+        basic.LineReceiver.sendLine(self,line)
 
     def connectionMade(self):
-        self.state = 'helo'
+        self._expected = [ 220 ]
+        self._okresponse = self.smtpState_helo
+        self._failresponse = self.smtpConnectionFailed
 
     def lineReceived(self, line):
-        if len(line)<4 or (line[3] not in ' -'):
-            raise ValueError("invalid line from SMTP server %s" % line)
-        if line[3] == '-':
-            return
-        code = int(line[:3])
-        method =  getattr(self, 'smtpCode_%d_%s' % (code, self.state), 
-                                self.smtpCode_default)
-        method(line[4:])
-
-    def smtpCode_220_helo(self, line):
-        self.sendLine('HELO '+self.identity)
-        self.state = 'from'
-
-    def smtpCode_250_from(self, line):
-        from_ = self.getMailFrom()
-        if from_ is not None:
-            self.sendLine('MAIL FROM:<%s>' % from_)
-            self.state = 'afterFrom'
-        else:
-            self.sendLine('QUIT')
-            self.state = 'quit'
+        why = None
 
-    def smtpCode_250_afterFrom(self, line):
-        self.toAddresses = self.getMailTo()
-        self.successAddresses = []
-        self.state = 'to'
-        self.sendToOrData()
+        self.log.append('<<< ' + line)
+        try:
+            self.code = int(line[:3])
+        except ValueError:
+            self.code = -1
+            self.resp = []
+            return self._failresponse(
+                -1, "Invalid response from SMTP server: %s" % line)
 
-    def smtpCode_221_quit(self, line):
-        self.transport.loseConnection()
 
-    def smtpCode_default(self, line):
-        log.msg("SMTPClient got unexpected message from server -- %s" % line)
+        if line[0] == '0':
+            # Verbose informational message, ignore it
+            return
+
+        self.resp.append(line[4:])
+        
+        if line[3:4] == '-':
+            # continuation
+            return
+
+        if self.code in self._expected:
+            why = self._okresponse(self.code,'\n'.join(self.resp))
+            self.lastfailed = 0
+        elif not self.lastfailed:
+            why = self._failresponse(self.code,'\n'.join(self.resp))
+            self.lastfailed += 1
+        else:
+            self.sendLine('QUIT')
+            self._expected = xrange(0,1000)
+            self._okresponse = self.smtpState_disconnect
+            self.lastfailed = 0
+
+        self.code = -1
+        self.resp = []
+        return why
+
+    def smtpConnectionFailed(self, code, resp):
+        return SMTPConnectError(code, resp, str(self.log))
+
+    def smtpTransferFailed(self, code, resp):
+        if code < 0:
+            # protocol error
+            return SMTPProtcolError(code, resp, str(self.log))
+        return self.smtpState_msgSent(code, resp)
+
+    def smtpState_helo(self, code, resp):
+        self.sendLine('HELO ' + self.identity)
+        self._expected = xrange(200,300)
+        self._okresponse = self.smtpState_from
+
+    def smtpState_from(self, code, resp):
+        self._from = self.getMailFrom()
+        self._failresponse = self.smtpTransferFailed
+        if self._from is not None:
+            self.sendLine('MAIL FROM:%s' % quoteaddr(self._from))
+            self._okresponse = self.smtpState_to
+        else:
+            self.sendLine('QUIT')
+            self._expected = xrange(0,1000)
+            self._okresponse = self.smtpState_disconnect
+
+    def smtpState_disconnect(self, code, resp):
         self.transport.loseConnection()
 
-    def sendToOrData(self):
+    def smtpState_to(self, code, resp):
+        self.toAddresses = self.getMailTo()
+        self.toAddressesResult = []
+        self.successAddresses = []
+        self._okresponse = self.smtpState_toOrData
+        self._expected = xrange(0,1000)
+        self.lastAddress = None
+        return self.smtpState_toOrData(0, '')
+
+    def smtpState_toOrData(self, code, resp):
+        if self.lastAddress is not None:
+            self.toAddressesResult.append((self.lastAddress, code, resp))
+            if 200 <= code <= 299:
+                self.successAddresses.append(self.lastAddress)
         if not self.toAddresses:
             if self.successAddresses:
                 self.sendLine('DATA')
-                self.state = 'data'
+                self._expected = [ 354 ]
+                self._okresponse = self.smtpState_data
             else:
-                self.sentMail([])
-                self.smtpCode_250_from('')
+                return self.smtpState_msgSent(-1,'No recipients accepted')
         else:
             self.lastAddress = self.toAddresses.pop()
-            self.sendLine('RCPT TO:<%s>' % self.lastAddress)
-
-    def smtpCode_250_to(self, line):
-        self.successAddresses.append(self.lastAddress)
-        self.sendToOrData()
+            self.sendLine('RCPT TO:%s' % quoteaddr(self.lastAddress))
 
-    def smtpCode_550_to(self, line):
-        self.sendToOrData()
-        
-    def smtpCode_354_data(self, line):
+    def smtpState_data(self, code, resp):
         self.mailFile = self.getMailData()
         self.lastsent = ''
         self.transport.registerProducer(self, 0)
+        self._expected = xrange(200,300)
+        self._okresponse = self.smtpState_msgSent
 
-    def smtpCode_250_afterData(self, line):
-        self.sentMail(self.successAddresses)
-        self.smtpCode_250_from('')
+    def smtpState_msgSent(self, code, resp):
+        if self._from is not None:
+            # If there was a pending message
+            try:
+                self.sentMail(code, resp, len(self.successAddresses),
+                              self.toAddressesResult, self.log)
+            except TypeError:
+                if self.sentMail.func_code.co_argcount == 2:
+                    warnings.warn(
+                        'File "%s", line %d, in %s\n'
+                        '  %s.sentMail call syntax has changed!\n'
+                        '  Please update your code!' %
+                        (self.sentMail.func_code.co_filename,
+                         self.sentMail.func_code.co_firstlineno,
+                         self.sentMail.func_code.co_name,
+                         self.__class__.__name__),
+                        category=DeprecationWarning,stacklevel=2)
+                    self.sentMail(self.successAddresses)
+                else:
+                    raise
 
+        self.toAddressesResult = []
+        self._from = None
+        self.sendLine('RSET')
+        self._exected = xrange(200,300)
+        self._okresponse = self.smtpState_from
+        
     # IProducer interface
     def resumeProducing(self):
         """Write another """
@@ -549,7 +802,6 @@
             else:
                 line = '.'
             self.sendLine(line)
-            self.state = 'afterData'
             return
 
         chunk = string.replace(chunk, "\n", "\r\n")
@@ -581,9 +833,19 @@
         """
         raise NotImplementedError
 
-    def sentMail(self, addresses):
-        """Called with list of emails to which we sent the message."""
-        pass
+    def sentMail(self, code, resp, numOk, addresses, log):
+        """Called when an attempt to send an email is completed.
+
+        If some addresses were accepted, code and resp are the response
+        to the DATA command. If no addresses were accepted, code is -1
+        and resp is an informative message.
+
+        numOK is the number of addresses accepted by the remote host.
+        addresses is a list of tuples (address, code, resp) listing
+            the response to each RCPT command.
+        log is the SMTP session log
+        """
+        raise NotImplementedError
 
 
 class SMTPSender(SMTPClient):
@@ -591,27 +853,33 @@
     
     done = 0
 
-    def smtpCode_default(self, line):
-        """Deal with unexpected SMTP messages."""
-        SMTPClient.smtpCode_default(self, line)
-        self.sentMail([])
-    
     def getMailFrom(self):
         if not self.done:
             self.done = 1
-            return self.factory.fromEmail
+            return str(self.factory.fromEmail)
         else:
             return None
 
     def getMailTo(self):
-        return [self.factory.toEmail]
+        return self.factory.toEmail
 
     def getMailData(self):
         return self.factory.file
 
-    def sentMail(self, addresses):
+    def sentMail(self, code, resp, numOk, addresses, log):
         self.factory.sendFinished = 1
-        self.factory.result.callback(addresses == [self.factory.toEmail])
+        if code not in xrange(200,300):
+            # Failure
+            errlog = []
+            for addr, acode, aresp in addresses:
+                if code not in xrange(200,300):
+                    errlog.append("%s: %03d %s" % (addr, acode, aresp))
+            if numOk:
+                errlog.append(str(log))
+            self.factory.result.errback(SMTPDeliveryError(code, resp,
+                                                          '\n'.join(errlog)))
+        else:
+            self.factory.result.callback((numOk, addresses))
 
 
 class SMTPSenderFactory(protocol.ClientFactory):
@@ -621,27 +889,80 @@
 
     protocol = SMTPSender
     
-    def __init__(self, fromEmail, toEmail, file, deferred):
-        self.fromEmail = fromEmail
+    def __init__(self, fromEmail, toEmail, file, deferred, retries=5):
+        if isinstance(toEmail, StringTypes):
+            toEmail = [toEmail]
+        self.fromEmail = Address(fromEmail)
         self.toEmail = toEmail
         self.file = file
         self.result = deferred
         self.sendFinished = 0
+        self.retries = -retries
     
     def clientConnectionFailed(self, connector, error):
         self.result.errback(error)
 
     def clientConnectionLost(self, connector, error):
         # if email wasn't sent, try again
-        if not self.sendFinished:
+        if self.retries < self.sendFinished <= 0:
             connector.connect() # reconnect to SMTP server
+        elif self.sendFinished <= 0:
+            self.result.errback(error)
+        self.sendFinished -= 1
 
     def buildProtocol(self, addr):
-        p = self.protocol(self.fromEmail.split('@')[-1])
+        p = self.protocol(DNSNAME, len(self.toEmail)*2+2)
         p.factory = self
         return p
 
+def sendmail(smtphost, from_addr, to_addrs, msg):
+    """Send an email
+
+    This interface is intended to be a direct replacement for
+    smtplib.SMTP.sendmail() (with the obvious change that
+    you specify the smtphost as well). Also, ESMTP options
+    are not accepted, as we don't do ESMTP yet. I reserve the
+    right to implement the ESMTP options differently.
+
+    Arguments:
+      smtphost   : The host the message should be sent to
+      from_addr  : The (envelope) address sending this mail.
+      to_addrs   : A list of addresses to send this mail to.
+                   A string will be treated as a list of one
+                   address
+      msg        : The message, including headers, either as
+                   a file or a string. File-like objects need
+                   to support read() and close(). Line endings
+                   must be local (i.e. '\\n'). If you pass
+                   something that doesn't look like a file,
+                   we try to convert it to a string (so you
+                   should be able to pass an email.Message
+                   directly, but doing the conversion using
+                   generator manually and passing the file
+                   object is probably more efficient).
+
+    Returns:
+      defered    : The callback will be called if a message is
+                   sent to ANY address, the errback if no message
+                   is sent.
+
+                   The callback will be called with a tuple
+                   (numOk, addresses) where numOk is the number
+                   of successful recipient addresses and
+                   addresses is a list of tuples
+                   (address, code, resp) giving the response
+                   to the RCPT command for each address.
+    """
+    if not hasattr(msg,'read'):
+        # It's not a file
+        msg = StringIO(str(msg))
+        
+    d = defer.Deferred()
+    factory = SMTPSenderFactory(from_addr, to_addrs, msg, d)
+    reactor.connectTCP(smtphost, 25, factory)
 
+    return d
+    
 def sendEmail(smtphost, fromEmail, toEmail, content, headers = None, attachments = None, multipartbody = "mixed"):
     """Send an email, optionally with attachments.
 
@@ -674,6 +995,11 @@
     @return: The returned Deferred has its callback or errback invoked when
       the mail is successfully sent or when an error occurs, respectively.
     """
+    warnings.warn("smtp.sendEmail may go away in the future.\n"
+                  "  Consider revising your code to use the email module\n"
+                  "  and smtp.sendmail.",
+                  category=DeprecationWarning, stacklevel=2)
+
     f = tempfile.TemporaryFile()
     writer = MimeWriter.MimeWriter(f)
 
@@ -682,6 +1008,20 @@
         # Setup the mail headers
         for (header, value) in headers.items():
             writer.addheader(header, value)
+            
+        headkeys = [k.lower() for k in headers.keys()]
+    else:
+        headkeys = ()
+
+    # Add required headers if not present
+    if "message-id" not in headkeys:
+        writer.addheader("Message-ID", messageid())
+    if "date" not in headkeys:
+        writer.addheader("Date", rfc822date())
+    if "from" not in headkeys and "sender" not in headkeys:
+        writer.addheader("From", fromEmail)
+    if "to" not in headkeys and "cc" not in headkeys and "bcc" not in headkeys:
+        writer.addheader("To", toEmail)
 
     writer.startmultipartbody(multipartbody)
 
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/python/linelog.py Twisted/twisted/python/linelog.py
--- Twisted.orig/twisted/python/linelog.py	1970-01-01 01:00:00.000000000 +0100
+++ Twisted/twisted/python/linelog.py	2003-02-24 21:07:26.000000000 +0100
@@ -0,0 +1,50 @@
+# Twisted, the Framework of Your Internet
+# Copyright (C) 2001 Matthew W. Lefkowitz
+# 
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of version 2.1 of the GNU Lesser General Public
+# License as published by the Free Software Foundation.
+# 
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+# 
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+class LineLog:
+    """
+    A limited-size line-based log, useful for logging line-based
+    protocols such as SMTP.
+    
+    When the log fills up, old entries drop off the end.
+    """
+    def __init__(self, size=10):
+        """
+        Create a new log, with size lines of storage (default 10).
+        A log size of 0 (or less) means an infinite log.
+        """
+        if size < 0:
+            size = 0
+        self.log = [None]*size
+        self.size = size
+
+    def append(self,line):
+        if self.size:
+            self.log[:-1] = self.log[1:]
+            self.log[-1] = line
+        else:
+            self.log.append(line)
+
+    def str(self):
+        return '\n'.join(filter(None,self.log))
+
+    def __getitem__(self, item):
+        return filter(None,self.log)[item]
+
+    def clear(self):
+        """Empty the log"""
+        self.log = [None]*self.size
+
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/test/myrebuilder.py Twisted/twisted/test/myrebuilder.py
--- Twisted.orig/twisted/test/myrebuilder.py	1970-01-01 01:00:00.000000000 +0100
+++ Twisted/twisted/test/myrebuilder.py	2003-05-12 16:03:46.000000000 +0200
@@ -0,0 +1,16 @@
+
+class A:
+    def a(self):
+        return 'b'
+try:
+    object
+except NameError:
+    pass
+else:
+    class B(A, object):
+        def b(self):
+            return 'c'
+
+class Inherit(A):
+    def a(self):
+        return 'd'
diff -urN -x TAGS -x CVS -x '*~' -x '.#*' -x '*.pyc' -x '#*#' Twisted.orig/twisted/test/test_smtp.py Twisted/twisted/test/test_smtp.py
--- Twisted.orig/twisted/test/test_smtp.py	2003-05-12 16:16:45.000000000 +0200
+++ Twisted/twisted/test/test_smtp.py	2003-05-12 15:23:40.000000000 +0200
@@ -29,6 +29,9 @@
 import string, re
 from cStringIO import StringIO
 
+def spameater(*spam, **eggs):
+    return None
+
 class DummyMessage:
 
     def __init__(self, domain, user):
@@ -59,7 +62,7 @@
    def exists(self, user):
        if self.messages.has_key(user.dest.local):
            return defer.succeed(user)
-       return defer.succeed(None)
+       return defer.fail(smtp.SMTPBadRcpt(user))
 
    def startMessage(self, user):
        return DummyMessage(self, user)
@@ -86,6 +89,7 @@
         protocol =  protocols.DomainSMTP()
         protocol.service = self.factory
         protocol.factory = self.factory
+        protocol.receivedHeader = spameater
         protocol.makeConnection(self.transport)
         protocol.lineReceived('HELO yyy.com')
         for message in self.messages:
@@ -124,7 +128,7 @@
     def getMailData(self):
         return StringIO(self.mail[2])
 
-    def sentMail(self, addresses):
+    def sentMail(self, code, resp, numOk, addresses, log):
         self.mail = None, None, None
 
 
@@ -200,9 +204,7 @@
         self.buffer = []
 
     def lineReceived(self, line):
-        # Throw away the generated Received: header
-        if not re.match('Received: From foo.com \(\[.*\]\) by foo.com;', line):
-            self.buffer.append(line)
+        self.buffer.append(line)
 
     def eomReceived(self):
         message = string.join(self.buffer, '\n')+'\n'
@@ -224,6 +226,9 @@
     def startMessage(self, users):
         return [DummySMTPMessage(self, users)]
 
+    def receivedHeader(*spam):
+        return None
+
 class AnotherSMTPTestCase(unittest.TestCase):
 
     messages = [ ('foo.com', 'moshez@foo.com', ['moshez@bar.com'],
