from twisted.internet import protocol, defer, error
from twisted.internet import win32eventreactor
win32eventreactor.install()
from twisted.internet import reactor
from twisted.python import log

class CmdProcessProtocol(protocol.ProcessProtocol):
	def __init__(self):
		self.finished = False
		self.stdout = ''
		self.stderr = ''
		self.status = None
		self.deferred = defer.Deferred()

	def connectionMade(self):
		self.stdout = ''
		self.stderr = ''

	def outReceived(self, data):
		self.stdout += data

	def errReceived(self, data):
		self.stderr += data

	def inConnectionLost(self):
		pass

	def outConnectionLost(self):
		pass

	def errConnectionLost(self):
		pass

	def processEnded(self, status):
		self.finished = True
		if isinstance(status, error.ProcessDone):
			self.deferred.callback((self.stdout, self.stderr))
		else:
			self.deferred.errback(status)

def successFunction((stdout, stderr)):
	log.msg("stdout: %r" % (stdout,))
	log.msg("stderr: %r" % (stderr,))
	# None gets chained to the ignore parameter of the reactor.stop() lambda
	return None

def failureFunction(reason):
	log.err(reason)
	# Since we're returning a non-failure from an errback, it gets passed to the next
	# callback, which means the None gets chained to the ignore parameter of the reactor.stop lambda
	return None

def main():
	import sys
	log.startLogging(sys.stdout)
	exe = r"c:\program files\rational\clearcase\bin\cleartool.exe"
	p = CmdProcessProtocol()
	reactor.spawnProcess(p, exe, [exe, "lsview", "-s"], env=None)
	p.deferred.addCallbacks(callback=successFunction, errback=failureFunction
	).addCallback(lambda ignore: reactor.stop())
	reactor.run()

if __name__=='__main__': main()