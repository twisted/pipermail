from __future__ import generators
from twisted.python.compat import True, False
from twisted.internet.protocol import Protocol
        
class StringPipe:
    _s = ''
    def __len__(self):
        return len(self._s)

    def clear(self):
        self._s = ''

    def write(self, s):
        self._s += s

    def read(self, bytes=None):
        s = self._s
        if bytes is None:
            bytes = len(s) or 1
        if bytes > len(s):
            return None
        rval = s[:bytes]
        self._s = s[bytes:]
        return rval

def iter_fn(fn, *args, **kwargs):
    return fn, args, kwargs

class IterableProtocol(Protocol):
    iterateOnLoss = True
    iterateOnStart = True
    def connectionMade(self):
        self.iterator = iter(self)
        self.stopcommand = None
        if self.iterateOnStart:
            self.dispatch()

    def dispatch(self):
        if self.stopcommand is not None:
            cmd, args, kwargs = self.stopcommand
            if not getattr(self, 'dispatch_' + cmd)(*args, **kwargs):
                return
            self.stopcommand = None
        for cmd, args, kwargs in self.iterator:
            if not getattr(self, 'dispatch_' + cmd)(*args, **kwargs):
                self.stopcommand = cmd, args, kwargs
                break

    def connectionLost(self, reason):
        try:
            if self.iterateOnLoss:
                self.dispatch()
        finally:
            self.iterator = None
            self.stopcommand = None

class IterableBytestreamProtocol(IterableProtocol):
    PipeClass = StringPipe
    def connectionMade(self):
        self.pipe = self.PipeClass()
        IterableProtocol.connectionMade(self)

    def dataReceived(self, data):
        self.pipe.write(data)
        self.dispatch()

    def dispatch_read(self, callback, bytes=None):
        if self.pipe is None:
            callback(None)
            return True
        rbytes = self.pipe.read(bytes) 
        if rbytes is not None:
            callback(rbytes)
            return True
    
    def connectionLost(self, reason):
        self.pipe = None
        IterableProtocol.connectionLost(self, reason)
