<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Deferred in C++
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Deferred%20in%20C%2B%2B&In-Reply-To=e27efe130810210914p6c64f7ccs129493a565ee4743%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018559.html">
   <LINK REL="Next"  HREF="018549.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Deferred in C++</H1>
    <B>Jamu Kakar</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Deferred%20in%20C%2B%2B&In-Reply-To=e27efe130810210914p6c64f7ccs129493a565ee4743%40mail.gmail.com"
       TITLE="[Twisted-Python] Deferred in C++">jkakar at kakar.ca
       </A><BR>
    <I>Wed Oct 22 05:05:43 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="018559.html">[Twisted-Python] Deferred in C++
</A></li>
        <LI>Next message: <A HREF="018549.html">[Twisted-Python] Weekly Bug Summary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18561">[ date ]</a>
              <a href="thread.html#18561">[ thread ]</a>
              <a href="subject.html#18561">[ subject ]</a>
              <a href="author.html#18561">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Amaury,

On Tue, Oct 21, 2008 at 5:14 PM, Amaury Forgeot d'Arc
&lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">amauryfa at gmail.com</A>&gt; wrote:
&gt;<i> So I am not the only one who tries to use Twisted concepts in C++.
</I>
Heh, it's lonely being a C++ nerd, isn't it. ;) I'm mostly
interested in seeing what's possible and trying to understand how to
port very interesting APIs from Python to C++.

&gt;<i> I did write some kind of a Deferred class in C++ myself, together with
</I>&gt;<i> a re-implementation of a Twisted framework (two reactors featuring TCP
</I>&gt;<i> client &amp; server, callLater, callInThread...; a selectReactor and a
</I>&gt;<i> native MFC reactor that merges nicely in a Windows application, yes,
</I>&gt;<i> there are some; Protocols, LineReceiver, HttpClient &amp; server...)
</I>&gt;<i> and I already have a running business application that uses all of it
</I>&gt;<i> on Windows.
</I>&gt;<i>
</I>&gt;<i> The Deferred part was really hard to implement, and may be the reason
</I>&gt;<i> why it was never done before. It really pushed me out of my C++
</I>&gt;<i> knowledge.
</I>&gt;<i> I tried to convert my code to use your class, which seems easier to
</I>&gt;<i> use than mine. Great job!
</I>
The most difficult part for me was dealing with Deferred-returning
callbacks and getting the pausing/unpausing behaviour to work
correctly.  The difficult part was that all the template functions
caused order of definition issues.  The DeferredTypeInfo was
introduced for this case to make Deferred a template parameter and,
therefore, work around the ordering issues.  It's really heinously
complicated inside and I have to decipher it each time I look at it.
It's always a bad sign when you're the author of the code you can't
comprehend. :)

&gt;<i> - First, good news, your code almost compiles on Windows (VS 2005). I
</I>&gt;<i> had to typedef int32_t (why don't you simply use int?), comment out
</I>&gt;<i> the StackFrameFactory, and declare some functions/classes with
</I>&gt;<i> __declspec(dllexport) (with the help of a macro) so we can build a
</I>&gt;<i> DLL.
</I>
Cool, glad to hear it.  I didn't expect problems, but just haven't
had time to port it (and also have VS2005 as my base target compiler
for Windows).  I plan to s/int32_t/int/, but haven't gotten around
to it.  It's a historic artifact in that code from many years ago
that I've continued for the time being to keep things consistent.

&gt;<i> - In my eyes, the notation &quot;addCallback&quot; is more readable than
</I>&gt;<i> &quot;add_callback&quot; (and it's the one used by twisted python), but that's a
</I>&gt;<i> matter of taste. On the other hand I found disturbing at first to fire
</I>&gt;<i> deferreds with the methods &quot;succeed()&quot; and &quot;fail()&quot; (instead of
</I>&gt;<i> callback() and errback()
</I>
The style issue is entirely personal, so yeah, I can see why you
feel that way.  As far as succeed() and fail() vs. callback() and
errback(), this change was a suggestion from Christopher Armstrong.
Apparently, a lot of Twisted users have been confused by callback
(the callable you add to a Deferred) vs callback (the method you
call to fire the Deferred), and similar for errback.

&gt;<i> - I found that my callbacks often have a void result, and deferred are
</I>&gt;<i> sometimes fired without a value. For example, a twisted DeferredList
</I>&gt;<i> often just waits for its children to finish. The results may be
</I>&gt;<i> gathered somewhere, but the callbacks return None.
</I>&gt;<i> I took the liberty to change your code and add *a lot* of template
</I>&gt;<i> specializations for the &quot;void&quot; ReturnType or ResultType.
</I>&gt;<i> I suggest that when a callback takes no parameter, it can be added to
</I>&gt;<i> any Deferred, whatever its current state (and the current value is
</I>&gt;<i> simply discarded).
</I>
This is on my list of things to add, but haven't gotten around to it
yet.  My plan is to throw a NoResultError or something whenever a
callback is added to a Deferred that already has void-returning
callback at the end of the chain.  Though, hmm... I guess you might
still want to add an errback to handle errors from the
void-returning callback.

&gt;<i> - In some cases my callbacks take additional arguments (the twisted
</I>&gt;<i> &quot;callbackArgs&quot;). To make it possible I used the
</I>&gt;<i> boost::bind functions, and a wrapper class that converts any
</I>&gt;<i> boost::function to a ion::ICallback.
</I>
Ah, nice.  Yeah, I was wondering about that and have been
considering implementing a specialized ICallback that can store
arguments.

&gt;<i> - Several times I had a &quot;Can't add invalid callback&quot; error, and I
</I>&gt;<i> found it difficult to figure which type was in the deferred state (the
</I>&gt;<i> previous callback returned a Deferred, and so on...) So I extended
</I>&gt;<i> ITypeInfo with a &quot;const char* typename&quot; member, that I fill with
</I>&gt;<i> &quot;typeid(Object).name()&quot;. Much easier to see with the debugger...
</I>
Good call.  Yeah, I've had the same issue interpreting
InvalidCallbackError's.

&gt;<i> - I tried to implement a DeferredList. I almost succeeded, except that
</I>&gt;<i> it simply inherit from Deferred and it seems a bad idea: when the
</I>&gt;<i> DeferredList is returned as a plain Deferred, all state is lost... and
</I>&gt;<i> the application crashes.
</I>&gt;<i> Maybe Deferred should be a kind of &quot;shared pointer&quot; to the real
</I>&gt;<i> object: DeferredState or DeferredListState
</I>
Deferred is a &quot;shared pointer&quot; to DeferredState...?  Maybe I'm not
understanding your point?

&gt;<i> - Errr... I'm not sure I understood the &quot;trule&quot; concept. When do you
</I>&gt;<i> use it? What are its semantics regarding ownership? is it similar to
</I>&gt;<i> std::auto_ptr?
</I>
This is an implementation of the Holder/Trule pattern described in
Josuttis' &quot;C++ Templates&quot; book.  There is a reason, which I can't
recall right now, that makes returning a ptr (or auto_ptr) from a
function potentially dangerous (and also passing one in) that trule
fixes.

My plan is to migrate to the Boost pointers that will become part of
the standard library in C++0x.  This will make working with smart
pointers in ion much nicer.  The ptr/trule pattern is quite
cumbersome, especially when templates are involved.

&gt;<i> - How is one supposed to get the content of a Failure? I use code like
</I>&gt;<i> this, but it seems too long for this simple task:
</I>&gt;<i>  void MyProcess::displayError(ion::trule&lt;ion::Failure&gt; failure)
</I>&gt;<i>  {
</I>&gt;<i>    std::string message = ion::ptr&lt;ion::Failure&gt;(failure)-&gt;get_message();
</I>&gt;<i>    [...]
</I>&gt;<i>    throw ion::UnhandledFailureError(failure);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> - likewise, it should be possible to simply
</I>&gt;<i>    throw Failure(&quot;Some error message&quot;);
</I>
The displayError above is what you're expected to do, so far.  If
there's a better way I'd love to hear it.  There's actually a deeper
issue that makes Failure/error handling in this implementation kind
of crappy.  The type of an exception is lost when caught in a catch
block for a base class of the thrown exception.  Which means that
it's not possible, currently, to determine the concrete exception
type from a Failure.  One thing I've been considering is making the
ion::Exception class provide some extra functionality to make this
possible, but I'm unhappy that doing that will make implementing
custom ion::Exception's harder.

Being able to throw a Failure with a string message is a good idea.

&gt;&gt;<i> The reliance on templates would negatively affect
</I>&gt;&gt;<i> compile time, for one thing.  More importantly, I've found
</I>&gt;&gt;<i> deciphering the error messages produced by simple mistakes can be
</I>&gt;&gt;<i> tricky.
</I>&gt;<i>
</I>&gt;<i> I confirm: it is.
</I>
Heh. :)

&gt;&gt;<i> Nonetheless, my main motivation was to see if it was
</I>&gt;&gt;<i> possible at all and so I'm pleased that it works in the end.
</I>&gt;<i>
</I>&gt;<i> I think my program can be considered as a non-trivial application (I
</I>&gt;<i> cannot show its code, though, except for the non-business framework)
</I>&gt;<i> It is definitely possible to implement a Twisted framework in C++. The
</I>&gt;<i> hard part is to make it nice for the developer. Programming with
</I>&gt;<i> callbacks already twists your mind, it becomes very difficult if the
</I>&gt;<i> language syntax hides the important part of the code.
</I>
This &quot;make it nice for the developer&quot; is the primary goal I have
with this effort.

&gt;<i> The &quot;ion&quot; project seems promising! What extend do you intend to give it?
</I>
I'm interested in getting to the point where there's a Twisted-style
reactor and, eventually, support for using AMP-based protocols.

Thanks,
J.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018559.html">[Twisted-Python] Deferred in C++
</A></li>
	<LI>Next message: <A HREF="018549.html">[Twisted-Python] Weekly Bug Summary
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18561">[ date ]</a>
              <a href="thread.html#18561">[ thread ]</a>
              <a href="subject.html#18561">[ subject ]</a>
              <a href="author.html#18561">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
