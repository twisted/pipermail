<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] cursors
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20cursors&In-Reply-To=%3C20011123220112.A4992%40troglodyte.menefee%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] cursors</H1>
    <B>Kevin Turner</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20cursors&In-Reply-To=%3C20011123220112.A4992%40troglodyte.menefee%3E"
       TITLE="[Twisted-Python] cursors">acapnotic at twistedmatrix.com
       </A><BR>
    <I>Fri Nov 23 23:01:12 MST 2001</I>
    <P><UL>
        
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33111">[ date ]</a>
              <a href="thread.html#33111">[ thread ]</a>
              <a href="subject.html#33111">[ subject ]</a>
              <a href="author.html#33111">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Someone, either Glyph or Tommi, mentioned that they wanted cursors a
while back.  &quot;What's that,&quot; I asked; then thought &quot;hm.  I could do
that.&quot;  But I didn't.  Only, now I did.  I think.

-- 
The moon is waxing gibbous, 58.9% illuminated, 8.2 days old.
-------------- next part --------------
# -*- Python -*-
# Kevin Turner &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">acapnotic at foobox.net</A>&gt;, November 23, 2001
# This code is in the Public Domain.

from UserList import UserList
import types

class CursoredList(UserList):
    _cursorlist = None

    def __init__(self, seq=None):
        UserList.__init__(self, seq)

    def setCursor(self):
        if self._cursorlist is None:
            self._cursorlist = []

        self._cursorlist[:] = range(len(self.data))
        self._cursorLen = len(self.data)

    def cursor(self, key):
        if self._cursorlist is None:
            return self.__getitem__(key)

        if isinstance(key, types.SliceType):
            start, stop, step = key.start, key.stop, key.step
            if not step:
                step = 1
            if start is None:
                start = 0
            elif start &lt; 0:
                start = self._cursorLen + start

            if (stop is None) or (stop &gt; self._cursorLen):
                stop = self._cursorLen
            elif stop &lt; 0:
                start = self._cursorLen + stop

            result = []
            for i in xrange(start, stop, step):
                result.append(self.cursor(i))
            return result

        else:
            key = int(key)
            if key &lt; 0:
                key = self._cursorLen + key
            assert(0 &lt;= key &lt; self._cursorLen)

            new_key = self._cursorlist.index(key)

            return self.__getitem__(new_key)

    def __setitem__(self, key, value):
        if (self._cursorlist is not None) \
           and isinstance(key, types.SliceType):

            self._cursorlist[key.start:key.stop] = [None] * len(value)

        if isinstance(key, types.SliceType):
            self.data[key.start:key.stop] = value
        else:
            self.data[key] = value

    def __getitem__(self, key):
        if isinstance(key, types.SliceType):
            return self.data[key.start:key.stop]
        else:
            return self.data[key]

    def __delitem__(self, key):
        if not isinstance(key, types.SliceType):
            key = slice(key, key+1)

        self.__setitem__(key, [])

    def __getslice__(self, start, stop):
        return self.__getitem__(slice(start, stop))

    def __setslice__(self, start, stop, value):
        return self.__setitem__(slice(start, stop), value)

    def __delslice__(self, start, stop):
        return self.__delitem__(slice(start, stop))

    def __iadd__(self, other):
        self.extend(other)
        return self

    def __imul__(self, multiplier):
        if self._cursorlist is not None:
            self._cursorlist.extend(([None] * len(self.data))
                                    * (multiplier-1))
        self.data[:] = self.data * multiplier

    def append(self, item):
        self[len(self):len(self)] = [item]

    def insert(self, i, item):
        self[i:i] = [item]

    def pop(self, i=-1):
        value = self[i]
        del self[i]
        return value

    def remove(self, item):
        i = self.index(item)
        del self[i]

    def reverse(self):
        self.data.reverse()
        if self._cursorlist is not None:
            self._cursorlist.reverse()

    def sort(self, cmpfunc=None):
        if self._cursorlist is not None:
            zipped = map(None, self.data, self._cursorlist)
            if cmpfunc:
                # The supplied cmpfunc won't be expecting the zipped list.
                cmpfunc_ = lambda x, y, c=cmpfunc: c(x[0], y[0])
                zipped.sort(cmpfunc_)
            else:
                zipped.sort()
            for i in range(len(zipped)):
                self.data[i], self._cursorlist[i] = zipped[i]
        else:
            self.data.sort()

    def extend(self, other):
        self[len(self):len(self)] = other
</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33111">[ date ]</a>
              <a href="thread.html#33111">[ thread ]</a>
              <a href="subject.html#33111">[ subject ]</a>
              <a href="author.html#33111">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
