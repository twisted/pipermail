<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] I could swear I've seen this pattern	*somewhere*	in Twisted...
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20I%20could%20swear%20I%27ve%20seen%20this%20pattern%09%2Asomewhere%2A%0A%09in%20Twisted...&In-Reply-To=20050510030454.15422.298300077.divmod.quotient.29233%40ohm">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010416.html">
   <LINK REL="Next"  HREF="010420.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] I could swear I've seen this pattern	*somewhere*	in Twisted...</H1>
    <B>Mike C. Fletcher</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20I%20could%20swear%20I%27ve%20seen%20this%20pattern%09%2Asomewhere%2A%0A%09in%20Twisted...&In-Reply-To=20050510030454.15422.298300077.divmod.quotient.29233%40ohm"
       TITLE="[Twisted-Python] I could swear I've seen this pattern	*somewhere*	in Twisted...">mcfletch at rogers.com
       </A><BR>
    <I>Tue May 10 00:30:12 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010416.html">[Twisted-Python] I could swear I've seen this pattern	*somewhere*	in Twisted...
</A></li>
        <LI>Next message: <A HREF="010420.html">[Twisted-Python] I could swear I've seen this	pattern	*somewhere* in Twisted...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10418">[ date ]</a>
              <a href="thread.html#10418">[ thread ]</a>
              <a href="subject.html#10418">[ subject ]</a>
              <a href="author.html#10418">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jp Calderone wrote:

&gt;<i> I'd be interested to hear about the relative performance of your two
</I>&gt;<i> solutions.  I would expect DeferredSemaphore to create many more
</I>&gt;<i> Deferreds, and thus perhaps perform less well.
</I>
Hmm, never really worried about raw performance overhead of the
scheduling operations... should I be?  I'd been under the impression
that the deferred objects were rather lightweight.  Within our apps I'm
more concerned about getting the queues so full that they can't get
through to process the high-priority events.

&gt;<i>  Also, Glyph and I did some work for Quotient today on some code which
</I>&gt;<i> may be applicable to this kind of problem.  Here's an example:
</I>&gt;<i>
</I>&gt;<i>    from twisted.internet import defer
</I>&gt;<i>    from atop.tpython import Cooperator
</I>&gt;<i>
</I>&gt;<i>    def parallel(iterable, count, callable, *args, **named):
</I>&gt;<i>        source = iter(iterable)
</I>&gt;<i>        def work():
</I>&gt;<i>            for elem in source:
</I>&gt;<i>                yield callable(elem, *args, **named)
</I>&gt;<i>        coop = Cooperator()
</I>&gt;<i>        tasks = []
</I>&gt;<i>        for i in range(count):
</I>&gt;<i>            tasks.append(coop.coiterate(work()))
</I>&gt;<i>        return defer.DeferredList(tasks)
</I>&gt;<i>
</I>&gt;<i>  Note that this returns a DeferredList of each &quot;task&quot;, rather than of
</I>&gt;<i> each result.  If results are desired as well, adding a callback
</I>&gt;<i> (before yielding) to the result of callable() inside work() which
</I>&gt;<i> saved the result, then adding a callback to the DeferredList which
</I>&gt;<i> discarded the list of task results and returned the saved results
</I>&gt;<i> would accomplish this.
</I>&gt;<i>
</I>&gt;<i>  Note also that Cooperator is in a branch at the moment.  It'll most
</I>&gt;<i> likely be in Quotient trunk sometime tomorrow.
</I>
Seems okay, but Jame's implementation of parallel with
DeferredSemaphore.run seems less complex as an implementation (to me
anyway), but then I haven't really gotten into the whole &quot;flow&quot; Twisted
sub-culture yet :) .

Your version really does highlight the possibility of just passing in an
&quot;iterapply&quot; instance instead of defining the &quot;work&quot; function inside
(especially given the need to alter the work function to retrieve the
results).  I am curious, though, doesn't your version cause the source
to be iterated over count times in total?  I *think* you want to share
the work() instance among the coop.coiterate calls (at least, you would
if I understand how everything works from their names).

Have fun,
Mike

-- 
________________________________________________
  Mike C. Fletcher
  Designer, VR Plumber, Coder
  <A HREF="http://www.vrplumber.com">http://www.vrplumber.com</A>
  <A HREF="http://blog.vrplumber.com">http://blog.vrplumber.com</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010416.html">[Twisted-Python] I could swear I've seen this pattern	*somewhere*	in Twisted...
</A></li>
	<LI>Next message: <A HREF="010420.html">[Twisted-Python] I could swear I've seen this	pattern	*somewhere* in Twisted...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10418">[ date ]</a>
              <a href="thread.html#10418">[ thread ]</a>
              <a href="subject.html#10418">[ subject ]</a>
              <a href="author.html#10418">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
