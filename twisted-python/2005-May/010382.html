<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Hanging%20test%20cases%20%28Was%3A%20Evangelism%20notes...%29&In-Reply-To=u1x8jkhum.fsf%40fitlinxx.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010376.html">
   <LINK REL="Next"  HREF="010383.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)</H1>
    <B>Bob Ippolito</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20Hanging%20test%20cases%20%28Was%3A%20Evangelism%20notes...%29&In-Reply-To=u1x8jkhum.fsf%40fitlinxx.com"
       TITLE="[Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)">bob at redivi.com
       </A><BR>
    <I>Sat May  7 18:36:32 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010376.html">[Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)
</A></li>
        <LI>Next message: <A HREF="010383.html">[Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10382">[ date ]</a>
              <a href="thread.html#10382">[ thread ]</a>
              <a href="subject.html#10382">[ subject ]</a>
              <a href="author.html#10382">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On May 6, 2005, at 8:19 PM, David Bolen wrote:

&gt;<i> Bob Ippolito &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">bob at redivi.com</A>&gt; writes:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> (1) Reactors can only be (meaningfully/predictably/etc) iterated if
</I>&gt;&gt;<i> Twisted rules the universe AND the implementation of that reactor is
</I>&gt;&gt;<i> amenable to that feature.  This is not a tautology.
</I>&gt;&gt;<i> (2) Reactors need to fire various startup/shutdown events.  Reactors
</I>&gt;&gt;<i> shouldn't be doing ANYTHING unless they are in a running state.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The current deferredResult/deferredError breaks both of these
</I>&gt;&gt;<i> conditions.
</I>&gt;&gt;<i> (1) It iterates the reactor (which is a historically public, but
</I>&gt;&gt;<i> conceptually broken interface)
</I>&gt;&gt;<i> (2) It iterates the reactor in a STOPPED state.  The reactor is never
</I>&gt;&gt;<i> &quot;running&quot; during these tests.  Startup/Shutdown does not happen!
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> This seems like an internal implementation issue to me - when a
</I>&gt;<i> reactor is &quot;running&quot; (I've called run()), it's basically stuck in a
</I>&gt;<i> loop doing runUntilCurrent and then doIteration.  That's precisely
</I>&gt;<i> what iterate does.
</I>
This is an implementation detail.  runUntilCurrent, doIteration, and  
iterate should not be public API.

&gt;<i> Now, I agree that if you have tests that never initiate the run, that
</I>&gt;<i> you skip over some startup events.  But except for the uppermost
</I>&gt;<i> tests, what is being tested is a specific unit test for a piece of the
</I>&gt;<i> system that should be testable in isolation.  If the item under test
</I>&gt;<i> has a dependency on startup events, the test should arrange for them.
</I>
The reactor itself needs startup/shutdown events.  As you've noticed,  
the thread pool depends on them.

&gt;&gt;<i> The problem, for tests, is that using a properly written
</I>&gt;&gt;<i> deferredResult / deferredError the reactor would startup/shutdown
</I>&gt;&gt;<i> violently throughout the course of a single test, and will break the
</I>&gt;&gt;<i> hell out of it if it has anything to do with services/etc.  So, while
</I>&gt;&gt;<i> for SOME deferreds it would work fine, but for others, it wouldn't.
</I>&gt;&gt;<i> Basically, unless you can encapsulate the entire test in a single
</I>&gt;&gt;<i> deferred, then it shouldn't be using deferredResult/deferredError.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I still don't necessarily see that (the last sentence).  We use
</I>&gt;<i> multiple deferrable operations in single tests, but never more than
</I>&gt;<i> one at a time (e.g., no recursive or nested uses).  But certainly more
</I>&gt;<i> than a single deferrable operation within a single test.
</I>&gt;<i>
</I>&gt;<i> I would, however, agree that I'd prefer even more the ability to
</I>&gt;<i> completely start/stop a reactor during the course of a test, but would
</I>&gt;<i> still like to be able to iterate it manually during the test to
</I>&gt;<i> provide a natural blocking flow to the test.
</I>
We all want things that aren't really possible to do :)

&gt;<i> But in my current scenario, the majority of my components under test
</I>&gt;<i> are having interfaces tested that are not impacted by startup/shutdown
</I>&gt;<i> (and we don't use any services, in the Twisted sense, for example).
</I>
However if some implementation detail of twisted changes to take  
advantage of reactor startup/shutdown events internally then all of  
your tests would break even though the application would work.   
Having tests that fail in theory but work in practice is uh, bad.

&gt;&gt;<i> Therefore, what SHOULD happen is that trial should let you write
</I>&gt;&gt;<i> tests that return deferreds, and it should let you write it in the
</I>&gt;&gt;<i> deferredGenerator style (so it doesn't suck so much).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I don't think I'd disagree with that - we pretty much stayed away from
</I>&gt;<i> trial since I wasn't comfortable with it initially, so we're a pure
</I>&gt;<i> Unittest approach, which certainly doesn't provide any framework for
</I>&gt;<i> something like that.
</I>
Staying away from trial isn't really a bad idea.  It's obviously  
broken.  However, bringing the broken functionality from trial back  
into unittest doesn't make it any better :)

&gt;&gt;&gt;<i>     self.user = deferredResult(self.umgr.user())
</I>&gt;&gt;&gt;<i>     self.user.email = '<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">test at dom.ain</A>'
</I>&gt;&gt;&gt;<i>     deferredResult(self.umgr.saveUser(self.user))
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # let's assume I've aliased waitForDeferred to &quot;wait&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> d = waitForDeferred(self.umgr.user())
</I>&gt;&gt;<i> yield d
</I>&gt;&gt;<i> self.user = d.getResult()
</I>&gt;&gt;<i> self.user.email = '<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">test at dom.ain</A>'
</I>&gt;&gt;<i> d = waitForDeferred(self.umgr.saveUser(self.user))
</I>&gt;&gt;<i> yield d
</I>&gt;&gt;<i> d.getResult()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So, the test is 6 lines instead of 3.  Which sucks, but it's   
</I>&gt;&gt;<i> correct.
</I>&gt;&gt;<i> For tests that do more stuff, it probably should be even  less of a
</I>&gt;&gt;<i> problem.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Except that you didn't include the additional code I'd now have to
</I>&gt;<i> write to actually turn that into a generator which is iterated over by
</I>&gt;<i> the test in order to actually process the deferrable yields.  (Unless
</I>&gt;<i> this is something trial does automatically somehow).
</I>
Trial could and should (but doesn't currently) do that automatically  
if your test function returns an iterator instead of None.

&gt;<i> That's what I meant by saying that the integration into generators is
</I>&gt;<i> slick (and goes a good way to linearizing what is normally a callback
</I>&gt;<i> chain), but still isn't quite as simple as the interface provided by
</I>&gt;<i> the deferred{Result,Error} functions.
</I>
Using Twisted isn't as simple as using urllib to suck down a web  
page, and using ascii strings is easier than using unicode...

&gt;&gt;<i> Well, let's say your database thing is a service, that maintains some
</I>&gt;&gt;<i> kind of ephemeral state that's required in some way.  If
</I>&gt;&gt;<i> deferredResult were properly written, this ephemeral state would hit
</I>&gt;&gt;<i> the bit bucket on each deferredResult, probably breaking your code
</I>&gt;&gt;<i> even though the test are &quot;correct&quot;.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I might be getting lost on the &quot;properly written&quot; part, but if I were
</I>&gt;<i> testing a component that did have state triggered during reactor
</I>&gt;<i> startup/shutdown (which is what I think you're referring to), that
</I>&gt;<i> test would likely be using direct calls to the component to trigger
</I>&gt;<i> the startup/shutdown actions as part of the test setup/teardown, but
</I>&gt;<i> without using the reactor.
</I>
That's assuming you actually know about all of the services necessary  
to make something work, and that these services can startup/shutdown  
properly in this manner.  The more special crap you write in a test  
the less useful the test is because it's testing something in an  
entirely different way than it actually works.

&gt;&gt;<i> So, use deferredGenerator / waitForDeferred.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Once we move to 2.0 we might consider that (I'm not quite up for
</I>&gt;<i> back-porting into 1.3 that we're using now), but I still think that
</I>&gt;<i> would complicate the tests (in terms of the overhead to actually run
</I>&gt;<i> each test like a generator) - but different people can have different
</I>&gt;<i> views on what is more maintainable.
</I>
Move to 2.0 ASAP.  Don't backport to 1.3.

&gt;<i> Since we're not running our entire test bed under control of a single
</I>&gt;<i> &quot;reactor.run&quot; call (I presume that's more of what trial does?), even
</I>&gt;<i> using the generator would effectively be iterating the reactor
</I>&gt;<i> somewhere along the line.
</I>
Trial doesn't use reactor.run at all, that's why it's broken.  Using  
the generator would be iterating the reactor but it would be not  
broken.  A good implementation of test would start and stop the  
reactor at the beginning and end of every test so that you (probably)  
don't end up with side-effects due to the order that the tests run.

&gt;<i> I don't know - maybe my use case is just limited enough (non trial, no
</I>&gt;<i> nesting, etc...) that I don't see any true exposures through
</I>&gt;<i> deferred{Result,Error} while I'm getting benefits.
</I>
You're right, some things don't break in horrible ways when you use  
deferred{Result,Error}.  Sometimes you can concatenate a str and a  
unicode and it Just Works too, but it only works if the str contains  
characters that can be decoded by the default encoding, whatever that  
happens to be at the time :)

-bob



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010376.html">[Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)
</A></li>
	<LI>Next message: <A HREF="010383.html">[Twisted-Python] Re: Hanging test cases (Was: Evangelism notes...)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10382">[ date ]</a>
              <a href="thread.html#10382">[ thread ]</a>
              <a href="subject.html#10382">[ subject ]</a>
              <a href="author.html#10382">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
