<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: So how does everyone use an ORM in twisted?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20So%20how%20does%20everyone%20use%20an%20ORM%20in%20twisted%3F&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019364.html">
   <LINK REL="Next"  HREF="019367.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: So how does everyone use an ORM in twisted?</H1>
    <B>David Bolen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20So%20how%20does%20everyone%20use%20an%20ORM%20in%20twisted%3F&In-Reply-To="
       TITLE="[Twisted-Python] Re: So how does everyone use an ORM in twisted?">db3l.net at gmail.com
       </A><BR>
    <I>Tue Mar 17 18:13:53 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="019364.html">[Twisted-Python] Re: So how does everyone use an ORM in twisted?
</A></li>
        <LI>Next message: <A HREF="019367.html">[Twisted-Python] Re: So how does everyone use an ORM in twisted?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19365">[ date ]</a>
              <a href="thread.html#19365">[ thread ]</a>
              <a href="subject.html#19365">[ subject ]</a>
              <a href="author.html#19365">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Stephen Waterbury &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">waterbug at pangalactic.us</A>&gt; writes:

&gt;<i> This is a good point -- although the attractive part of using an
</I>&gt;<i> ORM in the first place is somewhat OT here, the main attraction
</I>&gt;<i> for me is usually *DRY* rather than &quot;automatic persistence&quot;, so for
</I>&gt;<i> my purposes such &quot;magical&quot; features as direct attribute access,
</I>&gt;<i> lazy loading, etc. can actually be undesirable, since they
</I>&gt;<i> can make application semantics tricky to implement in some cases.
</I>&gt;<i> (This is somewhat analogous to the original rationale for PB's
</I>&gt;<i> implementation of &quot;translucently&quot; distributed objects --
</I>&gt;<i> &quot;transparently&quot; [magically] distributed objects are not
</I>&gt;<i> always desirable, and the same goes for &quot;transparently&quot;
</I>&gt;<i> persistent objects.)
</I>
It's a spectrum, but as you start to move further down the &quot;explicit&quot;
route at some point I tend to find it closing in on just executing the
SQL.  For example, if you bypass just iterating an attribute to find
matching foreign key records in favor of a more explicit approach such
as a separate method call, it becomes closer to just iterating over
the SQL to query such records.  And having a database layer with
explicit SQL for retrieval/update can implement DRY quite well.

Of course you can also be more explicit with SQLAlchemy by defining
the default loader to be eager, or using eagerload() directly, you
just might pay a penalty in overhead in some schemas.

I guess what I always run into with ORMs is that I'm rarely lucky
enough to have my Python module be the only user of the database, and
while SQLAlchemy plays nicer with other tools at the schema level than
many ORMs that want to completely manage their persistence tables, I've
just had better luck sticking with SQL against a traditional relational
schema than one trying to mimic object persistence.  But that's more
of a general ORM usage debate than a twisted-specific one.  What is
twisted-specific, is that the additional work to ensure ORM features
work without interfering with twisted does seem to make their benefit
harder to achieve within the twisted environment.

Since I don't think it's been mentioned yet, one other item worth
pointing out is that SQLAlchemy does provide quite a bit of
flexibility and control over the mapping process, so there's some
wiggle room between raw SQL and fully ORM driven eager loading.  You
can have custom mappers that work against generic selectables (even
the results of raw SQL) which can take some of the drudgery out of
processing database results into more easily manageable object
instances, while still being rather friendly to being offloaded to a
dedicated DB thread.

-- David



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019364.html">[Twisted-Python] Re: So how does everyone use an ORM in twisted?
</A></li>
	<LI>Next message: <A HREF="019367.html">[Twisted-Python] Re: So how does everyone use an ORM in twisted?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19365">[ date ]</a>
              <a href="thread.html#19365">[ thread ]</a>
              <a href="subject.html#19365">[ subject ]</a>
              <a href="author.html#19365">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
