<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] RE: how to create state machines?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20RE%3A%20how%20to%20create%20state%20machines%3F&In-Reply-To=E1LnETT-0002Ff-OU%40cube.twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019411.html">
   <LINK REL="Next"  HREF="019409.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] RE: how to create state machines?</H1>
    <B>Doug Farrell</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20RE%3A%20how%20to%20create%20state%20machines%3F&In-Reply-To=E1LnETT-0002Ff-OU%40cube.twistedmatrix.com"
       TITLE="[Twisted-Python] RE: how to create state machines?">dfarrell at mypublisher.com
       </A><BR>
    <I>Mon Mar 30 11:10:48 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="019411.html">[Twisted-Python] How to use defer.fail better...
</A></li>
        <LI>Next message: <A HREF="019409.html">[Twisted-Python] RE: how to create state machines?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19408">[ date ]</a>
              <a href="thread.html#19408">[ thread ]</a>
              <a href="subject.html#19408">[ subject ]</a>
              <a href="author.html#19408">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Andrew,
&gt;<i> 
</I>&gt;<i> Hi Doug:
</I>&gt;<i> 
</I>&gt;<i> &gt;This state machine initializes a system, issues an asynchronous
</I>&gt;<i> command
</I>&gt;<i> &gt;that takes time to complete (say a motor move command) and then waits
</I>&gt;<i> &gt;for that command to be done before exiting. In the context of a
</I>&gt;<i> &gt;framework that is calling this state machine, the WAITCMD1 is
</I>executed
&gt;<i> &gt;repeatedly (polling) while the asynchronous command completes. A
</I>&gt;<i> system
</I>&gt;<i> &gt;can be constructed with lots of little state machines like this and
</I>be
&gt;<i> &gt;made to look like it is doing many things at once even though the
</I>&gt;<i> &gt;execution of the program is single threaded.
</I>&gt;<i> 
</I>&gt;<i> &gt;I understand (pretty much) the Twisted framework is like this and
</I>&gt;<i> &gt;implmenting event handlers like connectionMade(), etc., is a state
</I>&gt;<i> &gt;machine, but I'm wondering how to implement what I've outlined above
</I>&gt;<i> in
</I>&gt;<i> &gt;one of Twisted's state event handlers, or inside something like
</I>&gt;<i> &gt;callLater(). For example, let's say I want to use Twisted to run a
</I>&gt;<i> long
</I>&gt;<i> &gt;running daemon process that has an XMLRPC interface. That XMLRPC
</I>&gt;<i> &gt;interface is an interface to a state machine inside Twisted that
</I>&gt;<i> allows
</I>&gt;<i> &gt;the caller to change state, or start new state machines, or get the
</I>&gt;<i> &gt;status of a running state machine. In that case I'm thinking I want a
</I>&gt;<i> &gt;state machine the runs continuously in the Twisted loop, structured
</I>&gt;<i> like
</I>&gt;<i> &gt;the example above; co-operatively yielding back to Twisted, but
</I>&gt;<i> running
</I>&gt;<i> &gt;non-stop. Something like callLater(1, stateMachine), but non-stop,
</I>&gt;<i> &gt;without even the 1 second call loop.
</I>&gt;<i> 
</I>&gt;<i> If I understand your correctly, I don't think you need to implement a
</I>&gt;<i> state machine to simulate concurrency with Twisted - Twisted does a
</I>lot
&gt;<i> of that for you. You can think of a Twisted application as a state
</I>&gt;<i> machine - the callback being the state and the completion of the
</I>&gt;<i> operation and the calling of the callback is the transition. These
</I>&gt;<i> callbacks at runtime act like a thread of execution.
</I>&gt;<i> 
</I>&gt;<i> def Initialize(...):
</I>&gt;<i>     # do something
</I>&gt;<i>     deferred = someFunctionThatReturnsADeferred()
</I>&gt;<i>     deferred.addCallback(State2)
</I>&gt;<i> 
</I>&gt;<i> def State2(...):
</I>&gt;<i>     # do something
</I>&gt;<i>     deferred = someFunctionThatReturnsADeferred()
</I>&gt;<i>     deferred.addCallback(State3)
</I>&gt;<i> 
</I>&gt;<i> def State3(someData):
</I>&gt;<i>     # do something
</I>&gt;<i>     if someData == 'State4':
</I>&gt;<i>        deferred = someFunctionThatReturnsADeferred()
</I>&gt;<i>        func = State4
</I>&gt;<i>     elif someData == 'State5':
</I>&gt;<i>        deferred = someOtherFunctionThatReturnsADeferred()
</I>&gt;<i>        func = State5
</I>&gt;<i>     ...
</I>&gt;<i>     deferred.addCallback(func)
</I>&gt;<i> 
</I>&gt;<i> if __name__ = &quot;__main__&quot;:
</I>&gt;<i>    initialize()
</I>&gt;<i>    reactor.run()
</I>&gt;<i> 
</I>&gt;<i> As for the Twisted loop. Well, you don't really see the Twisted loop
</I>&gt;<i> since that is hidden in the reactor. Also you should distinguish
</I>&gt;<i> between writing a new protocol and using an existing one.
</I>&gt;<i> 
</I>&gt;<i> In the case of XMLRPC, creating the server isn't the problem.
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://twistedmatrix.com/projects/web/documentation/howto/xmlrpc.html">http://twistedmatrix.com/projects/web/documentation/howto/xmlrpc.html</A>
</I>&gt;<i> 
</I>&gt;<i> Once a XMLRPC server is created, Twisted will take responsibility for
</I>&gt;<i> creating new instances (or threads if you want to see it that way). If
</I>&gt;<i> you still need a state machine, then the only hiccup I can see is
</I>&gt;<i> sharing  state machine (if you really need one) between XMLRPC method
</I>&gt;<i> invocations.
</I>&gt;<i> 
</I>&gt;<i> Cheers,
</I>&gt;<i> Andrew
</I>&gt;<i> 
</I>[Doug Farrell] Thank you very much for your detailed response, I'm kinda
getting it and am going to try out a prototype to make sure I do. As you
mention, Twisted does take care of a lot of the issues dealing with
concurrency. Having written a few threaded applications, I didn't really
want to get into starting my state machine in a thread and then having
to deal with all the cross thread data safety issues.

One thing I'm still a little confused by in your reply is how you're
getting the deferred instance. Is there a particular reason your example
does this:

deferred = someOtherFunctionThatReturnsADeferred()

rather than this:

deferred = defer.deferred()

I just want to understand if there a reason the deferred is being
created in the other function.

Again, thanks for your help and response!
Doug


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019411.html">[Twisted-Python] How to use defer.fail better...
</A></li>
	<LI>Next message: <A HREF="019409.html">[Twisted-Python] RE: how to create state machines?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19408">[ date ]</a>
              <a href="thread.html#19408">[ thread ]</a>
              <a href="subject.html#19408">[ subject ]</a>
              <a href="author.html#19408">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
