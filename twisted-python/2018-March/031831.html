<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Waiting for a contended resource
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Waiting%20for%20a%20contended%20resource&In-Reply-To=%3CetPan.5aa6d6a6.7a5ae51b.287d%40me.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="031830.html">
   <LINK REL="Next"  HREF="031832.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Waiting for a contended resource</H1>
    <B>L. Daniel Burr</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Waiting%20for%20a%20contended%20resource&In-Reply-To=%3CetPan.5aa6d6a6.7a5ae51b.287d%40me.com%3E"
       TITLE="[Twisted-Python] Waiting for a contended resource">ldanielburr at me.com
       </A><BR>
    <I>Mon Mar 12 13:36:06 MDT 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="031830.html">[Twisted-Python] Waiting for a contended resource
</A></li>
        <LI>Next message (by thread): <A HREF="031832.html">[Twisted-Python] Waiting for a contended resource
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31831">[ date ]</a>
              <a href="thread.html#31831">[ thread ]</a>
              <a href="subject.html#31831">[ subject ]</a>
              <a href="author.html#31831">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Richard,
On March 12, 2018 at 1:49:41 PM, Richard van der Hoff (<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">richard at matrix.org</A>) wrote:

Hi folks,

I thought I'd poll the list on the best way to approach a problem in 
Twisted.

The background is that we have a number of resources which can be 
requested by a REST client, and which are calculated on demand. The 
calculation is moderately expensive (can take multiple seconds), so the 
results of the calculation are cached so multiple lookups of the same 
resource are more efficient.

The problem comes in trying to handle multiple clients requesting the 
same resource at once. Obviously if 200 clients all request the same 
resource at the same time, we don't want to fire off 200 calculation 
requests.

The approach we adopted was, effectively, to maintain a lock for each 
resource:

&gt;<i> lock = defer.DeferredLock()
</I>&gt;<i> cached_result = None
</I>&gt;<i>
</I>&gt;<i> @defer.inlineCallbacks
</I>&gt;<i> def getResource():
</I>&gt;<i> yield lock.acquire()
</I>&gt;<i> try:
</I>&gt;<i> if cached_result is None:
</I>&gt;<i> cached_result = yield do_expensive_calculation()
</I>&gt;<i> defer.returnValue(cached_result)
</I>&gt;<i> finally:
</I>&gt;<i> lock.release()
</I>
(Of course one can optimise the above to avoid getting the lock if we 
already have the cached result - I've omitted that for simplicity.)

That's all very well, but it falls down when we get more than about 200 
requests for the same resource: once the calculation completes, we can 
suddenly serve all the requests, and the Deferreds returned by 
DeferredLock end up chaining together in a way that overflows the stack.

I reported this as <A HREF="http://twistedmatrix.com/trac/ticket/9304">http://twistedmatrix.com/trac/ticket/9304</A> and, at the 
time, worked around it by adding a call to reactor.callLater(0) into our 
implementation. However, Jean-Paul's comments on that bug implied that 
we were approaching the problem in completely the wrong way, and instead 
we should be avoiding queuing up work like this in the first place.


You mention using callLater to solve this problem, so I’m guessing that instead of using a lock you are re-scheduling the call to getResource if there is no cached_result value.  I’ve used this solution plenty of times across multiple projects, and have found it both simple and reliable.  Is there some reason why this solution is not desirable in your case?

It's worth reiterating that the requests arrive from REST clients which 
we have no direct control over. We *could* keep track of the number of 
waiting clients, and make the API respond with a 5xx error or similar if 
that number gets too high, with the expectation that the client retries 
- but one concern would be that the load from the additional HTTP 
traffic would outweigh any efficiency gained by not stacking up Deferreds.


Have you validated this concern through load-testing?  You may find that there is no meaningful negative impact to this approach.

So, I'd welcome any advice on better ways to approach the problem.

Richard
Hope this helps,

L. Daniel Burr
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20180312/d98197a3/attachment.html&gt;
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="031830.html">[Twisted-Python] Waiting for a contended resource
</A></li>
	<LI>Next message (by thread): <A HREF="031832.html">[Twisted-Python] Waiting for a contended resource
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31831">[ date ]</a>
              <a href="thread.html#31831">[ thread ]</a>
              <a href="subject.html#31831">[ subject ]</a>
              <a href="author.html#31831">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
