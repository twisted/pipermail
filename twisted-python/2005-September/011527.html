<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] twisted.vfs issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20twisted.vfs%20issues&In-Reply-To=433AF3B0.9040709%40thecablelounge.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011526.html">
   <LINK REL="Next"  HREF="011528.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] twisted.vfs issues</H1>
    <B>Jp Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20twisted.vfs%20issues&In-Reply-To=433AF3B0.9040709%40thecablelounge.com"
       TITLE="[Twisted-Python] twisted.vfs issues">exarkun at divmod.com
       </A><BR>
    <I>Wed Sep 28 20:04:24 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011526.html">[Twisted-Python] twisted.vfs issues
</A></li>
        <LI>Next message: <A HREF="011528.html">[Twisted-Python] twisted.vfs issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11527">[ date ]</a>
              <a href="thread.html#11527">[ thread ]</a>
              <a href="subject.html#11527">[ subject ]</a>
              <a href="author.html#11527">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 29 Sep 2005 05:49:04 +1000, Andy Gayton &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">andy at thecablelounge.com</A>&gt; wrote:
&gt;<i>James Y Knight wrote:
</I>&gt;&gt;<i>So, starting to look through twisted.vfs, I'm finding a few things  that 
</I>&gt;&gt;<i>need work.
</I>&gt;<i>
</I>&gt;<i>Hey James,
</I>&gt;<i>
</I>&gt;<i>Thanks for the feedback.  We need it.  Heaps of decisions for the vfs stuff 
</I>&gt;<i>have been put off to see what other use cases would need from the vfs. 
</I>&gt;<i>Inparticular permissions and metadata.
</I>
With that in mind.... ;)

&gt;&gt;<i>1) I see no way of reading from or writing to a file in 
</I>&gt;&gt;<i>ivfs.IFileSystemLeaf.
</I>&gt;<i>
</I>&gt;<i>The vfs stuff is still heavily influenced by the interface that conch 
</I>&gt;<i>expects as sftp has been the main motivation for the current contributors.
</I>&gt;<i>
</I>&gt;<i>Reading and writing is done through writeChunk and readChunk - we've always 
</I>&gt;<i>felt this wasn't quite right though for a general backend. But after two 
</I>&gt;<i>sprints we still haven't come up with something that is better.  Adding the 
</I>&gt;<i>web2.Stream adaptor seems to have glazed over the issue for protocols that 
</I>&gt;<i>read/writeChunk doesn't work for.  Spiv even used streams for the vfs ftp 
</I>&gt;<i>adaptor!
</I>
  twisted.vfs should not import things from or depend upon twisted.web2:

    * web2 is unreleased
    * web2's APIs are unstable
    * vfs is more generally applicable than web2 
    * web2's stream abstraction is not generally agreed upon

  If you like, we can talk more about how this interface should work.  However, my first inclination is to say that it should use the existing producer/consumer APIs.  While these are not the best APIs, they are used widely throughout Twisted, and therefore this will give the greatest usability to the resulting VFS code.  While there are adapters between these APIs and web2 streams, I still recommend against web2 streams for the reasons mentioned above.

&gt;<i>
</I>&gt;<i>I've added read/writeChunk to ivfs.IFileSystemLeaf's interface.
</I>
  I mentioned these in a separate email, so I won't repeat those points.

&gt;&gt;<i>2) createFile is racy -- it requires opening a file by the given  name, 
</I>&gt;&gt;<i>with default permissions, then immediately closing it.
</I>&gt;<i>
</I>&gt;:<i>), racy is good right?
</I>&gt;&gt;<i>In  addition, it doesn't specify whether it's an error if the file  already 
</I>&gt;&gt;<i>exists.
</I>&gt;<i>
</I>&gt;<i>It should, I've added this to the interface.
</I>&gt;&gt;<i>3) Looks like all operations are blocking? What about a remote vfs? I 
</I>&gt;&gt;<i>think every operation in the vfs interface ought to be non-blocking.
</I>&gt;<i>
</I>&gt;<i>The other option is the vfs interface could be maybe deferred.  Most 
</I>&gt;<i>protocols are good at handling this (sftp, streams).  But given how easy it 
</I>&gt;<i>is to return deferred.succeed - it's probably simpler to say always non- 
</I>&gt;<i>blocking.
</I>
  I assume you mean that they should always return a Deferred.  In this case, I agree.  maybeDeferred is intended as a convenience for application-level code.  Framework-level code can avoid introducing the need for it at the application-level by simply always using Deferreds.

&gt;&gt;<i>4) IFileSystemNode.remove doesn't say whether it's a recursive delete  (on 
</I>&gt;&gt;<i>a directory)
</I>&gt;<i>
</I>&gt;<i>Hrm yeah - should it?  Or should this be handled by higher level utilities 
</I>&gt;<i>(eg shutil).  The current os backend uses os.rmdir, so doesn't do a 
</I>&gt;<i>recursive delete.  I've updated the interface to say that it doesn't.
</I>&gt;&gt;<i>, and .rename don't specify whether newName can be in  a different 
</I>&gt;&gt;<i>directory, whether it replaces an existing file, or  whether it works on a 
</I>&gt;&gt;<i>directory.
</I>&gt;<i>
</I>&gt;<i>The method is against Node, so it works on directories.
</I>&gt;<i>
</I>&gt;<i>This is os.rename's spec:
</I>&gt;<i>
</I>&gt;<i>---
</I>&gt;<i>Rename the file or directory src to dst. If dst is a directory, OSError will 
</I>&gt;<i>be raised. On Unix, if dst exists and is a file, it will be removed silently 
</I>&gt;<i>if the user has permission. The operation may fail on some Unix flavors if 
</I>&gt;<i>src and dst are on different filesystems. If successful, the renaming will 
</I>&gt;<i>be an atomic operation (this is a POSIX requirement). On Windows, if dst 
</I>&gt;<i>already exists, OSError will be raised even if it is a file; there may be no 
</I>&gt;<i>way to implement an atomic rename when dst names an existing file. 
</I>&gt;<i>Availability: Macintosh, Unix, Windows.
</I>&gt;<i>---
</I>&gt;<i>
</I>&gt;<i>Should vfs be aiming to provide consistent behaviour for all operations 
</I>&gt;<i>across all backends?  Or should some behaviour be left down to the 
</I>&gt;<i>particular backend to decide?
</I>&gt;<i>
</I>&gt;<i>For the moment I've updated the interface to read:
</I>&gt;<i>
</I>&gt;<i>Renames this node to newName.  newName can be in a different directory.  If 
</I>&gt;<i>the destination is an existing directory, an error will be raised.
</I>
The semantics provided by vfs should be the same across all platforms and all backends.  Since os.rename's semantics vary between platforms, this probably eliminates it from (unaided) use in an implementation.  .rename() in VFS should work across filesystems, guarantee atomicity (if this is feasible - I think it is.  If not, it should explicitly deny atomicity), and have well-defined edge cases (for example, whether an exception is raised because the destination exists already should be defined one way or the other, and that's how it should always work).

&gt;&gt;<i>5) Errors are coarse-grained. Everything is a VFSError, and the only 
</I>&gt;&gt;<i>detailed information is in human-readable text, not any nice computer- 
</I>&gt;&gt;<i>readable form.
</I>&gt;<i>
</I>&gt;<i>yeah :( that needs to be fixed.
</I>&gt;&gt;<i>6) Need some support in the interface for extended attributes.
</I>&gt;<i>
</I>&gt;<i>There's getMetadata. That let's you return arbitrary attributes.
</I>&gt;<i>
</I>&gt;<i>Would that cover what you're thinking?
</I>&gt;<i>
</I>&gt;<i>Protocol's should try to get by with as little metadata as they can.  If a 
</I>&gt;<i>backend doesn't supply a bit of metadata a protocol must have, then it won't 
</I>&gt;<i>be able to be used with the protocol.
</I>&gt;<i>
</I>
There needs to be a convention for the format of this metadata.  Protocol implementations should not need to be familiar with the backend they are using, and different backends should provide the same metadata in the same way.  It may make sense to expand the example dictionary in getMetadata's docstring, and continue expanding it as new requirements are made (perhaps getMetadata's docstring isn't the best place for this information, either).  This still doesn't strike me as ideal, but it's better than nothing.

Going further, I'd like to see pathutils implemented in terms of twisted.python.filepath: there's a lot of code duplication between these two modules.

The code in twisted/vfs/adapters/dav.py is misplaced.  Itamar posted to this list about this issue a couple weeks ago, but I'll re-iterate.  Third-party package dependencies need to be considered carefully.  Most importantly, dependencies *must* not be cyclic.  Twisted cannot import from akadav, because akadav imports from Twisted.  If akadav can be used to provide VFS functionality, then the adapters to do so belong in akadav, or in some other package: not beneath the Python package &quot;twisted&quot;.

As I mentioned above, twisted/vfs/adapters/ftp.py and stream.py shouldn't be importing from twisted.web2.  Likewise, twisted/vfs/adapters/sftp.py's dependence on twisted.conch is backwards: twisted.conch should provide code which augments twisted.vfs.  These are both great candidates for use of the plugin system.  This also lets you take care of the nasty registration-requires-import issues, since gathering plugins will necessarily import the required modules, or if not, will provide a hook so that they can be imported at precisely the right time.

Some easy things: new code in Twisted should use new-style classes; modules should have `test-case-name' declarations; zope Interface's convention is to not include &quot;self&quot; in method declarations; &quot;type(x) is y&quot; is generally wrong - osfs.py uses it in getMode() - both because isinstance() should really be used, and because type checking generally indicates some weakness in an API (why might the mode be either a string or an integer?  pick one and require only that).

I hope this doesn't come off as too critical :)  I'm very much looking forward to the day when setting up a dav server against a purely virtual, dynamic filesystem is as easy as implementing a couple interfaces out of ivfs.py.

Jp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011526.html">[Twisted-Python] twisted.vfs issues
</A></li>
	<LI>Next message: <A HREF="011528.html">[Twisted-Python] twisted.vfs issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11527">[ date ]</a>
              <a href="thread.html#11527">[ thread ]</a>
              <a href="subject.html#11527">[ subject ]</a>
              <a href="author.html#11527">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
