<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Guidance needed on serial device interaction
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Guidance%20needed%20on%20serial%20device%20interaction&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023474.html">
   <LINK REL="Next"  HREF="023481.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Guidance needed on serial device interaction</H1>
    <B>Jason Heeris</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Guidance%20needed%20on%20serial%20device%20interaction&In-Reply-To="
       TITLE="[Twisted-Python] Guidance needed on serial device interaction">jason.heeris at gmail.com
       </A><BR>
    <I>Wed Feb  2 01:36:55 EST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="023474.html">[Twisted-Python] Fingering Finger
</A></li>
        <LI>Next message: <A HREF="023481.html">[Twisted-Python] Guidance needed on serial device interaction
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23479">[ date ]</a>
              <a href="thread.html#23479">[ thread ]</a>
              <a href="subject.html#23479">[ subject ]</a>
              <a href="author.html#23479">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a bit long, sorry...

I have a PyGTK program that uses threads and pyserial's blocking
methods to interact with an RS232 connected device. I'd like to throw
out the threading awfulness and redo it in Twisted, if possible, but
I'm a little lost.

The real protocol is a bit convoluted, but basically:
  - You can issue single character commands to the device that give a fixed
    length response, such as sending 'C' and getting an eight-digit hex
    string back (the program flash CRC)
  - You can put the device into &quot;programming mode&quot; (command 'P'), where it
    takes an arbitrary length sequence of records, verifying each record and
    stopping when it sees the special &quot;end record&quot;
  - The device will send back '!' to indicate an error
  - The device will send back '&gt;' to indicate that it's ready for more
    commands

I know I need to use the SerialPort transport, and since that takes a
protocol I've tried to sketch one out but can't seem to get very far.

I want to have methods that can be called from the UI, returning
deferreds to which UI responses can be added as callbacks. I also want
to be able to monitor progress of the programming, so I need a
callback for that separate from the deferred itself. I figure that
calling, say, device.program(program, progress_cb) should return a
Deferred and queue the command, and that somehow the dataReceived()
method should be the start of a chain of events that either:
  - updates state and waits for the next piece of data, or
  - calls back on the appropriate Deferred

I'd also like to structure things so that successive calls to the
DeviceProtocol object queue up, something like:

----
class DeviceProtocol(Protocol):

    def dataReceived(self, data):
        # ...?

    def checksum(self):
        res = defer.Deferred()
        # When ready, send 'C' over the serial line (ie.
        # self.transport.write('C'))
        # Somehow callback via a deferred when the checksum comes back
        return res

    def program(self, program_records, progress_cb):
        res = defer.Deferred()
        # When ready, send 'P' over the serial line
        # Write all the data in &quot;program_records&quot;, checking each
        # response, calling back via a deferred when done.
        # ...
        return res

    def connectionLost(self):
        # maybe have something here, like calling the errback of all
        # pending deferreds

def go(reactor):
    # callbacks/errbacks not shown

    device = DeviceProtocol()
    transport = SerialPort(device, portname, reactor)

    program_result_1 = device.program(records, good_programming_progress)
    program_result_1.addCallbacks(programming_done, programming_err)

    checksum_result = device.checksum()
    checksum_result.addCallbacks(checksum, checksum_err)

    # This will fail at some point:
    program_result_2 = device.program(bad_records)
    cp_deferred.addCallbacks(programming_done, programming_err)

if __name__ == &quot;__main__&quot;:
    reactor.callWhenRunning(go, reactor)
    reactor.run()
----

But I'm really lost as to how to start structuring things within the
protocol object itself. Should I even be doing this in a Protocol
subclass, or should I be putting some of this functionality into a
Factory of some sort (eg. a ClientFactory)? And if so, how do I
actually connect the factory to the serial port transport? Or am I on
the wrong track altogether?

More to the point, has a problem like this already been solved
somewhere? Is the solution obvious to Twisted gurus?

Any help would be appreciated.

Cheers,
Jason

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023474.html">[Twisted-Python] Fingering Finger
</A></li>
	<LI>Next message: <A HREF="023481.html">[Twisted-Python] Guidance needed on serial device interaction
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23479">[ date ]</a>
              <a href="thread.html#23479">[ thread ]</a>
              <a href="subject.html#23479">[ subject ]</a>
              <a href="author.html#23479">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
