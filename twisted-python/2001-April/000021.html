<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] config interface
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20config%20interface&In-Reply-To=20010408210402.A325%40Fookidla.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000020.html">
   <LINK REL="Next"  HREF="000022.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] config interface</H1>
    <B>Glyph Lefkowitz</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20config%20interface&In-Reply-To=20010408210402.A325%40Fookidla.org"
       TITLE="[Twisted-Python] config interface">glyph at twistedmatrix.com
       </A><BR>
    <I>Wed Apr 11 07:31:32 EDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000020.html">[Twisted-Python] config interface
</A></li>
        <LI>Next message: <A HREF="000022.html">[Twisted-Python] config interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21">[ date ]</a>
              <a href="thread.html#21">[ thread ]</a>
              <a href="subject.html#21">[ subject ]</a>
              <a href="author.html#21">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sunday 08 April 2001 20:04, you wrote:
&gt;<i> configurable objects are organized in a tree. Every object defines these
</I>&gt;<i> methods:
</I>
&gt;<i>     #ContainableTypes should return a list of classes that
</I>&gt;<i>     #it can hold.
</I>&gt;<i>     def configContainableTypes(self): pass
</I>
This seems fine...

&gt;<i>     #Type should return the type of the current object
</I>&gt;<i>     def configType(self): pass
</I>
I don't think this is necessary though.  Can't you just use the Python class?

&gt;<i>     #GetContents should return a dict of children of this object. {&quot;name&quot;:
</I>&gt;<i> obj} def configGetChildren(self): pass
</I>
Seems like a list of tuples (.items() style) might be more appropriate than a 
dict, considering that this really isn't mutable.

&gt;<i>     #AddItem should add a child to this object
</I>&gt;<i>     def configAddItem(self, id, item): pass
</I>
Also fine...

&gt;<i>     #RemoveItem should remove a child from this object.
</I>&gt;<i>     def configRemoveItem(self, id): pass
</I>
&gt;<i> I'd like to change this API somewhat to allow different paramaters to add
</I>&gt;<i> and remove item methods. Not all objects need ids to add an object, and
</I>&gt;<i> it's not natural for some objects to represent their contents as a dict
</I>&gt;<i> (selectors, for instance). I was thinking about a solution similar to the
</I>&gt;<i> improper-state trick that glyph described to me, only it would just look at
</I>&gt;<i> the arguments that a method needs rather than a constructor of a class.
</I>
That trick is a necessary addition to the API in any case -- these functions 
aren't enough.  However, you might want to have ConfigurableDictionary, 
ConfigurableItem, and ConfigurableSequence types which have different ideas 
about how things get added to them.


In order for new configurable things to be instantiatable, you'll need API 
additions like:

def configGetRequiredInitArgs(self)

This returns a 2-tuple of a sequence and a hash.  The first sequence is a 
list of types/classes of the required arguments, in order, and the second is 
a hash of name:type/class of optional argument.

These arguments get filled in by your configuration interface code, and 
passed to:

def configCheckInitArgs(self, args, kw)

This to separate preconditions of the init from the init itself -- if this 
indicates there's something wrong with the arguments (for example, an integer 
is outside of its acceptable range) then this message can be displayed to the 
user for them to try again.

def configDoInit(self, args, kw)

This will most likely be a passthru to self.__init__, probably frequently 
enough to make that the default implementation, but since 
configGetRequiredInitArgs may want to do some pre-initialization, things 
could be different.


Note that if something returned by configGetRequiredInitArgs is a class, that 
class be configurable as well -- that, and your interface may need to be 
somewhat recursive in order to allow you to pass configurable elements to the 
initializers of other configurable elements... I'd recommend trying to get 
something work only supporting basic types at first.

Also, what are you planning on doing for configuring an object's attributes?  
It seems like that should behave differently from configuring the objects it 
contains.


-- 
                      ______      __   __  _____  _     _
                     |  ____ |      \_/   |_____] |_____|
                     |_____| |_____  |    |       |     |
                     @ t w i s t e d m a t r i x  . c o m
                     <A HREF="http://twistedmatrix.com/users/glyph">http://twistedmatrix.com/users/glyph</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000020.html">[Twisted-Python] config interface
</A></li>
	<LI>Next message: <A HREF="000022.html">[Twisted-Python] config interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21">[ date ]</a>
              <a href="thread.html#21">[ thread ]</a>
              <a href="subject.html#21">[ subject ]</a>
              <a href="author.html#21">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
