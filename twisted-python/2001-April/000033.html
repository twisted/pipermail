<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] First Port to twisted.protocols
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20First%20Port%20to%20twisted.protocols&In-Reply-To=E14pXnh-0002x3-00%40darjeeling">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000032.html">
   <LINK REL="Next"  HREF="000034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] First Port to twisted.protocols</H1>
    <B>Moshe Zadka</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20First%20Port%20to%20twisted.protocols&In-Reply-To=E14pXnh-0002x3-00%40darjeeling"
       TITLE="[Twisted-Python] First Port to twisted.protocols">moshez at zadka.site.co.il
       </A><BR>
    <I>Tue Apr 17 14:58:38 EDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000032.html">[Twisted-Python] First Port to twisted.protocols
</A></li>
        <LI>Next message: <A HREF="000034.html">[Twisted-Python] First Port to twisted.protocols
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33">[ date ]</a>
              <a href="thread.html#33">[ thread ]</a>
              <a href="subject.html#33">[ subject ]</a>
              <a href="author.html#33">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, 17 Apr 2001 18:53:57 +0300, Moshe Zadka &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">moshez at zadka.site.co.il</A>&gt; wrote:
 
&gt;<i> &gt; I'll check in the protocols stuff later today.
</I>&gt;<i> 
</I>&gt;<i> As promised, I've check it in.
</I>
And now I've fixed a little bug in twisted.protocols.http
The HTTP server code now works fine.

&gt;<i> &gt; And....as a special surprise, I've ported twisted.web over to stop
</I>&gt;<i> &gt; knowing so much HTTP. HTTP knowledge used to be smeared all over
</I>&gt;<i> &gt; Request and HTTPHandler, and now neither of them knows much HTTP.
</I>&gt;<i> 
</I>&gt;<i> I'm working on integrating and testing my web.py port.
</I>
Here's a first rough patch to do that:

Please do *not* apply it -- I've got some ideas about improving the
HTTP handlers to make it even smoother.

Stay tuned!

Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.81
diff -c -r1.81 web.py
*** twisted/web.py	2001/04/12 17:32:14	1.81
--- twisted/web.py	2001/04/17 18:59:16
***************
*** 29,34 ****
--- 29,36 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ import twisted.protocols.http
+ from twisted import protocols
  
  # Useful constants
  
***************
*** 238,280 ****
              else:
                  return name
  
!     def __init__(self, blob):
          # parse the blob
          # ...
          split = string.split
          find = string.find
          lower = string.lower
  
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
          received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         reqfields = split(reqstring, ' ')
! 
!         assert 2 &lt;= len(reqfields) &lt;=3, &quot;Invalid request format.&quot;
! 
!         self.method, self.uri = reqfields[0], reqfields[1]
! 
!         if len(reqfields) == 2:
!             # we are dealing with HTTP/0.9
!             self.clientproto = &quot;HTTP/0.9&quot;
!         else:
!             self.clientproto = reqfields[2]
! 
!         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = urllib.unquote(self.uri)
          else:
              if len(x) != 2:
                  print &quot;May ignore parts of this invalid URI:&quot;,repr(self.uri)
!             self.path, argstring = urllib.unquote(x[0]), x[1]
              for kvp in split(argstring,'&amp;'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
--- 240,270 ----
              else:
                  return name
  
!     def __init__(self, method, uri, version, blob):
          # parse the blob
          # ...
          split = string.split
          find = string.find
          lower = string.lower
  
!         blobf = StringIO.StringIO(blob)
          received = self.received = {}
          args = self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri, self.clientproto = method, uri, version
!         self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
!             self.path = self.uri
          else:
              if len(x) != 2:
                  print &quot;May ignore parts of this invalid URI:&quot;,repr(self.uri)
!             self.path, argstring = x[0], x[1]
              for kvp in split(argstring,'&amp;'):
!                 keyval = split(kvp, '=')
                  if len(keyval)==2:
                      key, value = keyval
                      if args.has_key(key):
***************
*** 282,304 ****
                      else:
                          args[key] = [value]
  
!         for header in blobs:
              x = find(header,&quot;:&quot;)
              if x != -1:
                  received[lower(header[:x])] = header[x+2:]
              else:
                  print 'Invalid HTTP/1.1 protocol message?'
                  print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '&lt;%s %s %s&gt;'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
--- 272,292 ----
                      else:
                          args[key] = [value]
  
!         while 1:
!             header = blobf.readline()
!             if header == '\n':
!                 break
              x = find(header,&quot;:&quot;)
              if x != -1:
                  received[lower(header[:x])] = header[x+2:]
              else:
                  print 'Invalid HTTP/1.1 protocol message?'
                  print header
!         self.content = blobf.read()
  
      def __repr__(self):
          return '&lt;%s %s %s&gt;'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
      def process(self, server):
***************
*** 370,387 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          &quot;&quot;&quot;
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != &quot;HTTP/0.9&quot;:
                  message = HTTP.responses.get(self.code, &quot;Unknown Status&quot;)
!                 self.write(&quot;%s %s %s\r\n&quot; % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write(&quot;%s: %s\r\n&quot; % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
--- 358,372 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          &quot;&quot;&quot;
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != &quot;HTTP/0.9&quot;:
                  message = HTTP.responses.get(self.code, &quot;Unknown Status&quot;)
!                 self.handler.sendStatus(self.code, message)
!                 for header, value in self.headers.items():
!                     self.handler.sendHeader(header, value)
!                 self.handler.endHeaders
!         self.handler.write(data)
  
      def finish(self):
          self.handler.stopConsuming()
***************
*** 1386,1441 ****
              return page
  
  
! class HTTPHandler(net.GenericHandler):
!     contentLength = 0
!     request = None
!     recvd = &quot;&quot;
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def _process(self, request):
!         &quot;&quot;&quot; (private) &quot;&quot;&quot;
!         request.handler = self
!         request.process(self.server)
! 
!     def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend &lt; 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
-         if self.contentLength:
-             if len(self.recvd) &gt;= self.contentLength:
-                 self.request.content = recvd[:self.contentLength]
-                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1371,1387 ----
              return page
  
  
! class HTTPHandler(net.GenericHandler, protocols.http.HTTPHandler):
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
!     def handleRequest(self, command, selector, version, request):
!         self.request = Request(command, selector, version, request)
!         self.request.handler = self
!         self.request.process(self.server)
  
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
************************************************************



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000032.html">[Twisted-Python] First Port to twisted.protocols
</A></li>
	<LI>Next message: <A HREF="000034.html">[Twisted-Python] First Port to twisted.protocols
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33">[ date ]</a>
              <a href="thread.html#33">[ thread ]</a>
              <a href="subject.html#33">[ subject ]</a>
              <a href="author.html#33">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
