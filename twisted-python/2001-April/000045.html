<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] twisted.web uses twisted.protocols
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20twisted.web%20uses%20twisted.protocols&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000041.html">
   <LINK REL="Next"  HREF="000046.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] twisted.web uses twisted.protocols</H1>
    <B>Moshe Zadka</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20twisted.web%20uses%20twisted.protocols&In-Reply-To="
       TITLE="[Twisted-Python] twisted.web uses twisted.protocols">moshez at zadka.site.co.il
       </A><BR>
    <I>Mon Apr 30 00:57:45 EDT 2001</I>
    <P><UL>
        <LI>Previous message: <A HREF="000041.html">[Twisted-Python] Twisted.Web memory usage, and other things
</A></li>
        <LI>Next message: <A HREF="000046.html">[Twisted-Python] twisted.web split
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Well, not the official version, but here's a patch:


Index: twisted/web.py
===================================================================
RCS file: /cvs/TwistedPython/twisted/web.py,v
retrieving revision 1.82
diff -c -r1.82 web.py
*** twisted/web.py	2001/04/27 13:27:37	1.82
--- twisted/web.py	2001/04/30 04:56:59
***************
*** 29,34 ****
--- 29,35 ----
  from twisted import reflect
  from twisted import gloop
  from twisted import copyright
+ from twisted.protocols import http
  
  # Useful constants
  
***************
*** 206,219 ****
  
  
  
! class Request:
!     &quot;&quot;&quot;web.Request(blob)
  
-     This defines HTTP request.  'blob' is a list of lines that
-     represent the request to parse.
-     &quot;&quot;&quot;
- 
-     content = None
      code = HTTP.OK
  
      # HTML generation helpers
--- 207,214 ----
  
  
  
! class Request(http.HTTPRequestHandler):
  
      code = HTTP.OK
  
      # HTML generation helpers
***************
*** 238,270 ****
              else:
                  return name
  
!     def __init__(self, blob):
!         # parse the blob
!         # ...
!         split = string.split
!         find = string.find
!         lower = string.lower
! 
!         blobs = split(blob, '\r\n')
!         reqstring = blobs.pop(0)
!         received = self.received = {}
!         args = self.args = {}
          self.stack = []
          self.headers = {}
- 
-         reqfields = split(reqstring, ' ')
  
!         assert 2 &lt;= len(reqfields) &lt;=3, &quot;Invalid request format.&quot;
  
-         self.method, self.uri = reqfields[0], reqfields[1]
- 
-         if len(reqfields) == 2:
-             # we are dealing with HTTP/0.9
-             self.clientproto = &quot;HTTP/0.9&quot;
-         else:
-             self.clientproto = reqfields[2]
- 
-         ###self.uri = urllib.unquote(self.uri)
          x = split(self.uri,'?')
  
          if len(x) == 1:
--- 233,257 ----
              else:
                  return name
  
!     def _parse_argstring(self, argstring, split=string.split):
!         for kvp in split(argstring, '&amp;'):
!             keyval = map(urllib.unquote, split(kvp, '='))
!             if len(keyval) != 2:
!                 continue
!             arg = self.args[key] = self.args.get(key, [])
!             arg.append(value)
! 
!     def handleRequest(self, command, selector, version, headers, content):
!         from string import split
!         self.received = headers
!         self.args = {}
          self.stack = []
          self.headers = {}
  
!         self.method, self.uri = command, selector
!         self.clientproto = version
!         self.content = content
  
          x = split(self.uri,'?')
  
          if len(x) == 1:
***************
*** 273,311 ****
              if len(x) != 2:
                  print &quot;May ignore parts of this invalid URI:&quot;,repr(self.uri)
              self.path, argstring = urllib.unquote(x[0]), x[1]
!             for kvp in split(argstring,'&amp;'):
!                 keyval = map(urllib.unquote, split(kvp, '='))
!                 if len(keyval)==2:
!                     key, value = keyval
!                     if args.has_key(key):
!                         args[key].append(value)
!                     else:
!                         args[key] = [value]
  
!         for header in blobs:
!             x = find(header,&quot;:&quot;)
!             if x != -1:
!                 received[lower(header[:x])] = header[x+2:]
!             else:
!                 print 'Invalid HTTP/1.1 protocol message?'
!                 print header
!         try:
!             self.requiredContent = int(received['content-length'])
!         except:
!             self.requiredContent = 0
  
      def __repr__(self):
          return '&lt;%s %s %s&gt;'% (self.method, self.uri, self.clientproto)
  
- 
- 
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
!     def process(self, server):
          &quot;Process a request.&quot;
          # Log the request to a file.
          print self
!         self.setHeader('server', Server.version)
          self.setHeader('date', date_time_string())
          self.setHeader('content-type', &quot;text/html&quot;)
          self.setHeader('connection', 'close')
--- 260,279 ----
              if len(x) != 2:
                  print &quot;May ignore parts of this invalid URI:&quot;,repr(self.uri)
              self.path, argstring = urllib.unquote(x[0]), x[1]
!             self._parse_args(argstring)
  
!         self.process()
  
      def __repr__(self):
          return '&lt;%s %s %s&gt;'% (self.method, self.uri, self.clientproto)
  
      _host = socket.gethostbyaddr(socket.gethostname())[0]
  
!     def process(self):
          &quot;Process a request.&quot;
          # Log the request to a file.
          print self
!         self.setHeader('server', self.server.version)
          self.setHeader('date', date_time_string())
          self.setHeader('content-type', &quot;text/html&quot;)
          self.setHeader('connection', 'close')
***************
*** 327,336 ****
                      raise 'bad content-type'
  
              # Resource Identification
!             self.server = server
!             self.selector = server.selector
!             self.server_port = server.port
!             resource = server.resource(self)
              body = resource.render(self)
              if body == NOT_DONE_YET:
                  return
--- 295,303 ----
                      raise 'bad content-type'
  
              # Resource Identification
!             self.selector = self.handler.server.selector
!             self.server_port = self.handler.server.port
!             resource = self.handler.server.resource(self)
              body = resource.render(self)
              if body == NOT_DONE_YET:
                  return
***************
*** 371,392 ****
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          &quot;&quot;&quot;
!         if self.startedWriting:
!             self.handler.write(data)
!         else:
              self.startedWriting = 1
              if self.clientproto != &quot;HTTP/0.9&quot;:
                  message = HTTP.responses.get(self.code, &quot;Unknown Status&quot;)
!                 self.write(&quot;%s %s %s\r\n&quot; % (HTTP.protocol_version,
!                                              str(self.code), message) )
!                 for header in self.headers.items():
!                     self.write(&quot;%s: %s\r\n&quot; % header)
!                 self.write('\r\n')
!             self.write(data)
  
      def finish(self):
!         self.handler.stopConsuming()
!         del self.handler
  
      def setHeader(self, k, v):
          self.headers[string.lower(k)] = v
--- 338,355 ----
          Write some data as a result of an HTTP request.  The first
          time this is called, it writes out response data.
          &quot;&quot;&quot;
!         if not self.startedWriting:
              self.startedWriting = 1
              if self.clientproto != &quot;HTTP/0.9&quot;:
                  message = HTTP.responses.get(self.code, &quot;Unknown Status&quot;)
!                 self.sendStatus(self.code, message)
!                 for name, value in self.headers.items():
!                     self.sendHeader(name, value)
!                 self.endHeaders()
!         self.handler.write(data)
  
      def finish(self):
!         self.handler.close()
  
      def setHeader(self, k, v):
          self.headers[string.lower(k)] = v
***************
*** 1393,1447 ****
  
  
  class HTTPHandler(net.GenericHandler):
!     contentLength = 0
      request = None
-     recvd = &quot;&quot;
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
-     def _process(self, request):
-         &quot;&quot;&quot; (private) &quot;&quot;&quot;
-         request.handler = self
-         request.process(self.server)
- 
      def handleData(self, data):
!         recvd = self.recvd = self.recvd + data
!         if not self.request:
!             # HTTP/0.9 special handling.
!             firstend = string.find(recvd, '\r\n')
!             reqend = -1
!             if firstend != -1:
!                 first = recvd[:firstend]
!                 spaces = string.count(first, ' ')
!                 if spaces == 1:
!                     # we are HTTP/0.9
!                     reqend = firstend
! 
!             if reqend &lt; 0:
!                 # we didn't encounter 0.9, so proceed normally.
!                 reqend = string.find(recvd, '\r\n\r\n')
! 
!             if reqend != -1:
!                 reqdata = recvd[:reqend]
!                 self.recvd = recvd = recvd[reqend+4:]
! 
!                 request = Request(reqdata)
!                 request.client = self.client
!                 request.handler = self
!                 cl = request.requiredContent
!                 if cl:
!                     self.contentLength = cl
!                     self.request = request
!                 else:
!                     self._process(request)
!                     return
  
!         if self.contentLength:
!             if len(self.recvd) &gt;= self.contentLength:
!                 self.request.content = recvd[:self.contentLength]
!                 self._process(self.request)
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler
--- 1356,1376 ----
  
  
  class HTTPHandler(net.GenericHandler):
! 
      request = None
  
      def connectionLost(self, reason):
          self.request = None
          net.GenericHandler.connectionLost(self, reason)
  
      def handleData(self, data):
!         if self.request is None:
!             self.request = Request(self)
!             self.request.server = self.server
!         self.request.handleData(data)
  
!     def close(self):
!         self.loseConnection()
  
  class Server(net.GenericServer, authenticator.SessionManager, config.Configurable):
      handler = HTTPHandler



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000041.html">[Twisted-Python] Twisted.Web memory usage, and other things
</A></li>
	<LI>Next message: <A HREF="000046.html">[Twisted-Python] twisted.web split
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
