<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: [Twisted-web] CPUShare-Twisted
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20%5BTwisted-web%5D%20CPUShare-Twisted&In-Reply-To=%3C20060122095912.2697.1307843016.divmod.quotient.768%40ohm%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="044919.html">
   <LINK REL="Next"  HREF="044911.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: [Twisted-web] CPUShare-Twisted</H1>
    <B>glyph at divmod.com</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20%5BTwisted-web%5D%20CPUShare-Twisted&In-Reply-To=%3C20060122095912.2697.1307843016.divmod.quotient.768%40ohm%3E"
       TITLE="[Twisted-Python] Re: [Twisted-web] CPUShare-Twisted">glyph at divmod.com
       </A><BR>
    <I>Sun Jan 22 02:59:12 MST 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="044919.html">[Twisted-Python] Bugfixes and tests [was: CPUShare-Twisted]
</A></li>
        <LI>Next message (by thread): <A HREF="044911.html">[Twisted-Python] Re: [Twisted-web] CPUShare-Twisted
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44910">[ date ]</a>
              <a href="thread.html#44910">[ thread ]</a>
              <a href="subject.html#44910">[ subject ]</a>
              <a href="author.html#44910">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, 22 Jan 2006 07:52:18 +0100, Andrea Arcangeli &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">andrea at cpushare.com</A>&gt; wrote:
&gt;<i>On Sat, Jan 21, 2006 at 11:55:44PM -0500, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">glyph at divmod.com</A> wrote:
</I>&gt;&gt;<i> If you've pending patches that have not been applied, would you please
</I>&gt;&gt;<i> consider instead to agitate for those patches on the mailing lists, and add
</I>&gt;<i>
</I>&gt;<i>These are the very old ones (ignore the web2 part that is recent).
</I>&gt;<i>
</I>&gt;<i><A HREF="http://www.cpushare.com/hg/Twisted/?cs=400da64bd5a6">http://www.cpushare.com/hg/Twisted/?cs=400da64bd5a6</A>
</I>
&gt;<i>IIRC you said that (some stuff)
</I>
I'm sorry I was unclear, and you typed all that stuff to no effect.  Discussions that draw attention to unapplied patches should really refer to bug URLs in the tracker.

If they don't, nobody can tell how long the patches have been languishing, who was supposed to apply them, or why they weren't applied, unless there are links to dozens of previous mailing list messages in each post.  Also, summaries of these discussions should be attached to the ticket by the reporter or the maintainer, if they advance the issue at all.  Overall, without some support from the tracker, we just don't know whether the issues are really stuck on a serious problem, or whether someone has just become confused about what is required to make progress on the bug.

Even the absence of information on a bug can be useful.  &quot;Why hasn't anybody replied to this for 6 months?  Was there some discussion on IRC?&quot; can lead someone to post a helpful summary of current status if they have a recollection of where it did end up... sometimes, the bugs have even been fixed, and nobody has noted that fact.

&gt;<i>Sure I understand (twisted devs will work from bugtracker)
</I>
Thank you.

&gt;<i>My developmnt is generally test-driven.
</I>
Maybe, but it sure doesn't sound like it.  If your development is test-driven that means you are used to writing unit-tests *first*, not hacking in a fix and testing *later*, which is what you have repeatedly suggested.  &quot;TDD&quot; is not the same thing as &quot;unit testing&quot;.

FWIW Twisted does not require TDD.  I do not personally do TDD much of the time.  I think tests need to be added before a feature is added, but I don't always have a clear enough picture of what the code will look like to write tests, before I've tried to write the code.

&gt;<i>I'm only opposed to unit-test
</I>&gt;<i>mandatory development to fix bugs or add new features. Writing unit-test
</I>&gt;<i>isn't the only way to test code. It's nice to have a unit test, even a
</I>&gt;<i>simple one, but it shouldn't be mandatory.
</I>
Hmm.  &quot;Unit Test Mandatory Development&quot; - UTMD.  That sounds like a good acronym.  I think I will use it in the future.

One productive use of this set of threads is that I've repeated our testing policy - UTMD - in a few different ways.  I'm not sure that I can explain it to you (you seem to have some resistance to understanding) but maybe this will be useful to others.

Whether unit tests *should* be required is a discussion that requires some kind of value system.  What's good, what's bad, etc.  Right now unit testing *is* required.  There is a reason.  Unit testing is not the objective here, rather, requiring unit tests provides a mechanism to satisfy a greater requirement.  If you can suggest a better way to achieve that requirement then perhaps we can discuss other strategies.

Twisted is used by lots of different people in lots of different ways.  Before test requirements were adopted, it was quite common for a developer who fixed a bug in one system on one platform broke another system on another platform.  We are trying to improve Twisted, and such changes are not improvements.  Such changes simply muddle around the set of places and times where Twisted works correctly, they don't enlarge it.

Conceptually this makes sense.  Software is extremely complex, etc.  If you want to fix a bug, you need a way to verify that it doesn't introduce a new bug, or at least a way to verify that *previously*-verified behavior is still working as expected, in previously-verified environments.

That is the goal that unit tests serve.  Without unit tests, *we do not know* whether a particular change will continue to work in the face of future changes, or if it broke past changes.  We can reason about the breakage on past changes, at least, but to think that we can actually understand the impact of the patch on a system the size of even something modest like Twisted is hubris.  Every software project has embarrassing releases that break obvious frequently-used functionality - even projects with *better* testing track-records than Twisted has.  I believe Linus coined the term &quot;brown paper release&quot;, for the brown paper bag you have to wear on your head to prevent being recognized after such an event.

However, we can't even attempt to reason about future changes, because we can't possibly consider them when reviewing a current change.  Is it likely that other things might break this later?  How could we possibly know, without a way to accurately predict the future?

Consider that different people review different patches to Twisted at different times, and they have different skill levels.  I have written and read a LOT of Twisted code, and I doubt that even I understand 90% of it.  This partial ignorance makes reviewing past changes a lot like reviewing future changes - a change might break something in a Twisted subsystem the reviewer didn't even know about.

Of course, unit tests are imperfect too; we don't have 100% coverage, and even if we did, we wouldn't have 100% coverage in combination.  Still, they are the best option that we know about.

Can you suggest an alternative to unit tests that would accomplish this goal of providing some level of knowledge as to whether Twisted is probably improving or just changing randomly between releases?

Here are some objections which don't really address the question, just so I can head these off before they are asked.  Andrea - some of these are quite silly and I don't mean to imply that you are necessarily going to ask all of these questions, but I am now writing this for a general audience, and these *are* questions others have asked me.

&quot;but, my changes are so simple, what could they break&quot;

There is a story about a butterfly and a hurricaine that you need to read.  Simple changes can have complex effects that break things horribly.

&quot;not EVERYTHING in Twisted has to be tested.  some easy stuff could break, it's not likely since it doesn't change too often, and you could just do another release&quot;

This leads to a game of whack-a-mole.  One bug pops up, you smash it down.  That makes another bug pop up.  You smash it down.  The whole time, you feel like you are being very productive, because you are fixing all these bugs! Really though, you're just making the same two motions over and over again between different releases.  'back and forth' is an oversimplification, of course.  In reality the cycle probably takes hundreds of releases and goes through dozens of features in various combinations.  Nevertheless, things get fixed, and other things break.

&quot;you can just test it manually&quot;

No, you can't.  There is a HUGE combinatorial explosion of work involved - did you test it with every revision?  Did you test it on Windows?  Did you test it on a slow machine?  Did you test it with Python2.3?  Did you test it with Python 2.3 - on Windows?  Did you test the OTHER thing with Python 2.3 on Windows?  Did you test the other thing with Python 2.4 on Windows?  What about FreeBSD?  What about QNX?  What about AIX?!??!?  What about Linux 2.4?

Right now this matrix has over 20,000 units of work in it, just based on the current buildbots and the tests they're supposed to be running (and as you can see on the buildbot page, we are still trying to get the EXISTING features into shape, it is no wonder we don't want to rush to accept new ones quickly).

Every unit test that is added does the work of manual testing on 9 configurations on 4 platforms every time someone does a commit, which is several times a day.  Do the math.  Even replicating our *current* automated testing with a manual replacement would take something like a million dollars a week in tester salaries, if we were to pay them.  Open source does produce some really good free labor, but not NEARLY that much, and Twisted is a small project besides.

&quot;other projects release untested code, why can't you&quot;

Didn't your mother ever tell you &quot;If Billy jumped off a bridge, would you jump off a bridge too?&quot;  (Wait, am I being &quot;Mommist&quot; now? ;-))

&quot;Some projects separate testing from development, such as the LTP&quot;

Forgetting any flames about Linux's stability for a moment (let's be fair: for such a large piece of software that changes so fast, it's amazingly robust), this is the brute force approach.

LTP is sponsored by IBM and SGI.  It is a HUGE project - at one point, I visited the LTP booth at LinuxWorld.  Twisted does not have a booth at any conference.  Just the test project on linux has ten times as many people as Twisted.  With fewer resources, we have to have a better strategy, otherwise we will not find any bugs.  And by the way, even with all that testing that the LTP does, sometimes Twisted finds even regressions in Linux, remember? :)

&gt;&gt;<i> [..] I am sure that it will be full of bugs.
</I>&gt;<i>
</I>&gt;<i>Time will tell.
</I>
Code that has passing tests almost by definition has fewer bugs than code which does not have passing tests.  At the very least, it has more bugs in an unresolved quantum state, because you haven't observed them - so the probability of actual bugs is higher.

They whole point of this fork is that you want to put more bugs in and don't want to take the effort to verify that they won't be introduced.  I am not making a prediction about your skill, I am making an observation on the nature of the project.

&gt;<i>Since you made your prediction I'll make mine. I'm sure
</I>&gt;<i>axiom is wasted time in its current API (at least as far as twisted is
</I>&gt;<i>concerned).
</I>
Axiom was developed for a specific application.  It is not appropriate for everyone.  Some people like it, some people don't.  The ones who like it can go ahead and use it.

&gt;<i>I don't see how you can advertize axiom saying &quot;We do plan to add some
</I>&gt;<i>later, and perhaps also support other databases in the future.&quot;.
</I>
&gt;<i>Sure you can add it, but if you do it, the whole axiom api will fall apart
</I>&gt;<i>unless you want to make synchronous queries over the network. The only
</I>&gt;<i>two deferreds you have are during startup and in the testsuite, just
</I>&gt;<i>grep for the word Deferred.
</I>
I think you mean we are going to add more Deferreds later?  There will be a different operational mode for 'transact' which returns a Deferred; the exact spelling hasn't been determined yet, but surely the semantics for that mode will be different and it will not work with all existing axiom code.  (Of course, existing axiom code will not invoke that mode, so it will continue to work side-by-side code which does use it happily enough.)

&gt;<i>Making synchronous sql queries in the
</I>&gt;<i>twisted async model is unacceptable for anything serious.
</I>
Everyone is welcome to think that Axiom is not very serious.  I am not a serious person.  Twisted, in fact, is not serious, as you yourself pointed out - Twisted.Quotes proves it.

&gt;<i>Infact even
</I>&gt;<i>sqllite queries are obviously unacceptable once the db grows beyond the
</I>&gt;<i>size of the cache
</I>
Only if you're not using an index.  An implication of the current axiom model is that you had better be damn sure that you've got indexes in the right place.

&gt;<i>(and for sure you can't scale the queries over
</I>&gt;<i>different servers to have more ram-cache when using sqllite).
</I>
Who says your application has to scale by doing multi-machine queries within a single database?  Google's search team doesn't (at least according to the papers they've published), and I think they know something about scale.  You could apply their same general technique, or the one Netezza uses, to Axiom: either (google style) segment your application data into logical groups, and have high-level queries only talk to appropriate nodes, or (netezza) make null queries really fast (netezza has crazy stuff for this, I think, but Axiom would just use indexes), then run every query on every node in parallel, return results to an aggregating node.  It currently requires extra work, but in our application at least, you rarely want to query the whole universe.  At some point I imagine we will add support for that.

Anyway, I hope that indicates that I have considered the issue of scale a little bit.  Right now scale is not my biggest concern but I am confident we can handle it.  If Divmod were to have a potential customer approach us and say, &quot;we want Axiom to scale to a hundred million node cluster, and we have a very complex application, and we want to get to that scale within a month.  can we do that?&quot;  I'd say no.

That doesn't mean it will never scale.  If a potential client were instead to say, &quot;we have a six month timeframe, and such-and-such budget, can we launch something and eventually scale to a billion users with axiom?&quot;  I'd say yes, probably.  Depends on our allocation in the budget, of course ;-).  The application would have to be aware of scaling issues in its own code.

It turns out that you always do anyway.  The &quot;sufficiently parallel cluster&quot; of RDBMS machines is like the &quot;sufficiently smart compiler&quot; that LISP people talk about.  The existence of projects like memcached indicates that there is a general problem with the idea that you can just use one giant database and scale it up and up and up.

&gt;<i>Ironically axiom current api would have a chance to work well with
</I>&gt;<i>threads, with twisted single threaded async model not.
</I>
Database-managed concurrency is not the same thing as shared-state threading.    You might superficially implement database-managed concurrency with shared-state threads for convenience, but the whole programming model is different - most importantly, you don't touch locking from application code, ever.  I need to write a blog post about that or something, but I doubt I will do it justice.  There are easily 3 CS Ph.D dissertations in that topic and I am not the person to write them.

In fact, you can use the current Axiom API with threads, mostly, and it works about as well as most other Python ORMs.  There are some concurrency issues (also present in several other systems) which I'd like to fix before that is a suggested use though.

&gt;<i>There are good python storage packages to use with twisted and threads
</I>           ^
That word right there is debatable.  I've used, and even even written, a few of those and I'm not happy with them.  Again - for a particular application.  Divmod's application is very ambitious and it is not clear that Axiom is the best possible approach for it.  But it seems to be working out OK.

&gt;<i>I can't imagine why you insist on making your inferior
</I>&gt;<i>solution with a design that can't work well with twisted.
</I>
Your point: Axiom does not work well with Twisted.

Your evidence: you do not think Axiom works well with Twisted.

This is a rhetorical fallacy.  It is called a &quot;circular&quot; argument.

I have a favorite rhetorical fallacy too, but it's not this one.

My point: Axiom works great with Twisted!

My evidence: There are about 30 people in #divmod who think Axiom works great with Twisted.

This rhetorical fallacy is called an &quot;ad populum&quot; argument, and it's still wrong, but it has a bit more heft to it.

&gt;<i>I'm feeling guilty for risking hitting the harddisk for a few msec when
</I>
Hard disk?  You mean &quot;filesystem&quot;, surely.  Linux decides to put things which are in RAM onto disk and which are on disk into RAM all the time.

&gt;<i>people clicks on the mailing list archives, and infact I keep two
</I>&gt;<i>webservers exactly to avoid hurting the scalability of the ssl one.
</I>
Aah.  And how do you do that?  Inter-process communication.

Divmod does have problems that require extremely low-latency response and concurrency, but it turns out that these are the exception, not the rule.  Allen Short is currently putting Voice-over-IP audio playback into a subprocess so that performance does not suffer from delays which are perfectly acceptable for the interactive web app (everybody has to hit the database to display these web pages anyway, and there is only one disk, so the performance is not going to change if it's in parallel) but are excruciatingly long for delays between sound samples.

We also have plans to scale our service up amongst large groups of commodity machines, with separate, small axiom databases running on each one.  Axiom databases do scale up in size better than you have suggested (I have tested very responsive query and insert performance up to ~5G databases so far, and there is no indication it would slow down significantly anywhere up to a terabyte) but you are definitely not going to be able to run a million-subscriber service out of a single Axiom database.

You make spawning a second webserver sound like a really serious problem.  It's not.  When your application need parallelism, to maximize utilization, spawn a process.  Sometimes it's OK to block.

At the beginning of the project, I thought very much like you are suggesting, absolutely terrified of blocking for any reason, reasoning about what the kenel would do, about what my program would do, but without any solid performance numbers.  I got over it and wrote some simple code that stored and retrieved objects with SQLite, then did some basic measurements and discovered that it was actually adequately fast.

&gt;&gt;<i> Perhaps instead you could change the version
</I>&gt;&gt;<i> from SVN-Trunk to 'HG-CPUShare', so that the CPUShare-ness of the code is
</I>&gt;<i>
</I>&gt;<i>Ok, I'll make this change right away. I already did that for the web2 side.
</I>
and thanks again for that.

&gt;<i>This is a very fair requirement (changing the version is trivial).
</I>&gt;<i>However I don't see much point in changing the commands if the module
</I>&gt;<i>name is the same. Either I change both, or none.
</I>
Definitely the version is the most important thing.  I suggested the command-names because that way pasted shell output without tracebacks would also be visibly identifiable without having to say 'please run xxx --version'.  If you don't think that would be appropriate, I don't mind.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="044919.html">[Twisted-Python] Bugfixes and tests [was: CPUShare-Twisted]
</A></li>
	<LI>Next message (by thread): <A HREF="044911.html">[Twisted-Python] Re: [Twisted-web] CPUShare-Twisted
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44910">[ date ]</a>
              <a href="thread.html#44910">[ thread ]</a>
              <a href="subject.html#44910">[ subject ]</a>
              <a href="author.html#44910">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
