<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] reactor.callLater ponderings
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20reactor.callLater%20ponderings&In-Reply-To=%3C20031215031736.GA3302%40frobozz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="039286.html">
   <LINK REL="Next"  HREF="039288.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] reactor.callLater ponderings</H1>
    <B>Andrew Bennetts</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20reactor.callLater%20ponderings&In-Reply-To=%3C20031215031736.GA3302%40frobozz%3E"
       TITLE="[Twisted-Python] reactor.callLater ponderings">andrew-twisted at puzzling.org
       </A><BR>
    <I>Sun Dec 14 20:17:36 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="039286.html">[Twisted-Python] reactor.callLater ponderings
</A></li>
        <LI>Next message (by thread): <A HREF="039288.html">[Twisted-Python] Re: reactor.callLater ponderings (what i am trying to do) :)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39287">[ date ]</a>
              <a href="thread.html#39287">[ thread ]</a>
              <a href="subject.html#39287">[ subject ]</a>
              <a href="author.html#39287">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, Dec 14, 2003 at 05:41:37PM -0800, <A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">jjanecek at telusplanet.net</A> wrote:
&gt;<i> I created this little program to test the callLater feacture in
</I>&gt;<i> twisted.
</I>
It's not immediately clear to me exactly what you are trying to test with
this code... if you're just testing the resolution of callLater, then why
are you using threads?

callLater uses the timeout facility of select(2), poll(2) or whatever
underlying mechanism your reactor is using (you're using the poll reactor).
The poll system call takes a timeout in milliseconds, so I would expect that
on linux the theoretical minimum timeout you could get is determined by the
kernel's HZ value.  I don't know if the intervening layers of libc and
Python's runtime would have any impact... but given the way that Python does
multithreading, I *would* expect using threads in Python to have a
measurable impact.  Maybe try again without using threads?

Also, you call reactor.stop() from within a thread... I *think* that to be
correct, that you need to do reactor.callFromThread(reactor.stop).  I'm not
sure, though.

&gt;<i> def clock_pulse_thread() :
</I>[...]
&gt;<i>     time.sleep(0.01)
</I>&gt;<i>   
</I>&gt;<i> reactor.callLater(frequency/1000.0,clock_pulse)
</I>&gt;<i> reactor.run()
</I>&gt;<i> 
</I>&gt;<i> Now the instresting thing is that is windows the smallest
</I>&gt;<i> increment i can call the callback with is like 10 ms. 
</I>
This is probably due to a hard-coded value on line 153 of win32reactor.py
(assuming you're using win32reactor and not just the default select
reactor..?)

&gt;<i> Also is there a place that I can use to set how frequent i want the reactor
</I>&gt;<i> to check to see if a callLater function should be run ?
</I>
This question doesn't really make sense for most of the reactors.  The
reactor looks at the queue of callLaters to determine when it needs to next
wake up by to process the next one on time.  If there's activity on one of
its file descriptors (i.e. there's network traffic waiting to be read), it
will wake up sooner, process the traffic, and recalculate the timeout.  If
there is a new callLater added, it will recalculate the timeout.  The
timeout is passed to select or poll or kqueue or whatever, and the OS kernel
is in charge of making the system call return after the timeout has expired
if I/O hasn't already caused that to happen.

In the case of the win32reactor, there is a value with roughly the meaning
you have in mind (line 153 of win32reactor...)

&gt;<i> While on Linux (I tested using redhat 9.0 and mandrake 9.2) it does
</I>&gt;<i> not seem to be accurate on anything under 1 second. I peeked inside the
</I>&gt;<i> basereactor code and it does not seem to shed anylight. 
</I>
Is the consistent with both the default reactor (which uses select), and the
poll reactor?  Can you reproduce this without threads?

&gt;<i> I am running the clock pulse in a thread to simulate that it has to 
</I>&gt;<i> wait for something.
</I>
As I've mentioned before, I don't really understand what you mean by this.

-Andrew.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="039286.html">[Twisted-Python] reactor.callLater ponderings
</A></li>
	<LI>Next message (by thread): <A HREF="039288.html">[Twisted-Python] Re: reactor.callLater ponderings (what i am trying to do) :)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39287">[ date ]</a>
              <a href="thread.html#39287">[ thread ]</a>
              <a href="subject.html#39287">[ subject ]</a>
              <a href="author.html#39287">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
