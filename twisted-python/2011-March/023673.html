<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] UDP Logging Server
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20UDP%20Logging%20Server&In-Reply-To=20110312013227.GB31069%40boombah.thristian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023671.html">
   <LINK REL="Next"  HREF="023674.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] UDP Logging Server</H1>
    <B>Pandelis Theodosiou</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20UDP%20Logging%20Server&In-Reply-To=20110312013227.GB31069%40boombah.thristian.org"
       TITLE="[Twisted-Python] UDP Logging Server">ypercube at gmail.com
       </A><BR>
    <I>Sat Mar 12 07:33:45 EST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="023671.html">[Twisted-Python] UDP Logging Server
</A></li>
        <LI>Next message: <A HREF="023674.html">[Twisted-Python] UDP Logging Server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23673">[ date ]</a>
              <a href="thread.html#23673">[ thread ]</a>
              <a href="subject.html#23673">[ subject ]</a>
              <a href="author.html#23673">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sat, Mar 12, 2011 at 3:32 AM, Tim Allen &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">screwtape at froup.com</A>&gt; wrote:

&gt;<i> On Fri, Mar 11, 2011 at 01:15:47PM -0600, SIC FS LIST wrote:
</I>&gt;<i> &gt; So far I have a &quot;working&quot; implementation ... but I'm noticing that if I
</I>&gt;<i> do
</I>&gt;<i> &gt; the following:
</I>&gt;<i> &gt; -- log when a message is received
</I>&gt;<i> &gt; -- that for that message it &quot;might&quot; show up in the file a pretty lengthy
</I>&gt;<i> &gt; period of time later
</I>&gt;<i>
</I>&gt;<i> Assuming the objects stored in DISKINFO[1] etc. are file objects, you
</I>&gt;<i> seem to be writing to the files but never calling flush(). If you don't
</I>&gt;<i> call flush(), Python (well, the C standard library) won't send the data
</I>&gt;<i> on to the OS until its buffer is full, or the file handle is closed. If
</I>&gt;<i> you're not getting that many log lines, it can take a while for that to
</I>&gt;<i> happen.
</I>&gt;<i>
</I>&gt;<i> Of course, if you flush after every disk read, your program will run
</I>&gt;<i> a bit more slowly and with more I/O... for an application where
</I>&gt;<i> reliability is more important than performance (like logging) that's
</I>&gt;<i> probably acceptable.
</I>&gt;<i>
</I>
You may also setup a timer that flushes files every, say, 5 minutes.

One other thing I've read in the Python.org site is that flush() is not 100%
sure to work immediately and should be used in combination with os.fsync().
Is there someone that can explain if that is correct?


&gt;<i>
</I>&gt;<i> &gt; The actual UDP protocol:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; class VocsLogger(DatagramProtocol):
</I>&gt;<i> &gt;     def datagramReceived(self, data, (host, port)):
</I>&gt;<i> &gt;         _proc_msg(self.transport, data, (host,
</I>&gt;<i> &gt; port))._new_msg().addCallback(handler)
</I>&gt;<i>
</I>&gt;<i> _proc_msg doesn't seem to be complicated enough to need its own class,
</I>&gt;<i> why not just do what _proc_msg does in VocsLogger?
</I>&gt;<i>
</I>&gt;<i> &gt; The _proc_msg class:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; class _proc_msg:
</I>&gt;<i> &gt;     def __init__(self, sck, data, (host, port)):
</I>&gt;<i> &gt;         self._sck = sck
</I>&gt;<i> &gt;         self._data = data
</I>&gt;<i> &gt;         self._host = host
</I>&gt;<i> &gt;         self._port = port
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     def _new_msg(self):
</I>&gt;<i> &gt;         d, _ = LogMsg().ParseSocketMsg(self._data)
</I>&gt;<i> &gt;         if d.type.upper() == DISKINFO[0]:
</I>&gt;<i> &gt;             DISKINFO[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i> &gt;         elif d.type.upper() == LOADAVG[0]:
</I>&gt;<i> &gt;             LOADAVG[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i> &gt;         elif d.type.upper() == MEMINFO[0]:
</I>&gt;<i> &gt;             MEMINFO[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i> &gt;         elif d.type.upper() == NETDEV[0]:
</I>&gt;<i> &gt;             NETDEV[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i> &gt;         elif d.type.upper() == PSAUX[0]:
</I>&gt;<i> &gt;             PSAUX[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i> &gt;         elif d.type.upper() == WHOINFO[0]:
</I>&gt;<i> &gt;             WHOINFO[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i> &gt;         else:
</I>&gt;<i> &gt;             DEFAULT[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>
</I>&gt;<i> It depends on what DISKINFO[0] and DISKINFO[1] actually are, but
</I>&gt;<i> assuming they're a string and a file-handle, this code would look more
</I>&gt;<i> Pythonic as something like this:
</I>&gt;<i>
</I>&gt;<i> LOGSINKS = {
</I>&gt;<i>        &quot;DISKINFO&quot;: open(&quot;/var/log/diskinfo&quot;, &quot;w&quot;),
</I>&gt;<i>        &quot;LOADAVG&quot;: open(&quot;/var/log/loadavg&quot;, &quot;w&quot;),
</I>&gt;<i>        &quot;MEMINFO&quot;: open(&quot;/var/log/meminfo&quot;, &quot;w&quot;),
</I>&gt;<i>        &quot;NETDEV&quot;: open(&quot;/var/log/netdev&quot;, &quot;w&quot;),
</I>&gt;<i>        &quot;PSAUX&quot;: open(&quot;/var/log/psaux&quot;, &quot;w&quot;),
</I>&gt;<i>        &quot;WHOINFO&quot;: open(&quot;/var/log/whoinfo&quot;, &quot;w&quot;),
</I>&gt;<i>        &quot;DEFAULT&quot;: open(&quot;/var/log/default&quot;, &quot;w&quot;),
</I>&gt;<i>    }
</I>&gt;<i>
</I>&gt;<i> def _new_msg(self, data):
</I>&gt;<i>    d, _ = LogMsg().ParseSocketMsg(data)
</I>&gt;<i>    type = d.type.upper()
</I>&gt;<i>    sink = LOGSINKS.get(type, LOGSINKS['DEFAULT'])
</I>&gt;<i>    sink.write(&quot;%s\n%s\n&quot; % (d.ToString(), LOG_DELIM))
</I>&gt;<i>
</I>&gt;<i> Hope that helps!
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Twisted-Python mailing list
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">Twisted-Python at twistedmatrix.com</A>
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20110312/a23fa892/attachment-0001.htm">http://twistedmatrix.com/pipermail/twisted-python/attachments/20110312/a23fa892/attachment-0001.htm</A> 
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023671.html">[Twisted-Python] UDP Logging Server
</A></li>
	<LI>Next message: <A HREF="023674.html">[Twisted-Python] UDP Logging Server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23673">[ date ]</a>
              <a href="thread.html#23673">[ thread ]</a>
              <a href="subject.html#23673">[ subject ]</a>
              <a href="author.html#23673">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
