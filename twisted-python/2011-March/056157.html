<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] UDP Logging Server
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20UDP%20Logging%20Server&In-Reply-To=%3C20110312013227.GB31069%40boombah.thristian.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="056154.html">
   <LINK REL="Next"  HREF="056159.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] UDP Logging Server</H1>
    <B>Tim Allen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20UDP%20Logging%20Server&In-Reply-To=%3C20110312013227.GB31069%40boombah.thristian.org%3E"
       TITLE="[Twisted-Python] UDP Logging Server">screwtape at froup.com
       </A><BR>
    <I>Fri Mar 11 18:32:27 MST 2011</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="056154.html">[Twisted-Python] UDP Logging Server
</A></li>
        <LI>Next message (by thread): <A HREF="056159.html">[Twisted-Python] UDP Logging Server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#56157">[ date ]</a>
              <a href="thread.html#56157">[ thread ]</a>
              <a href="subject.html#56157">[ subject ]</a>
              <a href="author.html#56157">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Mar 11, 2011 at 01:15:47PM -0600, SIC FS LIST wrote:
&gt;<i> So far I have a &quot;working&quot; implementation ... but I'm noticing that if I do
</I>&gt;<i> the following:
</I>&gt;<i> -- log when a message is received
</I>&gt;<i> -- that for that message it &quot;might&quot; show up in the file a pretty lengthy
</I>&gt;<i> period of time later
</I>
Assuming the objects stored in DISKINFO[1] etc. are file objects, you
seem to be writing to the files but never calling flush(). If you don't
call flush(), Python (well, the C standard library) won't send the data
on to the OS until its buffer is full, or the file handle is closed. If
you're not getting that many log lines, it can take a while for that to
happen.

Of course, if you flush after every disk read, your program will run
a bit more slowly and with more I/O... for an application where
reliability is more important than performance (like logging) that's
probably acceptable.

&gt;<i> The actual UDP protocol:
</I>&gt;<i> 
</I>&gt;<i> class VocsLogger(DatagramProtocol):
</I>&gt;<i>     def datagramReceived(self, data, (host, port)):
</I>&gt;<i>         _proc_msg(self.transport, data, (host,
</I>&gt;<i> port))._new_msg().addCallback(handler)
</I>
_proc_msg doesn't seem to be complicated enough to need its own class,
why not just do what _proc_msg does in VocsLogger?

&gt;<i> The _proc_msg class:
</I>&gt;<i> 
</I>&gt;<i> class _proc_msg:
</I>&gt;<i>     def __init__(self, sck, data, (host, port)):
</I>&gt;<i>         self._sck = sck
</I>&gt;<i>         self._data = data
</I>&gt;<i>         self._host = host
</I>&gt;<i>         self._port = port
</I>&gt;<i> 
</I>&gt;<i>     def _new_msg(self):
</I>&gt;<i>         d, _ = LogMsg().ParseSocketMsg(self._data)
</I>&gt;<i>         if d.type.upper() == DISKINFO[0]:
</I>&gt;<i>             DISKINFO[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>         elif d.type.upper() == LOADAVG[0]:
</I>&gt;<i>             LOADAVG[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>         elif d.type.upper() == MEMINFO[0]:
</I>&gt;<i>             MEMINFO[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>         elif d.type.upper() == NETDEV[0]:
</I>&gt;<i>             NETDEV[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>         elif d.type.upper() == PSAUX[0]:
</I>&gt;<i>             PSAUX[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>         elif d.type.upper() == WHOINFO[0]:
</I>&gt;<i>             WHOINFO[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>&gt;<i>         else:
</I>&gt;<i>             DEFAULT[1].write(d.ToString() + &quot;\n%s\n&quot; % (LOG_DELIM))
</I>
It depends on what DISKINFO[0] and DISKINFO[1] actually are, but
assuming they're a string and a file-handle, this code would look more
Pythonic as something like this:

LOGSINKS = {
	&quot;DISKINFO&quot;: open(&quot;/var/log/diskinfo&quot;, &quot;w&quot;),
	&quot;LOADAVG&quot;: open(&quot;/var/log/loadavg&quot;, &quot;w&quot;),
	&quot;MEMINFO&quot;: open(&quot;/var/log/meminfo&quot;, &quot;w&quot;),
	&quot;NETDEV&quot;: open(&quot;/var/log/netdev&quot;, &quot;w&quot;),
	&quot;PSAUX&quot;: open(&quot;/var/log/psaux&quot;, &quot;w&quot;),
	&quot;WHOINFO&quot;: open(&quot;/var/log/whoinfo&quot;, &quot;w&quot;),
	&quot;DEFAULT&quot;: open(&quot;/var/log/default&quot;, &quot;w&quot;),
    }

def _new_msg(self, data):
    d, _ = LogMsg().ParseSocketMsg(data)
    type = d.type.upper()
    sink = LOGSINKS.get(type, LOGSINKS['DEFAULT'])
    sink.write(&quot;%s\n%s\n&quot; % (d.ToString(), LOG_DELIM))

Hope that helps!


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="056154.html">[Twisted-Python] UDP Logging Server
</A></li>
	<LI>Next message (by thread): <A HREF="056159.html">[Twisted-Python] UDP Logging Server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#56157">[ date ]</a>
              <a href="thread.html#56157">[ thread ]</a>
              <a href="subject.html#56157">[ subject ]</a>
              <a href="author.html#56157">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
