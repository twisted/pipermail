<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Connection poolin
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Connection%20poolin&In-Reply-To=87brvg7nqh.fsf%40complete.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005210.html">
   <LINK REL="Next"  HREF="005212.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Connection poolin</H1>
    <B>Tommi Virtanen</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Connection%20poolin&In-Reply-To=87brvg7nqh.fsf%40complete.org"
       TITLE="[Twisted-Python] Connection poolin">tv at twistedmatrix.com
       </A><BR>
    <I>Sun Jul 27 05:00:03 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="005210.html">[Twisted-Python] Connection poolin
</A></li>
        <LI>Next message: <A HREF="005212.html">[Twisted-Python] Help w/ low adbapi connection pool limits?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5221">[ date ]</a>
              <a href="thread.html#5221">[ thread ]</a>
              <a href="subject.html#5221">[ subject ]</a>
              <a href="author.html#5221">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sat, Jul 26, 2003 at 08:38:30PM -0500, John Goerzen wrote:
&gt;<i> imap = self.imapserver.acquireconnection()
</I>&gt;<i> try:
</I>&gt;<i>     # select the appropriate mailbox
</I>&gt;<i>     # do stuff here
</I>&gt;<i>     return result
</I>&gt;<i> finally:
</I>&gt;<i>    self.imapserver.release(imap)
</I>
	Here's two quick hacks that differ mostly in where you put
	the connection release, and how you organize the deferreds.

	Method 1: manage the release in the caller, but need to jump
	through hoops to get the connection passed to
	_releaseConnection. self.imapserver.acquireconnection() is
	of the traditional &quot;returns a Deferred&quot; style.

class Something:
    def startDoingStuff(self):
	d = self.imapserver.acquireconnection()
	d.addCallback(self._gotConnection)
	return d

    def _gotConnection(self, connection):
	d = defer.Deferred()
	d.addCallback(self._doStuff)
	d.addBoth(self._releaseConnection, connection)
	d.callback(connection)
	return d

    def _doStuff(self, connection):
	# select the appropriate mailbox
	# do stuff here

    def _releaseConnection(self, stuff, connection):
	connection.release()
	return stuff


	Method 2: manage the release in the connection pool. Needs
	to change the API of acquireconnection into taking a deferred,
	as otherwise it would be impossible to make _doStuff get called
	before the connection release. Note how close this is to the above,
	with just release logic located in the same class as
	acquireconnection.

class SomethingBetter:
    def startDoingStuff(self):
	d = defer.Deferred()
	d.addCallback(self._doStuff)
	self.imapserver.acquireconnection(d)
	return d

    def _doStuff(self, connection):
	# select the appropriate mailbox
	# do stuff here

class ...:
    def acquireconnection(self, d):
	d2 = self._grabConnection()
	d2.addCallback(self._gotConnection, d)
	d2.chainCallback(d)

    def _gotConnection(self, connection, d):
	d.addBoth(self._releaseConnection, connection)
	return connection

    def _releaseConnection(self, stuff, connection):
	connection.release()
	return stuff

&gt;<i> I've thought that in each method I have that needs a connection, I
</I>&gt;<i> could write two methods: one that calls the Twisted version of
</I>&gt;<i> acquireconnection and sets its callback to the second, which does the
</I>&gt;<i> real work (and possibly chains to others via callbacks.)
</I>&gt;<i> 
</I>&gt;<i> There are some problems with that approach.  One is that it is very
</I>&gt;<i> verbose and requires a lot of code all over the place to manage.
</I>&gt;<i> Another is that there's no easy way to tell in Twisted when we are
</I>&gt;<i> done with the given connection.  I suppose I could always add errbacks
</I>&gt;<i> all along the way plus a callback, each of which releases the
</I>&gt;<i> connection, but that seems inconvenient and error-prone.
</I>
	I don't think the method 2 above is verbose. And there is no reason
	to add errbacks &quot;all along the way&quot;. Just a single addBoth is
	enough. When the .addBoth callback returns it's first arg, it
	pretty much equals python exception handling try: ... finally: ...

-- 
:<i>(){ :|:&amp;};:
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005210.html">[Twisted-Python] Connection poolin
</A></li>
	<LI>Next message: <A HREF="005212.html">[Twisted-Python] Help w/ low adbapi connection pool limits?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5221">[ date ]</a>
              <a href="thread.html#5221">[ thread ]</a>
              <a href="subject.html#5221">[ subject ]</a>
              <a href="author.html#5221">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
