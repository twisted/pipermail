<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: IMAP fixes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20IMAP%20fixes&In-Reply-To=%3C1ED4ECF91CDED24C8D012BCF2B034F1318CF0D%40its-xchg4.massey.ac.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="037448.html">
   <LINK REL="Next"  HREF="037454.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: IMAP fixes</H1>
    <B>Tony Meyer</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20IMAP%20fixes&In-Reply-To=%3C1ED4ECF91CDED24C8D012BCF2B034F1318CF0D%40its-xchg4.massey.ac.nz%3E"
       TITLE="[Twisted-Python] Re: IMAP fixes">ta-meyer at ihug.co.nz
       </A><BR>
    <I>Thu Jul 10 00:59:42 MDT 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="037448.html">[Twisted-Python] Re: IMAP fixes
</A></li>
        <LI>Next message (by thread): <A HREF="037454.html">[Twisted-Python] Re: IMAP fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37452">[ date ]</a>
              <a href="thread.html#37452">[ thread ]</a>
              <a href="subject.html#37452">[ subject ]</a>
              <a href="author.html#37452">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Why?
</I>
Well, efficiency, for one.  timeit rates the single re 5-6 times faster than
the proof of concept that you posted (corrected to work).  That's a
considerable speed difference.

&gt;<i> It's much better to split into several REs. When you need to 
</I>&gt;<i> comment your REs, they're obviously useless
</I>
It didn't _need_ to be commented, I did so to point out how simple it
actually was.  This is a bizarre statement.  Does it then follow that if you
need to comment code, it's obviously useless?  Why would the re.VERBOSE flag
even exist if this was the case?

This re really isn't that complex.  If I take out the uncapturing and naming
of groups (which are just to make the code easier to read), and drop the
alternation, like in your proof of concept, it becomes:
BODY\.?(PEEK)?\[(([\d\.]*)\.)?([A-Z\.]+)(
\(([^\(\)]*)\))?\](\&lt;\d+\.[1-9]\d*)\&gt;)?
If this was written out in verbose form, then it would be easily as readable
as the proof of concept.

&gt;<i> -- it is impossible to keep comments in sync with code,
</I>
Why?  Change the code, check the comment.  Simple.  How is it any different
than checking that a change you make doesn't effect other parts of the code?

&gt;<i> Not to mention you can't step with PDB through REs, or insert 
</I>&gt;<i> prints, to see what exactly is going wrong.
</I>
But there are other tools to test re's.  (In any case, you can insert print
statements, simply by using slices appropriately).

&gt;<i> Here's a proof of concept (untested) factorization into several REs
</I>&gt;<i> each of which is easy enough to describe:
</I>&gt;<i> 
</I>&gt;<i> sectionRe = re.compile('([\d\.])*\.') # digits and dots, ends with dot
</I>[...]
&gt;<i> cket = re.compile('\]') # literal ]
</I>
This section is no easier to understand - the only difference is the choice
in separation and wording of comments.

&gt;<i> # And when you write it like that, it is easy to find
</I>&gt;<i> # false positives. For example, should we check s is empty?
</I>
You can check whether the single re ends at the end of the string just as
easily; I can't think of any tests that can't be carried out just as easily
with either solution.

&gt;<i> # Note how the parsing is now done with code -- only the low-level
</I>&gt;<i> # tokenizing is done with REs. The code is relatively easy to read.
</I>
The code has become relatively more difficult to read, because almost all
the work is done by the re engine.  It's the parsing itself that is
theoretically easier to read.

In addition, having the multiple re's adds additional code that must be
written, tested and maintained.  The single re has the advantage that the
code to do the parsing is contained within the re module, and so is someone
else's problem.  There is only a single re to be sure of, instead of several
lines of code.

For the most part, this is a stylistic choice, not a correct/incorrect one.
The single re has the advantage of speed (important, in this particular
case), and less code to write/maintain.  The multiple re approach makes the
parsing more explicit, and makes changing the re less error-prone (an
unlikely event, in this particular case).

As I indicated, I don't really care whether Jp prefers a single re, multiple
re's like this, or using the string module and more if's; it's up to him
(whether I can be bothered coding the alternatives to offer as a patch is
another question ;).  I still personally believe that the single re is most
appropriate for this case, and given that I can always subclass the version
that gets checked in, it won't make any difference.

=Tony Meyer



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="037448.html">[Twisted-Python] Re: IMAP fixes
</A></li>
	<LI>Next message (by thread): <A HREF="037454.html">[Twisted-Python] Re: IMAP fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37452">[ date ]</a>
              <a href="thread.html#37452">[ thread ]</a>
              <a href="subject.html#37452">[ subject ]</a>
              <a href="author.html#37452">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
