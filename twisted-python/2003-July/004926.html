<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: IMAP fixes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20IMAP%20fixes&In-Reply-To=1ED4ECF91CDED24C8D012BCF2B034F130212AADD%40its-xchg4.massey.ac.nz">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004922.html">
   <LINK REL="Next"  HREF="004923.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: IMAP fixes</H1>
    <B>Jp Calderone</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=%5BTwisted-Python%5D%20Re%3A%20IMAP%20fixes&In-Reply-To=1ED4ECF91CDED24C8D012BCF2B034F130212AADD%40its-xchg4.massey.ac.nz"
       TITLE="[Twisted-Python] Re: IMAP fixes">exarkun at twistedmatrix.com
       </A><BR>
    <I>Wed Jul  9 06:04:48 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="004922.html">[Twisted-Python] Re: IMAP fixes
</A></li>
        <LI>Next message: <A HREF="004923.html">[Twisted-Python] Re: IMAP fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4926">[ date ]</a>
              <a href="thread.html#4926">[ thread ]</a>
              <a href="subject.html#4926">[ subject ]</a>
              <a href="author.html#4926">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Jul 09, 2003 at 04:47:57PM +1200, Tony Meyer wrote:
&gt;<i> [Tony]
</I>&gt;<i> &gt; &gt; For example, this command:
</I>&gt;<i> &gt;     0003 FETCH 1 BODY.PEEK[HEADER.FIELDS (References X-Ref)] UID
</I>&gt;<i> [Jp]
</I>&gt;<i> &gt; Ideally, I'd like to see this parsed into a structure 
</I>&gt;<i> &gt; resembling this:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;     [Header(peek=1, name=1, value=1, ['References', 'X-Ref']), UID()]
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Would you be interested in patching the fetch methods to 
</I>&gt;<i> &gt; generate a structure like the one I described above?
</I>&gt;<i> 
</I>&gt;<i> This command now becomes:
</I>&gt;<i>     [&quot;BODY(PEEK=1, HEADER=1, FIELDS=1, fielditems=['References', 'X-Ref'])&quot;,
</I>&gt;<i> 'UID()']
</I>&gt;<i> 
</I>&gt;<i> Is this suitable?  I presume(d) from the structure that you suggested that
</I>&gt;<i> one way of handling this would be to then exec each element (having a
</I>&gt;<i> BODY(), UID function, and so on).
</I>
  Eeep :o  This isn't quite what I was going for... The exec stage is a big
no-no from my point of view.  I'd rather have Body be a class, with peek,
fields, etc as boolean attributes on its instances.  This avoids having to
build up strings in the protocol code, and avoids forcing client code to
turn it back into something easily parsed.  I guess I should give a couple
examples.

  The body class might be defined something like this (and instantiated as
above, with proper case normalization and removal of the quotes making the
whole thing a string):

    class Body:
        name = 'body'
	def __init__(self, peek=False, header=False, fields=False, **kwargs):
            self.peek, self.header, self.fields = peek, header, fields
            self.__dict__.update(kwargs)

        def __str__(self):
            base = 'BODY'
            if self.peek:
                base = 'BODY.PEEK'
            opt = ''
            if self.header:
                if self.fields:
                    opt = '[HEADER.FIELDS %s]' % ' '.join(self.fielditems)
                else:
                    opt = '[HEADER %s]' % ' '.join(self.fielditems)
            elif # ... something else
                ...
            return '%s%s' % (base, opt)

  Client code could expect to use it like this:

    def fetch(self, msgs, queryParts, uid):
        r = {}
        for q in queryParts:
            r[q] = getattr(self, 'fetch_' + q.name)(msgs, q, uid)

    def fetch_body(self, msgs, query, uid):
        if not query.peek:
            # mark specified messages as seen
        if query.header:
            if query.fields:
                ...

  There's a clear problem with the way Body.__str__ is implemented (no
quoting -- but maybe this could be fixed with a DB-API-style quoting
tactic), and obviously large parts of the implementation are missing, but I
hope this gets my idea across a little more clearly.  I am dead tired at the
moment, I just wanted to respond quickly to clear up the point of strings vs
classes.  If I still haven't succeeded in conveying all my thoughts clearly,
please let me know and I'll try again :)

&gt;<i> 
</I>&gt;<i> If there are problems with this, I'm happy to make changes.  I wrote it
</I>&gt;<i> against the RFC, so there may be things that need to be changed if there are
</I>&gt;<i> clients that do things illegally that are meant to be supported.  It also
</I>&gt;<i> _only_ supports rfc2060, not any extra additions, although if they are
</I>&gt;<i> simple ones or macros then it would be easy to simply append them to the
</I>&gt;<i> appropriate list.
</I>
  This sounds fine.  I do like that it moves the macro processing out of the
mailbox and into the protocol code.

&gt;<i> 
</I>&gt;<i> Anyway, here it is, let me know what you think.
</I>
  The only other thing I wanted to mention was that scary regular
expression.  I haven't even attempted to decipher it yet, but I was curious
if you pulled it out of or based it off of one of the RFCs, or if you came
up with it yourself?  In my experience expressions that long tend to be
wrong in unexpected and surprising ways, and I'm not inclined to trust them
without careful analysis, or at least the knowledge that they come from an
authoritative source (and even then, ensuring the proper meaning survived
into the translation to python REs is a pain...)

  All that said, thanks for the patch!  I'm looking forward to the next
revision :)

  Jp

-- 
        &quot;I quite agree with you,&quot; said the Duchess; &quot;and the moral of
that is -- Be what you would seem to be' -- or, if you'd like it put
more simply -- Never imagine yourself not to be otherwise than what it
might appear to others that what you were or might have been was not 
otherwise than what you had been would have appeared to them to be
otherwise.'&quot;       -- Lewis Carrol, &quot;Alice in Wonderland&quot;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : <A HREF="http://twistedmatrix.com/pipermail/twisted-python/attachments/20030709/499cd46e/attachment.pgp">http://twistedmatrix.com/pipermail/twisted-python/attachments/20030709/499cd46e/attachment.pgp</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004922.html">[Twisted-Python] Re: IMAP fixes
</A></li>
	<LI>Next message: <A HREF="004923.html">[Twisted-Python] Re: IMAP fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4926">[ date ]</a>
              <a href="thread.html#4926">[ thread ]</a>
              <a href="subject.html#4926">[ subject ]</a>
              <a href="author.html#4926">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
