<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] How Twisted is This?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20How%20Twisted%20is%20This%3F&In-Reply-To=%3C50E4C45B-B7DE-11D7-8336-000A95686CD8%40redivi.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="037580.html">
   <LINK REL="Next"  HREF="037591.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] How Twisted is This?</H1>
    <B>Bob Ippolito</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20How%20Twisted%20is%20This%3F&In-Reply-To=%3C50E4C45B-B7DE-11D7-8336-000A95686CD8%40redivi.com%3E"
       TITLE="[Twisted-Python] How Twisted is This?">bob at redivi.com
       </A><BR>
    <I>Wed Jul 16 16:39:09 MDT 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="037580.html">[Twisted-Python] How Twisted is This?
</A></li>
        <LI>Next message (by thread): <A HREF="037591.html">[Twisted-Python] How Twisted is This?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37583">[ date ]</a>
              <a href="thread.html#37583">[ thread ]</a>
              <a href="subject.html#37583">[ subject ]</a>
              <a href="author.html#37583">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wednesday, Jul 16, 2003, at 16:53 America/New_York, Peter Hansen 
wrote:

&gt;<i> Bob Ippolito wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Wednesday, Jul 16, 2003, at 12:12 America/New_York, Peter Hansen
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> One good reason to do the &quot;every five minutes check&quot; thing instead of
</I>&gt;&gt;&gt;<i> &quot;wait exactly this long based on a precalculated value&quot; thing is that
</I>&gt;&gt;&gt;<i> if the things to be monitored can be added or removed dynamically,
</I>&gt;&gt;&gt;<i> interrupting the sleep is more difficult than it's worth, while the
</I>&gt;&gt;&gt;<i> blind periodic check is much simpler and more robust.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't necessarily agree with that.  With the &quot;every five minutes
</I>&gt;&gt;<i> check&quot; you have to write your own callLater mechanism, when you let
</I>&gt;&gt;<i> tasks schedule themselves, you don't.  Also with the &quot;every five
</I>&gt;&gt;<i> minutes check&quot; you're using computer+bandwidth resources in a much 
</I>&gt;&gt;<i> less
</I>&gt;&gt;<i> sane manner, it sure as hell isn't going to scale awfully well.
</I>&gt;<i>
</I>&gt;<i> Mentioning callLater makes this an implementation question now, whereas
</I>&gt;<i> I believe both Brad and I were talking from a more general point of 
</I>&gt;<i> view.
</I>
I said &quot;your own callLater mechanism&quot;, meaning &quot;your own code that 
doesn't do anything very different from callLater&quot;.  We're talking 
about using a particular framework here anyways, and the claim I'm 
making is that this framework already has a well-designed and tested 
implementation this particular functionality and it'd be silly to write 
your own.

&gt;<i> I was, anyway.  From a general point of view, I'm right ;-), because
</I>&gt;<i> you simply don't have to worry about issues related to adding or 
</I>&gt;<i> removing
</I>&gt;<i> items, or changing the time delays of them as you would if you 
</I>&gt;<i> calculated
</I>&gt;<i> the delay until the next activity and went to sleep for that long.
</I>
How can you not have to worry about adding or removing items to a list 
of recurring tasks?  You have the same list of tasks for either 
approach.  Calculating the number of seconds in 5 minutes isn't any 
harder for a &quot;waker&quot; than it is for whatever function is scheduling 
your tasks.. it's simple, the answer is minutes*60.0, which is 300.0 
seconds in this case.  With a &quot;wakerless&quot; approach you can have the 
tasks scheduled at different sorts of intervals, and even non-constant 
intervals (i.e. exponential backoff).  If you have a &quot;waker&quot; that 
supports this kind of functionality, that manages a list of stuff that 
should happen after variable intervals of time, finds the minimum, and 
sleeps for that long, you just rewrote part of the reactor.  The good 
thing about using pieces of the twisted framework that already exist is 
that you don't have to write them, they generally have tests, and 
generally work extremely well.

&gt;<i> As for bandwidth: I'm of the &quot;premature optimization is bad&quot; school
</I>&gt;<i> of thought, and it's far too early in this discussion to be worrying
</I>&gt;<i> about a few microseconds of CPU usage per day...
</I>
It's not a premature optimization, it's a different way of designing 
the networking core of this &quot;company branded salable application&quot; that 
happens to be easier and more scalable.  For example, a process can 
only acquire some fixed number of file handles (sockets) before it 
starts to get really-hard-to-handle errors.  If you try and open up X 
connections at the same time, you're much more likely to run into this 
error given enough sites to check, it's something you really have to 
watch out for when writing a web spider, for example.  It just doesn't 
make sense to intentionally design something that behaves like: 
______/\___________/\_____ when you really have an extremely 
parallelizable task at hand.  Checking site A is in no way dependent on 
checking site B, so there's no reason to intentionally make them happen 
at the same time if you know better.  We're not talking about a whole 
lot of code here.  Leveraging the fact that 99% of what needs to be 
done is glue code between stuff that's already in twisted, a prototype 
of his application could be easily be done in less than fifty lines 
using the scalable approach.  In fact, I think that the &quot;wake up and do 
stuff every N minutes&quot; approach would actually end up being a longer 
and easier to screw up implementation.

-bob



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="037580.html">[Twisted-Python] How Twisted is This?
</A></li>
	<LI>Next message (by thread): <A HREF="037591.html">[Twisted-Python] How Twisted is This?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37583">[ date ]</a>
              <a href="thread.html#37583">[ thread ]</a>
              <a href="subject.html#37583">[ subject ]</a>
              <a href="author.html#37583">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
