<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Re: IMAP fixes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20IMAP%20fixes&In-Reply-To=%3C1ED4ECF91CDED24C8D012BCF2B034F130212AAE7%40its-xchg4.massey.ac.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="037432.html">
   <LINK REL="Next"  HREF="037448.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Re: IMAP fixes</H1>
    <B>Tony Meyer</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Re%3A%20IMAP%20fixes&In-Reply-To=%3C1ED4ECF91CDED24C8D012BCF2B034F130212AAE7%40its-xchg4.massey.ac.nz%3E"
       TITLE="[Twisted-Python] Re: IMAP fixes">ta-meyer at ihug.co.nz
       </A><BR>
    <I>Wed Jul  9 21:27:15 MDT 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="037432.html">[Twisted-Python] Re: IMAP fixes
</A></li>
        <LI>Next message (by thread): <A HREF="037448.html">[Twisted-Python] Re: IMAP fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37447">[ date ]</a>
              <a href="thread.html#37447">[ thread ]</a>
              <a href="subject.html#37447">[ subject ]</a>
              <a href="author.html#37447">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>   Eeep :o  This isn't quite what I was going for... The exec
</I>&gt;<i> stage is a big no-no from my point of view.
</I>
Fair enough.

&gt;<i> I guess I should give a couple examples.
</I>
That helped!

&gt;<i>   The only other thing I wanted to mention was that scary
</I>&gt;<i> regular expression.  I haven't even attempted to decipher it 
</I>&gt;<i> yet, but I was curious if you pulled it out of or based it 
</I>&gt;<i> off of one of the RFCs, or if you came up with it yourself?  
</I>
I built it myself from RFC2060, using Kodos (and my server) to test it.

&gt;<i> In my experience expressions that long tend to be wrong in
</I>&gt;<i> unexpected and surprising ways, and I'm not inclined to trust 
</I>&gt;<i> them without careful analysis, or at least the knowledge that 
</I>&gt;<i> they come from an authoritative source (and even then, 
</I>&gt;<i> ensuring the proper meaning survived into the translation to 
</I>&gt;<i> python REs is a pain...)
</I>
Well, it started life as a python RE, so there was no translation.  I did
very carefully analyse (and test) it, and you're welcome to as well.  It's
easy enough to do without it, or split it into several smaller re's, but
this seems the best way to do it.

It's really not as complicated as it looks - a lot of the length comes from
having named groups, which makes things more reliable, not less.  There are
also several uncaptured groups, which could probably just be made into
regular groups, but the result is tidier this way.

I've made the re verbose, so maybe that helps?  (the changes also allowed it
to be simplified just a little, plus I've made it more for capturing and
less for checking, in the mime section specifier, particularly).

&gt;<i>   All that said, thanks for the patch!  I'm looking forward
</I>&gt;<i> to the next revision :)
</I>
Here it is.  The atts passed should be more-or-less what you described, now.

The mailbox code isn't quite the same; you had (as an example):
&gt;<i>     def fetch(self, msgs, queryParts, uid):
</I>&gt;<i>         r = {}
</I>&gt;<i>         for q in queryParts:
</I>&gt;<i>             r[q] = getattr(self, 'fetch_' + q.name)(msgs, q, uid)
</I>
But this seems strange to me - you end up with a dictionary where the keys
are the classes (Body(), UID(), etc).  Whatever the values end up being,
unless the message id is added to the class, then this really doesn't fit
with the existing __cbFetch at all, which wants the keys to be the message
ids (which makes sense to me).  My mailbox code looks like this:
    def fetch(self, msgs, queryParts, uid):
        r = {}
        for (id, msg) in self.messagesIter(msgs, uid):
            r[id] = {}
            for q in parts:
                r[id][q] = getattr(self, 'grab' + q.name.upper())(msg, q)
        return r
Which is pretty similar, except that the key is still the message id.  (I
also do it message by message, whereas yours was part by part, but that
shouldn't matter).

It also wasn't exactly clear how you wanted the values to be returned.  What
is does at the moment is pass back a dict where the values are dicts of
class (BODY(), UID(), etc) to string.  This seems to be pretty close to the
original.

Let me know what you think of this, and I'll keep on with the fixes...

=Tony Meyer
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: fetch_att.py
URL: &lt;/pipermail/twisted-python/attachments/20030710/5f4ce7b4/attachment.ksh&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="037432.html">[Twisted-Python] Re: IMAP fixes
</A></li>
	<LI>Next message (by thread): <A HREF="037448.html">[Twisted-Python] Re: IMAP fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37447">[ date ]</a>
              <a href="thread.html#37447">[ thread ]</a>
              <a href="subject.html#37447">[ subject ]</a>
              <a href="author.html#37447">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
