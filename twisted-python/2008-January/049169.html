<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Soon to be not-a-newbie?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Soon%20to%20be%20not-a-newbie%3F&In-Reply-To=%3C200801261342.04000.maarten%40treewalker.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="049168.html">
   <LINK REL="Next"  HREF="049173.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Soon to be not-a-newbie?</H1>
    <B>Maarten ter Huurne</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Soon%20to%20be%20not-a-newbie%3F&In-Reply-To=%3C200801261342.04000.maarten%40treewalker.org%3E"
       TITLE="[Twisted-Python] Soon to be not-a-newbie?">maarten at treewalker.org
       </A><BR>
    <I>Sat Jan 26 05:41:55 MST 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="049168.html">[Twisted-Python] Soon to be not-a-newbie?
</A></li>
        <LI>Next message (by thread): <A HREF="049173.html">[Twisted-Python] Soon to be not-a-newbie?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49169">[ date ]</a>
              <a href="thread.html#49169">[ thread ]</a>
              <a href="subject.html#49169">[ subject ]</a>
              <a href="author.html#49169">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Saturday 26 January 2008, Tristan Seligmann wrote:
&gt;<i> * Maarten ter Huurne &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">maarten at treewalker.org</A>&gt; [2008-01-26 12:51:27 +0100]:
</I>&gt;<i> &gt; The low-level flow of code (control going back to the reactor) is
</I>&gt;<i> &gt; obscured, but I think that is an advantage rather than a disadvantage,
</I>&gt;<i> &gt; since the high-level flow of code (the sequence of operations) becomes
</I>&gt;<i> &gt; more clear. The flow of data is explicit in both cases: it is either
</I>&gt;<i> &gt; passed as callback parameters or as return values from &quot;yield&quot;.
</I>&gt;<i>
</I>&gt;<i> In the vast majority of network applications, I believe deferred
</I>&gt;<i> operations are not sequenced in a linear fashion; they're happening in
</I>&gt;<i> an overlapping and concurrent fashion. The problem with data flow in the
</I>&gt;<i> case of &quot;yield&quot; is that every time &quot;yield&quot; is invoked, all sorts of
</I>&gt;<i> state can get mutated around you that wouldn't normally happen when
</I>&gt;<i> calling another function. For a normal function, this also happens when
</I>&gt;<i> you return control to your caller, but by that time you don't care; but
</I>&gt;<i> in a generator, you're going to be resumed again. The &quot;yield&quot; keyword
</I>&gt;<i> doesn't seem to act as a very good &quot;red flag&quot; for this kind of context
</I>&gt;<i> switch, especially once it starts getting buried in a more complex
</I>&gt;<i> expression.
</I>
The outside world changing is only a problem if you gather information about 
the outside world in stages, since you could end up with inconsistent data. 
However, this problem exists whether you store the gathered data in the 
local variables of an inline callback or in a data structure passed to 
non-inlined callbacks.

Whether &quot;yield&quot; is a worse red flag than separate functions I cannot really 
tell, since I wrote only one big application with Twisted and there I do 
all data gathering in a single operation. That is likely to change in the 
future though, when it will start fetching information from other servers.

&gt;<i> &gt; There are quite a few cases in which the dependencies between the
</I>&gt;<i> &gt; operations force sequential processing. In those cases, inline
</I>&gt;<i> &gt; callbacks are useful.
</I>&gt;<i>
</I>&gt;<i> I've personally encountered very few cases where there are more than a
</I>&gt;<i> handful of operations in sequence.
</I>
True, but even for a sequence of 3 operations I think it's already 
worthwhile.

&gt;<i> &gt; For example, to serve a web page, I want to authenticate the user, then
</I>&gt;<i> &gt; run a database query and finally present the result.
</I>&gt;<i>
</I>&gt;<i> Generally in my code, these are being handled by three different layers
</I>&gt;<i> of code that are mostly hooked up by Twisted and other frameworks; for
</I>&gt;<i> example, authentication is being handled by cred/guard in my web
</I>&gt;<i> applications. Thus, there isn't really any single function where all
</I>&gt;<i> these operations are plumbed together.
</I>
I do authenticate using cred. I don't use Nevow though: I played with it a 
bit and decided it was too complex for my taste (I was always wondering 
exactly when a substitution would be performed). So I wrote something 
specifically for our application: because it's less flexible it's also 
easier to use.

&gt;<i> &gt; If the code using inline callbacks looks like this, there is no problem
</I>&gt;<i> &gt; in testing the parts separately:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 	result1 = yield function1(arg)
</I>&gt;<i> &gt; 	result2 = yield function2(result1)
</I>&gt;<i>
</I>&gt;<i> But if it really looks like that, there's not much point in writing that
</I>&gt;<i> instead of this:
</I>&gt;<i>
</I>&gt;<i>     result1 = function1(arg)
</I>&gt;<i>     result2 = result1.addCallback(function2)
</I>
It doesn't literally look like that. What I mean is that if there is enough 
functionality to make it worth dedicating test cases to, then it's probably 
a good idea to put that functionality in a separate function. This is true 
for both inline and non-inline callbacks, and even for synchronous code.

The cases where inline callbacks really help are when the callback functions 
contain only 1 or 2 lines, for example logging a failure and propagating it 
using a different exception type.

Bye,
		Maarten
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 194 bytes
Desc: This is a digitally signed message part.
URL: &lt;/pipermail/twisted-python/attachments/20080126/a5419011/attachment.sig&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="049168.html">[Twisted-Python] Soon to be not-a-newbie?
</A></li>
	<LI>Next message (by thread): <A HREF="049173.html">[Twisted-Python] Soon to be not-a-newbie?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49169">[ date ]</a>
              <a href="thread.html#49169">[ thread ]</a>
              <a href="subject.html#49169">[ subject ]</a>
              <a href="author.html#49169">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
