<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Foolscap-0.0.5 released (aka newpb)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Foolscap-0.0.5%20released%20%28aka%20newpb%29&In-Reply-To=%3C20061105.003750.02715181.warner%40lothar.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="046919.html">
   <LINK REL="Next"  HREF="046822.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Foolscap-0.0.5 released (aka newpb)</H1>
    <B>Brian Warner</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Foolscap-0.0.5%20released%20%28aka%20newpb%29&In-Reply-To=%3C20061105.003750.02715181.warner%40lothar.com%3E"
       TITLE="[Twisted-Python] Foolscap-0.0.5 released (aka newpb)">warner at lothar.com
       </A><BR>
    <I>Sun Nov  5 01:37:50 MST 2006</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="046919.html">[Twisted-Python] Weekly Bug Summary
</A></li>
        <LI>Next message (by thread): <A HREF="046822.html">[Twisted-Python] Foolscap-0.0.5 released (aka newpb)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46813">[ date ]</a>
              <a href="thread.html#46813">[ thread ]</a>
              <a href="subject.html#46813">[ subject ]</a>
              <a href="author.html#46813">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I've uploaded another release of Foolscap, the next-generation remote-object
communication system for Twisted. (actually I've uploaded two, but 0.0.4 had
a brown-paper-bag bug and so it never got announced).

The new release makes all Referenceable objects &quot;giftable&quot; by default, making
it easier to share objects among multiple machines. There is a new
&quot;Reconnector&quot; with which you can announce your intention to connect to a
given target and have the Tub perform exponential-backoff retry attempts
whenever the connection is lost. Also, notifyOnDisconnect() now accepts args
and kwargs to be passed to the disconnect handler callback.

This release also adds support for making debian packages, for sid, sarge,
and dapper. Just type 'make debian-sid' (etc) to get an installable .deb
package in the parent directory.

The full list of user-visible changes is attached below. No wire-level
compatibility changes were introduced in this release, but there will be some
in the future.

Please see <A HREF="http://twistedmatrix.com/trac/wiki/FoolsCap">http://twistedmatrix.com/trac/wiki/FoolsCap</A> for complete
information about Foolscap. The 0.0.5 release tarball is available from
<A HREF="http://twistedmatrix.com/~warner/Foolscap/">http://twistedmatrix.com/~warner/Foolscap/</A> .

share and enjoy,
 -Brian



User visible changes in Foolscap (aka newpb/pb2).

* Release 0.0.5 (04 Nov 2006)

** add Tub.setOption, add logRemoteFailures and logLocalFailures

These options control whether we log exceptions (to the standard twisted log)
that occur on other systems in response to messages that we've sent, and that
occur on our system in response to messages that we've received
(respectively). These may be useful while developing a distributed
application. All such log messages have each line of the stack trace prefixed
by REMOTE: or LOCAL: to make it clear where the exception is happening.

** add sarge packaging, improve dependencies for sid and dapper .debs

** fix typo that prevented Reconnector from actually reconnecting


* Release 0.0.4 (26 Oct 2006)

** API Changes

*** notifyOnDisconnect() takes args/kwargs

RemoteReference.notifyOnDisconnect(), which registers a callback to be fired
when the connection to this RemoteReference is lost, now accepts args and
kwargs to be passed to the callback function. Without this, application code
needed to use inner functions or bound methods to close over any additional
state you wanted to get into the disconnect handler.

notifyOnDisconnect() returns a &quot;marker&quot;, an opaque values that should be
passed into the corresponding dontNotifyOnDisconnect() function to deregister
the callback. (previously dontNotifyOnDisconnect just took the same argument
as notifyOnDisconnect).

For example:

class Foo:
    def _disconnect(self, who, reason):
        print &quot;%s left us, because of %s&quot; % (who, reason)
    def connect(self, url, why):
        d = self.tub.getReference(url)
        def _connected(rref):
            self.rref = rref
            m = rref.notifyOnDisconnect(self._disconnect, who, reason=why)
            self.marker = m
        d.addCallback(_connected)
    def stop_caring(self):
        self.rref.dontNotifyOnDisconnect(self.marker)

*** Reconnector / Tub.connectTo()

There is a new connection API for applications that want to connect to a
target and to reconnect to it if/when that connection is lost. This is like
ReconnectingClientFactory, but at a higher layer. You give it a URL to
connect to, and a callback (plus args/kwargs) that should be called each time
a connection is established. Your callback should use notifyOnDisconnect() to
find out when it is disconnected. Reconnection attempts use exponential
backoff to limit the retry rate, and you can shut off reconnection attempts
when you no longer want to maintain a connection.

Use it something like this:

class Foo:
    def __init__(self, tub, url):
        self.tub = tub
        self.reconnector = tub.connectTo(url, self._connected, &quot;arg&quot;)
    def _connected(self, rref, arg):
        print &quot;connected&quot;
        assert arg == &quot;arg&quot;
        self.rref = rref
        self.rref.callRemote(&quot;hello&quot;)
        self.rref.notifyOnDisconnect(self._disconnected, &quot;blag&quot;)
    def _disconnected(self, blag):
        print &quot;disconnected&quot;
        assert blag == &quot;blag&quot;
        self.rref = None
    def shutdown(self):
        self.reconnector.stopConnecting()

Code which uses this pattern will see &quot;connected&quot; events strictly interleaved
with &quot;disconnected&quot; events (i.e. it will never see two &quot;connected&quot; events in
a row, nor two &quot;disconnected&quot; events).

The basic idea is that each time your _connected() method is called, it
should re-initialize all your state by making method calls to the remote
side. When the connection is lost, all that state goes away (since you have
no way to know what is happening until you reconnect).

** Behavioral Changes

*** All Referenceable object are now implicitly &quot;giftable&quot;

In 0.0.3, for a Referenceable to be &quot;giftable&quot; (i.e. useable as the payload
of an introduction), two conditions had to be satisfied. #1: the object must
be published through a Tub with Tub.registerReference(obj). #2: that Tub must
have a location set (with Tub.setLocation). Once those conditions were met,
if the object was sent over a wire from this Tub to another one, the
recipient of the corresponding RemoteReference could pass it on to a third
party. Another side effect of calling registerReference() is that the Tub
retains a strongref to the object, keeping it alive (with respect to gc)
until either the Tub is shut down or the object is explicitly de-registered
with unregisterReference().

Starting in 0.0.4, the first condition has been removed. All objects which
pass through a setLocation'ed Tub will be usable as gifts. This makes it much
more convenient to use third-party references.

Note that the Tub will *not* retain a strongref to these objects (merely a
weakref), so such objects might disappear before the recipient has had a
chance to claim it. The lifecycle of gifts is a subject of much research. The
hope is that, for reasonably punctual recipients, the gift will be kept alive
until they claim it. The whole gift/introduction mechanism is likely to
change in the near future, so this lifetime issue will be revisited in a
later release.

** Build Changes

The source tree now has some support for making debian-style packages (for
both sid and dapper). 'make debian-sid' and 'make debian-dapper' ought to
create a .deb package.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="046919.html">[Twisted-Python] Weekly Bug Summary
</A></li>
	<LI>Next message (by thread): <A HREF="046822.html">[Twisted-Python] Foolscap-0.0.5 released (aka newpb)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46813">[ date ]</a>
              <a href="thread.html#46813">[ thread ]</a>
              <a href="subject.html#46813">[ subject ]</a>
              <a href="author.html#46813">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
