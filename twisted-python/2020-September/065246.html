<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] Conch SFTP Questions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Conch%20SFTP%20Questions&In-Reply-To=%3CCAFycZ9foaYnP085_J__NvVfFyCf-b7E3jedp_zyWhka96qKVPw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="065245.html">
   <LINK REL="Next"  HREF="065248.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] Conch SFTP Questions</H1>
    <B>Adi Roiban</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20Conch%20SFTP%20Questions&In-Reply-To=%3CCAFycZ9foaYnP085_J__NvVfFyCf-b7E3jedp_zyWhka96qKVPw%40mail.gmail.com%3E"
       TITLE="[Twisted-Python] Conch SFTP Questions">adi at roiban.ro
       </A><BR>
    <I>Tue Sep 22 13:56:37 MDT 2020</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="065245.html">[Twisted-Python] Conch SFTP Questions
</A></li>
        <LI>Next message (by thread): <A HREF="065248.html">[Twisted-Python] Conch SFTP Questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65246">[ date ]</a>
              <a href="thread.html#65246">[ thread ]</a>
              <a href="subject.html#65246">[ subject ]</a>
              <a href="author.html#65246">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Robers

On Tue, 22 Sep 2020 at 16:43, Robert DiFalco &lt;<A HREF="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">robert.difalco at gmail.com</A>&gt;
wrote:

&gt;<i> Hey folks, I've cobbled together an SFTP client based on bits and pieces
</I>&gt;<i> I've found around the web. The issue is that it appears to be almost one
</I>&gt;<i> shot. I will need to send many files (the number not known ahead of time).
</I>&gt;<i> It's not clear to me when the connection is closed or how many factories
</I>&gt;<i> I'm creating. All the code I've grabbed looks like it's creating a new
</I>&gt;<i> factory for every SFTP file I send. Here's some of the code I have. It's
</I>&gt;<i> fairly straight forward in that it creates a directory if it doesn't exist
</I>&gt;<i> and then writes a file.
</I>&gt;<i>
</I>&gt;<i> @attr.s(frozen=True)
</I>&gt;<i> class FileInfo(object):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Class that tells SFTP details about the file to send.
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     directory = attr.ib(converter=str)  # type: str
</I>&gt;<i>     name = attr.ib(converter=str)  # type: str
</I>&gt;<i>     data = attr.ib()  # type: str
</I>&gt;<i>     chunk_size = attr.ib(converter=int, default=CHUNK_SIZE)  # type: int
</I>&gt;<i>
</I>&gt;<i>     def to_path(self):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Turns the folder and file name into a file path.
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         return self.directory + &quot;/&quot; + self.name
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @attr.s(frozen=True)
</I>&gt;<i> class SFTPClientOptions(object):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Client options for sending SFTP files.
</I>&gt;<i>
</I>&gt;<i>     :param host: the host of the SFTP server
</I>&gt;<i>     :param port: the port ofo the SFTP server
</I>&gt;<i>     :param fingerprint: the expected fingerprint of the host
</I>&gt;<i>     :param user: the user to login as
</I>&gt;<i>     :param identity: the identity file, optional and like the &quot;-i&quot; command line option
</I>&gt;<i>     :param password: an optional password
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     host = attr.ib(converter=str)  # type: str
</I>&gt;<i>     port = attr.ib(converter=int)  # type: int
</I>&gt;<i>     fingerprint = attr.ib(converter=str)  # type: str
</I>&gt;<i>     user = attr.ib(converter=str)  # type: str
</I>&gt;<i>     identity = attr.ib(converter=optional(str), default=None)  # type: Optional[str]
</I>&gt;<i>     password = attr.ib(converter=optional(str), default=None)  # type: Optional[str]
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @inlineCallbacks
</I>&gt;<i> def sftp_send(client_options, file_info):
</I>&gt;<i>     # type: (SFTPClientOptions, FileInfo)-&gt;Deferred
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Primary function to send an file over SFTP. You can send a password, identity, or both.
</I>&gt;<i>     :param client_options: the client connection options
</I>&gt;<i>     :param file_info: contains the file info to write
</I>&gt;<i>     :return: A deferred that signals &quot;OK&quot; if successful.
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     options = ClientOptions()
</I>&gt;<i>     options[&quot;host&quot;] = client_options.host
</I>&gt;<i>     options[&quot;port&quot;] = client_options.port
</I>&gt;<i>     options[&quot;password&quot;] = client_options.password
</I>&gt;<i>     options[&quot;fingerprint&quot;] = client_options.fingerprint
</I>&gt;<i>
</I>&gt;<i>     if client_options.identity:
</I>&gt;<i>         options.identitys = [client_options.identity]
</I>&gt;<i>
</I>&gt;<i>     conn = SFTPConnection()
</I>&gt;<i>     auth = SFTPUserAuthClient(client_options.user, options, conn)
</I>&gt;<i>     yield connect(client_options.host, client_options.port, options, _verify_host_key, auth)
</I>&gt;<i>
</I>&gt;<i>     sftpClient = yield conn.getSftpClientDeferred()
</I>&gt;<i>     yield _send_file(sftpClient, file_info)
</I>&gt;<i>
</I>&gt;<i>     returnValue(&quot;OK&quot;)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> def _verify_host_key(transport, host, pubKey, fingerprint):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Verify a host's key. Based on what is specified in options.
</I>&gt;<i>
</I>&gt;<i>     @param host: Due to a bug in L{SSHClientTransport.verifyHostKey}, this is
</I>&gt;<i>     always the dotted-quad IP address of the host being connected to.
</I>&gt;<i>     @type host: L{str}
</I>&gt;<i>
</I>&gt;<i>     @param transport: the client transport which is attempting to connect to
</I>&gt;<i>     the given host.
</I>&gt;<i>     @type transport: L{SSHClientTransport}
</I>&gt;<i>
</I>&gt;<i>     @param fingerprint: the fingerprint of the given public key, in
</I>&gt;<i>     xx:xx:xx:... format.
</I>&gt;<i>
</I>&gt;<i>     @param pubKey: The public key of the server being connected to.
</I>&gt;<i>     @type pubKey: L{str}
</I>&gt;<i>
</I>&gt;<i>     @return: a L{Deferred} which is success or error
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     expected = transport.factory.options.get(&quot;fingerprint&quot;, &quot;no_fingerprint&quot;)
</I>&gt;<i>     if fingerprint == expected:
</I>&gt;<i>         return succeed(1)
</I>&gt;<i>
</I>&gt;<i>     log.error(
</I>&gt;<i>         &quot;SSH Host Key fingerprint of ({fp}) does not match the expected value of ({expected}).&quot;,
</I>&gt;<i>         fp=fingerprint, expected=expected)
</I>&gt;<i>
</I>&gt;<i>     return fail(ConchError(&quot;Host fingerprint is unexpected.&quot;))
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class SFTPSession(SSHChannel):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Creates an SFTP session.
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     name = &quot;session&quot;
</I>&gt;<i>
</I>&gt;<i>     @inlineCallbacks
</I>&gt;<i>     def channelOpen(self, whatever):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Called when the channel is opened.  &quot;whatever&quot; is any data that the
</I>&gt;<i>         other side sent us when opening the channel.
</I>&gt;<i>
</I>&gt;<i>         @type whatever: L{bytes}
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         yield self.conn.sendRequest(self, &quot;subsystem&quot;, NS(&quot;sftp&quot;), wantReply=True)
</I>&gt;<i>
</I>&gt;<i>         client = FileTransferClient()
</I>&gt;<i>         client.makeConnection(self)
</I>&gt;<i>         self.dataReceived = client.dataReceived
</I>&gt;<i>         self.conn.notifyClientIsReady(client)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class SFTPConnection(SSHConnection):
</I>&gt;<i>     def __init__(self):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Adds a deferred here so client can add a callback when the SFTP client is ready.
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         SSHConnection.__init__(self)
</I>&gt;<i>         self._sftpClient = Deferred()
</I>&gt;<i>
</I>&gt;<i>     def serviceStarted(self):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Opens an SFTP session when the SSH connection has been started.
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         self.openChannel(SFTPSession())
</I>&gt;<i>
</I>&gt;<i>     def notifyClientIsReady(self, client):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Trigger callbacks associated with our SFTP client deferred. It's ready!
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         self._sftpClient.callback(client)
</I>&gt;<i>
</I>&gt;<i>     def getSftpClientDeferred(self):
</I>&gt;<i>         return self._sftpClient
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class SFTPUserAuthClient(SSHUserAuthClient):
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Twisted Conch doesn't have a way of getting a password. By default it gets it from stdin. This allows it
</I>&gt;<i>     to be retrieved from options instead.
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     def getPassword(self, prompt = None):
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         Get the password from the client options, is specified.
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         if &quot;password&quot; in self.options:
</I>&gt;<i>             return succeed(self.options[&quot;password&quot;])
</I>&gt;<i>
</I>&gt;<i>         return SSHUserAuthClient.getPassword(self, prompt)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @inlineCallbacks
</I>&gt;<i> def _send_file(client, file_info):
</I>&gt;<i>     # type: (FileTransferClient, FileInfo) -&gt; Deferred
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Creates a directory if required and then creates the file.
</I>&gt;<i>     :param client: the SFTP client to use
</I>&gt;<i>     :param file_info: contains file name, directory, and data
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     try:
</I>&gt;<i>         yield client.makeDirectory(file_info.directory, {})
</I>&gt;<i>
</I>&gt;<i>     except SFTPError as e:
</I>&gt;<i>         # In testing on various system, either a 4 or an 11 will indicate the directory
</I>&gt;<i>         # already exist. We are fine with that and want to continue if it does. If we misinterpreted
</I>&gt;<i>         # error code here we are probably still ok since we will just get the more systemic error
</I>&gt;<i>         # again on the next call to openFile.
</I>&gt;<i>         if e.code != 4 and e.code != 11:
</I>&gt;<i>             raise e
</I>&gt;<i>
</I>&gt;<i>     f = yield client.openFile(file_info.to_path(), FXF_WRITE | FXF_CREAT | FXF_TRUNC, {})
</I>&gt;<i>
</I>&gt;<i>     try:
</I>&gt;<i>         yield _write_chunks(f, file_info.data, file_info.chunk_size)
</I>&gt;<i>
</I>&gt;<i>     finally:
</I>&gt;<i>         yield f.close()
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @inlineCallbacks
</I>&gt;<i> def _write_chunks(f, data, chunk_size):
</I>&gt;<i>     # type: (ClientFile, str, int) -&gt; Deferred
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     Convenience function to write data in chunks
</I>&gt;<i>
</I>&gt;<i>     :param f: the file to write to
</I>&gt;<i>     :param data: the data to write
</I>&gt;<i>     :param chunk_size: the chunk size
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     for offset in range(0, len(data), chunk_size):
</I>&gt;<i>         chunk = data[offset: offset + chunk_size]
</I>&gt;<i>         yield f.writeChunk(offset, chunk)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It gets called like this:
</I>&gt;<i>
</I>&gt;<i> return sftp.sftp_send(
</I>&gt;<i>     client_options=SFTPClientOptions(
</I>&gt;<i>         host=self.options.host,
</I>&gt;<i>         port=self.options.port,
</I>&gt;<i>         user=self.options.user,
</I>&gt;<i>         fingerprint=self.options.fingerprint,
</I>&gt;<i>         identity=getattr(self.options, &quot;identity&quot;, None),
</I>&gt;<i>         password=self._getPassword()),
</I>&gt;<i>     file_info=sftp.FileInfo(
</I>&gt;<i>         directory=self.options.directory,
</I>&gt;<i>         name=fileName,
</I>&gt;<i>         data=data,
</I>&gt;<i>         chunk_size=getattr(self.options, &quot;chunkSize&quot;, sftp.CHUNK_SIZE)))
</I>&gt;<i>
</I>&gt;<i> But I supposed I'd like to see something more like this:
</I>&gt;<i>
</I>&gt;<i> sftpClient = self.getSftpClient(
</I>&gt;<i>     client_options=SFTPClientOptions(
</I>&gt;<i>         host=self.options.host,
</I>&gt;<i>         port=self.options.port,
</I>&gt;<i>         user=self.options.user,
</I>&gt;<i>         fingerprint=self.options.fingerprint,
</I>&gt;<i>         identity=getattr(self.options, &quot;identity&quot;, None),
</I>&gt;<i>         password=self._getPassword()))
</I>&gt;<i>
</I>&gt;<i> return sftpClient.send(
</I>&gt;<i>     file_info=sftp.FileInfo(
</I>&gt;<i>         directory=self.options.directory,
</I>&gt;<i>         name=fileName,
</I>&gt;<i>         data=data,
</I>&gt;<i>         chunk_size=getattr(self.options, &quot;chunkSize&quot;, sftp.CHUNK_SIZE)))
</I>&gt;<i>
</I>&gt;<i> Where sftpClient reuses the existing SSH connection if it is active
</I>&gt;<i> (rather than logging in each time). But maybe the sftp service doesn't
</I>&gt;<i> multiplex so I have to create a new SSHClientFactory every time I want to
</I>&gt;<i> send a distinct file?
</I>&gt;<i>
</I>&gt;<i> Sorry for all the questions, new to twisted and a bit confused. Thanks!
</I>&gt;<i>
</I>&gt;<i> Robert
</I>&gt;<i>
</I>&gt;<i> It would help to have the full code...maybe a gist or repo.
</I>I am not sure what `connect` from `yield connect(client_options.host,
client_options.port, options, _verify_host_key, auth)` is.

You will need to understand the low-level Twisted connection API and
implement a reconnecting factory.

When a new client-side connection is made, Twisted will use a factory to
create the protocol/code used to handle that connection,
You will then need to hook into the connectionLost method and do an
auto-connection if the connection is lost (when you were not expecting it).

---------

For my project, I am doing in this way:

I have my own subclass of FileTransferClient which overwrites the default
FileTransferClient,connectionLost method.
With that, I am notified when the SFTP subsystem was closed and I can then
trigger a new connection

-------------

If you want to reuse an SFTP session for multiple operations just reuse the
`sftpClient` instance that you got to trigger multiple operations

sftpClient = yield conn.getSftpClientDeferred()
for file_info in list_of_files_to_send:
    yield _send_file(sftpClient, file_info)

----------

Hope it helps

-- 
Adi Roiban
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;/pipermail/twisted-python/attachments/20200922/95ca83f5/attachment-0001.htm&gt;
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="065245.html">[Twisted-Python] Conch SFTP Questions
</A></li>
	<LI>Next message (by thread): <A HREF="065248.html">[Twisted-Python] Conch SFTP Questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65246">[ date ]</a>
              <a href="thread.html#65246">[ thread ]</a>
              <a href="subject.html#65246">[ subject ]</a>
              <a href="author.html#65246">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
