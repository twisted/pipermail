<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-Python] TLS support for twisted (PATCH)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20TLS%20support%20for%20twisted%20%28PATCH%29&In-Reply-To=%3C20030206011632.GP32425%40shitbomb.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="035285.html">
   <LINK REL="Next"  HREF="035265.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-Python] TLS support for twisted (PATCH)</H1>
    <B>Skinny Puppy</B> 
    <A HREF="mailto:twisted-python%40twistedmatrix.com?Subject=Re%3A%20%5BTwisted-Python%5D%20TLS%20support%20for%20twisted%20%28PATCH%29&In-Reply-To=%3C20030206011632.GP32425%40shitbomb.com%3E"
       TITLE="[Twisted-Python] TLS support for twisted (PATCH)">skin_pup-twisted at damnable.happypoo.com
       </A><BR>
    <I>Wed Feb  5 18:16:32 MST 2003</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="035285.html">[Twisted-Python] Fw: Re: Zope and Twisted
</A></li>
        <LI>Next message (by thread): <A HREF="035265.html">[Twisted-Python] TLS support for twisted (PATCH)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35264">[ date ]</a>
              <a href="thread.html#35264">[ thread ]</a>
              <a href="subject.html#35264">[ subject ]</a>
              <a href="author.html#35264">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Attached is the patch for TLS support within twisted.  It is not the best
code,  but it passes all the SSL test (None working on that next) and
works.  The diff also adds an echoclient_tls.py/echoserv_tls.py, that
work along with the echoclient_ssl.py/echoserv_tls.py

Some things I did have questions about how best to handle:

- What error should starttls raise if OpenSSL is not installed?  exarkun
  suggested the following but I have no idea how to do it cleanly.  Any
  ideas?

exarkun : currently, connect/listenSSL aren't defined at all if
          the ssl support libs can't be implemented
exarkun : might it make sense to just duplicate that?


- the doRead_TLS/doRead_NOTLS and writeSomeData_TLS/writeSomeData_NOTLS
  are just damn ugly and could be combined but I felt it was best to leave
  the apart for now.  Is OK, should I merge them?

Jeremy Rossi 


-------------- next part --------------
diff -urP Twisted-1.0.2alpha4/doc/examples/echoclient_tls.py Twisted-1.0.2alpha4-halfass-branch/doc/examples/echoclient_tls.py
--- Twisted-1.0.2alpha4/doc/examples/echoclient_tls.py	Wed Dec 31 19:00:00 1969
+++ Twisted-1.0.2alpha4-halfass-branch/doc/examples/echoclient_tls.py	Wed Feb  5 19:21:06 2003
@@ -0,0 +1,65 @@
+#!/usr/bin/python
+# Twisted, the Framework of Your Internet
+# Copyright (C) 2001 Matthew W. Lefkowitz
+# 
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of version 2.1 of the GNU Lesser General Public
+# License as published by the Free Software Foundation.
+# 
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+# 
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+from twisted.internet.protocol import ClientFactory, Protocol
+from twisted.internet.app import Application
+from twisted.internet import reactor, tcp, ssl
+import sys
+
+class myContext(ssl.ClientContextFactory):
+    isClient = 1
+    def getContext(self):
+        return ssl.SSL.Context(ssl.SSL.TLSv1_METHOD)
+
+x = myContext()
+
+class EchoClient(Protocol):
+    end=&quot;Bye-bye!&quot;
+    def connectionMade(self):
+        self.transport.write(&quot;I am sending this in the clear\n&quot;)
+        self.transport.write(&quot;And why should I not?\n&quot;)
+        self.transport.write(&quot;STARTTLS;\n&quot;)
+
+    def dataReceived(self, data):
+     	for i in data.split(&quot;\n&quot;):
+            try:
+                command, other = i.split(&quot;;&quot;, 1)
+            except:
+                command = &quot;&quot;
+                other = i
+            if command==self.end:
+                self.transport.loseConnection()
+            elif command==&quot;READY&quot;:
+                self.transport.starttls(x)
+                self.transport.write(&quot;Spooks cannot see me now.\n&quot;)
+            else:
+                print i
+
+class EchoClientFactory(ClientFactory):
+    protocol = EchoClient
+
+    def clientConnectionFailed(self, connector, reason):
+        print 'connection failed:', reason.getErrorMessage()
+        reactor.stop()
+
+    def clientConnectionLost(self, connector, reason):
+        print 'connection lost:', reason.getErrorMessage()
+        reactor.stop()
+
+factory = EchoClientFactory()
+reactor.connectTCP('localhost', 8000, factory)
+reactor.run()
diff -urP Twisted-1.0.2alpha4/doc/examples/echoserv_tls.py Twisted-1.0.2alpha4-halfass-branch/doc/examples/echoserv_tls.py
--- Twisted-1.0.2alpha4/doc/examples/echoserv_tls.py	Wed Dec 31 19:00:00 1969
+++ Twisted-1.0.2alpha4-halfass-branch/doc/examples/echoserv_tls.py	Wed Feb  5 19:20:55 2003
@@ -0,0 +1,71 @@
+
+# Twisted, the Framework of Your Internet
+# Copyright (C) 2001 Matthew W. Lefkowitz
+# 
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of version 2.1 of the GNU Lesser General Public
+# License as published by the Free Software Foundation.
+# 
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+# 
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+from twisted.internet.protocol import Protocol, Factory
+from twisted.internet import udp, ssl
+
+### Protocol Implementation
+
+# This is just about the simplest possible protocol
+
+x = ssl.DefaultOpenSSLContextFactory(privateKeyFileName=&quot;server.pem&quot;,
+                                 certificateFileName=&quot;server.pem&quot;,
+                                 sslmethod=ssl.SSL.TLSv1_METHOD)
+
+
+class Echo(Protocol):
+    def dataReceived(self, data):
+        &quot;As soon as any data is received, write it back.&quot;
+        print data
+        try:
+            command, other = data.split(&quot;;&quot;, 1)
+        except:
+            command = data
+            other = &quot;&quot;
+        if command == &quot;STARTTLS&quot;:
+            print &quot;starting TLS&quot;
+            self.transport.write(&quot;READY;ajshdakjsd\n&quot;)
+            self.transport.starttls(x)
+#            self.transport.socket.set_accept_state()
+        else:
+            self.transport.write(data)
+
+
+### Persistent Application Builder
+
+# This builds a .tap file
+class EchoClientFactory(Factory):
+    protocol = Echo
+    def connectionFailed(self, connector, reason):
+        print 'connection failed:', reason.getErrorMessage()
+
+    def connectionLost(self, connector, reason):
+        print 'connection lost:', reason.getErrorMessage()
+
+
+if __name__ == '__main__':
+    # Since this is persistent, it's important to get the module naming right
+    # (If we just used Echo, then it would be __main__.Echo when it attempted
+    # to unpickle)
+    import echoserv_tls
+    from twisted.internet.app import Application
+    factory = echoserv_tls.EchoClientFactory()
+    factory.protocol = echoserv_tls.Echo
+    app = Application(&quot;echo-tls&quot;)
+    app.listenTCP(8000,factory)
+#    app.listenUDP(8000, factory)
+    app.save(&quot;start&quot;)
diff -urP Twisted-1.0.2alpha4/twisted/internet/ssl.py Twisted-1.0.2alpha4-halfass-branch/twisted/internet/ssl.py
--- Twisted-1.0.2alpha4/twisted/internet/ssl.py	Wed Jan  8 09:18:53 2003
+++ Twisted-1.0.2alpha4-halfass-branch/twisted/internet/ssl.py	Wed Feb  5 19:20:06 2003
@@ -40,11 +40,11 @@
 import socket
 
 # sibling imports
-import tcp, main, interfaces
+import main, interfaces, tcp
 
 # Twisted imports
 from twisted.python import log
-
+#from twisted.internet import reactor
 
 class ContextFactory:
     &quot;&quot;&quot;A factory for SSL context objects, for server SSL connections.&quot;&quot;&quot;
@@ -95,101 +95,7 @@
         return SSL.Context(SSL.SSLv3_METHOD)
 
 
-class Connection(tcp.Connection):
-    &quot;&quot;&quot;I am an SSL connection.
-    &quot;&quot;&quot;
-
-    __implements__ = tcp.Connection.__implements__, interfaces.ISSLTransport
-    
-    writeBlockedOnRead = 0
-    readBlockedOnWrite= 0
-    sslShutdown = 0
-    
-    def getPeerCertificate(self):
-        &quot;&quot;&quot;Return the certificate for the peer.&quot;&quot;&quot;
-        return self.socket.get_peer_certificate()
-
-    def _postLoseConnection(self):
-        &quot;&quot;&quot;Gets called after loseConnection(), after buffered data is sent.
-
-        We close the SSL transport layer, and if the other side hasn't
-        closed it yet we start reading, waiting for a ZeroReturnError
-        which will indicate the SSL shutdown has completed.
-        &quot;&quot;&quot;
-        try:
-            done = self.socket.shutdown()
-            self.sslShutdown = 1
-        except SSL.Error:
-            return main.CONNECTION_LOST
-        if done:
-            return main.CONNECTION_DONE
-        else:
-            # we wait for other side to close SSL connection -
-            # this will be signaled by SSL.ZeroReturnError when reading
-            # from the socket
-            self.stopWriting()
-            self.startReading()
-            return None # don't close socket just yet
-    
-    def doRead(self):
-        &quot;&quot;&quot;See tcp.Connection.doRead for details.
-        &quot;&quot;&quot;
-        if self.writeBlockedOnRead:
-            self.writeBlockedOnRead = 0
-            return self.doWrite()
-        try:
-            return tcp.Connection.doRead(self)
-        except SSL.ZeroReturnError:
-            # close SSL layer, since other side has done so, if we haven't
-            if not self.sslShutdown:
-                try:
-                    self.socket.shutdown()
-                    self.sslShutdown = 1
-                except SSL.Error:
-                    pass
-            return main.CONNECTION_DONE
-        except SSL.WantReadError:
-            return
-        except SSL.WantWriteError:
-            self.readBlockedOnWrite = 1
-            self.startWriting()
-            return
-        except SSL.Error:
-            return main.CONNECTION_LOST
-
-    def doWrite(self):
-        if self.readBlockedOnWrite:
-            self.readBlockedOnWrite = 0
-            if not self.unsent: self.stopWriting()
-            return self.doRead()
-        return tcp.Connection.doWrite(self)
-    
-    def writeSomeData(self, data):
-        &quot;&quot;&quot;See tcp.Connection.writeSomeData for details.
-        &quot;&quot;&quot;
-        if not data:
-            return 0
-
-        try:
-            return tcp.Connection.writeSomeData(self, data)
-        except SSL.WantWriteError:
-            return 0
-        except SSL.WantReadError:
-            self.writeBlockedOnRead = 1
-            return 0
-        except SSL.Error:
-            return main.CONNECTION_LOST
-
-    def _closeSocket(self):
-        &quot;&quot;&quot;Called to close our socket.&quot;&quot;&quot;
-        try:
-            self.socket.sock_shutdown(2)
-        except socket.error:
-            pass
-
-
-
-class Client(Connection, tcp.TCPClient):
+class Client(tcp.TCPClient):
     &quot;&quot;&quot;I am an SSL client.
     &quot;&quot;&quot;
     
@@ -197,11 +103,15 @@
         self.ctxFactory = ctxFactory
         tcp.TCPClient.__init__(self, host, port, bindAddress, connector, reactor)
     
+    def _finishInit(self, whenDone, skt, error, reactor):
+        tcp.TCPClient._finishInit(self, whenDone, skt, error, reactor)
+        self.starttls(self.ctxFactory)
+
     def createInternetSocket(self):
         &quot;&quot;&quot;(internal) create an SSL socket
         &quot;&quot;&quot;
         sock = tcp.TCPClient.createInternetSocket(self)
-        return SSL.Connection(self.ctxFactory.getContext(), sock)
+        return sock
 
     def getHost(self):
         &quot;&quot;&quot;Returns a tuple of ('SSL', hostname, port).
@@ -220,13 +130,14 @@
 
 
 
-class Server(Connection, tcp.Server):
+class Server(tcp.Connection, tcp.Server):
     &quot;&quot;&quot;I am an SSL server.
     &quot;&quot;&quot;
     
     def __init__(*args, **kwargs):
         # we need those so we don't use ssl.Connection's __init__
         apply(tcp.Server.__init__, args, kwargs)
+        
 
     def getHost(self):
         &quot;&quot;&quot;Returns a tuple of ('SSL', hostname, port).
@@ -258,7 +169,8 @@
         &quot;&quot;&quot;(internal) create an SSL socket
         &quot;&quot;&quot;
         sock = tcp.Port.createInternetSocket(self)
-        return SSL.Connection(self.ctxFactory.getContext(), sock)
+        sock = SSL.Connection(self.ctxFactory.getContext(), sock)
+        return sock
     
     def doRead(self):
         &quot;&quot;&quot;Called when my socket is ready for reading.
@@ -283,6 +195,7 @@
             s = self.sessionno
             self.sessionno = s+1
             transport = self.transport(skt, protocol, addr, self, s)
+            transport.TLS = 1
             protocol.makeConnection(transport)
         except:
             log.deferr()
diff -urP Twisted-1.0.2alpha4/twisted/internet/tcp.py Twisted-1.0.2alpha4-halfass-branch/twisted/internet/tcp.py
--- Twisted-1.0.2alpha4/twisted/internet/tcp.py	Wed Jan  1 09:32:27 2003
+++ Twisted-1.0.2alpha4-halfass-branch/twisted/internet/tcp.py	Wed Feb  5 19:20:02 2003
@@ -34,6 +34,10 @@
 import select
 import operator
 import warnings
+try:
+    from OpenSSL import SSL
+except:
+    SSL = None
 
 if os.name == 'nt':
     EINVAL      = 10022
@@ -73,6 +77,10 @@
     This is an abstract superclass of all objects which represent a TCP/IP
     connection based socket.
     &quot;&quot;&quot;
+    writeBlockedOnRead = 0
+    readBlockedOnWrite= 0
+    sslShutdown = 0
+    TLS = 0
 
     __implements__ = abstract.FileDescriptor.__implements__, interfaces.ITCPTransport
 
@@ -83,7 +91,47 @@
         self.fileno = skt.fileno
         self.protocol = protocol
 
+    def starttls(self, ctx):
+        self._oldsocket = self.socket
+        self.socket = SSL.Connection(ctx.getContext(), self.socket)
+        self.fileno = self.socket.fileno
+        self.TLS = 1
+
+    def stoptls(self):
+        self.socket = self._oldsocket
+        self.TLS = 0
+
     def doRead(self):
+        if self.TLS:
+            return self.doRead_TLS()
+        else:
+            return self.doRead_NOTLS()
+
+    def doRead_TLS(self):
+        if self.writeBlockedOnRead:
+            self.writeBlockedOnRead = 0
+            return self.doWrite()
+        try:
+            return self.doRead_NOTLS()
+        except SSL.ZeroReturnError:
+            # close SSL layer, since other side has done so, if we haven't
+            if not self.sslShutdown:
+                try:
+                    self.socket.shutdown()
+                    self.sslShutdown = 1
+                except SSL.Error:
+                    pass
+            return main.CONNECTION_DONE
+        except SSL.WantReadError:
+            return
+        except SSL.WantWriteError:
+            self.readBlockedOnWrite = 1
+            self.startWriting()
+            return
+        except SSL.Error:
+            return main.CONNECTION_LOST
+
+    def doRead_NOTLS(self):
         &quot;&quot;&quot;Calls self.protocol.dataReceived with all available data.
 
         This reads up to self.bufferSize bytes of data from its socket, then
@@ -102,7 +150,36 @@
             return main.CONNECTION_LOST
         return self.protocol.dataReceived(data)
 
+    
+    def doWrite(self):
+        if self.TLS:
+            if self.readBlockedOnWrite:
+                self.readBlockedOnWrite = 0
+                if not self.unsent: self.stopWriting()
+                return self.doRead()
+        return abstract.FileDescriptor.doWrite(self)
+
     def writeSomeData(self, data):
+        if self.TLS:
+            return self.writeSomeData_TLS(data)
+        else:
+            return self.writeSomeData_NOTLS(data)
+
+
+    def writeSomeData_TLS(self, data):
+        if not data:
+            return 0
+        try:
+            return self.writeSomeData_NOTLS(data)
+        except SSL.WantWriteError:
+            return 0
+        except SSL.WantReadError:
+            self.writeBlockedOnRead = 1
+            return 0
+        except SSL.Error:
+            return main.CONNECTION_LOST
+
+    def writeSomeData_NOTLS(self, data):
         &quot;&quot;&quot;Connection.writeSomeData(data) -&gt; #of bytes written | CONNECTION_LOST
         This writes as much data as possible to the socket and returns either
         the number of bytes read (which is positive) or a connection error code
@@ -123,7 +200,10 @@
         # was inherited by a subprocess. And we really do want to close the
         # connection. So we use shutdown() instead.
         try:
-            self.socket.shutdown(2)
+            if self.TLS:
+                self.socket.sock_shutdown(2)
+            else:
+                self.socket.shutdown(2)
         except socket.error:
             pass
 
@@ -162,11 +242,45 @@
     def setTcpNoDelay(self, enabled):
         self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, enabled)
 
+    def getPeerCertificate(self):
+        &quot;&quot;&quot;Return the certificate for the peer.&quot;&quot;&quot;
+        return self.socket.get_peer_certificate()
+
+    def _postLoseConnection(self):
+        &quot;&quot;&quot;Gets called after loseConnection(), after buffered data is sent.
+
+        We close the SSL transport layer, and if the other side hasn't
+        closed it yet we start reading, waiting for a ZeroReturnError
+        which will indicate the SSL shutdown has completed.
+        &quot;&quot;&quot;
+        if self.TLS:
+            try:
+                done = self.socket.shutdown()
+                self.sslShutdown = 1
+            except SSL.Error:
+                return main.CONNECTION_LOST
+            if done:
+                return main.CONNECTION_DONE
+            else:
+                # we wait for other side to close SSL connection -
+                # this will be signaled by SSL.ZeroReturnError when reading
+                # from the socket
+                self.stopWriting()
+                self.startReading()
+                return None # don't close socket just yet
+        else:
+            print &quot;quiting&quot;
+            return main.CONNECTION_DONE
 
 class BaseClient(Connection):
     &quot;&quot;&quot;A base class for client TCP (and similiar) sockets.
     &quot;&quot;&quot;
 
+    def starttls(self, ctx):
+        holder = Connection.starttls(self, ctx)
+        self.socket.set_connect_state()
+        return holder
+
     def _finishInit(self, whenDone, skt, error, reactor):
         &quot;&quot;&quot;Called by base classes to continue to next stage of initialization.&quot;&quot;&quot;
         if whenDone:
@@ -360,6 +474,12 @@
         self.startReading()
         self.connected = 1
 
+
+    def starttls(self, ctx):
+        holder = Connection.starttls(self, ctx)
+        self.socket.set_accept_state()
+        return holder
+
     def __repr__(self):
         &quot;&quot;&quot;A string representation of this connection.
         &quot;&quot;&quot;
@@ -489,6 +609,11 @@
                         self.numberAccepts = i
                         break
                     raise
+                # XXX Hummmmmmmmmmmmmm what to do about this
+                except SSL.Error:
+                    if self.TLS:
+                        log.deferr()
+                        return
                 protocol = self.factory.buildProtocol(addr)
                 if protocol is None:
                     skt.close()
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="035285.html">[Twisted-Python] Fw: Re: Zope and Twisted
</A></li>
	<LI>Next message (by thread): <A HREF="035265.html">[Twisted-Python] TLS support for twisted (PATCH)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35264">[ date ]</a>
              <a href="thread.html#35264">[ thread ]</a>
              <a href="subject.html#35264">[ subject ]</a>
              <a href="author.html#35264">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">More information about the Twisted-Python
mailing list</a><br>
</body></html>
