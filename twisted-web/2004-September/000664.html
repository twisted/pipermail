<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: [Web-SIG] WSGI woes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20WSGI%20woes&In-Reply-To=4149E99B.3060003%40xhaus.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000663.html">
   <LINK REL="Next"  HREF="000665.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: [Web-SIG] WSGI woes</H1>
    <B>Phillip J. Eby</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20WSGI%20woes&In-Reply-To=4149E99B.3060003%40xhaus.com"
       TITLE="[Twisted-web] Re: [Web-SIG] WSGI woes">pje at telecommunity.com
       </A><BR>
    <I>Thu Sep 16 14:08:48 MDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000663.html">[Twisted-web] Draft language for WSGI to forbid blocking by
	middleware
</A></li>
        <LI>Next message: <A HREF="000665.html">[Twisted-web] Re: [Web-SIG] WSGI woes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#664">[ date ]</a>
              <a href="thread.html#664">[ thread ]</a>
              <a href="subject.html#664">[ subject ]</a>
              <a href="author.html#664">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 08:29 PM 9/16/04 +0100, Alan Kennedy wrote:
&gt;<i>[Alan Kennedy]
</I>&gt;<i> &gt;&gt; In an asynchronous situation, the application cannot simply do a
</I>&gt;<i> &gt;&gt; blocking read on the input: that will tie up the server thread.
</I>&gt;<i>
</I>&gt;<i>[Phillip J. Eby]
</I>&gt;<i> &gt; What do you mean by &quot;server thread&quot;?  A truly asynchronous server (one
</I>&gt;<i> &gt; using &quot;no threads&quot;) cannot serve multiple WSGI requests
</I>&gt;<i> &gt; simultaneously.  In the general case, a WSGI server can only serve as
</I>&gt;<i> &gt; many requests simultaneously as it has available threads for.
</I>&gt;<i>
</I>&gt;<i>Sorry, I should have paid more attention to phrasing in this context.
</I>&gt;<i>
</I>&gt;<i>By  &quot;server thread&quot; I mean the thread of execution that is running the 
</I>&gt;<i>select/poll operation in the server (which needs at least *one* thread). 
</I>&gt;<i>If the application did a blocking read of the input running in a simple, 
</I>&gt;<i>single-threaded asyncore-style server, that single thread would block, 
</I>&gt;<i>holding up event processing.
</I>
Right, which is (one reason) why a WSGI server can in the general case only 
serve as many WSGI requests simultaneously as it has available threads for, 
although it's possible to improve on that worst-case condition by 
appropriate use of iterators.


&gt;<i>But I don't see the need for pausing logic or queues? Why can't the server 
</I>&gt;<i>simply call directly into the application, e.g. using a &quot;process_input&quot; 
</I>&gt;<i>method, in effect saying &quot;you have some input ready&quot;.
</I>&gt;<i>
</I>&gt;<i>And I'm not sure I see the need for the application to check that the 
</I>&gt;<i>wsgi.input hasn't been replaced: if there were middleware further down 
</I>&gt;<i>that stack that was intercepting and transforming the input stream, then 
</I>&gt;<i>*it* should be the one receiving the asynchronous notification from the 
</I>&gt;<i>server. This lower level component would then read some input, process it, 
</I>&gt;<i>and then call a &quot;process_input&quot; method on the next component up in the 
</I>&gt;<i>stack, etc, etc.
</I>&gt;<i>
</I>&gt;<i>I suppose I'm talking about the server &quot;pushing&quot; the input through the 
</I>&gt;<i>middleware stack, whereas you're talking about the application at the stop 
</I>&gt;<i>of the stack &quot;pulling&quot; the data up through the stack. Is that right?
</I>
That's correct, and that's what I'm trying to avoid if at all possible, 
because it enormously complicates middleware, to the sole benefit of 
asynchronous apps -- that mostly aren't going to be portable anyway.

So, going by STASCTAP theory (Simple Things Are Simple, Complex Things Are 
Possible), the pause/resume approach makes asynchronous applications 
*possible*, while keeping the nominal synchronous cases and middleware 
*simple*.


&gt;<i>And I'd be interested to see how your approach would handle a situation 
</I>&gt;<i>where there is both streaming input and output. For example, a server that 
</I>&gt;<i>takes strings of any length, say 10**9 bytes, and .encode('rot13')'s each 
</I>&gt;<i>byte in turn, before sending it back to the client.
</I>
Presumably, the function to pause for input needs to take a minimum length, 
or have some way to communicate available length to the application.

I don't pretend to fully understand the needed use cases here, because I 
have little experience writing web applications that need to wait on other 
network services (other than databases) while a client is waiting.  And if 
I were writing an asynchronous server, I'd probably at least consider using 
Greenlets to context-switch blocking operations so that they wouldn't tie 
up an active thread.  Such an approach is conceptually easier to deal with, 
IMO, than writing everything in continuation-passing style.

But I *do* want WSGI to make it *possible* to meet async apps' use cases, 
which is why I'm seeking input from those that do have the relevant 
experience.  The trade-off is that it shouldn't excessively complicate 
nominal compliance with WSGI.  In particular, I'd prefer that the current 
&quot;example CGI gateway&quot; in PEP 333 not require any major changes or 
significant expansion.


</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000663.html">[Twisted-web] Draft language for WSGI to forbid blocking by
	middleware
</A></li>
	<LI>Next message: <A HREF="000665.html">[Twisted-web] Re: [Web-SIG] WSGI woes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#664">[ date ]</a>
              <a href="thread.html#664">[ thread ]</a>
              <a href="subject.html#664">[ subject ]</a>
              <a href="author.html#664">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
