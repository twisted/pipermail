<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: [Web-SIG] WSGI woes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20WSGI%20woes&In-Reply-To=4149C330.8060009%40xhaus.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000660.html">
   <LINK REL="Next"  HREF="000663.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: [Web-SIG] WSGI woes</H1>
    <B>Phillip J. Eby</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20WSGI%20woes&In-Reply-To=4149C330.8060009%40xhaus.com"
       TITLE="[Twisted-web] Re: [Web-SIG] WSGI woes">pje at telecommunity.com
       </A><BR>
    <I>Thu Sep 16 11:41:54 MDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000660.html">[Twisted-web] Re: [Web-SIG] WSGI woes
</A></li>
        <LI>Next message: <A HREF="000663.html">[Twisted-web] Draft language for WSGI to forbid blocking by
	middleware
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#662">[ date ]</a>
              <a href="thread.html#662">[ thread ]</a>
              <a href="subject.html#662">[ subject ]</a>
              <a href="author.html#662">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 05:45 PM 9/16/04 +0100, Alan Kennedy wrote:
&gt;<i>The only thing I disagree on are the names &quot;sleep&quot; and &quot;wake&quot;, which IMHO 
</I>&gt;<i>come with too many semantic hangovers from the threading world. When an 
</I>&gt;<i>application calls wsgi.sleep(), it's not really sleeping, it's just 
</I>&gt;<i>declaring that it currently has no output: a call to its iterator will 
</I>&gt;<i>succeed, but the returned value will be an empty string.
</I>&gt;<i>
</I>&gt;<i>So basically, WSGI is providing an on/off indicator for every instance of 
</I>&gt;<i>a middleware stack, which indicates to the server if there is currently 
</I>&gt;<i>output available.
</I>
Well, I'm proposing it as an optional extension, not a required 
feature.  And, I think I'd like to streamline it to a single 
'wsgi.pause_output' function, e.g.:

     resume = environ['wsgi.pause_output']()

Where 'resume' is then a callback function that can be invoked to resume 
iteration.  This keeps it to a single extension key, helps ensure the 
correct sequence of actions, and makes it easier to implement in some 
cases, while not making other cases any harder.


&gt;<i>In an asynchronous situation, the application cannot simply do a blocking 
</I>&gt;<i>read on the input: that will tie up the server thread.
</I>
What do you mean by &quot;server thread&quot;?  A truly asynchronous server (one 
using &quot;no threads&quot;) cannot serve multiple WSGI requests simultaneously.  In 
the general case, a WSGI server can only serve as many requests 
simultaneously as it has available threads for.  However, WSGI applications 
that use iteration in place of 'write()' can sometimes be run with fewer 
than one thread per simultaneous request -- that's why iteration is 
recommended for applications that can be implemented that way.


&gt;<i>  So we need a way for the application to be notified/called when input 
</I>&gt;<i> becomes available from the client.
</I>&gt;<i>
</I>&gt;<i>Perhaps we need to add an environment entry, e.g. &quot;wsgi.input_handler&quot;, 
</I>&gt;<i>which the app uses to pass a callable to the server. This callable would 
</I>&gt;<i>be called whenever data became available on the input stream.
</I>&gt;<i>
</I>&gt;<i>So how would that work in the middleware stack?
</I>
You would have to pass either 'environ' or 'wsgi.input' *into* this input 
handler request function, so that the server can verify it hasn't been 
replaced by any middleware.  This is the standard way in WSGI of providing 
enhanced communication facilities that could &quot;bypass&quot; middleware.  See:

     <A HREF="http://www.python.org/peps/pep-0333.html#server-extension-apis">http://www.python.org/peps/pep-0333.html#server-extension-apis</A>

So, in principle, if the spec is modified to require middleware to honor 
child applications' block boundaries, then you could use an extension API 
to pause iteration until input is available, in much the same way that you 
would pause iteration for any other reason.

Neither of these &quot;pause iteration&quot; solutions are especially elegant, at 
least from the POV of an async application author.  But my objective here 
is only to make it *possible*, not necessarily pretty.  I imagine that if 
there's actual demand for async apps to run under WSGI, it should be 
possible to create wrappers to let an application written in Twisted's 
continuation-passing style be run as a WSGI app.

Such a wrapper would basically be just a function returning an iterator, 
with a bunch of pausing logic and a queue to communicate with the actual 
asynchronous app.  And, such wrappers should only need to be written once 
for each asynchronous API, which as a practical matter probably means only 
Twisted, anyway, as (IMO) it has no real competitors in the Python async 
framework space.


</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000660.html">[Twisted-web] Re: [Web-SIG] WSGI woes
</A></li>
	<LI>Next message: <A HREF="000663.html">[Twisted-web] Draft language for WSGI to forbid blocking by
	middleware
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#662">[ date ]</a>
              <a href="thread.html#662">[ thread ]</a>
              <a href="subject.html#662">[ subject ]</a>
              <a href="author.html#662">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
