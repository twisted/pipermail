<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] html cache with timeout
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20html%20cache%20with%20timeout&In-Reply-To=20050202075614.21318.1291353150.divmod.quotient.788%40ohm">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001140.html">
   <LINK REL="Next"  HREF="001143.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] html cache with timeout</H1>
    <B>Andrea Arcangeli</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20html%20cache%20with%20timeout&In-Reply-To=20050202075614.21318.1291353150.divmod.quotient.788%40ohm"
       TITLE="[Twisted-web] html cache with timeout">andrea at cpushare.com
       </A><BR>
    <I>Wed Feb  2 11:12:29 MST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001140.html">[Twisted-web] html cache with timeout
</A></li>
        <LI>Next message: <A HREF="001143.html">[Twisted-web] html cache with timeout
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1141">[ date ]</a>
              <a href="thread.html#1141">[ thread ]</a>
              <a href="subject.html#1141">[ subject ]</a>
              <a href="author.html#1141">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Feb 02, 2005 at 07:56:14AM +0000, Valentino Volonghi wrote:
&gt;<i> The benefits are that it scales to multiple computers, which means a
</I>&gt;<i> better way to distribute the load. But, as I said, it's just one of
</I>&gt;<i> the possible backends.
</I>
For most common sites, I doubt the gain of scaling the caching could
ever be significant. There's so much memory on each system that local
caching w/o context switches and w/o interprocess communication makes
more sense IMHO. Especially if you can get to the data in almost
constant time with hashes. I get a 4/5msec total time for each page with
local caching in the httprender, it would probably get at visible
slowdown if I were to access the cache remotely through sockets.

Anyway I'm not against options, infact I'd like to keep the option
myself to use the so handy and trivial to use httprender cache ;), I'm
just prioritizing on what's is more important first ;)

&gt;<i> In weever I did a test, and I simply put this in the base class where
</I>&gt;<i> I fill the content slot (each page is a main page which contains a
</I>&gt;<i> content slot that is filled with the content Fragment):
</I>&gt;<i> 
</I>&gt;<i> t.cached(name=str(self.__class__)+IA(ctx).get('uid', ''), lifetime=10)[...]
</I>
Isn't that going to leak memory badly with tons of users seldom
accessing the site? At least for my usage I can't do the above or it
would risk to run my app out of memory.  lifetime isn't a timer, so
it'll never be freed.

To get automatic garbage collection one should store it in the
session, or at least attach a timer that fires indipendently if the
rendering is enabled or not.

&gt;<i> Doing this in the main baseclass gave me caching on ALL pages with a per/user cache.
</I>&gt;<i> Anyway this is just an implementation problem. Nobody stops you from doing:
</I>&gt;<i> 
</I>&gt;<i> def myHttpCache(ctx, lifetime):
</I>&gt;<i>     return t.cached(name=str(url.URL.fromContext(ctx)), lifetime=lifetime)
</I>&gt;<i> 
</I>&gt;<i> Which will give you the same result.
</I>
I'm using this only for the forms right now:

def renderCachedForms(ctx, lifetime=0, *args, **kwargs):
	return tags.cached(lifetime=lifetime,
			   name='formless-'+str(url.URL.fromContext(ctx)))[webform.renderForms(*args, **kwargs)]

It's very handy to use by just repalcing webform.renderForms() with
renderCachedForms(ctx).

&gt;<i> When I say that it won't work with xml templates I mean that you need
</I>&gt;<i> a way to create a cached tag from the xml. This is all.
</I>
I still doubt it'll be as fast as httprender cache, but I can try.

It has taken me minutes to enable httprender caching in the whole http
site, so I tend to consider that API more handy, and peformance should
be a bit higher too. So I don't see much point to use the stan cache in
order to cache whole documents when the other lowlevel cache can be used
in the rend.Page.

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001140.html">[Twisted-web] html cache with timeout
</A></li>
	<LI>Next message: <A HREF="001143.html">[Twisted-web] html cache with timeout
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1141">[ date ]</a>
              <a href="thread.html#1141">[ thread ]</a>
              <a href="subject.html#1141">[ subject ]</a>
              <a href="author.html#1141">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
