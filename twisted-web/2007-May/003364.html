<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Quick Questions about JS mapping in Athena.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Quick%20Questions%20about%20JS%20mapping%20in%20Athena.&In-Reply-To=200705171929.26139.iacovou%40gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003363.html">
   <LINK REL="Next"  HREF="003365.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Quick Questions about JS mapping in Athena.</H1>
    <B>Jean-Paul Calderone</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Quick%20Questions%20about%20JS%20mapping%20in%20Athena.&In-Reply-To=200705171929.26139.iacovou%40gmail.com"
       TITLE="[Twisted-web] Quick Questions about JS mapping in Athena.">exarkun at divmod.com
       </A><BR>
    <I>Thu May 17 12:54:40 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003363.html">[Twisted-web] Quick Questions about JS mapping in Athena.
</A></li>
        <LI>Next message: <A HREF="003365.html">[Twisted-web] Quick Questions about JS mapping in Athena.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3364">[ date ]</a>
              <a href="thread.html#3364">[ thread ]</a>
              <a href="subject.html#3364">[ subject ]</a>
              <a href="author.html#3364">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 17 May 2007 19:29:26 +0300, kgi &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">iacovou at gmail.com</A>&gt; wrote:
&gt;<i>On Thursday 17 May 2007 18:31:59 Jean-Paul Calderone wrote:
</I>&gt;<i>
</I>&gt;<i>Hi Jean-Paul; thanks for your quick answer.
</I>&gt;<i>
</I>&gt;&gt;<i> The import system requires more or less complete knowledge of what modules
</I>&gt;&gt;<i> are defined in order to resolve dependencies.  If each LiveElement took
</I>&gt;&gt;<i> care to declaring which file it needed, then the page would need to be
</I>&gt;&gt;<i> rendered completely before Athena could figure out which modules needed to
</I>&gt;&gt;<i> be loaded, by which time it is a little too late to include them in the
</I>&gt;&gt;<i> page (perhaps this could be made to work, but it would be a hassle).
</I>&gt;<i>
</I>&gt;<i>OK, I guess I'll just have to bite the bullet. Adding something to sys.path is
</I>&gt;<i>not such a big deal.
</I>&gt;<i>
</I>&gt;&gt;<i> I wouldn't be happy to see a solution that required declaring all
</I>&gt;&gt;<i> LiveElement classes a LivePage is going to use, since my own most common
</I>&gt;&gt;<i> use-case for LivePages involves my not having any idea what most of the
</I>&gt;&gt;<i> LiveElements will be (and in fact, changing what they will be with almost
</I>&gt;&gt;<i> every render).  I'm open to other suggestions and discussion about
</I>&gt;&gt;<i> improving this area of Athena, though.
</I>&gt;<i>
</I>&gt;<i>Oh, really? That's interesting. How does Athena push new Javascript code to a
</I>&gt;<i>page after the initial render? I didn't even know it was possible to do such
</I>&gt;<i>a thing: for me, Javascript has always been something you link to from the
</I>&gt;<i>page header. Looks like my 4th Edition &quot;JS Definitive Guide&quot; (2001) is
</I>&gt;<i>showing its age :-)
</I>
Basically it just notices when some required javascript is absent, loads it
from the server, and eval()'s it.  The same dependency system is used to
resolve dependencies at page render time (which are turned into &lt;script&gt;
tags in the &lt;head&gt; of the rendered page) and dynamically after the initial
page render (which are turned into these dynamic load/evals).

&gt;<i>
</I>&gt;&gt;<i> The idea is to provide a package hierarchy, as Python has.  The strings
</I>&gt;&gt;<i> will be split on &quot;.&quot; in a couple places, but if there is simply no &quot;.&quot; in
</I>&gt;&gt;<i> them, this will work (since it is equivalent to any top-level name in an
</I>&gt;&gt;<i> arrangement which does use dotted names).  The goal of dotted names is to
</I>&gt;&gt;<i> avoid polluting the top-level namespace more than necessary.
</I>&gt;<i>
</I>&gt;<i>You're talking about Javascript's top-level namespace, right? (I assume these
</I>&gt;<i>strings never go anywhere near Python's namespace). OK, that sounds logical;
</I>&gt;<i>I was just wondering whether there was anything more to it that.
</I>
Yep.

&gt;<i>
</I>&gt;&gt;<i>  For sanity's
</I>&gt;&gt;<i> sake, I would define classes in a module as attributes of that module,
</I>&gt;&gt;<i> rather than using arbitrary other names
</I>&gt;<i>
</I>&gt;<i>Hmm, I'm not quite sure I understand what you mean in this context. I *think*
</I>&gt;<i>you're talking about JS classes, but the terminology is Python terminology.
</I>
Yep.  Python has a pretty reasonable module system.  Athena's JS &quot;module
system&quot; is loosely based on it, so a lot of Python terminology makes sense
for it as well.

&gt;<i>
</I>&gt;<i>If the former (JS classes) do you mean, you'd prefer to have a single (or a
</I>&gt;<i>few) javascript file(s) and have these define the JS for *lots* of related
</I>&gt;<i>LiveElement classes, which all declare themselves to be a (namespaced)
</I>&gt;<i>jsClass, and all these jsClasses map to the same physical JS file?
</I>
I didn't mean to imply anything about how much or little JS is in any single
source file.  Mostly I just wanted to point out that I think a single source
file should completely define any particular module.  ie, if a.js puts things
onto the JS &quot;module&quot; A, b.js should _not_ put things onto it.

&gt;<i>
</I>&gt;<i>In other words, for project &quot;Cutlery&quot;:
</I>&gt;<i>
</I>&gt;<i># In Python LivePage stuff:
</I>&gt;<i>
</I>&gt;<i>class Fork ( LiveElement ):
</I>&gt;<i>    jsClass = u'Cutlery.Fork'
</I>&gt;<i>
</I>&gt;<i>class Spoon ( LiveElement ):
</I>&gt;<i>    jsClass = u'Cutlery.Spoon'
</I>&gt;<i>
</I>&gt;<i>class Knife ( LiveElement ):
</I>&gt;<i>    jsClass = u'Cutlery.Knife'
</I>&gt;<i>
</I>&gt;<i># In Python plugin code:
</I>&gt;<i>
</I>&gt;<i>jsModules.mapping = {
</I>&gt;<i>  # Note: the same file!
</I>&gt;<i>  u'Cutlery.Fork' : 'cutlery.js',
</I>&gt;<i>  u'Cutlery.Spoon' : 'cutlery.js',
</I>&gt;<i>  u'Cutlery.Knife' : 'cutlery.js',
</I>&gt;<i>}
</I>
Note that since the dependency resolution system works upwards, this
mapping only needs one entry for this example to work:

    jsModules.mapping = {u'Cutlery': 'cutlery.js'}

&gt;<i>
</I>&gt;<i># In the file cutlery.js:
</I>&gt;<i>
</I>&gt;<i>Cutlery = {};
</I>&gt;<i>
</I>&gt;<i>Cutlery.Fork = Nevow.Athena.Widget.subclass ( 'Cutlery.Fork' );
</I>&gt;<i>Cutlery.Fork.methods ( ... );
</I>&gt;<i>
</I>&gt;<i>Cutlery.Spoon = Nevow.Athena.Widget.subclass ( 'Cutlery.Spoon' );
</I>&gt;<i>Cutlery.Spoon.methods ( ... );
</I>&gt;<i>
</I>&gt;<i>Cutlery.Knife = Nevow.Athena.Widget.subclass ( 'Cutlery.Knife' );
</I>&gt;<i>Cutlery.Knife.methods ( ... );
</I>&gt;<i>
</I>&gt;<i>Is this what you mean?
</I>
I... think?  so...  I'm not sure if you were trying to demonstrate something
by putting the jsModules mapping into the same file as the rest of the
Python (since you pointed it out, I suspect you were, but I'm not sure what).

&gt;<i>
</I>&gt;<i>Actually, I have a couple more very quick questions that I thought up while
</I>&gt;<i>typing this:
</I>&gt;<i>
</I>&gt;<i>- Am I right in thinking that no athena JS files ever need to have declare any
</I>&gt;<i>of the modules mentioned in BOOTSTRAP_MODULES (e.g. Divmod, Nevow.Athena)?
</I>
Well, it'll work if they don't, since those are always loaded on every page,
but I might decide to change what's in BOOTSTRAP_MODULES. :)  To be safe,
I'd declare any dependency, even one that's in that collection at the time.

&gt;<i>
</I>&gt;<i>- Is there a recommended way for LiveElements to access each other on the
</I>&gt;<i>server? For example, I click on an element of (client-side) Foo that invokes
</I>&gt;<i>a method on (server-side) Foo; this then needs to update the state of
</I>&gt;<i>(server-side) Bar, which needs to update (client-side) Bar. At the moment I'm
</I>&gt;<i>using an manual ad-hoc registry, with the occasional (naughty?)
</I>&gt;<i>obj.fragmentParent thrown in. I was wondering if there was a more robust
</I>&gt;<i>method already in place that I had totally missed (like the LiveElements
</I>&gt;<i>being assigned names upon creation, which can then be automagically found
</I>&gt;<i>through something like page.findElementByName ( &quot;Bar&quot; )).
</I>&gt;<i>
</I>
Unfortunately, names would have to be unique within the context of a page,
which leads to the possibility of collisions.  Resolving this would make
it impossible to know the actual name of the element you want. :)  I'd
suggest instantiating your LiveElements with direct references to whatever
other objects they need.

This is somewhat similar to a problem many people have when implementing
protocols with Twisted.  I don't know of a general solution, but arranging
for the right objects to be referencable from the right places should solve
any particular case that comes up.

Jean-Paul

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003363.html">[Twisted-web] Quick Questions about JS mapping in Athena.
</A></li>
	<LI>Next message: <A HREF="003365.html">[Twisted-web] Quick Questions about JS mapping in Athena.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3364">[ date ]</a>
              <a href="thread.html#3364">[ thread ]</a>
              <a href="subject.html#3364">[ subject ]</a>
              <a href="author.html#3364">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
