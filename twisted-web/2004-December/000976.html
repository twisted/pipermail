<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: [Nevow-commits] r962 - One billion times better
	Choice...
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BNevow-commits%5D%20r962%20-%20One%20billion%20times%20better%0A%09Choice...&In-Reply-To=E1Cf0gr-0001bo-4O%40tesla.divmod.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000977.html">
   <LINK REL="Next"  HREF="000978.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: [Nevow-commits] r962 - One billion times better
	Choice...</H1>
    <B>Alex Levy</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BNevow-commits%5D%20r962%20-%20One%20billion%20times%20better%0A%09Choice...&In-Reply-To=E1Cf0gr-0001bo-4O%40tesla.divmod.com"
       TITLE="[Twisted-web] Re: [Nevow-commits] r962 - One billion times better
	Choice...">mesozoic at polynode.com
       </A><BR>
    <I>Tue Dec 21 08:30:14 MST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000977.html">[Twisted-web] loaders.xmlstr versus loader.xmlfile
</A></li>
        <LI>Next message: <A HREF="000978.html">[Twisted-web] Re: [Nevow-commits] r962 - One billion times better
	Choice...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#976">[ date ]</a>
              <a href="thread.html#976">[ thread ]</a>
              <a href="subject.html#976">[ subject ]</a>
              <a href="author.html#976">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm a little behind on Nevow changes, and I just came across this change to
the Choice interface. It looks cool (deferred support is a big plus), but so
far all the examples I've seen involve declaring the available choices as
part of the interface definition, e.g.:

class MyInterface(TypedInterface):
  pickOne = Choice(lambda c,d: [1,2,3,4])
  
What I do (fairly regularly) with my application involves declaring the
available choices as part of the _implementing_ class, not as part of the
interface. I typically used choicesAttribute to do this, and was working on
something along the lines of a choicesMethod, but now it seems that this
behavior has been deprecated.

So, what is the new recommended syntax for a Choice where the implementing
class can change the choices dynamically?


On Thu, Dec 16, 2004 at 01:49:29PM -0500, Donovan Preston wrote:
&gt;<i> MIME-Version: 1.0
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i> 
</I>&gt;<i> Author: dp
</I>&gt;<i> Date: Thu Dec 16 13:49:28 2004
</I>&gt;<i> New Revision: 962
</I>&gt;<i> 
</I>&gt;<i> Modified:
</I>&gt;<i>    trunk/examples/formbuilder.py
</I>&gt;<i>    trunk/examples/formpost2.py
</I>&gt;<i>    trunk/formless/annotate.py
</I>&gt;<i>    trunk/formless/webform.py
</I>&gt;<i> Log:
</I>&gt;<i> One billion times better Choice implementation; supports lazy choices from a function, a deferred, etc. Has valueToKey and keyToValue methods which are used to serialize/unserialize the choice instead of the index into the list.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Modified: trunk/examples/formbuilder.py
</I>&gt;<i> ==============================================================================
</I>&gt;<i> --- trunk/examples/formbuilder.py	(original)
</I>&gt;<i> +++ trunk/examples/formbuilder.py	Thu Dec 16 13:49:28 2004
</I>&gt;<i> @@ -10,6 +10,9 @@
</I>&gt;<i>  from formless import webform
</I>&gt;<i>  from formless import configurable
</I>&gt;<i>  
</I>&gt;<i> +from twisted.python import reflect
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  class BuilderCore(configurable.Configurable):
</I>&gt;<i>      def __init__(self):
</I>&gt;<i>          configurable.Configurable.__init__(self, None)
</I>&gt;<i> @@ -32,10 +35,11 @@
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i>  allTypes = [annotate.String, annotate.Text, annotate.Integer, annotate.Real, annotate.Password]
</I>&gt;<i> +typeChoice = annotate.Choice(choices=allTypes, valueToKey=reflect.qual, keyToValue=reflect.namedAny, stringify=lambda x: x.__name__)
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i>  class IFormBuilder(annotate.TypedInterface):
</I>&gt;<i> -    def addElement(self, name=annotate.String(required=True), type=annotate.Choice(choices=allTypes)):
</I>&gt;<i> +    def addElement(self, name=annotate.String(required=True), type=typeChoice):
</I>&gt;<i>          &quot;&quot;&quot;Add Element
</I>&gt;<i>          
</I>&gt;<i>          Add an element to this form.
</I>&gt;<i> 
</I>&gt;<i> Modified: trunk/examples/formpost2.py
</I>&gt;<i> ==============================================================================
</I>&gt;<i> --- trunk/examples/formpost2.py	(original)
</I>&gt;<i> +++ trunk/examples/formpost2.py	Thu Dec 16 13:49:28 2004
</I>&gt;<i> @@ -3,15 +3,24 @@
</I>&gt;<i>  from nevow import loaders
</I>&gt;<i>  from nevow import rend
</I>&gt;<i>  from nevow import tags
</I>&gt;<i> +from nevow import inevow
</I>&gt;<i>  
</I>&gt;<i>  from formless import annotate
</I>&gt;<i>  from formless import webform
</I>&gt;<i>  
</I>&gt;<i> +from twisted.internet import defer
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +oldChoicesWay = annotate.Choice(choicesAttribute='theChoices') # Doing this gives you a DeprecationWarning now
</I>&gt;<i> +# If you still want to use an attribute or method of some other object, you should use a function as shown below,
</I>&gt;<i> +# but look up IResource(ctx) or IConfigurable(ctx), whichever is more appropriate.
</I>&gt;<i> +newChoicesWay = annotate.Choice(lambda c, d: range(30))
</I>&gt;<i> +deferChoicesWay = annotate.Choice(lambda c, d: defer.succeed(['abcd', 'efgh', 'ijkl']))
</I>&gt;<i>  
</I>&gt;<i>  class IMyForm(annotate.TypedInterface):
</I>&gt;<i>      foo = annotate.Integer()
</I>&gt;<i>  
</I>&gt;<i> -    def bar(self, baz=annotate.Integer()):
</I>&gt;<i> +    def bar(self, baz=annotate.Integer(), bamf=oldChoicesWay, slam=newChoicesWay, ham=deferChoicesWay):
</I>&gt;<i>          pass
</I>&gt;<i>      bar = annotate.autocallable(bar)
</I>&gt;<i>  
</I>&gt;<i> @@ -21,8 +30,10 @@
</I>&gt;<i>  
</I>&gt;<i>      foo = 5
</I>&gt;<i>  
</I>&gt;<i> -    def bar(self, baz):
</I>&gt;<i> -        print &quot;baz!&quot;, baz
</I>&gt;<i> +    def bar(self, baz, bamf, slam, ham):
</I>&gt;<i> +        return &quot;You called bar! %s %s %s %s&quot; % (baz, bamf, slam, ham)
</I>&gt;<i> +
</I>&gt;<i> +    theChoices = [1, 2, 3]
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i>  class FormPage(rend.Page):
</I>&gt;<i> @@ -31,12 +42,19 @@
</I>&gt;<i>  
</I>&gt;<i>      child_webform_css = webform.defaultCSS
</I>&gt;<i>  
</I>&gt;<i> +    def render_hand(self, ctx, data):
</I>&gt;<i> +        hand = inevow.IHand(ctx, default=None)
</I>&gt;<i> +        if hand is not None:
</I>&gt;<i> +            return ctx.tag[hand]
</I>&gt;<i> +        return ''
</I>&gt;<i> +
</I>&gt;<i>      docFactory = loaders.stan(
</I>&gt;<i>          tags.html[
</I>&gt;<i>              tags.head[
</I>&gt;<i>                  tags.link(rel='stylesheet', type='text/css', href='/webform_css'),
</I>&gt;<i>                  ],
</I>&gt;<i>              tags.body[
</I>&gt;<i> +                tags.h3(render=render_hand, style=&quot;color: red; font-size: xx-large&quot;),
</I>&gt;<i>                  &quot;Hello! Here is a form:&quot;,
</I>&gt;<i>  
</I>&gt;<i>                  # We want to render forms defined by the Implementation instance.
</I>&gt;<i> 
</I>&gt;<i> Modified: trunk/formless/annotate.py
</I>&gt;<i> ==============================================================================
</I>&gt;<i> --- trunk/formless/annotate.py	(original)
</I>&gt;<i> +++ trunk/formless/annotate.py	Thu Dec 16 13:49:28 2004
</I>&gt;<i> @@ -10,6 +10,7 @@
</I>&gt;<i>  import copy
</I>&gt;<i>  import inspect
</I>&gt;<i>  import types
</I>&gt;<i> +import warnings
</I>&gt;<i>  
</I>&gt;<i>  from nevow import inevow
</I>&gt;<i>  from nevow import util
</I>&gt;<i> @@ -238,28 +239,29 @@
</I>&gt;<i>      are configuring. The elements of the list will be rendered by calling the 
</I>&gt;<i>      function passed to stringify, which is by default &quot;str&quot;.
</I>&gt;<i>      &quot;&quot;&quot;
</I>&gt;<i> -    def __init__(self, choices=None, choicesAttribute=None, stringify=str, *args, **kw):
</I>&gt;<i> +    def __init__(self, choices=None, choicesAttribute=None, stringify=str, valueToKey=str, keyToValue=str, *args, **kw):
</I>&gt;<i>          Typed.__init__(self, *args, **kw)
</I>&gt;<i> -        if choices is None:
</I>&gt;<i> -            self.choices = []
</I>&gt;<i> -        else:
</I>&gt;<i> -            self.choices = choices
</I>&gt;<i> -        self.choicesAttribute = choicesAttribute
</I>&gt;<i> +        self.choices = choices
</I>&gt;<i> +        if choicesAttribute:
</I>&gt;<i> +            self.choicesAttribute = choicesAttribute
</I>&gt;<i> +        if getattr(self, 'choicesAttribute', None):
</I>&gt;<i> +            warnings.warn(
</I>&gt;<i> +                &quot;Choice.choicesAttribute is deprecated. Please pass a function to choices instead.&quot;,
</I>&gt;<i> +                DeprecationWarning,
</I>&gt;<i> +                stacklevel=2)
</I>&gt;<i> +            def findTheChoices(ctx, data):
</I>&gt;<i> +                return getattr(iformless.IConfigurable(ctx).original, self.choicesAttribute)
</I>&gt;<i> +            self.choices = findTheChoices
</I>&gt;<i> +
</I>&gt;<i>          self.stringify = stringify
</I>&gt;<i> +        self.valueToKey=valueToKey
</I>&gt;<i> +        self.keyToValue=keyToValue
</I>&gt;<i>  
</I>&gt;<i>      def coerce(self, val, binding):
</I>&gt;<i>          &quot;&quot;&quot;Coerce a value with the help of an object, which is the object
</I>&gt;<i>          we are configuring.
</I>&gt;<i>          &quot;&quot;&quot;
</I>&gt;<i> -        try:
</I>&gt;<i> -            val = int(val)
</I>&gt;<i> -        except ValueError:
</I>&gt;<i> -            raise InputError(&quot;%r is an invalid choice.&quot; % val)
</I>&gt;<i> -        if self.choicesAttribute is not None:
</I>&gt;<i> -            choices = getattr(binding, self.choicesAttribute)
</I>&gt;<i> -        else:
</I>&gt;<i> -            choices = self.choices
</I>&gt;<i> -        return choices[val]
</I>&gt;<i> +        return self.keyToValue(val)
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i>  class Any(object):
</I>&gt;<i> 
</I>&gt;<i> Modified: trunk/formless/webform.py
</I>&gt;<i> ==============================================================================
</I>&gt;<i> --- trunk/formless/webform.py	(original)
</I>&gt;<i> +++ trunk/formless/webform.py	Thu Dec 16 13:49:28 2004
</I>&gt;<i> @@ -62,6 +62,7 @@
</I>&gt;<i>      def rend(self, context, data):
</I>&gt;<i>          defaults = context.locate(iformless.IFormDefaults)
</I>&gt;<i>          value = defaults.getDefault(context.key, context)
</I>&gt;<i> +        context.remember(data.typedValue, iformless.ITyped)
</I>&gt;<i>  
</I>&gt;<i>          if data.typedValue.getAttribute('immutable'):
</I>&gt;<i>              inp = span(id=keyToXMLID(context.key))[value]
</I>&gt;<i> @@ -145,32 +146,45 @@
</I>&gt;<i>                            _class='freeform-input-file')]
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i> +class ICurrentlySelectedValue(compy.Interface):
</I>&gt;<i> +    &quot;&quot;&quot;The currently-selected-value for the ITypedRenderer being rendered.
</I>&gt;<i> +    &quot;&quot;&quot;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +csv = ICurrentlySelectedValue
</I>&gt;<i> +def valToKey(c, d):
</I>&gt;<i> +    return iformless.ITyped(c).valueToKey(d)
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +def isSelected(c, d):
</I>&gt;<i> +    if csv(c) == valToKey(c, d):
</I>&gt;<i> +        return c.tag(selected='selected')
</I>&gt;<i> +    return c.tag
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +default_select = select(id=slot('id'), name=slot('name'), render=directive('sequence'), foo=&quot;bar&quot;)[
</I>&gt;<i> +    option(pattern=&quot;item&quot;, 
</I>&gt;<i> +        value=valToKey, 
</I>&gt;<i> +        render=isSelected)[
</I>&gt;<i> +        lambda c, d: iformless.ITyped(c).stringify(d)]]
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  class ChoiceRenderer(BaseInputRenderer):
</I>&gt;<i>      def input(self, context, slot, data, name, value):
</I>&gt;<i>          tv = data.typedValue
</I>&gt;<i> -        if tv.choicesAttribute:
</I>&gt;<i> -            choices = getattr(context.locate(iformless.IConfigurable).boundTo, tv.choicesAttribute)
</I>&gt;<i> -        else:
</I>&gt;<i> -            choices = tv.choices
</I>&gt;<i> +        choices = tv.choices
</I>&gt;<i>  
</I>&gt;<i> -        numChoices = len(choices)
</I>&gt;<i> -        if numChoices == 0:
</I>&gt;<i> -            return None
</I>&gt;<i> +        if value:
</I>&gt;<i> +            context.remember(self.original.valueToKey(value), csv)
</I>&gt;<i> +        else:
</I>&gt;<i> +            context.remember('', csv)
</I>&gt;<i>  
</I>&gt;<i>          try:
</I>&gt;<i>              selector = context.tag.patternGenerator( 'selector' )
</I>&gt;<i>          except NodeNotFound:
</I>&gt;<i> -            selector = select
</I>&gt;<i> -
</I>&gt;<i> -        selector = selector(id=keyToXMLID(context.key), name=name)
</I>&gt;<i> -        stringify = tv.stringify
</I>&gt;<i> +            selector = default_select
</I>&gt;<i>  
</I>&gt;<i> -        for index, val in enumerate(choices):
</I>&gt;<i> -            if val == value:
</I>&gt;<i> -                selector[option(value=str(index), selected=&quot;selected&quot;)[stringify(val)]]
</I>&gt;<i> -            else:
</I>&gt;<i> -                selector[option(value=str(index))[stringify(val)]]
</I>&gt;<i> -        return slot[selector]
</I>&gt;<i> +        return selector(data=choices)
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i>  class ObjectRenderer(compy.Adapter):
</I>&gt;<i> @@ -259,6 +273,7 @@
</I>&gt;<i>  class PropertyBindingRenderer(BaseBindingRenderer):
</I>&gt;<i>      def rend(self, context, data):
</I>&gt;<i>          context.remember(data, iformless.IBinding)
</I>&gt;<i> +        context.remember(data.typedValue, iformless.ITyped)
</I>&gt;<i>          typedRenderer = iformless.ITypedRenderer(data.typedValue, defaultBindingRenderer, persist=False)
</I>&gt;<i>          if typedRenderer.complexType:
</I>&gt;<i>              return invisible(data=data, render=typedRenderer)
</I>&gt;<i> @@ -337,11 +352,13 @@
</I>&gt;<i>                      except NodeNotFound:
</I>&gt;<i>                          default_content_pattern = freeformDefaultContentPattern
</I>&gt;<i>                  content_pattern = default_content_pattern
</I>&gt;<i> +            renderer = iformless.ITypedRenderer(
</I>&gt;<i> +                argument.typedValue, defaultBindingRenderer, persist=False)
</I>&gt;<i>              pat = content_pattern(
</I>&gt;<i>                  key=argument.name,
</I>&gt;<i>                  data=argument,
</I>&gt;<i> -                render= iformless.ITypedRenderer(
</I>&gt;<i> -                    argument.typedValue, defaultBindingRenderer, persist=False))
</I>&gt;<i> +                render=renderer,
</I>&gt;<i> +                remember={iformless.ITyped: argument.typedValue})
</I>&gt;<i>              context.fillSlots( 'argument!!%s' % argument.name, pat )
</I>&gt;<i>              yield pat
</I>&gt;<i>  
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Nevow-commits mailing list
</I>&gt;<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">Nevow-commits at divmod.org</A>
</I>&gt;<i> <A HREF="http://divmod.org/users/mailman.twistd/listinfo/nevow-commits">http://divmod.org/users/mailman.twistd/listinfo/nevow-commits</A>
</I>
-- 
Alex Levy
WWW: <A HREF="http://mesozoic.geecs.org/">http://mesozoic.geecs.org/</A>
 
&quot;Never let your sense of morals prevent you from doing what is right.&quot;
 -- Salvor Hardin, Isaac Asimov's _Foundation_

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000977.html">[Twisted-web] loaders.xmlstr versus loader.xmlfile
</A></li>
	<LI>Next message: <A HREF="000978.html">[Twisted-web] Re: [Nevow-commits] r962 - One billion times better
	Choice...
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#976">[ date ]</a>
              <a href="thread.html#976">[ thread ]</a>
              <a href="subject.html#976">[ subject ]</a>
              <a href="author.html#976">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
