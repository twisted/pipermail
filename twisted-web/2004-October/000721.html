<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20A%20more%20Twisted%20approach%20to%0A%09async%20apps%20in%20WSGI&In-Reply-To=6B8CDF7C-168A-11D9-B112-000A95A50FB2%40fuhm.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000720.html">
   <LINK REL="Next"  HREF="000723.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI</H1>
    <B>Phillip J. Eby</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20A%20more%20Twisted%20approach%20to%0A%09async%20apps%20in%20WSGI&In-Reply-To=6B8CDF7C-168A-11D9-B112-000A95A50FB2%40fuhm.net"
       TITLE="[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI">pje at telecommunity.com
       </A><BR>
    <I>Tue Oct  5 00:37:18 MDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000720.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to async apps
	in WSGI
</A></li>
        <LI>Next message: <A HREF="000723.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#721">[ date ]</a>
              <a href="thread.html#721">[ thread ]</a>
              <a href="subject.html#721">[ subject ]</a>
              <a href="author.html#721">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 12:52 AM 10/5/04 -0400, James Y Knight wrote:
&gt;<i>A bit late with the response...but better late than never I hope. ;)
</I>&gt;<i>
</I>&gt;<i>On Sep 22, 2004, at 9:56 PM, Phillip J. Eby wrote:
</I>&gt;&gt;<i>On the positive side of the iterator approach, it could make it easier 
</I>&gt;&gt;<i>for asynchronous applications to pause waiting for input, and it could in 
</I>&gt;&gt;<i>principle support &quot;chunked&quot; transfer encoding of the input stream.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Anyway, the long and short of it is that CGI and chunked encoding are 
</I>&gt;&gt;<i>quite simply incompatible, which means that relying on its availability 
</I>&gt;&gt;<i>would be nonportable in a WSGI application anyway.
</I>&gt;<i>
</I>&gt;<i>I do not find that a good reason to copy the mistake (not supporting 
</I>&gt;<i>chunking) to a new API.
</I>
Perhaps not, but there are also lots of other reasons not to support 
chunked input, mainly that a Google search for &quot;chunked encoding CGI&quot; turns 
up reams of vulnerabilities that suggest existing HTTP implementations may 
leave a bit to be desired with respect to accepting a POST of chunked 
input.  :)


&gt;<i>However! I don't think that the file-like-object API even has a problem 
</I>&gt;<i>with chunked incoming data. As long as WSGI does not make CONTENT_LENGTH a 
</I>&gt;<i>required header, and as long as the result of read looks different for 
</I>&gt;<i>&quot;more data still to come&quot; and &quot;data finished&quot; (it does, blocking for more 
</I>&gt;<i>data to occur vs. returning ''), I think it should be fine (for non-async 
</I>&gt;<i>apps). Am I missing something here?
</I>
I don't think so.  Although you probably want something more like a pipe 
error if the input times out or the connection is broken.


&gt;&gt;<i>So, I'm thinking we should shift the burden to an async-specific API.
</I>&gt;&gt;<i>But, in this case, &quot;burden&quot; means that we get to give asynchronous apps 
</I>&gt;&gt;<i>an API much more suited to their use cases.
</I>&gt;&gt;<i>[...]
</I>&gt;&gt;<i>The idea is that this would create an iterator that the server/gateway 
</I>&gt;&gt;<i>could recognize as &quot;special&quot;, similar to the file-wrapper trick.  But, 
</I>&gt;&gt;<i>the object returned would provide an extra API for use by the 
</I>&gt;&gt;<i>asynchronous application, maybe something like:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     put(data) -- queue data for retrieval when the controller is 
</I>&gt;&gt;<i> iterated over
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     finish() -- mark the iterator finished, so it raises StopIteration
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     on_get(length,callback) -- call 'callback(data)' when 'length' bytes 
</I>&gt;&gt;<i> are available on 'wsgi.input' (but return immediately from the 'on_get()' call)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>While this API is an optional extension, it seems it would be closer to 
</I>&gt;&gt;<i>what some async fans wanted, and less of a kludge.  It won't do away with 
</I>&gt;&gt;<i>the possibility that middleware might block waiting for input, of course, 
</I>&gt;&gt;<i>but when no middleware is present or the middleware isn't transforming 
</I>&gt;&gt;<i>the input stream, it should work out quite well.
</I>&gt;<i>
</I>&gt;<i>That sounds okay. I'd specify that the on_get &quot;length&quot; bit is a hint, and 
</I>&gt;<i>may or may not be honored. put/finish is the right API for output 
</I>&gt;<i>(although I'd call it write/finish myself),
</I>
The reason for not using 'write' is to avoid confusion with the existing 
&quot;write&quot; callable, both in terms of knowing which one we're talking about, 
and in terms of not confusing the semantics, which may differ subtly 
between the two.


&gt;<i>  and on_get seems like the a fairly usable API for input. It doesn't let 
</I>&gt;<i> you pause the incoming data,
</I>
Actually it does; it's supposed to be a one-shot.  You have to call it 
again if you want to get called back again.


&gt;<i>  so if you're passing it on to a slow downstream you'll potentially need 
</I>&gt;<i> to buffer a lot, but maybe that's too much to ask for. I assume 
</I>&gt;<i> callback('') is used to indicate end of incoming data: that should be 
</I>&gt;<i> specified.
</I>
I missed that entirely, but it sounds like a good idea.



&gt;<i>However, interaction with middleware seems quite tricky here:
</I>&gt;<i>- For input modifying middleware: I guess on_get would have to just raise 
</I>&gt;<i>an exception if wsgi.input has been replaced.
</I>
Yep.  Although it might be that the wrapper would just refuse to 
instantiate in the first place in that circumstance.


&gt;<i>  If the input stream was iterable, an on_get callback could just be 
</I>&gt;<i> considered notice that you can iterate the input stream once without 
</I>&gt;<i> blocking, assuming the block boundary requirements were also in effect here.
</I>
Yes, but this'd only work if the input were an iterator.  input.read() 
returning an empty string would mean EOF, so the boundary stuff doesn't 
work in that case.


&gt;<i>- Output. The block boundary section implies that middleware that follows 
</I>&gt;<i>the guidelines, and doesn't do any blocking operations of its own should 
</I>&gt;<i>work without worrying about the server and application being async or 
</I>&gt;<i>sync. If this is to work, the server cannot expect to actually receive an 
</I>&gt;<i>asyncwrapper iterable as the return value, even if the app is using it, 
</I>&gt;<i>because the middleware might be consuming that iterable and returning one 
</I>&gt;<i>of its own.
</I>
Correct.


&gt;<i>  This means the .put/.next methods should communicate out-of-band, 
</I>&gt;<i> effectively calling pause/resume functions in the server so it knows when 
</I>&gt;<i> it's safe to iterate the vanilla iterator the middleware returned without 
</I>&gt;<i> the middleware blocking when calling the asyncwrapper-iterator.
</I>
It could do that, certainly.  But, the truth is it's *always* safe to 
iterate.  Note that the application can just use the on_get callback to set 
a flag that it's ready to continue, and just keep yielding empty strings 
till then.

More to the point, the iterator-wrapper can simply yield empty strings when 
its internal queue is empty, and a sensible async server should back off 
its iterator.next() retry attempts when an application yields empty 
strings.  This is pretty much always safe and sensible.

However, the out-of-band communication you describe can also take place, 
since it provides better communication in the case where the extension is 
available.


</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000720.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to async apps
	in WSGI
</A></li>
	<LI>Next message: <A HREF="000723.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#721">[ date ]</a>
              <a href="thread.html#721">[ thread ]</a>
              <a href="subject.html#721">[ subject ]</a>
              <a href="author.html#721">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
