<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: [Web-SIG] A more Twisted approach to async apps
	in WSGI
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20A%20more%20Twisted%20approach%20to%20async%20apps%0A%09in%20WSGI&In-Reply-To=5.1.1.6.0.20041007010942.02d33c90%40mail.telecommunity.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000724.html">
   <LINK REL="Next"  HREF="000746.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: [Web-SIG] A more Twisted approach to async apps
	in WSGI</H1>
    <B>James Y Knight</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20%5BWeb-SIG%5D%20A%20more%20Twisted%20approach%20to%20async%20apps%0A%09in%20WSGI&In-Reply-To=5.1.1.6.0.20041007010942.02d33c90%40mail.telecommunity.com"
       TITLE="[Twisted-web] Re: [Web-SIG] A more Twisted approach to async apps
	in WSGI">foom at fuhm.net
       </A><BR>
    <I>Fri Oct 15 09:20:34 MDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000724.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
</A></li>
        <LI>Next message: <A HREF="000746.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#745">[ date ]</a>
              <a href="thread.html#745">[ thread ]</a>
              <a href="subject.html#745">[ subject ]</a>
              <a href="author.html#745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Oct 7, 2004, at 1:28 AM, Phillip J. Eby wrote:
&gt;&gt;<i> - For async applications, with the proposed API, that may not be an 
</I>&gt;&gt;<i> option, because the iterable returned is the special wrapper, not a 
</I>&gt;&gt;<i> user-created class. Although, actually, I guess the app can return 
</I>&gt;&gt;<i> its own iterable whose __iter__ calls through and returns the 
</I>&gt;&gt;<i> wrapper's __iter__.
</I>&gt;<i>
</I>&gt;<i> Not if the server wants to be able to handle that iterable specially.  
</I>&gt;<i> But anyway, it seems that the wrapper's constructor should take a 
</I>&gt;<i> close method, or have a way to set one.
</I>
As already discussed, the server cannot really expect to actually get 
the iterable back anyhow. But yes, I'd say either the init should take 
a close argument, or else the use of something like &quot;wrapper.close = 
myCloseFunction&quot; should be part of the API.


&gt;&gt;<i> Hmm, yes. I totally missed the option of just yielding ''. Of course 
</I>&gt;&gt;<i> it's a very bad idea to repeatedly yield '' to a server if you don't 
</I>&gt;&gt;<i> know the server can properly handle it (by e.g. delaying longer and 
</I>&gt;&gt;<i> longer), but, in this case, since the server itself is providing the 
</I>&gt;&gt;<i> special iterable, that should be fine.
</I>&gt;<i>
</I>&gt;<i> Yes.  Also, when we finally settle on an async API, I do want to cover 
</I>&gt;<i> the issue of backing off iteration when empty strings are yielded.  
</I>&gt;<i> I'm actually inclined to suggest that an async application should take 
</I>&gt;<i> responsibility for doing the delaying if it's called repeatedly, and 
</I>&gt;<i> the async API isn't available.
</I>
If the async API isn't available, and I'm an async application, I would 
assume I'm running on a synch server, and thus am allowed to block the 
request thread indefinitely, and do so, waiting for a wakeup 
notification from the reactor loop. It doesn't seem to me that any 
iterator back-off behavior is needed, or desirable. I can fabricate an 
async wrapper that uses threads

&gt;&gt;<i> It seems like it should be possible to make a generic class that 
</I>&gt;&gt;<i> implements this async API for use with sync servers that do not 
</I>&gt;&gt;<i> support it natively. That would allow async apps to run on a sync 
</I>&gt;&gt;<i> server without modification, which is potentially useful. To do that, 
</I>&gt;&gt;<i> though, I think the it'd have to spawn an extra thread per request 
</I>&gt;&gt;<i> that is waiting to read data, for the read() call to block on. 
</I>&gt;&gt;<i> Unless, of course, the app never needs to yield outgoing data while 
</I>&gt;&gt;<i> waiting for incoming data.
</I>&gt;<i>
</I>&gt;<i> Well, with Twisted you could deferToThread the read() operations, 
</I>&gt;<i> though it's hard for me to think straight about that scenario because 
</I>&gt;<i> I keep finding it hard to imagine an async web app that isn't just 
</I>&gt;<i> written to the Twisted API to start with... ;)
</I>
Right -- but deferToThread'ing a read() operation is essentially the 
same as spawning an extra thread per request to read the data, just 
with nicer thread management.

&gt;<i> [thread stuff]
</I>&gt;<i>
</I>&gt;&gt;<i>  I haven't really thought about these thready questions much either, 
</I>&gt;&gt;<i> so maybe the answers are obvious, but in my experience, that's 
</I>&gt;&gt;<i> usually not the case when it comes to threads.
</I>&gt;<i>
</I>&gt;<i> Yep.  :)  However, the more I think about it, the more it seems to me 
</I>&gt;<i> that WSGI should emulate single-threadedness with respect to any 
</I>&gt;<i> function/method/iterator invocations associated with a given 
</I>&gt;<i> application invocation.  However, it is *not* guaranteed that all such 
</I>&gt;<i> invocations will occur from the same thread.
</I>&gt;<i>
</I>&gt;<i> Basically, it means &quot;no multitasking with the other guy's objects&quot;, 
</I>&gt;<i> and puts the locking burdens on whoever's trying to mix multitasking 
</I>&gt;<i> into the works.
</I>
That does sound good. No multitasking means it's impossible to write a 
response while already waiting for incoming data. But actually I think 
it's probably fine for an async app running on a sync server to not be 
able to simultaneously read data and write data, so I take back 
anything about needing to call wsgi server methods from more than one 
thread. In the compat wrapper, calling on_get can just block writing 
until the read has occurred; in that case, all wsgi methods can be 
called from the server's request thread.

&gt;<i> By the way, after all this discussion...  do you think it would be 
</I>&gt;<i> better to:
</I>&gt;<i>
</I>&gt;<i> 1) Push towards a full async API, nailing down all these loose ends
</I>&gt;<i>
</I>&gt;<i> 2) Use the simple-but-klugdy &quot;pause iteration&quot; API idea
</I>&gt;<i>
</I>&gt;<i> 3) Don't make an &quot;official&quot; async API, and just leave it open to 
</I>&gt;<i> server authors to create their own extensions, and maybe cherry pick 
</I>&gt;<i> the best ideas for WSGI 2.0, or
</I>&gt;<i>
</I>&gt;<i> 4) Do something else altogether?
</I>
I think the API you've outlined sounds good. I can imagine ways to 
implement it both for an async server like twisted, and as a 
compatibility layer for an async-requiring application on a sync 
server. I think it's easier to make the compatibility layer with this 
API than with the pause/resume API.  However, I would be quite wary of 
including it in the final spec without it being implemented first.

Another question is: what is the current use for it? Does anyone want 
to write untwisted async web applications?

My current interest in WSGI is basically on the &quot;plug twisted web into 
another webserver as an application&quot; side of things. I wouldn't want to 
write an application to WSGI (without a framework on top)... If 
everyone else feels that way, an async API may not be actually useful 
until there is some other Async-WSGI web server that you could plug 
twisted framework stuff on top of, or some other async framework you 
can plug on top of the twisted server.

As for postponing until WSGI 2.0, I would hope there doesn't need to be 
a WSGI 2.0, though, since the interface is so darn simple. ;) But it 
could be in a separate WSGI async addons.

James


</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000724.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
</A></li>
	<LI>Next message: <A HREF="000746.html">[Twisted-web] Re: [Web-SIG] A more Twisted approach to
	async apps in WSGI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#745">[ date ]</a>
              <a href="thread.html#745">[ thread ]</a>
              <a href="subject.html#745">[ subject ]</a>
              <a href="author.html#745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
