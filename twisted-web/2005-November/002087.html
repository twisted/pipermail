<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20HTTP-AUTH%20for%20web2%20/%20Kudos%20on%20web2%27s%20operation&In-Reply-To=980A6D2D-489A-4586-825A-753A500C3DC5%40fuhm.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002077.html">
   <LINK REL="Next"  HREF="002093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation</H1>
    <B>glyph at divmod.com</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20HTTP-AUTH%20for%20web2%20/%20Kudos%20on%20web2%27s%20operation&In-Reply-To=980A6D2D-489A-4586-825A-753A500C3DC5%40fuhm.net"
       TITLE="[Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation">glyph at divmod.com
       </A><BR>
    <I>Thu Nov 17 06:17:25 MST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002077.html">[Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation
</A></li>
        <LI>Next message: <A HREF="002093.html">[Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2087">[ date ]</a>
              <a href="thread.html#2087">[ thread ]</a>
              <a href="subject.html#2087">[ subject ]</a>
              <a href="author.html#2087">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On Wed, 16 Nov 2005 11:11:49 -0500, James Y Knight &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">foom at fuhm.net</A>&gt; wrote:

&gt;<i>I think of something like parsing user authentication information at  a high 
</I>&gt;<i>level up in the resource tree and making it available to a  Resource low in 
</I>&gt;<i>the tree. It is fairly clearly a per-request bit of  state which may be 
</I>&gt;<i>useful to a some subset of the pages, and as such  seems like it should be 
</I>&gt;<i>attached to the Request. Just going and  adding random attributes onto 
</I>&gt;<i>Request is not nice thing to do, so  I'll pretend I didn't just consider it. 
</I>&gt;<i>But it really seems like some  designated storage spot for extra data is 
</I>&gt;<i>necessary.
</I>
Abstractly: if you have a page which requires some &quot;per-request state&quot; to be set by a resource higher up in the tree, and can't operate without it, how do you guarantee it's been set?  Can we come up with any declarative interface for specifying this relationship?  I've never seen one and it seems like it would be insanely hard to do.  The convention in Nevow is to look for something in the context, find 'None', and midway through rendering a page, vomit a &quot;'NoneType' object has no attribute 'x'&quot; traceback onto the user's page with no explanation of what data was expected or where it was supposed to come from.  Regardless of whether we use the context or not, this is not a convention I think we should continue with.

Concretely: come to think of it I've never heard of a legitimate requirement other than &quot;currently logged in user&quot;, which ought to be handled by another system anyway.  As per CCE's previous emails, the system for initializing those and setting them up needs to be pretty flexible in terms of how and when login forms get displayed, but the use of cred is non-negotiable.  We need a unifying cross-protocol abstraction.

Though I missed the conversation, I imagine the handwavy stuff that JP was suggesting was &quot;the top resource, which is a proxy for the user, should pass information down to its children as it creates them&quot;.  Some kind of explicit relationship is required.

Let me try to anticipate the argument against this here: you have a top-level site which is an application.  One of its children is some generic type of resource with no mechanism to pass additional information down through it, such as a static.File.  That static.File has a dynamic child which is a super-simple epy-style script that is nevertheless part of the application - it needs to know what user is currently logged in, or it needs to display a little shopping cart emblem that indicates that the currently logged-in user can buy stuff on this page, and a link to the user-specific page where they can buy it.

I'll here backpedal just a tiny bit on my earlier adamance on getSession and say that perhaps there is a valid use for access to the currently logged-in user as request data.  By &quot;currently logged-in user&quot; I mean &quot;'topmost' resource object&quot;.

This still establishes a slightly more implicit interface than I'd like, but without it, it would be difficult to write any kind of generic 'dispatcher' resource (virtual hosting, etc) which exists below a session-capable application.  At least the rules are simple: certain kinds of resources are &quot;applications&quot; or &quot;sites&quot;.  Any resources they return from locateChild should expect them, and ONLY them, or nothing, as the current site resource.  Rather than being of the &quot;something was missing&quot; variety, errors will instead be of the &quot;I expected a site of type X, instead I got one of type Y&quot; variety, which tend to be easier to diagnose. Sketch of an interface:

Site resources call Request.setSiteResource() in locateChild - this method takes no arguments, and preserves the current URL being processed as well as the current resource.

Regular resources can, at any time, call Request.getSiteResource() or Request.getSiteURL() which return, respectively, the last resource to call setSiteResource() and a nevow.url-style object that indicates its location.

This was the intent of the original twisted.web Site object, although it has become clear over time that it isn't really feasible to use Site for this since putting them anywhere but at the absolute top of the resource hierarchy causes other problems.

I still think that this sort of interface should be used sparingly, but it has several advantages over the context as manifested in Nevow.

 - The relationship between objects which require implicit state and objects which provide it is more explicit.  They must both be resources, one calls setSiteResource, one calls getSiteResource.

 - By default, no site resource is set, so you must always implement both halves of the interface.  In other words, this is entirely a facility for an application to communicate with itself, no framework code should ever provide a site resource, and no framework code should ever expect to find anything useful from the site resource.

 - All information required by a given application must be encapsulated by the single top-level resource.  No piecemeal assembling of required information from 5 different interfaces set by 5 different systems during resource traversal.  If you need information from a different system, the top-level resource can aggregate it using traditional means (methods returning different objects, attributes, adaptation, etc)

 - All information is specifically &quot;per HTTP request&quot; rather than &quot;per abstract transaction execution&quot; - Nevow (or other templating / page generating mechanisms used with web2) can be expected to do any necessary translations at render time and not abuse the same mechanism used by the dispatch mechanism.

 - By providing a URL as well as a site object, sub-applications can properly link to resources defined by the application.  I'm sure that most people will ignore that and link directly to / most of the time, but at least it is the kind of issue which *can* be resolved by using this interface.

 - As I mentioned previously, error messages can be more detailed, since they will indicate what type the current site resource is, and thereby provide the developer some indication of how the offending resource got where it is.  Furthermore the URL can also be used to aid in error reporting, so the developer can tell &quot;where&quot; the path traversal went wrong.  If we want to push the error reporting even harder, we can have an explicit 'interface' argument which has to be passed to both setSiteResource and getSiteResource, used for nothing but matching up to make sure that the implicit state matches the application's expectations.

Thoughts?

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002077.html">[Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation
</A></li>
	<LI>Next message: <A HREF="002093.html">[Twisted-web] HTTP-AUTH for web2 / Kudos on web2's operation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2087">[ date ]</a>
              <a href="thread.html#2087">[ thread ]</a>
              <a href="subject.html#2087">[ subject ]</a>
              <a href="author.html#2087">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
