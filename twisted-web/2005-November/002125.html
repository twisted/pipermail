<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] State and web2 (or, how to not follow REST)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20State%20and%20web2%20%28or%2C%20how%20to%20not%20follow%20REST%29&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002124.html">
   <LINK REL="Next"  HREF="002126.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] State and web2 (or, how to not follow REST)</H1>
    <B>Clark C. Evans</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20State%20and%20web2%20%28or%2C%20how%20to%20not%20follow%20REST%29&In-Reply-To="
       TITLE="[Twisted-web] State and web2 (or, how to not follow REST)">cce at clarkevans.com
       </A><BR>
    <I>Sun Nov 20 13:45:30 MST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002124.html">[Twisted-web] Forms - question
</A></li>
        <LI>Next message: <A HREF="002126.html">[Twisted-web] State and web2 (or, how to not follow REST)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2125">[ date ]</a>
              <a href="thread.html#2125">[ thread ]</a>
              <a href="subject.html#2125">[ subject ]</a>
              <a href="author.html#2125">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an attempt to summarize a conversation I had /w glyph on
#twisted.web earlier today.  I've attached the IRC log.  The basic
problem discussed was how to manage server-side state; which in
particular includes sessions and authentication.  Stateful servers
cause serious problems with scalability and with bug hunting.

Glyph is adamant that getSession() as it currently works (by raising a
redirect exception if the session does not already exist) must be fixed.
I absolutely agree with this; as it currently stands the top-level
resource must always ask for a Session object to avoid unexpected
redirects down the request stream.  This shouldn't be a lesson of
experience; it should be built-in convention.

A related issue, one to which Glyph is very concerned about, is the
implicit coupling of resources during the handling of a given request.
In particular, where a resource X (located at /foo) sets a variable V in
the request R and then a resource Y (at /foo/bar) comes to depend upon
this variable V.  If this coupling is not made explicit and checked-for,
then an opportunity for rather obscure bugs emerge; one where the
resource Y is re-used in another context (say at /bing/bar) and still
assumes that V is set.   While Twisted framework cannot prevent such
nonsense, it should propose an alternative mechanism, or at the very
least not promote such dynamic resource dependencies.

One way to make resource dependencies explicit is to require that the
constructor for a child resource take an optional ancestor resource in
its constructor.  In this model, each user/session would in essence have
its own top-level resource, and all resources which dependended upon
session state would take in its constructor the parent resource.  This
approach has a few deficiencies: (a) there might be more than one
instance of a resource Y at /foo/bar, one for each user; this is not
only inefficient but makes debugging hard beause the relation of a URI
onto a resource object is not a relation; (b) while leaf resources, such
as a static.File object need not take a parent resource in its
constructor; it forces generic Resources to have a &quot;pass-through&quot; parent
Resource, even if it does not need state information.  In the IRC
conversation, I believe (and hope) this was proposed and then eventually
rejected; but I'm not sure.  I don't like the idea of any Resource
objects in the system being user or session specific.

Another alternative is to add a getSiteResource() and setSiteResource()
to the Request interface.  The SiteResource would then contain the top
level resource &quot;/&quot; which reflected the user's Session and any other
application specific server side state (ie, nasty persistent global-like
variables which breaks REST).  The SiteResource would therefore be an
appliation specific object; it could, for example contain an session-id
and a username property for down-stream Resource authorization.   Later
in the IRC chat, Glyph said he is &quot;coming around to the fact that it's
not really a resource&quot;.  This is good; beacuse I don't think that this
server side state is a resource by the definition of web architecture.

I didn't mention it in the IRC chat, but I'm now thinking that these
methods on the request object could be setState() and getState(); and
that they return an arbitrary application-defined object which has all
of the nastly (but unfortunately mandatory and pratical) session and
request &quot;global variables&quot; that break REST and can cause all sorts of
problems.   Glyph mentioned earlier in an email that perhaps a
declarative syntax could be introduced so that arbitrary Resources could
advertise exactly what &quot;state&quot; they will access; and hence, these sorts
of errors could be detected and reported more intelligently.  I like
this idea; it is framework support to prompt developers to put in
the assertion checks that they should already be doing.  It codifies
a solid pratice, and this is a good thing.  ;)

I think that Glyph and I did have a clear agreement: all of the
information on the State (in Glyph's terms SiteResource) object should
be set (and perhaps made read-only?) _before_ any Resource delegation is
made.   We do have a slight (but very slight) semantic difference.  I
see the process of setting up a session and creating any server-side
state as done in a IRequestHandler _before_ any IResources are called.
Glyph sees this as being done &quot;by a resource which sits at the the top
level&quot;.  In both models, this sort of stuff is done before your average
every-day resources are processed; my model is just more explicit and
allows for chaining IRequestHandlers (such as one for sessions, and
another one for authentiction) before IResources are processed.  

I think that's about it.  I just want a simple solution to this, 
and soon.

Best,

Clark

-------------- next part --------------
12:18 -!- glyph [n=<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">glyph at c-24-61-138-211.hsd1.ma.comcast.net</A>] has joined #twisted.web
12:22 &lt; cce&gt; glyph: here
12:23 &lt; cce&gt; sorry; I have horrible connection /w latency and frequent drops
12:23 &lt; cce&gt; but my irc client is server side /w screen; so I can reconnect
12:25 &lt; cce&gt; Anyway, my primary question is how you pictured a down-stream Resource to obtain the Session-ID (which is needed for my application logging)
12:26 &lt; glyph&gt; cce: There are a number of ways
12:26 &lt; glyph&gt; cce: The getSiteResource thing from the mailing list is one way
12:26 &lt; cce&gt; A secondary question is... how is this method actually different from a getSession() both in operation and in the ability to prevent program logic errors.
12:26 &lt; cce&gt; ok
12:26 &lt; glyph&gt; cce: but that's really the non-preferred way
12:26  * cce listens intently.
12:26 &lt; glyph&gt; cce: the way that apps generally *should* work is that, under all these resources, there is a model.  your topmost resource is pointing at that model
12:27 &lt; glyph&gt; cce: when that resource renders itself or hands off the request to its children, it first gathers appropriate data or sub-objects from the model to create the Response or the Resource child
12:27 &lt; cce&gt; ok
12:27 &lt; glyph&gt; cce: so let's say an attribute of your underlying model is LoggingContext(sessionID=xxx)
12:28 &lt; cce&gt; so, all of the information needed to process the request (besides what is in the request itself) is collected by this GenerateModel mechanism.
12:28 &lt; glyph&gt; Right
12:28 &lt; cce&gt; That's how my app works; wonderful. ;)
12:29 &lt; cce&gt; by the time any resouce processing starts; all &quot;state dependent&quot; information has been previously constructed
12:29 &lt; glyph&gt; the top of the session for a particular user is all determined by what object is returned by the IRealm implementor returns from requestAvatar
12:29 &lt; cce&gt; in this way _all_ resources are stateless (and no additional information is put on the request)
12:30 &lt; glyph&gt; cce: Put another way, all Resources are *views*, and the underlying model is something distinct that they wrap
12:30 &lt; cce&gt; ok; we're on the same page here 
12:30 &lt; cce&gt; so the session logger is part of the model
12:30 &lt; cce&gt; (which is application specifi)
12:30 &lt; glyph&gt; cce: The way that Mantissa et. al. do this is just by adapting the user's login database object to IResource; that adaptation already has a 'original' (model) object, which is the user's private database
12:31 &lt; glyph&gt; cce: that's about where I stop suggesting that everyone do it the same way though; if you want to use mantissa's authentication model you can just use mantissa, IRealm implementations don't belong in web2 :)
12:31 &lt; cce&gt; and this is better than a request.get/setPeer(...) since the resources arn't modifying the request (they are only interacting with the model)
12:31 &lt; glyph&gt; cce: yes absolutely
12:31 &lt; cce&gt; well, this is common sense (IMHO)
12:32 &lt; cce&gt; glyph: ok, question, is there a reason why the Model should be considered a Resrouce itself?
12:32 &lt; glyph&gt; cce: no, I'm not advocating that
12:32 &lt; cce&gt; ok, so from my low-level resource / request pair, how do I get the model?
12:32 &lt; glyph&gt; cce: attributes of self :)
12:32 &lt; cce&gt; request.getModel() ?
12:33 &lt; glyph&gt; noooo
12:33 &lt; cce&gt; its a property of Request, right?
12:33 &lt; cce&gt;   def render(self, request):
12:33 &lt; glyph&gt; cce: each Resource is initialized with whatever model objects it needs as arguments to __init__
12:33 &lt; cce&gt;     # from within a nested IResource
12:33 &lt; cce&gt; oh; but then my resources are _user_ specific
12:33 &lt; glyph&gt; cce: that's why the &quot;top of the resource tree&quot; is your &quot;session&quot;
12:33 &lt; cce&gt; oh, I don't like that
12:34 &lt; cce&gt; my resources should not be specific to a given user
12:34 &lt; glyph&gt; cce: why not?
12:34 &lt; cce&gt; a File Resource, in particular, should not care what user it was created from
12:34 &lt; glyph&gt; cce: ah yes
12:35 &lt; glyph&gt; cce: that's the particular use case where you need getSiteResource
12:35 &lt; cce&gt; I _do_ like the idea of officially recongizing and talking abuot a model construction stage
12:35 &lt; glyph&gt; cce: your-app-with-model-data -&gt; File resource -&gt; some-other-part-of-your-app-dynamically-created-from-a-file
12:35 &lt; cce&gt; are you assuming that Resrouces form a tree?
12:35 &lt; glyph&gt; getSiteResource is for passing your model data between two resources which are on opposite sites of a generic resource doing some kind of dispatching
12:36 &lt; glyph&gt; cce: calling it a &quot;tree&quot; or a &quot;graph&quot; is really getting caught up in semantics
12:36 &lt; cce&gt; well, there is a difference
12:36 &lt; glyph&gt; cce: there's a traversal path of calls to locateChild
12:36 &lt; glyph&gt; cce: it could be traversing a tree, or a graph, whatever you like; the framework won't ever enforce that
12:36 &lt; cce&gt; in a tre you can get resource.getParent() and return a parent resource regardless of the Request
12:36 &lt; cce&gt; I don't want this assumption; so I'm just checking
12:37 &lt; cce&gt; so getSiteResource() is a property of Request then?
12:37 &lt; glyph&gt; yes.
12:37 &lt; cce&gt; how is  getSiteResource() different from getModel() in this case?
12:37 &lt; glyph&gt; cce: I don't like explicit functions for dealing with models
12:37 &lt; glyph&gt; cce: Maybe your view requires multiple attributes to its initializer, making its &quot;model&quot; complex
12:37 &lt; cce&gt; (where a model is the program's representation of the user's information that is constructed _before_ any resources are active_)
12:38 &lt; glyph&gt; cce: a good example of this is that you've got your user-specific model and your generic site-wide model
12:38 &lt; glyph&gt; cce: the reason I say 'SiteResource' and not 'SiteObject' is because the point of getSiteResource is view code communicating with other view code; if one view needs to extract a model component from another, that's fine, the view code is in the same layer and it can know what to do there
12:38 &lt; cce&gt; ok, so I'd do getSiteResource().getModel() then?
12:39 &lt; glyph&gt; cce: but the web framework code shouldn't be dealing in arbitrary objects, it should stick to interfaces it knows about
12:39 &lt; glyph&gt; cce: yes
12:39 &lt; cce&gt; glyph: I fail to see how this is any different than getSession()
12:40 &lt; cce&gt; other than the *pratice* that a &quot;Session&quot; or &quot;Model&quot; is constructed _before_ any resource processing takes place.
12:40 &lt; glyph&gt; cce: except getSiteResource() is a Resource (or, allowably, another object) of your own design, so getModel() can be whatever you want; getSessionIDForLog or whatever; the bottom resource in the tree
12:40 &lt; glyph&gt; cce: it's more restrictive
12:40 -!- dreid [i=<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">dreid at c-67-166-157-80.hsd1.ca.comcast.net</A>] has joined #twisted.web
12:40 &lt; glyph&gt; cce: getSession allows you to have multiple parallel sessions set by different systems and passed through the web framework
12:40 &lt; cce&gt; well, it's an extra call; but that's about it.
12:40 &lt; cce&gt; ok
12:40 &lt; cce&gt; (listening)
12:41 &lt; cce&gt; so there is exactly _one_ SiteResource independent of user?
12:41 &lt; glyph&gt; cce: yes
12:41 &lt; glyph&gt; cce: the idea is, don't provide *any* unnecessary mechanisms for users to jam their model objects into the web framework
12:41 &lt; cce&gt; ok, so request.getSiteResource().getModel(request) is needed
12:41 &lt; glyph&gt; cce: models should be passed from model to model
12:41 &lt; cce&gt; glyph: you're confusing me
12:42 &lt; cce&gt; I want to draw  &quot;Hello John&quot; in my resouce 5 layers down
12:42 &lt; glyph&gt; cce: OK wait, let me start with the simpler difference
12:42 &lt; cce&gt; how do I get the user's name...
12:42 &lt; cce&gt; from that resource/request pair
12:42 &lt; glyph&gt; cce: the main difference is that getSession raises a redirect and sets a cookie - this will not do that :)
12:42 &lt; cce&gt; ah; super
12:43 &lt; cce&gt; but let's assume I do a request.getModel().username instead
12:43 &lt; cce&gt; where my application model always sets up a session _before_ any Resources are accessed.
12:43 &lt; cce&gt; how would you do it?
12:43 &lt; glyph&gt; cce: the other difference is superficial, and not too important to understand.  It's a bit more limited than getSession (one state object per request vs. many) but you won't hit the limitations unless you are trying to do things which are bad, and if you already understand that you should be communicating between model objects in terms of your particular model interfaces and methods, it is unlikely that you will be trying to do that
12:44 &lt; cce&gt; yea, I was glossing over the session vs request-specific data
12:44 &lt; cce&gt; that can be handled in the application's model ;)
12:44 &lt; glyph&gt; right :)
12:44 &lt; glyph&gt; Session management will be implemented by a resource which sits at the top level and determines what the top-level model-wrapping site resource is
12:45 &lt; cce&gt; ok
12:45 &lt; cce&gt; what invocation would I need to get the username from my model?
12:45 &lt; glyph&gt; cce: getting there :)
12:45  * cce grins wildly.  (and thanks for your time, BTW)
12:46 &lt; cce&gt; I will make good by writing up meeting minutes and posting them
12:47 &lt; glyph&gt; the session manager won't put any data into the request at all; if your application needs to pass site-specific data down to views that are not created through explicit locateChild that passes along appropriate model data (say, through a static.File, or a vhost) then you can use setSiteResource when you create the File or the Vhost, and then in the locateChild of the resource created through the generic dispatcher resource (file or v
12:47 &lt; glyph&gt; you can call getSiteResource and retrieve it
12:48 &lt; glyph&gt; generic non-application-specific resources like files and static.Data and soforth will therefore never call either of those methods
12:48 &lt; Karnaugh&gt; tell me something
12:48 &lt; glyph&gt; When you need to get the username (here we are!) in a resource, it should be somewhere down in renderHTTP or after locateChild has been called
12:48 &lt; Karnaugh&gt; How does Guarded persist an Avatar internaly?
12:49 &lt; cce&gt; glyph: sorry, I'm confused
12:49 &lt; glyph&gt; Karnaugh: dictionary
12:49 &lt; glyph&gt; cce: let me go with a more concrete example
12:49 &lt; glyph&gt; example 1: your app can do all its communication properly without using any dispatching resources
12:50 &lt; glyph&gt; your user logs in and gets a CCEAvatarResource(cceAvatarModel) as their top resource
12:50 &lt; Karnaugh&gt; glyph: ok, but I'm wondering how it tracks the users session, or is that mangled into Twisted's resource interface or something
12:50 &lt; glyph&gt; cceAvatarModel.username is u&quot;John&quot;
12:51 &lt; Karnaugh&gt; oh wait, it comes from the realm
12:51 &lt; glyph&gt; Karnaugh: yep
12:51 &lt; glyph&gt; cce: The URL being processed is /app/appobject1
12:52 &lt; cce&gt; ok
12:52 &lt; glyph&gt; cce: CCEAvatarResource.child_app looks like this: 'return CCEApplicationObject(self.avatarModel)'
12:54 &lt; glyph&gt; cce: CCEApplicationObject.locateChild looks like this: objname = segments[0]; return CCESingleObjectView(self.avatarModel, self.avatarModel.dataModel.getObjectByName(objname)), segments[1:]
12:55 &lt; glyph&gt; cce: in CCESingleObjectView.renderHTTP (or in the appropriate place in the template) you can simply do 'return self.avatarModel.username'
12:57 &lt; glyph&gt; cce: does this example make sense?  (keep in mind that my point is not that you have to have all these intermediary resources - in an application like a blog where URLs are like /2005/11/15, you would probably create a 'Post' object straight from multiple segments rather than creating an intermediary Year/Month/Day object - my point is that if you do, this is the way to pass data between them.)
12:58 &lt; cce&gt; glyph: so, what your're saying is that the /app resource would be _specific_ to each user
12:58 &lt; cce&gt; and thus the /app/appobject1 would also be specific to each user
12:58 &lt; Karnaugh&gt; glyph: if you have static content or children under a resource, what would be a sensible way to ensure those ar eproccessesd first by locate child before getting arguments like /2005/11/15?
12:59 &lt; cce&gt; ie, you're talking about _alot_ of unnecessary objects, IMHO ;)
12:59 &lt; Karnaugh&gt; I think that sort of thing should be decoupled from the locateChild implementation...
12:59 &lt; cce&gt; Karnaugh: well, if your static resources have dynamic resources, you'd need one copy of each static object (one per user)
12:59 &lt; glyph&gt; cce: not true :)
13:00 &lt; cce&gt; so that it can create the dynamic objects /w the right model
13:00 &lt; glyph&gt; cce: You can easily store a shared static object in a fixed location
13:00 &lt; cce&gt; glyph: I was referring to static objects that have dynamic children (not static leaf objects, which are fine)
13:00 &lt; glyph&gt; cce: I'll get to the static.File example next :)
13:01 &lt; cce&gt; yea, static.File is fine with your presentation
13:01 &lt; cce&gt; it is a leaf (and I'm not sure if you can have static objects that arn't leaves)
13:01 &lt; Karnaugh&gt; What i was saying is if i have /blog/add and /blog/delete and /blog/1 or something where the latter is a refference to some id
13:01 &lt; cce&gt; glyph: well, I must say, I'd rather have request.getModel()
13:01 &lt; Karnaugh&gt; you have to reimplement locateChild to handle the children
13:01 &lt; Karnaugh&gt; afaik
13:01 &lt; glyph&gt; cce: also, you don't need the unnecessary objects; I imagine in a system like yours based on stages, you can have locateChild immediately locate the appropriate leaf resource
13:02 &lt; glyph&gt; cce: and just pass the model data to that leaf in the same way that I passed it down to each intermediary resource
13:02 &lt; cce&gt; yea; it works for me, no doubt
13:02 &lt; Karnaugh&gt; thing is if you're making a big system, constantly customising locateChild for each resource becomes a chore
13:02 &lt; cce&gt; (but anything can be fudged to wkr)
13:02 &lt; cce&gt; glyph: I agree with Karnaugh
13:03 &lt; glyph&gt; Karnaugh: Yeah, we are probably going to add some features to Nevow soon which can be cribbed by web2 for simplifying that chore
13:03 &lt; cce&gt; it is alot of creating/dicarding resource objects
13:03 &lt; cce&gt; unnecesarly
13:03 &lt; Karnaugh&gt; well you're not creating or discarding anything, you just have to reimplement locateChild every gosh darn time
13:03 &lt; cce&gt; how is this any different from putting a getModel() on the request?
13:04 &lt; cce&gt; Karnaugh: well, if each request creates a different model; then _all_ of the child Resoruces need to be re-created
13:04 &lt; glyph&gt; cce: getModel on the request requires that the resource be passed an &quot;appropriate&quot; request in order to be able to render itself
13:04 &lt; glyph&gt; cce: it's unnecessary coupling
13:04 &lt; glyph&gt; cce: in most cases, the resource ought to be able to render itself for *any* request
13:04 &lt; cce&gt; glyph: I think you're just moving the complexity (to a more innefficient form) not actually solving the problem ;)
13:05 &lt; glyph&gt; cce: in some cases it will depend on a cookie or a session-id or whatever, but the idea is to keep all that dependency locked away at the top of the tree, and have all the resources lower down be able to be unit tested with an extremely simple subset of Request
13:05 &lt; glyph&gt; cce: I don't understand why you think this is inefficient
13:05 &lt; cce&gt; well; with this mechanism you're essentially forcing Resoruces (that are Branches) into a Tree
13:06 &lt; cce&gt; ie, you mine as well add a getParent() method while you're at it
13:06 &lt; glyph&gt; cce: no
13:06 &lt; cce&gt; and this tree is essentially created at the time the request arrives
13:06 &lt; glyph&gt; cce: consider the case of the shared static File resource that multiple different users' Resource objects return
13:06 &lt; glyph&gt; cce: they are returned as children from different parents
13:06 &lt; cce&gt; I said Resources that are _branches_
13:06 &lt; cce&gt; a file isn't a branch
13:07 &lt; cce&gt; glyph: well, it's a neat idea, I suppose
13:07 &lt; cce&gt; glyph: ok
13:08 &lt; cce&gt; I've got a counter example problem
13:08 &lt; cce&gt; Suppose that you want to make a 3 deep resource tree
13:08 &lt; cce&gt; but the 2nd and Resource is &quot;generic&quot; module shared across several projects
13:09 &lt; cce&gt; in this case, you'll have to allow for the &quot;model&quot; to be anything, and it just passes along the model
13:09 &lt; cce&gt; so; your 3rd resource deep is passed a model; but it doesn't really know what kind of model
13:09 &lt; glyph&gt; Right.
13:09 &lt; glyph&gt; That's what getSiteResource is for.
13:09 &lt; cce&gt; hence, if your goal is to be able to mix resources form different sources you will always run into the problem of a bad context
13:09 &lt; glyph&gt; In this case, you do need context
13:09 &lt; cce&gt; ie, a resource is used in a way where the data it needs isn't there
13:10 &lt; glyph&gt; and you can't route around it, so the framework *needs* to provide support
13:10 &lt; glyph&gt; that's exactly the case I'm proposing getSiteResource for
13:10 &lt; cce&gt; glyph: the simplest solution, IMHO, is a getModel() on the request, and ask your programmres to be remotely intelligent by (a) asserting that the things they need are there, and (b) writing regression tests.
13:10 &lt; glyph&gt; however, I don't think we should introduce that context dependency *unless* it is needed
13:10 &lt; glyph&gt; the context dependency has a cost
13:11 &lt; cce&gt; ok, so getSiteResource() is a property of the Request?
13:11 &lt; glyph&gt; cce: Yes
13:11 &lt; cce&gt; ok, so that is essentialy my model...
13:11 &lt; glyph&gt; cce: You call setSiteResource in resource #1, and then call getSiteResource in resource #3 in your example, yes
13:11 &lt; cce&gt; any reason why you don't want to call it getModel ?
13:12 &lt; cce&gt; ie, it really isn't a Resource
13:12 &lt; cce&gt; (accoridng to the web definition anyway)
13:12 &lt; glyph&gt; cce: Yeah, I think I'm coming around to the fact that it's not really a resource
13:13 &lt; cce&gt; ok; as much as I like your 'pass-along-the-model-via-constructors' I think it doesn't allow for genreic resources and it has the tendency to create alot of &quot;duplicate&quot; Resoruce objects for the same URI, and this could make debugging harder, not easier.
13:13 &lt; glyph&gt; cce: I don't mind calling it something else, I don't like &quot;getModel&quot; because it sounds too generic, it implies to me that it's suggested that model data *always* be applied to the request, whereas I want to make it clear that such data shouldn't be applied unless it's necessary to traverse a generic resource
13:14 &lt; cce&gt; glyph: well, there are only two peices of information that I really need down-low
13:14 &lt; glyph&gt; cce: setRequestSpecific and getRequestSpecific, maybe
13:15 &lt; cce&gt; AuthenticatedUserIdentifier (a string)
13:15 &lt; cce&gt; and SessionIdentifier (a string)
13:15 &lt; cce&gt; I don't even want them to be objects
13:15 &lt; cce&gt; (my app can look the objects up if they need them)
13:15 &lt; glyph&gt; cce: you mean you don't want them to be user-defined classes? :)
13:15 &lt; cce&gt; could the Request object just have those as properties? None if the sessoin identifier or the authenticated user identifier isn't therE?
13:15 &lt; glyph&gt; cce: (strings are objects, rara)
13:16 &lt; cce&gt; yes; I suppose so; ok
13:16 &lt; glyph&gt; cce: Yes, you can set them in your app, and that will work fine, I just don't thin it should be the suggested mechanism
13:16 &lt; glyph&gt; cce: I'd prefer a documentation convention so that request-specific state is really explicit in every class that uses it
13:16 &lt; cce&gt; but the two common cases is I want to get the username and the session-id, and I'd guess these are the common needs of most commercial applications
13:16 &lt; cce&gt; glyph: fantastic idea
13:17 &lt; glyph&gt; cce: such a documentation convention strongly implies framework support and conventions too - that's all I'm suggesting this getRequestSpecific is; it's really a workaround in my mind :)
13:17 &lt; glyph&gt; anyway, I must depart
13:17 &lt; cce&gt; thank you so much for the chat
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002124.html">[Twisted-web] Forms - question
</A></li>
	<LI>Next message: <A HREF="002126.html">[Twisted-web] State and web2 (or, how to not follow REST)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2125">[ date ]</a>
              <a href="thread.html#2125">[ thread ]</a>
              <a href="subject.html#2125">[ subject ]</a>
              <a href="author.html#2125">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
