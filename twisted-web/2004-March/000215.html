<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: new nevow know-how needs...;-)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000214.html">
   <LINK REL="Next"  HREF="000216.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: new nevow know-how needs...;-)
   </H1>
    <B>Alex Martelli
    </B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com"
       TITLE="[Twisted-web] Re: new nevow know-how needs...;-)">twisted-web@twistedmatrix.com
       </A><BR>
    <I>Fri, 05 Mar 2004 12:15:56 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="000214.html">[Twisted-web] new nevow know-how needs...;-)
</A></li>
        <LI> Next message: <A HREF="000216.html">[Twisted-web] Re: new nevow know-how needs...;-)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#215">[ date ]</a>
              <a href="thread.html#215">[ thread ]</a>
              <a href="subject.html#215">[ subject ]</a>
              <a href="author.html#215">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>James Y Knight wrote:
   ...
&gt;<i> I just totally changed how this worked today. I'll describe what *now*
</I>&gt;<i> happens, which is different from what used to happen:
</I>&gt;<i> 
</I>&gt;<i> def data_foo(context, data):
</I>&gt;<i>    return 4
</I>&gt;<i> def render_foo(context, data):
</I>&gt;<i>    return context.tag['Hi: '+data]
</I>&gt;<i> span(data=data_foo, renderer=render_foo)
</I>&gt;<i> 
</I>&gt;<i> This will first call data_foo, returning '4'. data_foo's context will
</I>&gt;<i> be the context of the span (context.tag is the span tag), without its
</I>&gt;<i> IData remembered yet (thus, the data argument will be whatever the
</I>&gt;<i> containing data is, in most cases, the rend.Page instance.
</I>&gt;<i> 
</I>&gt;<i> Then, render_foo will be called, with the tag's context, again, but now
</I>&gt;<i> with the result of data_foo's result (4) as 'data'.
</I>&gt;<i> Thus, this will result in the string &quot;&lt;span&gt;Hi: 4&lt;/span&gt;&quot;.
</I>
Wonderful!  This new behavior, as you describe it, perfectly matches my
intuition about &quot;what _should_ happen&quot;.


&gt;<i> Now, take another example:
</I>&gt;<i> number = 0
</I>&gt;<i> def data_count(context, data):
</I>&gt;<i>    global number
</I>&gt;<i>    number = number + 1
</I>&gt;<i>    return number
</I>&gt;<i> 
</I>&gt;<i> span(data=data_count)[str, ' ', str, ' ', str], ' ',
</I>&gt;<i> span(data=data_count)[str, ' ', str, ' ', str]
</I>&gt;<i> 
</I>&gt;<i> This will result in the string &quot;&lt;span&gt;1 1 1&lt;/span&gt; &lt;span&gt;2 2 2&lt;/span&gt;&quot;.
</I>
One more thing that feels just right -- two &quot;calls&quot; (data directives that
mention data_count), two &quot;executions&quot; (actual calls to the function).


&gt;<i> Note that returning deferreds from the data_ is now supported. In
</I>
Again, wonderful!  I'll be able to dismantle my pesky &quot;fake renderers&quot;
that basically dealt with data being intrinsically deferred.

&gt;<i> detail, the way this works:
</I>&gt;<i> nevow.flat.flatstan.TagRenderer calls (quite paraphrased)
</I>&gt;<i> &quot;context.remember(convertToData(data, context), IData)&quot; when it first
</I>&gt;<i> sees a tag, right before it calls the function specified by the render=
</I>&gt;<i> attribute.
</I>&gt;<i> 
</I>&gt;<i> convertToData causes functions to be called, 'directive' statements to
</I>&gt;<i> be looked up, and deferreds to be handled. Then, when the actual
</I>&gt;<i> rendering function is called, it does context.locate(IData), which
</I>&gt;<i> finds the previously remembered data, and passes it directly (no
</I>&gt;<i> further fiddling is done!) to the data argument of the renderer.
</I>
Superb.  Feels simple, direct, and predictable.


&gt;<i> If you use a directive('name') form in a data=, this causes the current
</I>&gt;<i> data to be adapted to IContainer before calling .get on it. There are
</I>&gt;<i> currently adapters for dict, list, and tuple for this.
</I>
Hmmm, yes, I had to write an adapter to IContainer for my application's
&quot;business object&quot; class just to redirect data lookups back to the resource,
because this kind of thing just seemed to happen &quot;when it felt like it&quot;:-).

&gt;<i> Thus,
</I>&gt;<i> def data_foo(context, data):
</I>&gt;<i>    return defer.succeed({'foo':1, 'bar':2})
</I>&gt;<i> 
</I>&gt;<i> span(data=data_foo)[span(data=directive('foo'))[str],
</I>&gt;<i> span(data=directive('bar')[str]]
</I>&gt;<i> 
</I>&gt;<i> Should work as expected, and call data_foo *once*, and produce
</I>&gt;<i> &quot;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&quot;.
</I>&gt;<i> 
</I>&gt;<i> Hope this helps,
</I>&gt;<i> James
</I>
Sure does!  Thanks James.  The one aspect that's still a bit obscure to
me is, how is this distinction between &quot;data=data_foo&quot; (where I want to
use function or method named data_foo as the data supplier) and
&quot;data=directive('bar')&quot; (where I want the IContainer adaptation and
call to .get) distinguished, _when the HTML comes from an on-disk
template, rather than from a stan expression in my code_?  My application
is thoroughly based on on-disk templates -- I don't code much stan stuff
at all, except basically for quick and dirty prototyping of stuff that's
destined to move to an on-disk template soon anyway.  So, won't every
HTML construct coming from a template of some form such as:

&lt;span nevow:data=&quot;bar&quot;&gt;
    etc, etc
&lt;/span&gt;

end up &quot;compiled&quot; into a &quot;span(data=directive('bar'))[etc, etc]&quot; anyway,
leading me right back into subtle issues of &quot;WHERE is this 'bar'
going to be looked up, depending on phase of the moon etc&quot;...?  Or are
there two different ways I should code that '&lt;span nevow:data=&quot;bar&quot;&gt;' in
the on-disk template depending on whether I mean one thing or the other?

Anyway, if I understand correctly, I'll now get this &quot;new behavior&quot; with
just a cvs up on the (stand-alone) Nevow CVS, which I intend to do at
once, so I can experiment.  But, if I can get some explanation of how
things are designed to work, this might help.  Perhaps as small a change
as &quot;if the current IData remembrance is not adaptable to IContainer [and
perhaps also if it is, but its .get raises?], just back off to 'external'
IData remembrances until a satisfactory one is found&quot; would be sufficient
for my purposes, and -- if you can confirm there's no other solution that
better matches the current intent of the code -- I could experiment with
that kind of approach.


Thanks again,

Alex




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000214.html">[Twisted-web] new nevow know-how needs...;-)
</A></li>
	<LI> Next message: <A HREF="000216.html">[Twisted-web] Re: new nevow know-how needs...;-)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#215">[ date ]</a>
              <a href="thread.html#215">[ thread ]</a>
              <a href="subject.html#215">[ subject ]</a>
              <a href="author.html#215">[ author ]</a>
         </LI>
       </UL>
</body></html>
