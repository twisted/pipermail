<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: Re: new nevow know-how needs...;-)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000216.html">
   <LINK REL="Next"  HREF="000218.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: Re: new nevow know-how needs...;-)
   </H1>
    <B>Alex Martelli
    </B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com"
       TITLE="[Twisted-web] Re: Re: new nevow know-how needs...;-)">twisted-web@twistedmatrix.com
       </A><BR>
    <I>Sat, 06 Mar 2004 09:07:36 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="000216.html">[Twisted-web] Re: new nevow know-how needs...;-)
</A></li>
        <LI> Next message: <A HREF="000218.html">[Twisted-web] Re: Re: new nevow know-how needs...;-)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#217">[ date ]</a>
              <a href="thread.html#217">[ thread ]</a>
              <a href="subject.html#217">[ subject ]</a>
              <a href="author.html#217">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>James Y Knight wrote:

&gt;<i> On Mar 5, 2004, at 6:15 AM, Alex Martelli wrote:
</I>&gt;&gt;<i> So, won't every
</I>&gt;&gt;<i> HTML construct coming from a template of some form such as:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &lt;span nevow:data=&quot;bar&quot;&gt;
</I>&gt;&gt;<i>     etc, etc
</I>&gt;&gt;<i> &lt;/span&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> end up &quot;compiled&quot; into a &quot;span(data=directive('bar'))[etc, etc]&quot;
</I>&gt;&gt;<i> anyway,
</I>&gt;&gt;<i> leading me right back into subtle issues of &quot;WHERE is this 'bar'
</I>&gt;&gt;<i> going to be looked up, depending on phase of the moon etc&quot;...?  Or are
</I>&gt;&gt;<i> there two different ways I should code that '&lt;span nevow:data=&quot;bar&quot;&gt;'
</I>&gt;&gt;<i> in
</I>&gt;&gt;<i> the on-disk template depending on whether I mean one thing or the
</I>&gt;&gt;<i> other?
</I>&gt;<i> 
</I>&gt;<i> Welll, it doesn't depend on the phase of the moon. directives always
</I>&gt;<i> get looked up on the first data it finds above it in the tree. I'm not
</I>&gt;<i> sure exactly what your question is, but, is it the lack of being able
</I>&gt;<i> to go back up the tree? e.g.:
</I>
I guess, essentiallly, that's it -- except that in my experience with
the previous mechanism it appeared to me that sometimes (unpredictably)
the lookup happened on the IData set by a &quot;SISTER&quot; tag, rather than on
the data set by a &quot;mother&quot; / &quot;grandmother&quot; one.  If now the lookup is
always strictly &quot;upwards&quot; (towards the root of the tree without
exceptions), that, at least, is progress, even though I'll still have
to do lots of data fetching in renderers (mixing view and model).

Basically, assuming that's how it always works now, I have to consider 
that putting a data fetch in a data directive &quot;poisons the well&quot; for a 
whole subtree -- there is no &quot;going back&quot;, ever.  If there is any
possibility at all that the templates-author (a web designer separate
from the programmer who codes the logic behind the templates) may want
to get to such other data suppliers, &quot;hidden&quot; by the current mechanism,
then I have to code render methods that know how to get their own
data.

&gt;<i> class MyPage:
</I>&gt;<i>    def data_foo(context, data):
</I>&gt;<i>      return {'bar':2, 'baz':3}
</I>&gt;<i>    def data_other(context, data):
</I>&gt;<i>      return 1
</I>&gt;<i>    docFactory = xmlstr(&quot;&quot;&quot;
</I>&gt;<i>    &lt;html&gt;
</I>&gt;<i>      &lt;span data=&quot;foo&quot;&gt;
</I>&gt;<i>        &lt;span data=&quot;bar&quot; render=&quot;string&quot;&gt;This works fine.&lt;/span&gt;
</I>&gt;<i>        &lt;span data=&quot;other&quot; render=&quot;string&quot;&gt;This won't work because
</I>&gt;<i> 'other' isn't a key in {'bar':2, 'baz':3}.&lt;/span&gt;
</I>&gt;<i>      &lt;/span&gt;
</I>&gt;<i>    &lt;/html&gt;&quot;&quot;&quot;)
</I>
Right.  calling .get(&quot;other&quot;) on that dictionary returns None,
and, that's it: the situation becomes irretrievable in the
current scheme (even though in a much clearer way than it was
in the previous one).


&gt;&gt;<i> Anyway, if I understand correctly, I'll now get this &quot;new behavior&quot;
</I>&gt;&gt;<i> with
</I>&gt;&gt;<i> just a cvs up on the (stand-alone) Nevow CVS, which I intend to do at
</I>&gt;&gt;<i> once, so I can experiment.
</I>&gt;<i> 
</I>&gt;<i> Yep.
</I>
I have indeed experimented, with my adapter still in place and print
statements in said adapter to track when it's called; the number of
occurrences has dropped from many dozens to just a couple in a typical
rendering pass -- real progress, but still a LITTLE to go.


&gt;&gt;<i> as &quot;if the current IData remembrance is not adaptable to IContainer
</I>&gt;&gt;<i> [and
</I>&gt;&gt;<i> perhaps also if it is, but its .get raises?], just back off to  
</I>&gt;&gt;<i> 'external'
</I>&gt;&gt;<i> IData remembrances until a satisfactory one is found&quot; would be
</I>   ...
&gt;<i> I dont think that's the right solution. Too magical. And, what if your
</I>&gt;<i> data *is* a container but you still want to get to something outside
</I>&gt;<i> it? One idea that's been proposed and that makes a lot of sense to me
</I>&gt;<i> is a &quot;../&quot; syntax, so you could say data=&quot;../other&quot; or &quot;/other&quot; in the
</I>&gt;<i> example above. It just hasn't been implemented yet.
</I>
It seems to me that, while a syntax to explicitly access &quot;overridden
names&quot; (of data suppliers) is helpful in some corner cases, the fundamental
mechanism should still be &quot;if a name has not been overridden it's still
accessible&quot; -- by analogy with OO programming, and also with CSS mechanics
(the latter may be more accessible to my target audience -- template authors
who are fundamentally web designers, rather than programmers).

So, basically, I'm thinking of IData remembrances as being &quot;in a stack&quot;.

When a data directive lookup happens, it should walk up the stack, trying,
for each different IData remembrance it meets, in order, to perform:
    new_data = IContainer(said_data).get('new_name')
Instead of giving up if this raises, or binds new_data to None, such
failures, it seems to me, should just mean one keeps walking up the stack.

I don't see this as 'too magical' any more than I consider OO name lookups
(and in a single-inheritance scenario, too, the very simplest!) to be so
(CSS is more complicated and thus might be 'too magical' for some, yet
web designers are mastering THAT complicated name-lookup scenario
already...).

Guess I'll try to play with these concepts in my copious spare time and
see if I can grasp enough of the remembrance and lookup mechanisms to
implement a sandbox version of this.  Any suggestions of where to focus
in the nevow sources?


Thanks,

Alex




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000216.html">[Twisted-web] Re: new nevow know-how needs...;-)
</A></li>
	<LI> Next message: <A HREF="000218.html">[Twisted-web] Re: Re: new nevow know-how needs...;-)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#217">[ date ]</a>
              <a href="thread.html#217">[ thread ]</a>
              <a href="subject.html#217">[ subject ]</a>
              <a href="author.html#217">[ author ]</a>
         </LI>
       </UL>
</body></html>
