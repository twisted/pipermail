<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Session class
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Session%20class&In-Reply-To=1223054877.5174.76.camel%40localhost.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003942.html">
   <LINK REL="Next"  HREF="003944.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Session class</H1>
    <B>Maarten ter Huurne</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Session%20class&In-Reply-To=1223054877.5174.76.camel%40localhost.localdomain"
       TITLE="[Twisted-web] Session class">maarten at treewalker.org
       </A><BR>
    <I>Fri Oct  3 20:13:13 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="003942.html">[Twisted-web] Session class
</A></li>
        <LI>Next message: <A HREF="003944.html">[Twisted-web] Athena &amp; browser 2-connection limit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3943">[ date ]</a>
              <a href="thread.html#3943">[ thread ]</a>
              <a href="subject.html#3943">[ subject ]</a>
              <a href="author.html#3943">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Friday 03 October 2008, George Pauly wrote:

&gt;<i> There are a couple  of things I don't understand about Site._mkuid()
</I>&gt;<i>
</I>&gt;<i> IANAC (I am not a cryptographer).
</I>&gt;<i>
</I>&gt;<i> Md5 collisions are rare, but (I guess) might theoretically happen
</I>&gt;<i> depending on length of input.  Does appending the counter to the random
</I>&gt;<i> output with an underscore change the statistics of collision?
</I>
The random() function returns a 53-bit float, while the MD5 hash is 128-bit, 
so I think combining the random number with something else does decrease 
the chance of collisions. However, it would probably be safer to ask the 
random generator to produce more bits.

&gt;<i> Alternatively, perhaps the counter is used as a salt?  If so, the salt
</I>&gt;<i> does not seem _very_ secret in this case.  If a sufficiently strong
</I>&gt;<i> random number is used a salt would seem unnecessary.
</I>
I think the idea is that the random number by itself is already 
unpredictable enough. But hashing more data will never make it easier to 
recover the random number and might make it harder, if I understand MD5 
correctly.

&gt;<i> I've looked at some python code for session keys (Django, something on
</I>&gt;<i> activestate that might be Zope code) and they hash together various
</I>&gt;<i> things, but not counters.
</I>&gt;<i>
</I>&gt;<i> I've generated session keys by appending plain-text counters (with an
</I>&gt;<i> offset) to random hashes.  This guarantees uniqueness &amp; is handy because
</I>&gt;<i> it is human readable &amp; you can quickly see how many sessions have been
</I>&gt;<i> used since initiation.  Of course, the counter value might be sensitive
</I>&gt;<i> information in some situations.  An encrypted counter might be helpful,
</I>&gt;<i> if the object is to have a session key that is guaranteed random and
</I>&gt;<i> unique.  Or you could just check to see if the key was in use, ala
</I>&gt;<i> Django, and leave off the counter altogether.
</I>
You can check whether there is already an active session with the newly 
generated UID, but if you want to know for sure whether or not there is an 
expired session with the newly generated UID, you'd have to remember all 
UIDs you ever handed out.

&gt;<i> One idea from this code (<A HREF="http://code.activestate.com/recipes/52252/">http://code.activestate.com/recipes/52252/</A>) :
</I>&gt;<i> &gt; # create a unique session id
</I>&gt;<i> &gt; # input - string to use as part of the data used to create the session
</I>&gt;<i> &gt; key. #         Although not required, it is best if this includes some
</I>&gt;<i> &gt; unique #         data from the site, such as it's IP address or other
</I>&gt;<i> &gt; environment #         information.  For ZOPE applications, pass in the
</I>&gt;<i> &gt; entire ZOPE &quot;REQUEST&quot; #         object.
</I>&gt;<i> &gt; def makeSessionId(st):
</I>&gt;<i> &gt; 	import md5, time, base64
</I>&gt;<i> &gt; 	m = md5.new()
</I>&gt;<i> &gt; 	m.update('this is a test of the emergency broadcasting system')
</I>&gt;<i> &gt; 	m.update(str(time.time()))
</I>&gt;<i> &gt; 	m.update(str(st))
</I>&gt;<i> &gt; 	return string.replace(base64.encodestring(m.digest())[:-3], '/', '$'
</I>&gt;<i> &gt; )
</I>
I don't know exactly what is in a ZOPE request object, but it's likely to be 
predictable. A constant string is impossible to mispredict. And the time 
might not predictable exactly, but if the uncertainty is small enough to 
make brute forcing it feasible, it's also relatively predictable. A hash of 
predictable things is itself predictable.

The Twisted session UID uses a random number generator which is seeded from 
a secure random generator (if the OS has one). So assuming the secure 
random generator does its job well, the initial session UID cannot be 
predicted. However, from that point on the random generator is completely 
deterministic, which means that someone who can discover its internal state 
can generate the same numbers.

The problem is that the current implementation uses Python's shared random 
generator instance, which might be used for other purposes as well and some 
applications might leak too many hints about the internal state of this 
shared generator. Although this is not very likely to happen, it is 
possible and could be avoided by allocating a dedicated generator just for 
session UIDs.

&gt;<i> is to pass in environment info to defend against hijacking.  I've used a
</I>&gt;<i> very similar method in a stateless (on the server, for cgi) session key
</I>&gt;<i> using several environment vars and a salt.  This code does not seem to
</I>&gt;<i> worry about uniqueness (may be OK, I'm not sure).
</I>
If collisions are rare enough that the chance of one occurring during the 
lifetime of the application is neglible, that's close enough to unique for 
practical purposes.

Bye,
		Maarten
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 194 bytes
Desc: This is a digitally signed message part.
Url : <A HREF="http://twistedmatrix.com/pipermail/twisted-web/attachments/20081004/9829bb50/attachment.pgp">http://twistedmatrix.com/pipermail/twisted-web/attachments/20081004/9829bb50/attachment.pgp</A>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003942.html">[Twisted-web] Session class
</A></li>
	<LI>Next message: <A HREF="003944.html">[Twisted-web] Athena &amp; browser 2-connection limit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3943">[ date ]</a>
              <a href="thread.html#3943">[ thread ]</a>
              <a href="subject.html#3943">[ subject ]</a>
              <a href="author.html#3943">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
