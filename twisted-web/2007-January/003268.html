<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Re: Twisted Flickr API library
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20Twisted%20Flickr%20API%20library&In-Reply-To=20070119033531.GA5571%40steerpike.home.puzzling.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003267.html">
   <LINK REL="Next"  HREF="003269.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Re: Twisted Flickr API library</H1>
    <B>Ross Burton</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Re%3A%20Twisted%20Flickr%20API%20library&In-Reply-To=20070119033531.GA5571%40steerpike.home.puzzling.org"
       TITLE="[Twisted-web] Re: Twisted Flickr API library">ross at burtonini.com
       </A><BR>
    <I>Fri Jan 19 04:13:24 CST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003267.html">[Twisted-web] Twisted Flickr API library
</A></li>
        <LI>Next message: <A HREF="003269.html">[Twisted-web] HTTP authentication and Nevow cred checker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3268">[ date ]</a>
              <a href="thread.html#3268">[ thread ]</a>
              <a href="subject.html#3268">[ subject ]</a>
              <a href="author.html#3268">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2007-01-19 at 14:35 +1100, Andrew Bennetts wrote:
&gt;<i> At a glance, it seems sane.  One thing I noticed skimming:
</I>&gt;<i> 
</I>&gt;<i>         self.auth_getToken(frob=state['frob']).addCallbacks(gotToken, lambda fault: d.errback(fault))
</I>&gt;<i> 
</I>&gt;<i> could be just:
</I>&gt;<i> 
</I>&gt;<i>         self.auth_getToken(frob=state['frob']).addCallbacks(gotToken, d.errback)
</I>
Ah yes, of course.

&gt;<i> Actually, more importantly, this pattern is a bit odd:
</I>&gt;<i> 
</I>&gt;<i> &gt;     def __getattr__(self, method, **kwargs):
</I>&gt;<i> &gt;         method = &quot;flickr.&quot; + method.replace(&quot;_&quot;, &quot;.&quot;)
</I>&gt;<i> &gt;         if not self.__methods.has_key(method):
</I>&gt;<i> &gt;             def proxy(method=method, **kwargs):
</I>&gt;<i> &gt;                 d = defer.Deferred()
</I>&gt;<i> &gt;                 def cb(data):
</I>&gt;<i> &gt;                     self.logger.info(&quot;%s returned&quot; % method)
</I>&gt;<i> &gt;                     xml = ElementTree.XML(data)
</I>&gt;<i> &gt;                     if xml.tag == &quot;rsp&quot; and xml.get(&quot;stat&quot;) == &quot;ok&quot;:
</I>&gt;<i> &gt;                         d.callback(xml)
</I>&gt;<i> &gt;                     elif xml.tag == &quot;rsp&quot; and xml.get(&quot;stat&quot;) == &quot;fail&quot;:
</I>&gt;<i> &gt;                         err = xml.find(&quot;err&quot;)
</I>&gt;<i> &gt;                         d.errback(Failure(FlickrError(err.get(&quot;code&quot;), err.get(&quot;msg&quot;))))
</I>&gt;<i> &gt;                     else:
</I>&gt;<i> &gt;                         # Fake an error in this case
</I>&gt;<i> &gt;                         d.errback(Failure(FlickrError(0, &quot;Invalid response&quot;)))
</I>&gt;<i> &gt;                 self.__call(method, kwargs).addCallbacks(cb, lambda fault: d.errback(fault))
</I>&gt;<i> &gt;                 return d
</I>&gt;<i> &gt;             self.__methods[method] = proxy
</I>&gt;<i> &gt;         return self.__methods[method]
</I>&gt;<i> 
</I>&gt;<i> Here the proxy function creates a deferred (&quot;d&quot;), effectively chains it to the
</I>&gt;<i> Deferred from __call, then returns d.  It would be simpler to just use the
</I>&gt;<i> Deferred you already have.  So something like (untested...):
</I>&gt;<i> 
</I>&gt;<i>     def __getattr__(self, method, **kwargs):
</I>&gt;<i>         method = &quot;flickr.&quot; + method.replace(&quot;_&quot;, &quot;.&quot;)
</I>&gt;<i>         if not self.__methods.has_key(method):
</I>&gt;<i>             def proxy(method=method, **kwargs):
</I>&gt;<i>                 def cb(data):
</I>&gt;<i>                     self.logger.info(&quot;%s returned&quot; % method)
</I>&gt;<i>                     xml = ElementTree.XML(data)
</I>&gt;<i>                     if xml.tag == &quot;rsp&quot; and xml.get(&quot;stat&quot;) == &quot;ok&quot;:
</I>&gt;<i>                         d.callback(xml)
</I>&gt;<i>                     elif xml.tag == &quot;rsp&quot; and xml.get(&quot;stat&quot;) == &quot;fail&quot;:
</I>&gt;<i>                         err = xml.find(&quot;err&quot;)
</I>&gt;<i>                         raise FlickrError(err.get(&quot;code&quot;), err.get(&quot;msg&quot;))
</I>&gt;<i>                     else:
</I>&gt;<i>                         # Fake an error in this case
</I>&gt;<i>                         raise FlickrError(0, &quot;Invalid response&quot;)
</I>&gt;<i>                 return self.__call(method, kwargs)
</I>&gt;<i>             self.__methods[method] = proxy
</I>&gt;<i>         return self.__methods[method]
</I>&gt;<i> 
</I>&gt;<i> Which is noticeably simpler.  You seem to do the same contortion everywhere.
</I>
Ah, I like the raising, I didn't know twisted would handle exceptions
and pass them to the errback.

Your re-written version doesn't actually call cb anywhere.  I introduced
a chained Deferred as I want to get the reply from the method call, and
further process it before the user sees the reply.  This is because a
successful reply from the PoV of the HTTP request can actually contain
an error message, which in cb() is converted to an exception.  Also, the
data from the HTTP call is processed and a different object is passed to
the application's callback.

I've only had my first coffee of the day so am obviously being a little
slow, but where would the addCallback(cb) go in your version, and what
would replace d.callback() inside cb()?

&gt;<i> Also, rather than s.spawnlp(os.P_WAIT, &quot;epiphany&quot;, &quot;epiphany&quot;, &quot;-p&quot;, url),
</I>&gt;<i> perhaps the stdlib's &quot;webbrowser&quot; module would be more appropriate.
</I>
Yeah, good call.

Thanks for the help,
Ross
-- 
Ross Burton                                 mail: <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">ross at burtonini.com</A>
                                          jabber: <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">ross at burtonini.com</A>
                                     www: <A HREF="http://www.burtonini.com./">http://www.burtonini.com./</A>
 PGP Fingerprint: 1A21 F5B0 D8D0 CFE3 81D4 E25A 2D09 E447 D0B4 33DF




</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003267.html">[Twisted-web] Twisted Flickr API library
</A></li>
	<LI>Next message: <A HREF="003269.html">[Twisted-web] HTTP authentication and Nevow cred checker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3268">[ date ]</a>
              <a href="thread.html#3268">[ thread ]</a>
              <a href="subject.html#3268">[ subject ]</a>
              <a href="author.html#3268">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
