<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] fragments with child lookup
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20fragments%20with%20child%20lookup&In-Reply-To=452E035F.2020006%40bluegap.ch">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003090.html">
   <LINK REL="Next"  HREF="003097.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] fragments with child lookup</H1>
    <B>L. Daniel Burr</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20fragments%20with%20child%20lookup&In-Reply-To=452E035F.2020006%40bluegap.ch"
       TITLE="[Twisted-web] fragments with child lookup">ldanielburr at mac.com
       </A><BR>
    <I>Thu Oct 12 12:12:02 CDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="003090.html">[Twisted-web] fragments with child lookup
</A></li>
        <LI>Next message: <A HREF="003097.html">[Twisted-web] fragments with child lookup
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3095">[ date ]</a>
              <a href="thread.html#3095">[ thread ]</a>
              <a href="subject.html#3095">[ subject ]</a>
              <a href="author.html#3095">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Markus,

Sorry I've been so tardy in responding, and thanks for reminding me.


On Thu, 12 Oct 2006 03:57:03 -0500, Markus Schiltknecht  
&lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">markus at bluegap.ch</A>&gt; wrote:

&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> L. Daniel Burr wrote:
</I>&gt;&gt;<i> I'm a bit busy today, but I will respond in greater length about why I  
</I>&gt;&gt;<i> do
</I>&gt;&gt;<i> not care for the &quot;every URL segment is a template&quot; design approach, and
</I>&gt;&gt;<i> what I prefer to do instead.
</I>&gt;&gt;<i>  Also, thanks for actually reading up on Zope Acquisition and WSGI  
</I>&gt;&gt;<i> issues;
</I>&gt;&gt;<i> I'll try to explain where I think they go wrong.
</I>&gt;<i>
</I>
Ok, first things first.  The reason I hate &quot;template per segment&quot; designs
is the same reason that I hate Zope acquisition.  They both suffer from
the same illness, which is complexity. Take the following URL:

<A HREF="http://myhost.com/foo/bar/baz">http://myhost.com/foo/bar/baz</A>

This URL identifies a resource, and when some client requests this URL,
a representation of that resource will be sent to the client.  In order
to render this representation in &quot;template-per-segment&quot; design, I have
to first traverse the tree and render &quot;foo&quot;, then &quot;bar&quot; then lastly,
&quot;baz&quot;.  This enforces a needless dependency upon containment.  Why does
the resource living at &quot;baz&quot; have to depend upon &quot;foo&quot; and &quot;bar&quot; in
order to produce a representation of &quot;baz&quot;?  Answer: It doesn't have to,
and it shouldn't.  By imposing this kind of dependency, you are *not*
gaining the componentization you desire; on the contrary, you've now
got tight coupling, and changes to the way &quot;foo&quot; is rendered may cause
problems when rendering &quot;bar&quot; or &quot;baz&quot;.  The longer your URLs get, and
the more segments you have to render, the greater the likelihood that
you are going to start breaking stuff each time you fiddle with one of
your templates.

The same argument applies to acquisition.  In the above example, let's
suppose that I need to access an object, named &quot;userData&quot;.  Using the
acquisition model, this means that first &quot;baz&quot; will be searched, then
&quot;bar&quot;, then &quot;foo&quot;.  If you are lucky, or extremely careful, you can
code to avoid problems with this, but sooner or later, you will run
into the situation where more than one resource in the URL has a
userData object.  When this collision occurs, the userData object
nearest to the end of the URL will be used.  Maybe that is what you
want, but maybe it isn't.

Put more simply, the problem with both &quot;template-per-segment&quot; and
acquisition is that they do not scale.  Cannot scale.  Will never
be made to scale without massive effort on the part of the coder,
and weren't you thinking that you wanted this model because it would
be *less* work?

&gt;<i> My current project which started all this is almost over now. As you  
</I>&gt;<i> might know, I tried to do it the nevow way. And I guess I've come to the  
</I>&gt;<i> root of my problem: I'm more looking for a _website_ building system,  
</I>&gt;<i> while nevow seems to be a system to build web applications. Which is in  
</I>&gt;<i> no way meant to put nevow down, it just has a slightly different focus.
</I>&gt;<i>
</I>
This is an excellent observation.  I find that I build far more web apps
than web sites, in my work, although it seems that the vast majority of
developers seem to still be building sites.  Note though, that I do not
think that the &quot;template-per-segment&quot; design is good for large web-sites
either.  The scale argument still applies.

That said, nevow could certainly use some help in documenting what the
&quot;best practices&quot; are, for building both nevow sites, and nevow apps.
I have long had good intentions about helping in this area, but I have
so far failed to find time to do it.

&gt;<i> Another thought I've had was: most probably I could come away with just  
</I>&gt;<i> having the templates split up. I don't need (and as you have pointed  
</I>&gt;<i> out, it's probably dangerous) to split the code behind. One way to do  
</I>&gt;<i> that would be writing a docFactory which compiles a template from  
</I>&gt;<i> multiple XML fragments.
</I>&gt;<i>
</I>
That's not a bad idea.  Another idea is to simply stop worrying about
HTML duplication, and let each URL segment be fully responsible for
rendering itself, rather than enforcing a meaningless inheritance
model on what should be a simple resource.  Seriously, URL segments
show containment, but nowhere is it written in stone that containment
equals inheritance.

Once you stop thinking this way, you can achieve great flexibility, just
as using interfaces is more flexible that relying on subclassing.

&gt;<i> Anyway, before writing any code I'd love to hear what concepts others  
</I>&gt;<i> have in mind. Especially your argumentation against WSGI would be  
</I>&gt;<i> interesting for me.
</I>&gt;<i>
</I>
WSGI.  This is one that I am virtually certain to be alone on.  The
fact is, some very smart people came up with WSGI.  Another fact is
that some very smart people came up with SOAP, WSDL, UDDI, etc.

I find WSGI of little value because, to me, it is just another attempt
at creating the &quot;lego&quot; model.  Every once in awhile, some smart people
get together and try to come up with a component model that will truly
give them &quot;lego&quot; style pluggability.  WSGI is all about saying, &quot;hey,
choose whatever app server you want, as long as it speaks German. Want
a session component?  Go ahead, use any one you like, as long as it
speaks German.  An ORM?  If it speaks German, you're good to go!&quot;

Seriously, the whole pluggability, freedom-of-choice thing is a bunch
of nonsense.  Who the hell cares if you can plug stuff together, when
it all has to plug together in the same way?  Any color you want, as
long as it is black.

Also, I've been using twisted since version 0.9 or so, and WSGI is
very honest about saying that it doesn't really have anything useful
to contribute to the async model of web development.  WSGI is really
great for those people who like threads, and that's great for them.
For people who prefer async architectures, WSGI will never be a good
fit.  Note that web2 does support WSGI, but in order to do so, it
has to give up most of the value of being async.

One last gripe with regards to WSGI: It claims to be a solution to
the problem of &quot;too many web stacks&quot; in Python-land.  In reality,
it is just another attempt at creating The One True Stack, and I
have been opposed to that since the first blog appeared,
complaining that other languages are &quot;winning&quot;, due to the existence
of one overwhelmingly popular choice for web dev.

Many people will disagree with my stance on these topics, I'm sure.
On the other hand, this rant is so long that many will simply avoid
responding ;)

&gt;<i> Regards
</I>&gt;<i>
</I>&gt;<i> Markus
</I>
Have a good one,

L. Daniel Burr

</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003090.html">[Twisted-web] fragments with child lookup
</A></li>
	<LI>Next message: <A HREF="003097.html">[Twisted-web] fragments with child lookup
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3095">[ date ]</a>
              <a href="thread.html#3095">[ thread ]</a>
              <a href="subject.html#3095">[ subject ]</a>
              <a href="author.html#3095">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
