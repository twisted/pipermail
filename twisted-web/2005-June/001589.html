<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Livepage, ClientHandle and context [continued]
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Livepage%2C%20ClientHandle%20and%20context%20%5Bcontinued%5D&In-Reply-To=35bb42690506262330eba7851%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001578.html">
   <LINK REL="Next"  HREF="001580.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Livepage, ClientHandle and context [continued]</H1>
    <B>Donovan Preston</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Livepage%2C%20ClientHandle%20and%20context%20%5Bcontinued%5D&In-Reply-To=35bb42690506262330eba7851%40mail.gmail.com"
       TITLE="[Twisted-web] Livepage, ClientHandle and context [continued]">dp at ulaluma.com
       </A><BR>
    <I>Tue Jun 28 12:43:49 MDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001578.html">[Twisted-web] Livepage, ClientHandle and context [continued]
</A></li>
        <LI>Next message: <A HREF="001580.html">[Twisted-web] Twisted network package for python implementation
	problem with GUI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1589">[ date ]</a>
              <a href="thread.html#1589">[ thread ]</a>
              <a href="subject.html#1589">[ subject ]</a>
              <a href="author.html#1589">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Jun 26, 2005, at 11:30 PM, Chris (FeedTagger) wrote:

&gt;<i> Sorry, just registered so unable to join existing thread.
</I>&gt;<i>
</I>&gt;<i> I'm having similar problems that are outlined here:
</I>&gt;<i> <A HREF="http://twistedmatrix.com/pipermail/twisted-web/2005-June/001523.html">http://twistedmatrix.com/pipermail/twisted-web/2005-June/001523.html</A>
</I>&gt;<i> &quot;I also can't see a way to use handler_* methods, because this methods
</I>&gt;<i> must be inside a rend.Fragment subclass in my case.&quot;
</I>
There's no way Nevow can automatically determine that a handler event  
should be dispatched to your Fragment instance, so you'll have to  
tell it. Your expectation below is correct:

&gt;<i> I expect this can be rectified in livepage.py (line 728 on my co):
</I>&gt;<i>     def locateHandler(self, ctx, path, name):
</I>&gt;<i>         ### XXX TODO: Handle path
</I>&gt;<i>         return getattr(self, 'handle_%s' % (name, ))
</I>
The path here is meant to be a string which names a Fragment or other  
dispatch path. As you can see, none of this is implemented yet, but  
this is my solution to this problem that you and others on this list  
have had. Basically the API in javascript would look something like  
this:

server.handleWithPath('onclick', 'some/path', 'someArgument')

locateHandler would change to look more like locateChild, breaking  
apart the path into segments and consuming them until it locates the  
target. I'm not sure how the default locateHandler implementation  
will locate action targets; perhaps with dispatch_* prefixed methods?  
Here is a small example:

class MainPage(Page):
     docFactory = loaders.xmlstring(&quot;&quot;&quot;&lt;html xmlns:n=&quot;http:// 
nevow.com/ns/nevow/0.1&quot;&gt;
   &lt;a onclick=&quot;server.handleWithPath('onclick', 'someFragment',  
'someArg')&quot;&gt;
     Click me
   &lt;/a&gt;
   &lt;span n:render=&quot;liveid&quot; /&gt;
   &lt;span n:render=&quot;liveglue&quot; /&gt;
&lt;/html&gt;&quot;&quot;&quot;)

     def dispatch_someFragment(self, ctx):
         return MyFragment()


class MyFragment(Fragment):
     def handle_onclick(self, ctx, someArg):
          assert someArg == 'someArg'


Suggestions on different names other than &quot;dispatch_*&quot; are welcome;  
the main reason I haven't implemented this functionality yet is  
because I can't decide what to call it! :-)

&gt;<i>
</I>&gt;<i> My implementation is slightly different in that I'm not using
</I>&gt;<i> rend.Fragment, I have a Page broker that responds to requests and
</I>&gt;<i> returns a new page that implements from a master page.
</I>&gt;<i>
</I>&gt;<i> --------------------------
</I>&gt;<i> myserver.py:
</I>&gt;<i>
</I>&gt;<i> pageMappings ] {
</I>&gt;<i>   'search': search.Page
</I>&gt;<i>   'index': index.Page
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> class Page(livepage.LivePage):
</I>&gt;<i>   def locateChild(self,ctx,segments):
</I>&gt;<i>     # depending on the value of segments[0] return the correct page
</I>&gt;<i>     # from a predefined map, otherwise 404
</I>&gt;<i>     page = pageMappings[segments[0]]
</I>&gt;<i>     return page(), segments[1]
</I>&gt;<i>
</I>&gt;<i> Then in index.Page.py:
</I>&gt;<i> class Page(_master.FrontPage):
</I>&gt;<i>
</I>&gt;<i>   def render_button(self,ctx,data):
</I>&gt;<i>     return ctx.tag(onclick=&quot;server.handle('click')&quot;)
</I>&gt;<i>
</I>&gt;<i>   def handle_click(self,ctx,client):
</I>&gt;<i>     client.alert('clicked button')
</I>&gt;<i>
</I>&gt;<i> _master.py:
</I>&gt;<i>
</I>&gt;<i> class CorePage(livepage.LivePage):
</I>&gt;<i>   # various properties that all generic pages should exhibit
</I>&gt;<i>
</I>&gt;<i> class FrontPage(CorePage):
</I>&gt;<i>   # load front page template
</I>&gt;<i>   # provide any default slot fills etc.
</I>&gt;<i>
</I>&gt;<i> --------------------
</I>&gt;<i> Now the problem as I see it (with primitive livepage knowledge) is
</I>&gt;<i> that the livepage request that's sent with server.handle('click') is
</I>&gt;<i> attempting to be mapped to myserver.Page, instead of my intended
</I>&gt;<i> index.Page class.
</I>&gt;<i> Is it possible to provide this functionality or should this whole
</I>&gt;<i> template based approach be re-worked in some other fashion?
</I>
Again, you want the above proposed architecture to be finished, but  
it isn't finished yet.

&gt;<i> ... as a side note using a generic dispatcher of pages (myserver.Page)
</I>&gt;<i> I can do cool things like detect /xml appended to url and instead of
</I>&gt;<i> loading .xhtml templates, load the appropriate .xml templates. Hence
</I>&gt;<i> without changing any application code I can generate xml versions of
</I>&gt;<i> every single webpage across a site.
</I>
I suggest using a query parameter rather than an additional URL  
segment. xml is a different &quot;view&quot; of the same &quot;object&quot;; in my  
opinion, URLs should represent &quot;objects&quot; (Resources) and query  
parameters should be used to parameterize how the view renders. One  
might also be able to use the &quot;Accept&quot; header that browsers send to  
negotiate the rendered content type. But this is just a suggestion.  
Whatever works for you is fine with me :-)

And yes, this is a cool capability to want to have.

Donovan

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://twistedmatrix.com/pipermail/twisted-web/attachments/20050628/3c3a9b84/attachment.htm">http://twistedmatrix.com/pipermail/twisted-web/attachments/20050628/3c3a9b84/attachment.htm</A>
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001578.html">[Twisted-web] Livepage, ClientHandle and context [continued]
</A></li>
	<LI>Next message: <A HREF="001580.html">[Twisted-web] Twisted network package for python implementation
	problem with GUI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1589">[ date ]</a>
              <a href="thread.html#1589">[ thread ]</a>
              <a href="subject.html#1589">[ subject ]</a>
              <a href="author.html#1589">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
