<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20streaming%20request%20%28was%3A%20status%20of%20Twisted%20Web%0A%09and%20Web%202%29&In-Reply-To=20080306210253.GD13580%40mcnabbs.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003679.html">
   <LINK REL="Next"  HREF="003681.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)</H1>
    <B>Jean-Paul Calderone</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20streaming%20request%20%28was%3A%20status%20of%20Twisted%20Web%0A%09and%20Web%202%29&In-Reply-To=20080306210253.GD13580%40mcnabbs.org"
       TITLE="[Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)">exarkun at divmod.com
       </A><BR>
    <I>Thu Mar  6 17:05:08 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="003679.html">[Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)
</A></li>
        <LI>Next message: <A HREF="003681.html">[Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3680">[ date ]</a>
              <a href="thread.html#3680">[ thread ]</a>
              <a href="subject.html#3680">[ subject ]</a>
              <a href="author.html#3680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 6 Mar 2008 14:02:53 -0700, Andrew McNabb &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">amcnabb at mcnabbs.org</A>&gt; wrote:
&gt;<i>On Thu, Mar 06, 2008 at 01:00:44PM -0500, Jean-Paul Calderone wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> FWIW, IConsumer is a better match here than IProtocol (that's a more or
</I>&gt;&gt;<i> less irrelevant detail, though).
</I>&gt;<i>
</I>&gt;<i>I can see why IConsumer would be more appropriate than IProtocol, but
</I>&gt;<i>I'm entirely unconvinced by the arguments that IStreamingRequestHandler
</I>&gt;<i>would be better than IConsumer.
</I>&gt;<i>
</I>&gt;<i>To start with, I don't understand what an IConsumer has to do with an
</I>&gt;<i>IResource.
</I>
Inherently?  Nothing.  I'm sure you're driving at something, but alas I
can't see what.

&gt;<i>
</I>&gt;&gt;<i> That said, here's where I see IStreamingRequestHandler as better than
</I>&gt;&gt;<i> re-using an existing interface like IProtocol or IConsumer:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  * IConsumer is a very general interface.  It provides no clues about its
</I>&gt;&gt;<i>    interaction with the HTTP protocol implementation.  There's no way to
</I>&gt;&gt;<i>    deduce that if an IResource is also an IConsumer that uploads will be
</I>&gt;&gt;<i>    streamed to it instead of delivered all at once at the end.  On the
</I>&gt;&gt;<i>    other hand, IStreamingRequestHandler can have documentation which
</I>&gt;&gt;<i>    describes its purpose and behavior.
</I>&gt;<i>
</I>&gt;<i>I didn't understand this.
</I>&gt;<i>
</I>
What I mean is that regardless of which approach is taken, it must be
documented.  The IStreamingRequestHandler approach gives you an interface
and a method to give docstrings.  The IConsumer approach doesn't, because
IConsumer encompasses far more than streaming upload handling.

&gt;&gt;<i>  * IConsumer has existing semantics.  There's no reason an existing
</I>&gt;&gt;<i>    IResource implementation might not already be an IConsumer as well,
</I>&gt;&gt;<i>    for a completely unrelated reason.  If it suddenly starts to receive
</I>&gt;&gt;<i>    streaming upload data, it will almost certainly break.  On the other
</I>&gt;&gt;<i>    hand, IStreamingRequestHandler is a new interface, so it cannot be
</I>&gt;&gt;<i>    misinterpreted.
</I>&gt;<i>
</I>&gt;<i>If you have to consume two different things, shouldn't you have two
</I>&gt;<i>objects?
</I>&gt;<i>
</I>
Perhaps so!  What I tried to point out is that there may be /existing
applications/ which have IResources which are also IConsumers.  There
is no reason not to have done this.  We should avoid breaking those
applications.

&gt;<i>
</I>&gt;&gt;<i>  * IConsumer isn't actually sufficiently expressive for this case.  It
</I>&gt;&gt;<i>    would be quite useful if the resource had a chance to look at the
</I>&gt;&gt;<i>    request headers before streaming begins (okay, I didn't bring this up
</I>&gt;&gt;<i>    earlier, so it may have seemed like IConsumer was sufficient).  On the
</I>&gt;&gt;<i>    other hand, IStreamingRequestHandler can have a method which takes the
</I>&gt;&gt;<i>    request as an argument.
</I>&gt;<i>
</I>&gt;<i>In my opinion, if you need to be looking at request headers before
</I>&gt;<i>streaming begins, you're not doing simple streaming, and you should be
</I>&gt;<i>hooking in at a lower level.
</I>
That may be valid, but I'm not really convinced.  For example, you may
want to see query arguments from the request before deciding how to handle
the upload.  Or you may want to look at the value of a cookie or some
HTTP AUTH credentials.  Or there might be an If-Modified-Since header in
the request which needs to be respected.  I don't know for sure that the
correct way to handle any of these use cases is to hook into the stream
setup the way I've described, but the plethora of possibilities suggests
that it shouldn't be ruled out.

&gt;<i>
</I>&gt;&gt;<i> It may be the case that the right method for IStreamingRequestHandler to
</I>&gt;&gt;<i> have, though, is one which takes the request and returns an IConsumer to
</I>&gt;&gt;<i> which the request body will be streamed.
</I>&gt;<i>
</I>&gt;<i>All of the IStreamingRequestHandler stuff sounds more complicated than
</I>&gt;<i>necessary.  I think I'm convinced that IConsumer is a good way to go.
</I>&gt;<i>It uses existing mechanisms to do something simple.
</I>&gt;<i>IStreamingRequestHandler, however, would create new mechanisms to do
</I>&gt;<i>something complicated.
</I>
I think you're overestimating the complexity.  Here's a sample
implementation of what I'm talking about:

    class FileSaver(object):
        implements(IResource, IStreamingRequestHandler)

        def getChild(self, name):
            return FourOhFour()

        def consume(self, request):
            cc = ClientCreator(
                reactor,
                FTPClient,
                request.args['username'][0],
                request.args['password'][0])
            d = cc.connectTCP(request.args['hostname'], 21)
            def connected(ftp):
                return ftp.storeFile(request.args['path'][0])
            d.addCallback(connected)
            def storeInitiated((consumer, control)):
                # I'm too lazy to make this stateless, so FileSaver will
                # only be good for one request.  Also I don't really know
                # how to use FTPClient, so I'm probably making a mistake
                # by ignoring `control&#180;
                self.consumer = consumer
                return consumer
            d.addCallback(storeInitiated)
            return d

        def render(self, request):
            # I don't really like IFinishableConsumer, but oh well.
            self.consumer.finish()
            return &quot;File uploaded!&quot;

If we jump straight to IConsumer and leave IStreamingRequestHandler out
then it'll look something like this:

    class FileSaver(object):
        implements(IRequest, IConsumer)

        def __init__(self, username, password, hostname, path):
            # Whoever implements getChild to return a FileSaver will
            # have to pull the args out of the request and pass them
            # in here, since I have no request here.  Although I'm
            # not sure if you can actually do that with twisted.web!

            self._buffer = []
            self._consumer = None
            self._finished = None
            self._request = None

            cc = ClientCreator(reactor, username, password)
            d = cc.connectTCP(hostname, 21)
            def connected(ftp):
                return ftp.storeFile(path)
            d.addCallback(connected)
            def storeInitiated((consumer, control)):
                self._consumer = consumer
                map(self._consumer.write, self._buffer)
                if self._request is not None:
                    self._consumer.finish()
                    self._request.write(&quot;File uploaded!&quot;)
                    self._request.finish()
                else:
                    self.write = self._consumer.write
            d.addCallback(storeInitiated)
            

        def getChild(self, name):
            return FourOhFour()

        def write(self, bytes):
            self._buffer.append(bytes)

        def render(self, request):
            if self._consumer is not None:
                self._consumer.finish()
                return &quot;File uploaded!&quot;
            else:
                self._request = request
                return NOT_DONE_YET


I actually had to think a bit harder about the 2nd version.  I wonder
if there's a simpler way to express it using that API.  Anyway, neither
of these is horrendously more complex than the other, so I don't think
the complexity argument carries much weight for me.

Jean-Paul

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003679.html">[Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)
</A></li>
	<LI>Next message: <A HREF="003681.html">[Twisted-web] streaming request (was: status of Twisted Web
	and Web 2)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3680">[ date ]</a>
              <a href="thread.html#3680">[ thread ]</a>
              <a href="subject.html#3680">[ subject ]</a>
              <a href="author.html#3680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
