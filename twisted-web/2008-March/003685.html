<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> WSGI support (was [Twisted-web] Re: status of Twisted Web and Web
	2)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=WSGI%20support%20%28was%20%5BTwisted-web%5D%20Re%3A%20status%20of%20Twisted%20Web%20and%20Web%0A%092%29&In-Reply-To=812252F7-FB2D-4304-9026-AC41EA5ECCF4%40dreid.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003683.html">
   <LINK REL="Next"  HREF="003686.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>WSGI support (was [Twisted-web] Re: status of Twisted Web and Web
	2)</H1>
    <B>Phil Christensen</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=WSGI%20support%20%28was%20%5BTwisted-web%5D%20Re%3A%20status%20of%20Twisted%20Web%20and%20Web%0A%092%29&In-Reply-To=812252F7-FB2D-4304-9026-AC41EA5ECCF4%40dreid.org"
       TITLE="WSGI support (was [Twisted-web] Re: status of Twisted Web and Web
	2)">phil at bubblehouse.org
       </A><BR>
    <I>Thu Mar  6 21:38:54 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="003683.html">WSGI support (was [Twisted-web] Re: status of Twisted Web and
	Web	2)
</A></li>
        <LI>Next message: <A HREF="003686.html">WSGI support (was [Twisted-web] Re: status of Twisted Web and
	Web	2)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3685">[ date ]</a>
              <a href="thread.html#3685">[ thread ]</a>
              <a href="subject.html#3685">[ subject ]</a>
              <a href="author.html#3685">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mar 6, 2008, at 6:17 PM, David Reid wrote:
&gt;<i> On Mar 6, 2008, at 11:06 AM, Manlio Perillo wrote:
</I>&gt;&gt;<i> Phil Christensen ha scritto:
</I>&gt;&gt;&gt;<i> On Mar 6, 2008, at 10:56 AM, David Reid wrote:
</I>&gt;&gt;&gt;&gt;<i> It shouldn't be very hard to add support for it to  
</I>&gt;&gt;&gt;&gt;<i> Twisted.web2's WSGI implementation either, but I don't much see  
</I>&gt;&gt;&gt;&gt;<i> the point if no one else supports it.  I'm not convinced that  
</I>&gt;&gt;&gt;&gt;<i> WSGI is at all a useful means of writing asynchronous web  
</I>&gt;&gt;&gt;&gt;<i> applications.  I think WSGI's only benefit is that it allows you  
</I>&gt;&gt;&gt;&gt;<i> to almost write your application code once and run it on  
</I>&gt;&gt;&gt;&gt;<i> multiple containers.
</I>&gt;&gt;&gt;<i> I'd have to disagree (slightly). There's nothing about WSGI that  
</I>&gt;&gt;&gt;<i> makes it only applicable to one approach or another (that is,  
</I>&gt;&gt;&gt;<i> synchronous versus asynchronous).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Right.
</I>&gt;&gt;<i> This is what makes WSGI great.
</I>&gt;<i>
</I>&gt;<i> Read: &quot;So the thing I like about WSGI is that it's actually poorly  
</I>&gt;<i> specified&quot;
</I>&gt;<i>
</I>&gt;<i> Why is attempting to adapt a currently synchronous API (the WSGI  
</I>&gt;<i> application API is synchronous) It's supposed to allow you to write  
</I>&gt;<i> web applications that may be able to run singlethreaded,  
</I>&gt;<i> multithreaded or in a multiprocess environment, it doesn't specify  
</I>&gt;<i> an asynchronous API.   If it did applications would still need to  
</I>&gt;<i> be written in an asynchronous manner.
</I>
I don't know that anyone was suggesting any magic would prevent  
having to write an asynchronous WSGI app in the traditional manner.

Assuming we are talking about the spec, and not a particular  
container, the WSGI API is *not* implicitly synchronous. It requires  
that the application execute the `start_response` callable that is  
passed to the handler function *at some point*. You can easily  
execute it in a callback from some Deferred, or in any other  
asynchronous fashion.

&gt;<i> Threads are the only way to make blocking code appear to be non- 
</I>&gt;<i> blocking.
</I>&gt;<i> Processes are the only way to make blocking code actually not block.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> It's just as easy to write a Deferred-using asynchronous  
</I>&gt;&gt;&gt;<i> application as a blocking one.
</I>&gt;<i>
</I>&gt;<i> It would be, except it's not at all specified that that is a thing  
</I>&gt;<i> you can do.  PEP 333 sure has no mention of Deferreds.
</I>
I think given my point above, that it's irrelevant as to whether PEP  
333 has a mention of Deferreds. It doesn't mention MySQLdb or Zope  
interfaces, either.

All that matters is that at some point you call start_response. As I  
said, there may be WSGI containers that make writing a asynchronous  
application irrelevant (because only one request is handled at a  
time, or requests are threaded), but there's nothing preventing  
someone from making an asynchronous container.

Now, whether that would be worth the effort is a matter of opinion.

&gt;&gt;&gt;<i> The real issue is that a &quot;proper&quot; WSGI app gets informed of it's  
</I>&gt;&gt;&gt;<i> environment by the wsgi.multithreaded and wsgi.multiprocess  
</I>&gt;&gt;&gt;<i> environ variables, so if you really wanted a write-once-run- 
</I>&gt;&gt;&gt;<i> anywhere, you'd need to be able to handle both scenarios.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> By the way, some time ago I proposed a wsgi.asynchronous  
</I>&gt;&gt;<i> enviroment variable.
</I>&gt;<i>
</I>&gt;<i> I don't get it.  I don't see the point at all.  I can't make  
</I>&gt;<i> blocking code magically not-block.  I could use a middlewear that  
</I>&gt;<i> translated from wsgi.asynchronous to a wsgi.multithreaded or  
</I>&gt;<i> wsgi.multiprocess implementation for running my synchronous code,  
</I>&gt;<i> but I don't think there are any benefits to a wsgi.asynchronous API  
</I>&gt;<i> at all.
</I>&gt;<i>
</I>&gt;<i> I can reasonably write an application that honestly doesn't care if  
</I>&gt;<i> it's being serialized, run in threads, or run in seperate  
</I>&gt;<i> processes.  As soon as you throw wsgi.asynchronous into the mix I  
</I>&gt;<i> lose that ability.
</I>
If you're in a multithreaded container, there's a slough of different  
ways to trip up, like saving state in module-level variables without  
using some kind of synchronization. I've definitely run into  
scenarios like that in complex web applications and had to deal with  
them with care.

So if I already have to consider my container's process/thread model,  
then determining if my app can run properly in an asynchronous  
environment seems like a non-issue.

Furthermore, a container that was written to be asynchronous could  
always support synchronous applications as necessary, whereas the  
reverse is obviously not true, at least not in any efficient sense.

&gt;&gt;&gt;<i> As far as Twisted's WSGI implementation, it should probably  
</I>&gt;&gt;&gt;<i> support both approaches, maybe where some kind of argument to the  
</I>&gt;&gt;&gt;<i> WSGIResource class constructor determines what it specifies in  
</I>&gt;&gt;&gt;<i> the environ dictionary. It should be the responsibility of the  
</I>&gt;&gt;&gt;<i> WSGI application itself to do the right thing depending on what's  
</I>&gt;&gt;&gt;<i> inside the environ dict.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure that this is possible.
</I>&gt;&gt;<i> An application is asynchronous or synchronous.
</I>
I was referring to things like thread synchronization, as I mentioned  
above.

&gt;<i> Exactly so why should we try to make the same API do both?
</I>
Because WSGI is a decent spec, and is a familiar environment from  
people who are transitioning from CGI, and to some extent, PHP web  
development. Since there is no technical reason WSGI couldn't be used  
in an asynchronous context, why not make it possible?

It would allow users to have a somewhat familiar environment, while  
still getting used to an asynchronous programming style. Then the  
leap to twisted.web/Nevow would be that much easier.

&gt;<i> All that being said I'm perfectly happy to accept patches that  
</I>&gt;<i> enhance twisted's wsgi support, but I feel no inclination to  
</I>&gt;<i> support anything out of spec.
</I>
Again, I think it's debatable if writing an asynchronous WSGI is  
outside the spec, although clearly a 'wsgi.asynchronous' variable  
would be.

Anyways, just my 2/100ths...

-phil

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003683.html">WSGI support (was [Twisted-web] Re: status of Twisted Web and
	Web	2)
</A></li>
	<LI>Next message: <A HREF="003686.html">WSGI support (was [Twisted-web] Re: status of Twisted Web and
	Web	2)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3685">[ date ]</a>
              <a href="thread.html#3685">[ thread ]</a>
              <a href="subject.html#3685">[ subject ]</a>
              <a href="author.html#3685">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
