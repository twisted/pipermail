<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Nevow future
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Nevow%20future&In-Reply-To=443C09E2.9040307%40libero.it">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002595.html">
   <LINK REL="Next"  HREF="002599.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Nevow future</H1>
    <B>glyph at divmod.com</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Nevow%20future&In-Reply-To=443C09E2.9040307%40libero.it"
       TITLE="[Twisted-web] Nevow future">glyph at divmod.com
       </A><BR>
    <I>Tue Apr 11 17:10:09 CDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="002595.html">[Twisted-web] Nevow future
</A></li>
        <LI>Next message: <A HREF="002599.html">[Twisted-web] Nevow future
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2598">[ date ]</a>
              <a href="thread.html#2598">[ thread ]</a>
              <a href="subject.html#2598">[ subject ]</a>
              <a href="author.html#2598">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On Tue, 11 Apr 2006 17:56:18 -0200, Manlio Perillo &lt;<A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">manlio_perillo at libero.it</A>&gt; wrote:
&gt;<i>Jean-Paul Calderone ha scritto:
</I>
&gt;<i>- what about formless?
</I>
Pollenation's &quot;Formal&quot; seems to be replacing it as a de-facto standard in the community for people who want form generation.  It may even be distributed with Nevow at some point.  However, formless itself is somewhat of a dead end; while it contains some handy convenience utilities to slap a form on a page, you end up having to do almost as much work to get a decent-looking form with formless as just writing the HTML by hand yourself, and the rules are often implicit and undocumented.

&gt;&gt;<i> When there is a 1.x release, you can begin to expect things
</I>&gt;&gt;<i> to stop changing as much.
</I>
&gt;<i>There are previsions?
</I>
What is a 'prevision'?

&gt;&gt;&gt;<i> It will remain indipendent from the underlying web server?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It isn't independent from the underlying web server now, so saying that
</I>&gt;&gt;<i> it would remain that way doesn't make sense.
</I>
&gt;<i>Well, there is support for WSGI and an implementation with Zomne...
</I>
The WSGI support may not work at all.  It is unsupported, undocumented, and there are no tests which import it.

The WSGI support will only realistically work in a Twisted-style environment.  Athena depends explicitly on the reactor, so invoking any Athena-using applications in a non-Twisted context will not work.  Livetest requires the reactor as well, so you will not be able to write nit tests for your application or use any 3rd party fragments which use athena or are tested in this manner.

It might be _possible_ to write a Nevow application through wsgi, but why bother?  Unless you already know Nevow intimately and have some bizarre deployment constraints, it is unlikely that it is the best tool for that job.

&quot;zomne&quot; is a way to run your twisted.web server in &quot;stealth mode&quot; behind another webserver.  It's also untested, and depends on a C component, which I believe the author did as a simple proof of concept to answer the question &quot;but my $5 hosting doesn't let me run a long-running server&quot;, not a robust deployment mechanism.

Don't get me wrong, I would love it if there were dedicated maintainers for these use-cases, since I realize they are important to many people.  They just aren't important to *us*, so we're not going to spend time.

&gt;&gt;<i> Your Nevow applications should remain independent of it, though.
</I>
&gt;<i>I would like to use lighttp as the *only* webserver, and Nevow *only*
</I>&gt;<i>for the rendering, session support, and so.
</I>
lighttpd supports reverse proxies.  Nevow's session support, in nevow.guard, depends on the reactor and twisted.web, so you will be unable to use it otherwise.

&gt;&gt;&gt;<i> Reverse Proxy is not an option for me (*why* to use two or more
</I>&gt;&gt;&gt;<i> webservers and duplicate HTTP protocol handling?).
</I>
&gt;&gt;<i> Because it solves a problem?  Why *not* do this?
</I>
&gt;<i>I don't like the idea.
</I>
Yes but _WHY_ don't you like the idea?  Do you live in some alternate reality where the arrangement of bytes in an HTTP packet has harmful effects but the arrangement of bytes in a FastCGI packet does not?

&gt;<i>Is this really necessary?
</I>
No, you could do away with LightTPD and then you wouldn't need a proxy ;-).  (Seriously though LightTPD is unbelievably fast for static content so dealing with the proxy is probably a good idea.)

&gt;&gt;&gt;<i> Why there is not support for FastCGI (so I can use lighttp)?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Because no one has implemented it.
</I>&gt;<i>
</I>&gt;<i>Well, why?
</I>
We don't need it.  We use twisted web, or reverse proxies, which solve all of the problems you have raised neatly.

&gt;<i>Is FastCGI really hated or flawed?
</I>&gt;<i>The author of twisted.web2.channel.fastcgi seems not to like it.
</I>
It is highly complex, and serves no purpose.  What is the goal of FastCGI?  To communicate between a web server and web applications.  I.E. to relay information about HTTP requests between a program which parses HTTP requests, and a program which acts upon the information present in an HTTP request.  Sometimes -- efficiency and security being the primary concerns here -- different programs have to handle different HTTP requests depending on their content, so a front-end server is required.

One way to do this is to reverse-proxy: I.E. take the HTTP request from the browser, identify the program which will handle it, and hand it off to that program in as close to the original format as possible, in standard HTTP, for minimal loss of information.

Another way to do this is the (Fast)CGI model: take the HTTP request, convert it into a random, half-documented sequence of bytes and/or and environment variables, and then send it to a program whose job is to process HTTP requests but, for some reason, cannot contain a parser for HTTP requests but *can* contain a parser for random mashed-up remnants of an HTTP requests over a different protocol.

This is a common mistake, because it seems &quot;simpler&quot; to design your own protocol for talking about HTTP than to use HTTP itself.  It isn't.  In fact, by definition, it cannot be: your new protocol has to provide all the information present in the original HTTP request (or risk breaking applications that depend on some information you did not relay), so in the best case it can be exactly as complex as HTTP.  I wrote something like this in twisted.web.distrib, where I converted the HTTP requests to PB and back again.  While the &quot;automated proxying for users&quot; functionality was cool, I had *just written* an HTTP parser and it was silly not to just use it over a unix socket.  I am pleased to note that web2, when it implements something like web.distrib, will do it the correct way and just make it a regular reverse proxy over a unix socket.

FastCGI itself is also actually harder to parse, contains numerous design errors, and more confusing and inconsistent than HTTP itself.  There are numerous inconsistencies it could have fixed in HTTP - it could have properly optimized the multiplexed-channel case with inband flow control to avoid TCP startup overhead for distant FastCGI proxies - it could have normalized the transport over something easy to audit and implement like netstrings - but it totally failed to do anything worthwhile despite being an entirely new protocol.

By contrast, SCGI has the same property of &quot;transmitter of HTTP data that isn't HTTP&quot; but is not insanely overcomplex and full of mistakes.  It at least works enough like CGI that it caters to a market of people writing server containers who can't necessarily write a good HTTP implementation -- whereas if you have enough time to implement FastCGI, you can _definitely_ implement HTTP.

Nevertheless, dumb as it is, supporting FastCGI is still worthwhile.  Various bits of useful software have integrated it for one reason or another, and some of them don't have other ways of talking to the outside world.  That doesn't mean it's a good idea to write new software that is similarly hamstrung by a bad integration decision.

&gt;&gt;<i> Feel free to contribute a FastCGI
</I>&gt;&gt;<i> implementation, if you like.  Efforts might better be spent finishing
</I>&gt;&gt;<i> twisted.web2 (this includes writing documentation, test cases, examples,
</I>&gt;&gt;<i> etc, not just coding) or figuring out how best to port Nevow to web2,
</I>&gt;&gt;<i> since web2 supports FastCGI already.
</I>
I would go so far as to say that web2 is _the_ way we will support FastCGI.  It might be worthwhile to support, but we need to move Nevow to web2 at some point, and any effort directed at this should be spent improving web2.

&gt;<i>Now the twisted.web2 implementation support only the Responder role,
</I>&gt;<i>what about the Authorizer and Filter roles?
</I>
You can contribute implementations if you like, but does anyone really use those?

&gt;<i>I'm very interested in this but I'm not an expert.
</I>&gt;<i>In the end, is FastCGI really worth of further investigations?
</I>
I hope I've made it clear that no, it isn't.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002595.html">[Twisted-web] Nevow future
</A></li>
	<LI>Next message: <A HREF="002599.html">[Twisted-web] Nevow future
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2598">[ date ]</a>
              <a href="thread.html#2598">[ thread ]</a>
              <a href="subject.html#2598">[ subject ]</a>
              <a href="author.html#2598">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
