<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into
	package	directories)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Fix%20for%20an%20issue%2092%20%28windows%20binary%20distribution%0A%09made%20with%20distutils%20doesn%27t%20install%20data%20files%20into%0A%09package%09directories%29&In-Reply-To=20050303165018.GO8880%40opteron.random">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001279.html">
   <LINK REL="Next"  HREF="001282.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into
	package	directories)</H1>
    <B>Cory Dodt</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20Fix%20for%20an%20issue%2092%20%28windows%20binary%20distribution%0A%09made%20with%20distutils%20doesn%27t%20install%20data%20files%20into%0A%09package%09directories%29&In-Reply-To=20050303165018.GO8880%40opteron.random"
       TITLE="[Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into
	package	directories)">corydodt at twistedmatrix.com
       </A><BR>
    <I>Thu Mar  3 10:33:42 MST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001279.html">[Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into package
	directories)
</A></li>
        <LI>Next message: <A HREF="001282.html">[Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into
	package	directories)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1280">[ date ]</a>
              <a href="thread.html#1280">[ thread ]</a>
              <a href="subject.html#1280">[ subject ]</a>
              <a href="author.html#1280">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

+1 performance-enhancing drugs.

BTW, is there an example of using cached anywhere?

C


Andrea Arcangeli wrote:
|<i> On Wed, Mar 02, 2005 at 10:48:03PM +0000, Matt Goodall wrote:
</I>|<i>
</I>|&gt;<i>Yes, someone will.
</I>|<i>
</I>|<i>
</I>|<i> btw, I would also like to send a reminder about getting the caching
</I>|<i> stuff into the trunk ;). I proved that the hard approach in rend.Page is
</I>|<i> significantly more performant than the tags.cached pure approach (even
</I>|<i> the hard approach is less clean).
</I>|<i>
</I>|<i> This is what I carry in my own Nevow branch (most of it is dialtone's
</I>|<i> Nevow-caching branch):
</I>|<i>
</I>|<i> Index: Nevow/nevow/tags.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/tags.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/tags.py	(working copy)
</I>|<i> @@ -25,7 +25,7 @@
</I>|<i>  &quot;&quot;&quot;
</I>|<i>
</I>|<i>
</I>|<i> -from nevow.stan import Proto, Tag, directive, raw, xml, CommentProto,
</I>invisible, slot, cdata
|<i> +from nevow.stan import Proto, Tag, directive, raw, xml, CommentProto,
</I>invisible, slot, cdata, cached
|<i>
</I>|<i>
</I>|<i>  comment = CommentProto()
</I>|<i> @@ -62,7 +62,9 @@
</I>|<i>  def inlineJS(s):
</I>|<i>      return script(type=&quot;text/javascript&quot;,
</I>language=&quot;JavaScript&quot;)[xml('\n//&lt;![CDATA[\n%s\n//]]&gt;\n' % s)]
|<i>
</I>|<i> -__all__ = tags + ['invisible', 'comment', '_dir', '_del', '_object',
</I>'_map', 'drange', 'Tag', 'directive', 'xml', 'raw', 'slot', 'cdata',
'inlineJS'] + ['_%s' % x for x in range(100)]
|<i> +__all__ = tags + ['invisible', 'comment', '_dir', '_del', '_object',
</I>|<i> +                  '_map', 'drange', 'Tag', 'directive', 'xml', 'raw',
</I>|<i> +                  'slot', 'cached', 'cdata', 'inlineJS'] + ['_%s' % x for x
</I>in range(100)]
|<i>
</I>|<i>
</I>|<i>  ########################
</I>|<i> Index: Nevow/nevow/__init__.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/__init__.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/__init__.py	(working copy)
</I>|<i> @@ -138,6 +138,8 @@
</I>|<i>  nevow.util.remainingSegmentsFactory  nevow.context.RequestContext
</I>nevow.inevow.IRemainingSegments
|<i>  nevow.util.currentSegmentsFactory  nevow.context.RequestContext
</I>nevow.inevow.ICurrentSegments
|<i>
</I>|<i> +nevow.cache.SiteCache   nevow.context.SiteContext   nevow.inevow.ICache
</I>|<i> +
</I>|<i>  nevow.query.QueryContext    nevow.context.WovenContext  nevow.inevow.IQ
</I>|<i>  nevow.query.QueryLoader     nevow.inevow.IDocFactory      nevow.inevow.IQ
</I>|<i>  nevow.query.QueryList       __builtin__.list        nevow.inevow.IQ
</I>|<i> @@ -186,6 +188,7 @@
</I>|<i>  nevow.flat.flatstan.RendererSerializer            nevow.inevow.IRenderer
</I>|<i>  nevow.flat.flatstan.DirectiveSerializer           nevow.stan.directive
</I>|<i>  nevow.flat.flatstan.SlotSerializer                nevow.stan.slot
</I>|<i> +nevow.flat.flatstan.CachedSerializer              nevow.stan.cached
</I>|<i>  nevow.flat.flatstan.ContextSerializer             nevow.context.WovenContext
</I>|<i>  nevow.flat.flatstan.DeferredSerializer
</I>twisted.internet.defer.Deferred
|<i>  nevow.flat.flatstan.DeferredSerializer
</I>twisted.internet.defer.DeferredList
|<i> Index: Nevow/nevow/flat/flatstan.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/flat/flatstan.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/flat/flatstan.py	(working copy)
</I>|<i> @@ -8,11 +8,15 @@
</I>|<i>
</I>|<i>  from nevow import util
</I>|<i>  from nevow.stan import Proto, Tag, xml, directive, Unset, invisible
</I>|<i> -from nevow.inevow import IRenderer, IRendererFactory, IGettable, IData
</I>|<i> -from nevow.flat import precompile, serialize
</I>|<i> +from nevow.inevow import IRenderer, IRendererFactory, IGettable, IData, ICache
</I>|<i> +from nevow.flat import precompile, serialize, iterflatten
</I>|<i>  from nevow.accessors import convertToData
</I>|<i>  from nevow.context import WovenContext
</I>|<i>
</I>|<i> +from time import time as now
</I>|<i> +from cStringIO import StringIO
</I>|<i> +from twisted.internet import defer
</I>|<i> +
</I>|<i>  allowSingleton = ('img', 'br', 'hr', 'base', 'meta', 'link', 'param', 'area',
</I>|<i>                    'input', 'col', 'basefont', 'isindex', 'frame')
</I>|<i>
</I>|<i> @@ -226,6 +230,43 @@
</I>|<i>          return serialize(original.default, context)
</I>|<i>      return serialize(data, context)
</I>|<i>
</I>|<i> +def CachedSerializer(original, context):
</I>|<i> +    cache = ICache(original.scope(context))
</I>|<i> +    cached = cache.get(original.key, original.lifetime)
</I>|<i> +    if cached:
</I>|<i> +        yield cached
</I>|<i> +        return
</I>|<i> +    io = StringIO()
</I>|<i> +    for child in iterflatten(original.children, context, io.write,
</I>|<i> +                             lambda item: True):
</I>|<i> +        if isinstance(child, tuple):
</I>|<i> +            childDeferred, childReturner = child
</I>|<i> +
</I>|<i> +            d = defer.Deferred() ## A new deferred for the outer loop,
</I>whose result
|<i> +            ## we don't care about, because we don't want the outer loop to
</I>write
|<i> +            ## anything when this deferred fires -- only when the entire
</I>for loop
|<i> +            ## has completed and we have all the &quot;children&quot; flattened
</I>|<i> +
</I>|<i> +            def innerDeferredResultAvailable(result):
</I>|<i> +                childReturner(result) ## Cause the inner iterflatten to
</I>continue
|<i> +                d.callback('') ## Cause the outer iterflatten to continue
</I>|<i> +                return ''
</I>|<i> +
</I>|<i> +            childDeferred.addCallback(innerDeferredResultAvailable)
</I>|<i> +
</I>|<i> +            ## Make the outer loop wait on our new deferred.
</I>|<i> +            ## We call the new deferred back with ''
</I>|<i> +            ## Which will cause the outer loop to write '' to the request,
</I>|<i> +            ## which doesn't matter. It will then call our &quot;returner&quot;,
</I>|<i> +            ## which is just the noop lambda below, because we don't care
</I>|<i> +            ## about the return result of the new deferred, which is just
</I>|<i> +            ## ''
</I>|<i> +
</I>|<i> +            yield d, lambda result: ''
</I>|<i> +    result = io.getvalue()
</I>|<i> +    cache.set(result, original.key)
</I>|<i> +    yield result
</I>|<i> +
</I>|<i>  def ContextSerializer(original, context):
</I>|<i>      originalContext = original.clone(deep=False)
</I>|<i>      originalContext.precompile = context and context.precompile or False
</I>|<i> Index: Nevow/nevow/stan.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/stan.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/stan.py	(working copy)
</I>|<i> @@ -119,8 +119,40 @@
</I>|<i>          &quot;&quot;&quot;
</I>|<i>          raise NotImplementedError, &quot;Stan slot instances are not iterable.&quot;
</I>|<i>
</I>|<i> +def passThrough(_):
</I>|<i> +    return _
</I>|<i>
</I>|<i> +class cached(object):
</I>|<i> +    &quot;&quot;&quot;Marker for cached content
</I>|<i> +    &quot;&quot;&quot;
</I>|<i> +    __slots__ = ['key', 'children', 'lifetime', 'scope']
</I>|<i>
</I>|<i> +    def __init__(self, key, scope=None, lifetime=-1):
</I>|<i> +        self.key = key
</I>|<i> +        self.children = []
</I>|<i> +        self.lifetime = lifetime
</I>|<i> +        self.scope = scope
</I>|<i> +        if not scope:
</I>|<i> +            self.scope = passThrough
</I>|<i> +
</I>|<i> +
</I>|<i> +    def __repr__(self):
</I>|<i> +        return &quot;cached('%s','%s')&quot; % self.key, self.lifetime
</I>|<i> +
</I>|<i> +    def __getitem__(self, children):
</I>|<i> +        &quot;&quot;&quot;cached content is what is being cached
</I>|<i> +        &quot;&quot;&quot;
</I>|<i> +        if not isinstance(children, (list, tuple)):
</I>|<i> +            children = [children]
</I>|<i> +        self.children.extend(children)
</I>|<i> +        return self
</I>|<i> +
</I>|<i> +    def __iter__(self):
</I>|<i> +        &quot;&quot;&quot;Prevent an infinite loop if someone tries to do
</I>|<i> +            for x in cached('foo'):
</I>|<i> +        &quot;&quot;&quot;
</I>|<i> +        raise NotImplementedError, &quot;Stan slot instances are not iterable.&quot;
</I>|<i> +
</I>|<i>  class Tag(object):
</I>|<i>      &quot;&quot;&quot;Tag instances represent XML tags with a tag name, attributes,
</I>|<i>      and children. Tag instances can be constructed using the Prototype
</I>|<i> Index: Nevow/nevow/inevow.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/inevow.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/inevow.py	(working copy)
</I>|<i> @@ -98,8 +98,24 @@
</I>|<i>
</I>|<i>      ANY python object is said to implement IData.
</I>|<i>      &quot;&quot;&quot;
</I>|<i> +class ICache(compy.Interface):
</I>|<i> +    &quot;&quot;&quot;This object represents the cache that contains all the
</I>|<i> +    pre-flattened fragments
</I>|<i> +    &quot;&quot;&quot;
</I>|<i> +    def get(self, index, lifetime):
</I>|<i> +        &quot;&quot;&quot; Get an object from the cache with the given index only if
</I>|<i> +        it is less old than lifetime, otherwise return None.
</I>|<i> +        &quot;&quot;&quot;
</I>|<i>
</I>|<i> +    def set(self, toBeCached, *indexes):
</I>|<i> +        &quot;&quot;&quot; Register toBeCached with each of the indexes passed &quot;&quot;&quot;
</I>|<i>
</I>|<i> +    def clear(self, what):
</I>|<i> +        &quot;&quot;&quot; Clear what keyed element from the cache, or search for
</I>|<i> +        what in sequences in all the keys and clear the item
</I>|<i> +        &quot;&quot;&quot;
</I>|<i> +
</I>|<i> +
</I>|<i>  class IGettable(compy.Interface):
</I>|<i>      def get(self, context):
</I>|<i>          &quot;&quot;&quot;Return the data
</I>|<i> Index: Nevow/nevow/rend.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/rend.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/rend.py	(working copy)
</I>|<i> @@ -30,6 +30,7 @@
</I>|<i>  from nevow import flat
</I>|<i>  from nevow.util import log
</I>|<i>  from nevow import util
</I>|<i> +from nevow import url
</I>|<i>
</I>|<i>  import formless
</I>|<i>  from formless import iformless
</I>|<i> @@ -376,6 +377,8 @@
</I>|<i>          self.children[name] = child
</I>|<i>
</I>|<i>
</I>|<i> +_CACHE = {}
</I>|<i> +
</I>|<i>  class Page(Fragment, ConfigurableFactory, ChildLookupMixin):
</I>|<i>      &quot;&quot;&quot;A page is the main Nevow resource and renders a document loaded
</I>|<i>      via the document factory (docFactory).
</I>|<i> @@ -389,8 +392,37 @@
</I>|<i>      afterRender = None
</I>|<i>      addSlash = None
</I>|<i>
</I>|<i> +    cache = False
</I>|<i> +    lifetime = -1
</I>|<i> +    __lastCacheRendering = 0
</I>|<i> +
</I>|<i>      flattenFactory = flat.flattenFactory
</I>|<i>
</I>|<i> +    def hasCache(self, ctx):
</I>|<i> +        if not self.cache:
</I>|<i> +            return
</I>|<i> +
</I>|<i> +        _now = now() # run gettimeofday only once
</I>|<i> +        timeout = _now &gt; self.__lastCacheRendering + self.lifetime and \
</I>|<i> +                  self.lifetime &gt;= 0
</I>|<i> +        c = self.lookupCache(ctx)
</I>|<i> +        if timeout or c is None:
</I>|<i> +            # stop other renders
</I>|<i> +            self.__lastCacheRendering = _now
</I>|<i> +            c = None
</I>|<i> +        return c
</I>|<i> +    def cacheRendered(self, ctx, c):
</I>|<i> +        if not self.cache:
</I>|<i> +            return
</I>|<i> +        # overwrite the deferred with the data
</I>|<i> +        self.storeCache(ctx, c)
</I>|<i> +    def cacheIDX(self, ctx):
</I>|<i> +        return str(url.URL.fromContext(ctx))
</I>|<i> +    def storeCache(self, ctx, c):
</I>|<i> +        _CACHE[self.cacheIDX(ctx)] = c
</I>|<i> +    def lookupCache(self, ctx):
</I>|<i> +        return _CACHE.get(self.cacheIDX(ctx))
</I>|<i> +
</I>|<i>      def renderHTTP(self, ctx):
</I>|<i>          ## XXX request is really ctx now, change the name here
</I>|<i>          request = inevow.IRequest(ctx)
</I>|<i> @@ -412,11 +444,18 @@
</I>|<i>              if self.afterRender is not None:
</I>|<i>                  self.afterRender(ctx)
</I>|<i>
</I>|<i> -        if self.buffered:
</I>|<i> +        c = self.hasCache(ctx)
</I>|<i> +        if c is not None:
</I>|<i> +            finishRequest()
</I>|<i> +            return c
</I>|<i> +
</I>|<i> +        if self.buffered or self.cache:
</I>|<i>              io = StringIO()
</I>|<i>              writer = io.write
</I>|<i>              def finisher(result):
</I>|<i> -                request.write(io.getvalue())
</I>|<i> +                c = io.getvalue()
</I>|<i> +                self.cacheRendered(ctx, c)
</I>|<i> +                request.write(c)
</I>|<i>                  finishRequest()
</I>|<i>                  return result
</I>|<i>          else:
</I>|<i> @@ -500,7 +539,6 @@
</I>|<i>              else:
</I>|<i>                  ## Use the redirectAfterPost url
</I>|<i>                  ref = str(redirectAfterPost)
</I>|<i> -            from nevow import url
</I>|<i>              refpath = url.URL.fromString(ref)
</I>|<i>              magicCookie = str(now())
</I>|<i>              refpath = refpath.replace('_nevow_carryover_', magicCookie)
</I>|<i> Index: Nevow/nevow/guard.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/guard.py	(revision 1257)
</I>|<i> +++ Nevow/nevow/guard.py	(working copy)
</I>|<i> @@ -24,7 +24,7 @@
</I>|<i>  from twisted.protocols import http
</I>|<i>
</I>|<i>  # Nevow imports
</I>|<i> -from nevow import inevow, url, stan
</I>|<i> +from nevow import inevow, url, stan, cache
</I>|<i>
</I>|<i>
</I>|<i>  def _sessionCookie():
</I>|<i> @@ -315,6 +315,7 @@
</I>|<i>                                path=&quot;/%s&quot; % '/'.join(request.prepath),
</I>|<i>                                secure=secure)
</I>|<i>          sz = self.sessions[newCookie] = self.sessionFactory(self, newCookie)
</I>|<i> +        sz.setComponent(inevow.ICache, cache.SessionCache())
</I>|<i>          sz.args = request.args
</I>|<i>          sz.fields = getattr(request, 'fields', {})
</I>|<i>          sz.content = request.content
</I>|<i> Index: Nevow/nevow/cache.py
</I>|<i> ===================================================================
</I>|<i> --- Nevow/nevow/cache.py	(revision 0)
</I>|<i> +++ Nevow/nevow/cache.py	(revision 0)
</I>|<i> @@ -0,0 +1,33 @@
</I>|<i> +from time import time as now
</I>|<i> +from nevow import inevow
</I>|<i> +
</I>|<i> +class SiteCache(object):
</I>|<i> +    __implements__ = inevow.ICache,
</I>|<i> +    _content = {}
</I>|<i> +    def __init__(self, original):
</I>|<i> +        self.original = original
</I>|<i> +
</I>|<i> +    def get(self, index, lifetime):
</I>|<i> +        cached = self._content.get(index, None)
</I>|<i> +        if cached is None:
</I>|<i> +            return
</I>|<i> +        if lifetime &lt; 0:
</I>|<i> +            return cached[1]
</I>|<i> +        if cached[0] + lifetime &gt; now():
</I>|<i> +            return cached[1]
</I>|<i> +
</I>|<i> +    def set(self, toBeCached, *indexes):
</I>|<i> +        _now = now()
</I>|<i> +        for index in indexes:
</I>|<i> +            self._content[index] = (_now, toBeCached)
</I>|<i> +
</I>|<i> +    def clear(self, what):
</I>|<i> +        if self._content.has_key(what):
</I>|<i> +            self._content.pop(what)
</I>|<i> +        for key in self._content.keys():
</I>|<i> +            if what in key:
</I>|<i> +                self._content.pop(key)
</I>|<i> +
</I>|<i> +class SessionCache(SiteCache):
</I>|<i> +    def __init__(self):
</I>|<i> +        self._content = {}
</I>|<i>
</I>|<i> This code is working for a few weeks on www.cpushare.com, so far so
</I>|<i> good (all http part is completely cached with the rand.Page lifetime and
</I>|<i> it delivers &gt;200 req per second of those small pages). I also use the
</I>|<i> tags.caching from dialtime in various places.
</I>|<i>
</I>|<i> Thanks a lot to dialtone and everyone else for making this possible.
</I>|<i>
</I>|<i> _______________________________________________
</I>|<i> Twisted-web mailing list
</I>|<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">Twisted-web at twistedmatrix.com</A>
</I>|<i> <A HREF="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web</A>
</I>
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.1 (MingW32)
Comment: Using GnuPG with Thunderbird - <A HREF="http://enigmail.mozdev.org">http://enigmail.mozdev.org</A>

iD8DBQFCJ0p23A5SrXAiHQcRApmdAJ96j3+OTlRyXjb5crYzoq6xq/lDBACcCEas
F0Mrvrylx1FOipT8q0EfQ8Y=
=iRMT
-----END PGP SIGNATURE-----

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001279.html">[Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into package
	directories)
</A></li>
	<LI>Next message: <A HREF="001282.html">[Twisted-web] Fix for an issue 92 (windows binary distribution
	made with distutils doesn't install data files into
	package	directories)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1280">[ date ]</a>
              <a href="thread.html#1280">[ thread ]</a>
              <a href="subject.html#1280">[ subject ]</a>
              <a href="author.html#1280">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
