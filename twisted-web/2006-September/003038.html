<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Twisted-web] fragments with child lookup
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20fragments%20with%20child%20lookup&In-Reply-To=20060925113130.1717.741990179.divmod.quotient.59502%40ohm">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003037.html">
   <LINK REL="Next"  HREF="003039.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Twisted-web] fragments with child lookup</H1>
    <B>Markus Schiltknecht</B> 
    <A HREF="mailto:twisted-web%40twistedmatrix.com?Subject=%5BTwisted-web%5D%20fragments%20with%20child%20lookup&In-Reply-To=20060925113130.1717.741990179.divmod.quotient.59502%40ohm"
       TITLE="[Twisted-web] fragments with child lookup">markus at bluegap.ch
       </A><BR>
    <I>Mon Sep 25 08:49:27 CDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="003037.html">[Twisted-web] fragments with child lookup
</A></li>
        <LI>Next message: <A HREF="003039.html">[Twisted-web] fragments with child lookup
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3038">[ date ]</a>
              <a href="thread.html#3038">[ thread ]</a>
              <a href="subject.html#3038">[ subject ]</a>
              <a href="author.html#3038">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

Valentino Volonghi aka Dialtone wrote:
&gt;<i> I don't completely understand why you really really really need this but...
</I>
I see... unfortunately I don't know how to explain this better. I don't
understand why writing a pastebin, a blog, or a news system should not
be written as a component / Fragment, which can be embedded into other
sites. And by embedded I mean URL _and_ template embedding. Isn't that
obvious to give a lot of flexibility?

&gt;<i> def render_content(self, level):
</I>&gt;<i>    def _(ctx, data):
</I>&gt;<i>        try:
</I>&gt;<i>            fragment_name = inevow.ICurrentSegments(ctx)[level]
</I>&gt;<i>        ...
</I>
Hm... looks tricky. I didn't know about def _(...). But who is expected
to pass the level to the renderer? The designer?

&gt;<i> Used:
</I>&gt;<i> 
</I>&gt;<i> &lt;nevow:invisible nevow:render=&quot;content 1&quot;&gt;...&lt;/nevow:invisible&gt;
</I>
That way I still have the level hard coded into the template.
Unfortunately, that's not an option for me. The designer should be able
to 'drag' the components around without having to worry about how deep
it's templates are nested.

&gt;&gt;<i> Sill I'm still surprised, nevow does not provide that functionality.
</I>&gt;<i> 
</I>&gt;<i> It's a bit frustrating for me to keep answering while you consistently say
</I>&gt;<i> that 'nevow does not provide XXX functionality', can you please stop 
</I>&gt;<i> implying that nevow is a pile of junk compared to others?
</I>
Sorry, I didn't mean to put nevow down. Not at all. I'm quite impressed
by how clever and thought through a templating system can be. And I
would not invest that much time into figuring out how to do what I want
if I didn't believe in it being mostly superior to all others.

&gt;&gt;<i> I think another way to look at my problem is: how do I code a pastebin 
</I>&gt;&gt;<i> that _can_ be embedded like that? A pastebin which can be a fragment 
</I>&gt;&gt;<i> of another page.
</I>&gt;<i> 
</I>&gt;<i> Using macros of course and it's very easy to do, and the code I showed 
</I>&gt;<i> you already does that and no it's not too static because you can make 
</I>&gt;<i> anything that looks static a lot more dynamic, 
</I>
Uh.. macros? This is where it gets frustrating for me, because I think 
you still don't known what I want to achieve. Macros don't know a lot. 
Their context is very limited. How am I supposed to resolve the all the 
locateChild machinery? How do I give that information to the 'child', 
the pastebin in my example?

I've tried using a macro, see the code below. With some of my fragment 
code (the dictionary thing, as you said that would be the right way to 
do it). That portion of the code works, but with the macro I don't know 
how pass necessary information around.

As it is done below, only the pastebin's RootPage is displayed. I don't 
know how to make subsites of it work. I.e.:

localhost:8080/            -&gt; okay, renders the _default fragment
localhost:8080/pastebin/   -&gt; okay, renders the pastebin's RootPage
                               embedded in the SuperRootPage's docFactory
                               template
localhost:8080/pastebin/1/ -&gt; not okay, still renders the pastebin's
                               RootPage.

I'm not going to say 'nevow can't do it' anymore, but if it really can, 
I would love to learn _how_ to do it.

Please excuse, but as long as I'm unconvinced of that capability, I have 
a good reason to believe nevow has not implemented that feature, yet. 
That's okay, however, and I believe I should keep trying to make nevow 
do what I want it to do.

&gt;<i> this is python not C++.
</I>
Hm... check 'C++ template metaprogramming'  *joking*
How static is that?   :-)

Anyway, once again, thank you for your patience.

Regards

Markus




My macro try:

Index: pastebin.tac
===================================================================
--- pastebin.tac        (revision 9132)
+++ pastebin.tac        (working copy)
@@ -5,6 +5,7 @@

  from nevow import appserver
  from nevow import vhost
+from nevow import inevow, rend, stan, loaders, tags as T

  from pastebin import interfaces
  from pastebin.service import FSPasteBinService
@@ -16,7 +17,33 @@
  pastebin = FSPasteBinService('data')
  pastebin.setServiceParent(application)

-appResource = pages.RootPage(pastebin)
+class SuperRootPage(rend.Page):
+
+    docFactory = loaders.stan(
+        T.div[
+            T.h1['hello world'],
+            T.invisible(render=T.directive('child_content'))
+        ])
+
+    fragments = {
+        '_default': loaders.stan(T.div[T.h2['hello component based 
world']]),
+        'pastebin': 
loaders.stan(T.invisible(macro=T.directive('child_content'))),
+    }
+
+    def render_child_content(self, ctx, data):
+        try:
+            fragment_name = inevow.ICurrentSegments(ctx)[0]
+            return self.fragments[fragment_name]
+        except KeyError:
+            return self.fragments['_default']
+
+    def macro_child_content(self, ctx):
+        return pages.RootPage(pastebin)
+
+    def locateChild(self, ctx, segments):
+        return self, ()
+
+appResource = SuperRootPage()
  appResource.putChild('robots.txt', static.File('static/robots.txt'))
  vResource = vhost.VHostMonsterResource()
  appResource.putChild('vhost', vResource)

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003037.html">[Twisted-web] fragments with child lookup
</A></li>
	<LI>Next message: <A HREF="003039.html">[Twisted-web] fragments with child lookup
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3038">[ date ]</a>
              <a href="thread.html#3038">[ thread ]</a>
              <a href="subject.html#3038">[ subject ]</a>
              <a href="author.html#3038">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-web">More information about the Twisted-web
mailing list</a><br>
</body></html>
