<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Divunal-devel] StringBuffers/string manipulation optimization</TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jknight%40MIT.EDU">
   <LINK REL="Previous"  HREF="000020.html">
   <LINK REL="Next" HREF="000021.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Divunal-devel] StringBuffers/string manipulation optimization</H1>
    <B>James Knight</B> 
    <A HREF="mailto:jknight%40MIT.EDU"
       TITLE="[Divunal-devel] StringBuffers/string manipulation optimization">jknight@MIT.EDU</A><BR>
    <I>Thu, 24 Jun 1999 18:32:22 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000020.html">[Divunal-devel] Faucet on Windows</A></li>
        <LI> Next message: <A HREF="000021.html">[Divunal-devel] StringBuffers/string manipulation optimization</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19">[ date ]</a>
              <a href="thread.html#19">[ thread ]</a>
              <a href="subject.html#19">[ subject ]</a>
              <a href="author.html#19">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>If you have been writing verbs that do lots of String manipulation (okay,
this applies to almost all verbs. :P), this is for you...
In java,
String buffers are used by the compiler to implement the binary string
concatenation operator +. For example, the code:
  String x = &quot;a&quot; + 4 + &quot;c&quot;;
is compiled to the equivalent of:
  String x = new StringBuffer().append(&quot;a&quot;).append(4).append(&quot;c&quot;).toString();
...
so what does this mean to you...
Basically, this is all fine, and you don't have to worry about it if you
just have one long line of +s. However, if you have a for loop, like this
(a shortened version of Inventory.java):
	String s = &quot;You are &quot;;
	Enumeration e = d.subject().things();
	if((e != null) &amp;&amp; e.hasMoreElements())
	{
		Thing t = (Thing)e.nextElement()
		s +=t.the() + t.name()
	}
	player.hears(s);
You will get some pretty inefficient code.
The code above compiles to the equivilent of:
	String s = &quot;You are &quot;;
	Enumeration e = d.subject().things();
	if((e != null) &amp;&amp; e.hasMoreElements())
	{
		Thing t = (Thing)e.nextElement()
		s = new
StringBuffer(s).append(t.the()).append(t.name()).toString();
	}
	player.hears(s);
This is very inefficient since it makes a new StringBuffer every time
through the loop.

If you instead change your code to explicitly use a StringBuffer, like so:
	StringBuffer s = new StringBuffer(&quot;You are &quot;);
	Enumeration e = d.subject().things();
	if((e != null) &amp;&amp; e.hasMoreElements())
	{
		Thing t = (Thing)e.nextElement()
		s.append(s).append(t.the()).append(t.name()).toString();
	}
	player.hears(s.toString());
the code will only make ONE StringBuffer the entire time, saving the
garbage collecter from much unnecessary work, and making your code faster.

So in summary, if you use keep appending stuff to a string on seperate
lines (or in a loop), you should be explicit and use a StringBuffer. If you
just have one line that does a+b+c+d+e, the compiler generates nice code
for you, so you don't have to worry about it.

(I've fixed all the bad places in the pump (including many in the
map-saving code), pending a checkin...)
-James

--
You are in a maze of testy little Java VMs, all subtly different.



</pre>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000020.html">[Divunal-devel] Faucet on Windows</A></li>
	<LI> Next message: <A HREF="000021.html">[Divunal-devel] StringBuffers/string manipulation optimization</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19">[ date ]</a>
              <a href="thread.html#19">[ thread ]</a>
              <a href="subject.html#19">[ subject ]</a>
              <a href="author.html#19">[ author ]</a>
         </LI>
       </UL>
</body></html>
